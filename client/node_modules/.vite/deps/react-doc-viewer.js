import {
  _asyncToGenerator,
  init_asyncToGenerator
} from "./chunk-VEQ2K3K3.js";
import {
  _classCallCheck,
  _createClass,
  _getPrototypeOf,
  _inherits,
  _objectWithoutProperties,
  _possibleConstructorReturn,
  _slicedToArray,
  _toConsumableArray,
  init_classCallCheck,
  init_createClass,
  init_getPrototypeOf,
  init_inherits,
  init_objectWithoutProperties,
  init_possibleConstructorReturn,
  init_slicedToArray,
  init_toConsumableArray
} from "./chunk-UPJHTJBW.js";
import {
  _assertThisInitialized,
  init_assertThisInitialized
} from "./chunk-27ACFE6W.js";
import {
  _defineProperty,
  init_defineProperty
} from "./chunk-LAGL4EW3.js";
import {
  _typeof,
  init_typeof
} from "./chunk-4YBSFPQZ.js";
import {
  emotion_is_prop_valid_esm_default,
  init_emotion_is_prop_valid_esm
} from "./chunk-NKMGUDHS.js";
import {
  require_react_is
} from "./chunk-BRL5J3NS.js";
import "./chunk-AJA3XKBD.js";
import {
  require_prop_types
} from "./chunk-QYOPZWSX.js";
import {
  _extends,
  init_extends,
  require_hoist_non_react_statics_cjs
} from "./chunk-J5BD2EM5.js";
import "./chunk-LVJDZHT2.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports2, module2) {
    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min(W2) {
  function M2(d2, c2, e2, h2, a2) {
    for (var m = 0, b2 = 0, v2 = 0, n2 = 0, q2, g2, x2 = 0, K2 = 0, k2, u2 = k2 = q2 = 0, l2 = 0, r2 = 0, I2 = 0, t2 = 0, B3 = e2.length, J2 = B3 - 1, y2, f = "", p = "", F3 = "", G3 = "", C2; l2 < B3; ) {
      g2 = e2.charCodeAt(l2);
      l2 === J2 && 0 !== b2 + n2 + v2 + m && (0 !== b2 && (g2 = 47 === b2 ? 10 : 47), n2 = v2 = m = 0, B3++, J2++);
      if (0 === b2 + n2 + v2 + m) {
        if (l2 === J2 && (0 < r2 && (f = f.replace(N2, "")), 0 < f.trim().length)) {
          switch (g2) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f += e2.charAt(l2);
          }
          g2 = 59;
        }
        switch (g2) {
          case 123:
            f = f.trim();
            q2 = f.charCodeAt(0);
            k2 = 1;
            for (t2 = ++l2; l2 < B3; ) {
              switch (g2 = e2.charCodeAt(l2)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g2 = e2.charCodeAt(l2 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u2 = l2 + 1; u2 < J2; ++u2) {
                          switch (e2.charCodeAt(u2)) {
                            case 47:
                              if (42 === g2 && 42 === e2.charCodeAt(u2 - 1) && l2 + 2 !== u2) {
                                l2 = u2 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g2) {
                                l2 = u2 + 1;
                                break a;
                              }
                          }
                        }
                        l2 = u2;
                      }
                  }
                  break;
                case 91:
                  g2++;
                case 40:
                  g2++;
                case 34:
                case 39:
                  for (; l2++ < J2 && e2.charCodeAt(l2) !== g2; ) {
                  }
              }
              if (0 === k2)
                break;
              l2++;
            }
            k2 = e2.substring(t2, l2);
            0 === q2 && (q2 = (f = f.replace(ca, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r2 && (f = f.replace(N2, ""));
                g2 = f.charCodeAt(1);
                switch (g2) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r2 = c2;
                    break;
                  default:
                    r2 = O2;
                }
                k2 = M2(c2, r2, k2, g2, a2 + 1);
                t2 = k2.length;
                0 < A2 && (r2 = X2(O2, f, I2), C2 = H2(3, k2, r2, c2, D2, z2, t2, g2, a2, h2), f = r2.join(""), void 0 !== C2 && 0 === (t2 = (k2 = C2.trim()).length) && (g2 = 0, k2 = ""));
                if (0 < t2)
                  switch (g2) {
                    case 115:
                      f = f.replace(da, ea);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f + "{" + k2 + "}";
                      break;
                    case 107:
                      f = f.replace(fa, "$1 $2");
                      k2 = f + "{" + k2 + "}";
                      k2 = 1 === w2 || 2 === w2 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f + k2, 112 === h2 && (k2 = (p += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M2(c2, X2(c2, f, I2), k2, h2, a2 + 1);
            }
            F3 += k2;
            k2 = I2 = r2 = u2 = q2 = 0;
            f = "";
            g2 = e2.charCodeAt(++l2);
            break;
          case 125:
          case 59:
            f = (0 < r2 ? f.replace(N2, "") : f).trim();
            if (1 < (t2 = f.length))
              switch (0 === u2 && (q2 = f.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t2 = (f = f.replace(" ", ":")).length), 0 < A2 && void 0 !== (C2 = H2(1, f, c2, d2, D2, z2, p.length, h2, a2, h2)) && 0 === (t2 = (f = C2.trim()).length) && (f = "\0\0"), q2 = f.charCodeAt(0), g2 = f.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g2 || 99 === g2) {
                    G3 += f + e2.charAt(l2);
                    break;
                  }
                default:
                  58 !== f.charCodeAt(t2 - 1) && (p += P2(f, q2, g2, f.charCodeAt(2)));
              }
            I2 = r2 = u2 = q2 = 0;
            f = "";
            g2 = e2.charCodeAt(++l2);
        }
      }
      switch (g2) {
        case 13:
        case 10:
          47 === b2 ? b2 = 0 : 0 === 1 + q2 && 107 !== h2 && 0 < f.length && (r2 = 1, f += "\0");
          0 < A2 * Y2 && H2(0, f, c2, d2, D2, z2, p.length, h2, a2, h2);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b2 + n2 + v2 + m) {
            z2++;
            break;
          }
        default:
          z2++;
          y2 = e2.charAt(l2);
          switch (g2) {
            case 9:
            case 32:
              if (0 === n2 + m + b2)
                switch (x2) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y2 = "";
                    break;
                  default:
                    32 !== g2 && (y2 = " ");
                }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              0 === n2 + b2 + m && (r2 = I2 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (0 === n2 + b2 + m + E2 && 0 < u2)
                switch (l2 - u2) {
                  case 2:
                    112 === x2 && 58 === e2.charCodeAt(l2 - 3) && (E2 = x2);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n2 + b2 + m && (u2 = l2);
              break;
            case 44:
              0 === b2 + v2 + n2 + m && (r2 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              0 === b2 && (n2 = n2 === g2 ? 0 : 0 === n2 ? g2 : n2);
              break;
            case 91:
              0 === n2 + b2 + v2 && m++;
              break;
            case 93:
              0 === n2 + b2 + v2 && m--;
              break;
            case 41:
              0 === n2 + b2 + m && v2--;
              break;
            case 40:
              if (0 === n2 + b2 + m) {
                if (0 === q2)
                  switch (2 * x2 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v2++;
              }
              break;
            case 64:
              0 === b2 + v2 + n2 + m + u2 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n2 + m + v2))
                switch (b2) {
                  case 0:
                    switch (2 * g2 + 3 * e2.charCodeAt(l2 + 1)) {
                      case 235:
                        b2 = 47;
                        break;
                      case 220:
                        t2 = l2, b2 = 42;
                    }
                    break;
                  case 42:
                    47 === g2 && 42 === x2 && t2 + 2 !== l2 && (33 === e2.charCodeAt(t2 + 2) && (p += e2.substring(t2, l2 + 1)), y2 = "", b2 = 0);
                }
          }
          0 === b2 && (f += y2);
      }
      K2 = x2;
      x2 = g2;
      l2++;
    }
    t2 = p.length;
    if (0 < t2) {
      r2 = c2;
      if (0 < A2 && (C2 = H2(2, p, r2, d2, D2, z2, t2, h2, a2, h2), void 0 !== C2 && 0 === (p = C2).length))
        return G3 + p + F3;
      p = r2.join(",") + "{" + p + "}";
      if (0 !== w2 * E2) {
        2 !== w2 || L2(p, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p = p.replace(ha, ":-moz-$1") + p;
            break;
          case 112:
            p = p.replace(Q2, "::-webkit-input-$1") + p.replace(Q2, "::-moz-$1") + p.replace(Q2, ":-ms-input-$1") + p;
        }
        E2 = 0;
      }
    }
    return G3 + p + F3;
  }
  function X2(d2, c2, e2) {
    var h2 = c2.trim().split(ia);
    c2 = h2;
    var a2 = h2.length, m = d2.length;
    switch (m) {
      case 0:
      case 1:
        var b2 = 0;
        for (d2 = 0 === m ? "" : d2[0] + " "; b2 < a2; ++b2) {
          c2[b2] = Z2(d2, c2[b2], e2).trim();
        }
        break;
      default:
        var v2 = b2 = 0;
        for (c2 = []; b2 < a2; ++b2) {
          for (var n2 = 0; n2 < m; ++n2) {
            c2[v2++] = Z2(d2[n2] + " ", h2[b2], e2).trim();
          }
        }
    }
    return c2;
  }
  function Z2(d2, c2, e2) {
    var h2 = c2.charCodeAt(0);
    33 > h2 && (h2 = (c2 = c2.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c2.replace(F2, "$1" + d2.trim());
      case 58:
        return d2.trim() + c2.replace(F2, "$1" + d2.trim());
      default:
        if (0 < 1 * e2 && 0 < c2.indexOf("\f"))
          return c2.replace(F2, (58 === d2.charCodeAt(0) ? "" : "$1") + d2.trim());
    }
    return d2 + c2;
  }
  function P2(d2, c2, e2, h2) {
    var a2 = d2 + ";", m = 2 * c2 + 3 * e2 + 4 * h2;
    if (944 === m) {
      d2 = a2.indexOf(":", 9) + 1;
      var b2 = a2.substring(d2, a2.length - 1).trim();
      b2 = a2.substring(0, d2).trim() + b2 + ";";
      return 1 === w2 || 2 === w2 && L2(b2, 1) ? "-webkit-" + b2 + b2 : b2;
    }
    if (0 === w2 || 2 === w2 && !L2(a2, 1))
      return a2;
    switch (m) {
      case 1015:
        return 97 === a2.charCodeAt(10) ? "-webkit-" + a2 + a2 : a2;
      case 951:
        return 116 === a2.charCodeAt(3) ? "-webkit-" + a2 + a2 : a2;
      case 963:
        return 110 === a2.charCodeAt(5) ? "-webkit-" + a2 + a2 : a2;
      case 1009:
        if (100 !== a2.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a2 + a2;
      case 978:
        return "-webkit-" + a2 + "-moz-" + a2 + a2;
      case 1019:
      case 983:
        return "-webkit-" + a2 + "-moz-" + a2 + "-ms-" + a2 + a2;
      case 883:
        if (45 === a2.charCodeAt(8))
          return "-webkit-" + a2 + a2;
        if (0 < a2.indexOf("image-set(", 11))
          return a2.replace(ja, "$1-webkit-$2") + a2;
        break;
      case 932:
        if (45 === a2.charCodeAt(4))
          switch (a2.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a2.replace("-grow", "") + "-webkit-" + a2 + "-ms-" + a2.replace("grow", "positive") + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-" + a2.replace("shrink", "negative") + a2;
            case 98:
              return "-webkit-" + a2 + "-ms-" + a2.replace("basis", "preferred-size") + a2;
          }
        return "-webkit-" + a2 + "-ms-" + a2 + a2;
      case 964:
        return "-webkit-" + a2 + "-ms-flex-" + a2 + a2;
      case 1023:
        if (99 !== a2.charCodeAt(8))
          break;
        b2 = a2.substring(a2.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b2 + "-webkit-" + a2 + "-ms-flex-pack" + b2 + a2;
      case 1005:
        return ka.test(a2) ? a2.replace(aa, ":-webkit-") + a2.replace(aa, ":-moz-") + a2 : a2;
      case 1e3:
        b2 = a2.substring(13).trim();
        c2 = b2.indexOf("-") + 1;
        switch (b2.charCodeAt(0) + b2.charCodeAt(c2)) {
          case 226:
            b2 = a2.replace(G2, "tb");
            break;
          case 232:
            b2 = a2.replace(G2, "tb-rl");
            break;
          case 220:
            b2 = a2.replace(G2, "lr");
            break;
          default:
            return a2;
        }
        return "-webkit-" + a2 + "-ms-" + b2 + a2;
      case 1017:
        if (-1 === a2.indexOf("sticky", 9))
          break;
      case 975:
        c2 = (a2 = d2).length - 10;
        b2 = (33 === a2.charCodeAt(c2) ? a2.substring(0, c2) : a2).substring(d2.indexOf(":", 7) + 1).trim();
        switch (m = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b2.charCodeAt(8))
              break;
          case 115:
            a2 = a2.replace(b2, "-webkit-" + b2) + ";" + a2;
            break;
          case 207:
          case 102:
            a2 = a2.replace(b2, "-webkit-" + (102 < m ? "inline-" : "") + "box") + ";" + a2.replace(b2, "-webkit-" + b2) + ";" + a2.replace(b2, "-ms-" + b2 + "box") + ";" + a2;
        }
        return a2 + ";";
      case 938:
        if (45 === a2.charCodeAt(5))
          switch (a2.charCodeAt(6)) {
            case 105:
              return b2 = a2.replace("-items", ""), "-webkit-" + a2 + "-webkit-box-" + b2 + "-ms-flex-" + b2 + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-flex-item-" + a2.replace(ba, "") + a2;
            default:
              return "-webkit-" + a2 + "-ms-flex-line-pack" + a2.replace("align-content", "").replace(ba, "") + a2;
          }
        break;
      case 973:
      case 989:
        if (45 !== a2.charCodeAt(3) || 122 === a2.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la.test(d2))
          return 115 === (b2 = d2.substring(d2.indexOf(":") + 1)).charCodeAt(0) ? P2(d2.replace("stretch", "fill-available"), c2, e2, h2).replace(":fill-available", ":stretch") : a2.replace(b2, "-webkit-" + b2) + a2.replace(b2, "-moz-" + b2.replace("fill-", "")) + a2;
        break;
      case 962:
        if (a2 = "-webkit-" + a2 + (102 === a2.charCodeAt(5) ? "-ms-" + a2 : "") + a2, 211 === e2 + h2 && 105 === a2.charCodeAt(13) && 0 < a2.indexOf("transform", 10))
          return a2.substring(0, a2.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a2;
    }
    return a2;
  }
  function L2(d2, c2) {
    var e2 = d2.indexOf(1 === c2 ? ":" : "{"), h2 = d2.substring(0, 3 !== c2 ? e2 : 10);
    e2 = d2.substring(e2 + 1, d2.length - 1);
    return R2(2 !== c2 ? h2 : h2.replace(na, "$1"), e2, c2);
  }
  function ea(d2, c2) {
    var e2 = P2(c2, c2.charCodeAt(0), c2.charCodeAt(1), c2.charCodeAt(2));
    return e2 !== c2 + ";" ? e2.replace(oa, " or ($1)").substring(4) : "(" + c2 + ")";
  }
  function H2(d2, c2, e2, h2, a2, m, b2, v2, n2, q2) {
    for (var g2 = 0, x2 = c2, w3; g2 < A2; ++g2) {
      switch (w3 = S2[g2].call(B2, d2, x2, e2, h2, a2, m, b2, v2, n2, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x2 = w3;
      }
    }
    if (x2 !== c2)
      return x2;
  }
  function T2(d2) {
    switch (d2) {
      case void 0:
      case null:
        A2 = S2.length = 0;
        break;
      default:
        if ("function" === typeof d2)
          S2[A2++] = d2;
        else if ("object" === typeof d2)
          for (var c2 = 0, e2 = d2.length; c2 < e2; ++c2) {
            T2(d2[c2]);
          }
        else
          Y2 = !!d2 | 0;
    }
    return T2;
  }
  function U2(d2) {
    d2 = d2.prefix;
    void 0 !== d2 && (R2 = null, d2 ? "function" !== typeof d2 ? w2 = 1 : (w2 = 2, R2 = d2) : w2 = 0);
    return U2;
  }
  function B2(d2, c2) {
    var e2 = d2;
    33 > e2.charCodeAt(0) && (e2 = e2.trim());
    V2 = e2;
    e2 = [V2];
    if (0 < A2) {
      var h2 = H2(-1, c2, e2, e2, D2, z2, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c2 = h2);
    }
    var a2 = M2(O2, e2, c2, 0, 0);
    0 < A2 && (h2 = H2(-2, a2, e2, e2, D2, z2, a2.length, 0, 0, 0), void 0 !== h2 && (a2 = h2));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a2;
  }
  var ca = /^\0+/g, N2 = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w2 = 1, O2 = [], S2 = [], A2 = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var stylis_browser_esm_default;
var init_stylis_browser_esm = __esm({
  "node_modules/@emotion/stylis/dist/stylis.browser.esm.js"() {
    stylis_browser_esm_default = stylis_min;
  }
});

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys, unitless_browser_esm_default;
var init_unitless_browser_esm = __esm({
  "node_modules/@emotion/unitless/dist/unitless.browser.esm.js"() {
    unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    unitless_browser_esm_default = unitlessKeys;
  }
});

// node_modules/styled-components/dist/styled-components.browser.esm.js
var styled_components_browser_esm_exports = {};
__export(styled_components_browser_esm_exports, {
  ServerStyleSheet: () => Je,
  StyleSheetConsumer: () => le,
  StyleSheetContext: () => ue,
  StyleSheetManager: () => ye,
  ThemeConsumer: () => Le,
  ThemeContext: () => Ge,
  ThemeProvider: () => Fe,
  __PRIVATE__: () => Ke,
  createGlobalStyle: () => We,
  css: () => Ce,
  default: () => styled_components_browser_esm_default,
  isStyledComponent: () => N,
  keyframes: () => Ue,
  useTheme: () => Ze,
  version: () => C,
  withTheme: () => Xe
});
function v() {
  return (v = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
function b(e2) {
  return "function" == typeof e2;
}
function _(e2) {
  return "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
}
function N(e2) {
  return e2 && "string" == typeof e2.styledComponentId;
}
function D() {
  for (var e2 = arguments.length <= 0 ? void 0 : arguments[0], t2 = [], n2 = 1, r2 = arguments.length; n2 < r2; n2 += 1)
    t2.push(n2 < 0 || arguments.length <= n2 ? void 0 : arguments[n2]);
  return t2.forEach(function(t3) {
    e2 = e2.replace(/%[a-z]/, t3);
  }), e2;
}
function j(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : "")) : new Error(D.apply(void 0, [R[e2]].concat(n2)).trim());
}
function ee(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = Q(t2 % 52) + n2;
  return (Q(t2 % 52) + n2).replace(K, "$1-$2");
}
function re(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (b(n2) && !N(n2))
      return false;
  }
  return true;
}
function ce(e2) {
  var t2, n2, r2, o2, s2 = void 0 === e2 ? E : e2, i2 = s2.options, a2 = void 0 === i2 ? E : i2, c2 = s2.plugins, u2 = void 0 === c2 ? w : c2, l2 = new stylis_browser_esm_default(a2), d2 = [], h2 = function(e3) {
    function t3(t4) {
      if (t4)
        try {
          e3(t4 + "}");
        } catch (e4) {
        }
    }
    return function(n3, r3, o3, s3, i3, a3, c3, u3, l3, d3) {
      switch (n3) {
        case 1:
          if (0 === l3 && 64 === r3.charCodeAt(0))
            return e3(r3 + ";"), "";
          break;
        case 2:
          if (0 === u3)
            return r3 + "/*|*/";
          break;
        case 3:
          switch (u3) {
            case 102:
            case 112:
              return e3(o3[0] + r3), "";
            default:
              return r3 + (0 === d3 ? "/*|*/" : "");
          }
        case -2:
          r3.split("/*|*/}").forEach(t3);
      }
    };
  }(function(e3) {
    d2.push(e3);
  }), f = function(e3, r3, s3) {
    return 0 === r3 && -1 !== ae.indexOf(s3[n2.length]) || s3.match(o2) ? e3 : "." + t2;
  };
  function m(e3, s3, i3, a3) {
    void 0 === a3 && (a3 = "&");
    var c3 = e3.replace(ie, ""), u3 = s3 && i3 ? i3 + " " + s3 + " { " + c3 + " }" : c3;
    return t2 = a3, n2 = s3, r2 = new RegExp("\\" + n2 + "\\b", "g"), o2 = new RegExp("(\\" + n2 + "\\b){2,}"), l2(i3 || !s3 ? "" : s3, u3);
  }
  return l2.use([].concat(u2, [function(e3, t3, o3) {
    2 === e3 && o3.length && o3[0].lastIndexOf(n2) > 0 && (o3[0] = o3[0].replace(r2, f));
  }, h2, function(e3) {
    if (-2 === e3) {
      var t3 = d2;
      return d2 = [], t3;
    }
  }])), m.hash = u2.length ? u2.reduce(function(e3, t3) {
    return t3.name || j(15), te(e3, t3.name);
  }, 5381).toString() : "", m;
}
function fe() {
  return (0, import_react.useContext)(ue) || he;
}
function me() {
  return (0, import_react.useContext)(de) || pe;
}
function ye(e2) {
  var t2 = (0, import_react.useState)(e2.stylisPlugins), n2 = t2[0], s2 = t2[1], c2 = fe(), u2 = (0, import_react.useMemo)(function() {
    var t3 = c2;
    return e2.sheet ? t3 = e2.sheet : e2.target && (t3 = t3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target]), l2 = (0, import_react.useMemo)(function() {
    return ce({ options: { prefix: !e2.disableVendorPrefixes }, plugins: n2 });
  }, [e2.disableVendorPrefixes, n2]);
  return (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n2, e2.stylisPlugins) || s2(e2.stylisPlugins);
  }, [e2.stylisPlugins]), import_react.default.createElement(ue.Provider, { value: u2 }, import_react.default.createElement(de.Provider, { value: l2 }, true ? import_react.default.Children.only(e2.children) : e2.children));
}
function be(e2) {
  return ge.test(e2) ? e2.replace(Se, Ee).replace(we, "-ms-") : e2;
}
function Ne(e2, n2, r2, o2) {
  if (Array.isArray(e2)) {
    for (var s2, i2 = [], a2 = 0, c2 = e2.length; a2 < c2; a2 += 1)
      "" !== (s2 = Ne(e2[a2], n2, r2, o2)) && (Array.isArray(s2) ? i2.push.apply(i2, s2) : i2.push(s2));
    return i2;
  }
  if (_e(e2))
    return "";
  if (N(e2))
    return "." + e2.styledComponentId;
  if (b(e2)) {
    if ("function" != typeof (l2 = e2) || l2.prototype && l2.prototype.isReactComponent || !n2)
      return e2;
    var u2 = e2(n2);
    return (0, import_react_is.isElement)(u2) && console.warn(_(e2) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), Ne(u2, n2, r2, o2);
  }
  var l2;
  return e2 instanceof ve ? r2 ? (e2.inject(r2, o2), e2.getName(o2)) : e2 : S(e2) ? function e3(t2, n3) {
    var r3, o3, s3 = [];
    for (var i3 in t2)
      t2.hasOwnProperty(i3) && !_e(t2[i3]) && (Array.isArray(t2[i3]) && t2[i3].isCss || b(t2[i3]) ? s3.push(be(i3) + ":", t2[i3], ";") : S(t2[i3]) ? s3.push.apply(s3, e3(t2[i3], i3)) : s3.push(be(i3) + ": " + (r3 = i3, null == (o3 = t2[i3]) || "boolean" == typeof o3 || "" === o3 ? "" : "number" != typeof o3 || 0 === o3 || r3 in unitless_browser_esm_default ? String(o3).trim() : o3 + "px") + ";"));
    return n3 ? [n3 + " {"].concat(s3, ["}"]) : s3;
  }(e2) : e2.toString();
}
function Ce(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  return b(e2) || S(e2) ? Ae(Ne(g(w, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : Ae(Ne(g(e2, n2)));
}
function Te(e2) {
  return e2.replace(De, "-").replace(je, "");
}
function ke(e2) {
  return "string" == typeof e2 && e2.charAt(0) === e2.charAt(0).toLowerCase();
}
function ze(e2, t2, n2) {
  var r2 = e2[n2];
  Ve(t2) && Ve(r2) ? Me(r2, t2) : e2[n2] = t2;
}
function Me(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  for (var o2 = 0, s2 = n2; o2 < s2.length; o2++) {
    var i2 = s2[o2];
    if (Ve(i2))
      for (var a2 in i2)
        Be(a2) && ze(e2, i2[a2], a2);
  }
  return e2;
}
function Fe(e2) {
  var t2 = (0, import_react.useContext)(Ge), n2 = (0, import_react.useMemo)(function() {
    return function(e3, t3) {
      if (!e3)
        return j(14);
      if (b(e3)) {
        var n3 = e3(t3);
        return null !== n3 && !Array.isArray(n3) && "object" == typeof n3 ? n3 : j(7);
      }
      return Array.isArray(e3) || "object" != typeof e3 ? j(8) : t3 ? v({}, t3, {}, e3) : e3;
    }(e2.theme, t2);
  }, [e2.theme, t2]);
  return e2.children ? import_react.default.createElement(Ge.Provider, { value: n2 }, e2.children) : null;
}
function qe(e2, t2, n2) {
  var o2 = N(e2), i2 = !ke(e2), a2 = t2.attrs, c2 = void 0 === a2 ? w : a2, d2 = t2.componentId, h2 = void 0 === d2 ? function(e3, t3) {
    var n3 = "string" != typeof e3 ? "sc" : Te(e3);
    Ye[n3] = (Ye[n3] || 0) + 1;
    var r2 = n3 + "-" + xe("5.3.9" + n3 + Ye[n3]);
    return t3 ? t3 + "-" + r2 : r2;
  }(t2.displayName, t2.parentComponentId) : d2, p = t2.displayName, f = void 0 === p ? function(e3) {
    return ke(e3) ? "styled." + e3 : "Styled(" + _(e3) + ")";
  }(e2) : p, g2 = t2.displayName && t2.componentId ? Te(t2.displayName) + "-" + t2.componentId : t2.componentId || h2, S2 = o2 && e2.attrs ? Array.prototype.concat(e2.attrs, c2).filter(Boolean) : c2, A2 = t2.shouldForwardProp;
  o2 && e2.shouldForwardProp && (A2 = t2.shouldForwardProp ? function(n3, r2, o3) {
    return e2.shouldForwardProp(n3, r2, o3) && t2.shouldForwardProp(n3, r2, o3);
  } : e2.shouldForwardProp);
  var C2, I2 = new se(n2, g2, o2 ? e2.componentStyle : void 0), P2 = I2.isStatic && 0 === c2.length, O2 = function(e3, t3) {
    return function(e4, t4, n3, r2) {
      var o3 = e4.attrs, i3 = e4.componentStyle, a3 = e4.defaultProps, c3 = e4.foldedComponentIds, d3 = e4.shouldForwardProp, h3 = e4.styledComponentId, p2 = e4.target;
      (0, import_react.useDebugValue)(h3);
      var f2 = function(e5, t5, n4) {
        void 0 === e5 && (e5 = E);
        var r3 = v({}, t5, { theme: e5 }), o4 = {};
        return n4.forEach(function(e6) {
          var t6, n5, s2, i4 = e6;
          for (t6 in b(i4) && (i4 = i4(r3)), i4)
            r3[t6] = o4[t6] = "className" === t6 ? (n5 = o4[t6], s2 = i4[t6], n5 && s2 ? n5 + " " + s2 : n5 || s2) : i4[t6];
        }), [r3, o4];
      }(Re(t4, (0, import_react.useContext)(Ge), a3) || E, t4, o3), y2 = f2[0], g3 = f2[1], S3 = function(e5, t5, n4, r3) {
        var o4 = fe(), s2 = me(), i4 = t5 ? e5.generateAndInjectStyles(E, o4, s2) : e5.generateAndInjectStyles(n4, o4, s2);
        return (0, import_react.useDebugValue)(i4), !t5 && r3 && r3(i4), i4;
      }(i3, r2, y2, true ? e4.warnTooManyClasses : void 0), w2 = n3, _2 = g3.$as || t4.$as || g3.as || t4.as || p2, N2 = ke(_2), A3 = g3 !== t4 ? v({}, t4, {}, g3) : t4, C3 = {};
      for (var I3 in A3)
        "$" !== I3[0] && "as" !== I3 && ("forwardedAs" === I3 ? C3.as = A3[I3] : (d3 ? d3(I3, emotion_is_prop_valid_esm_default, _2) : !N2 || emotion_is_prop_valid_esm_default(I3)) && (C3[I3] = A3[I3]));
      return t4.style && g3.style !== t4.style && (C3.style = v({}, t4.style, {}, g3.style)), C3.className = Array.prototype.concat(c3, h3, S3 !== h3 ? S3 : null, t4.className, g3.className).filter(Boolean).join(" "), C3.ref = w2, (0, import_react.createElement)(_2, C3);
    }(C2, e3, t3, P2);
  };
  return O2.displayName = f, (C2 = import_react.default.forwardRef(O2)).attrs = S2, C2.componentStyle = I2, C2.displayName = f, C2.shouldForwardProp = A2, C2.foldedComponentIds = o2 ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : w, C2.styledComponentId = g2, C2.target = o2 ? e2.target : e2, C2.withComponent = function(e3) {
    var r2 = t2.componentId, o3 = function(e4, t3) {
      if (null == e4)
        return {};
      var n3, r3, o4 = {}, s3 = Object.keys(e4);
      for (r3 = 0; r3 < s3.length; r3++)
        n3 = s3[r3], t3.indexOf(n3) >= 0 || (o4[n3] = e4[n3]);
      return o4;
    }(t2, ["componentId"]), s2 = r2 && r2 + "-" + (ke(e3) ? e3 : Te(_(e3)));
    return qe(e3, v({}, o3, { attrs: S2, componentId: s2 }), n2);
  }, Object.defineProperty(C2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t3) {
    this._foldedDefaultProps = o2 ? Me({}, e2.defaultProps, t3) : t3;
  } }), Oe(f, g2), C2.warnTooManyClasses = function(e3, t3) {
    var n3 = {}, r2 = false;
    return function(o3) {
      if (!r2 && (n3[o3] = true, Object.keys(n3).length >= 200)) {
        var s2 = t3 ? ' with the id of "' + t3 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e3 + s2 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r2 = true, n3 = {};
      }
    };
  }(f, g2), Object.defineProperty(C2, "toString", { value: function() {
    return "." + C2.styledComponentId;
  } }), i2 && (0, import_hoist_non_react_statics.default)(C2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), C2;
}
function We(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), o2 = 1; o2 < t2; o2++)
    n2[o2 - 1] = arguments[o2];
  var i2 = Ce.apply(void 0, [e2].concat(n2)), a2 = "sc-global-" + xe(JSON.stringify(i2)), u2 = new $e(i2, a2);
  function l2(e3) {
    var t3 = fe(), n3 = me(), o3 = (0, import_react.useContext)(Ge), l3 = (0, import_react.useRef)(t3.allocateGSInstance(a2)).current;
    return import_react.default.Children.count(e3.children) && console.warn("The global style component " + a2 + " was given child JSX. createGlobalStyle does not render children."), i2.some(function(e4) {
      return "string" == typeof e4 && -1 !== e4.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t3.server && h2(l3, e3, t3, o3, n3), (0, import_react.useLayoutEffect)(function() {
      if (!t3.server)
        return h2(l3, e3, t3, o3, n3), function() {
          return u2.removeStyles(l3, t3);
        };
    }, [l3, e3, t3, o3, n3]), null;
  }
  function h2(e3, t3, n3, r2, o3) {
    if (u2.isStatic)
      u2.renderStyles(e3, O, n3, o3);
    else {
      var s2 = v({}, t3, { theme: Re(t3, r2, l2.defaultProps) });
      u2.renderStyles(e3, s2, n3, o3);
    }
  }
  return Oe(a2), import_react.default.memo(l2);
}
function Ue(e2) {
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  var o2 = Ce.apply(void 0, [e2].concat(n2)).join(""), s2 = xe(o2);
  return new ve(s2, o2);
}
var import_react_is, import_react, import_shallowequal, import_hoist_non_react_statics, g, S, w, E, A, C, I, P, O, R, T, x, k, V, B, z, M, G, L, F, Y, q, H, $, W, U, J, X, Z, K, Q, te, ne, oe, se, ie, ae, ue, le, de, he, pe, ve, ge, Se, we, Ee, _e, Ae, Ie, Pe, Oe, Re, De, je, xe, Ve, Be, Ge, Le, Ye, He, $e, Je, Xe, Ze, Ke, styled_components_browser_esm_default;
var init_styled_components_browser_esm = __esm({
  "node_modules/styled-components/dist/styled-components.browser.esm.js"() {
    import_react_is = __toESM(require_react_is());
    import_react = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    init_stylis_browser_esm();
    init_unitless_browser_esm();
    init_emotion_is_prop_valid_esm();
    import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
    g = function(e2, t2) {
      for (var n2 = [e2[0]], r2 = 0, o2 = t2.length; r2 < o2; r2 += 1)
        n2.push(t2[r2], e2[r2 + 1]);
      return n2;
    };
    S = function(t2) {
      return null !== t2 && "object" == typeof t2 && "[object Object]" === (t2.toString ? t2.toString() : Object.prototype.toString.call(t2)) && !(0, import_react_is.typeOf)(t2);
    };
    w = Object.freeze([]);
    E = Object.freeze({});
    A = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
    C = "5.3.9";
    I = "undefined" != typeof window && "HTMLElement" in window;
    P = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true));
    O = {};
    R = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
    T = function() {
      function e2(e3) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
      }
      var t2 = e2.prototype;
      return t2.indexOfGroup = function(e3) {
        for (var t3 = 0, n2 = 0; n2 < e3; n2++)
          t3 += this.groupSizes[n2];
        return t3;
      }, t2.insertRules = function(e3, t3) {
        if (e3 >= this.groupSizes.length) {
          for (var n2 = this.groupSizes, r2 = n2.length, o2 = r2; e3 >= o2; )
            (o2 <<= 1) < 0 && j(16, "" + e3);
          this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n2), this.length = o2;
          for (var s2 = r2; s2 < o2; s2++)
            this.groupSizes[s2] = 0;
        }
        for (var i2 = this.indexOfGroup(e3 + 1), a2 = 0, c2 = t3.length; a2 < c2; a2++)
          this.tag.insertRule(i2, t3[a2]) && (this.groupSizes[e3]++, i2++);
      }, t2.clearGroup = function(e3) {
        if (e3 < this.length) {
          var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r2 = n2 + t3;
          this.groupSizes[e3] = 0;
          for (var o2 = n2; o2 < r2; o2++)
            this.tag.deleteRule(n2);
        }
      }, t2.getGroup = function(e3) {
        var t3 = "";
        if (e3 >= this.length || 0 === this.groupSizes[e3])
          return t3;
        for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o2 = r2 + n2, s2 = r2; s2 < o2; s2++)
          t3 += this.tag.getRule(s2) + "/*!sc*/\n";
        return t3;
      }, e2;
    }();
    x = /* @__PURE__ */ new Map();
    k = /* @__PURE__ */ new Map();
    V = 1;
    B = function(e2) {
      if (x.has(e2))
        return x.get(e2);
      for (; k.has(V); )
        V++;
      var t2 = V++;
      return ((0 | t2) < 0 || t2 > 1 << 30) && j(16, "" + t2), x.set(e2, t2), k.set(t2, e2), t2;
    };
    z = function(e2) {
      return k.get(e2);
    };
    M = function(e2, t2) {
      t2 >= V && (V = t2 + 1), x.set(e2, t2), k.set(t2, e2);
    };
    G = "style[" + A + '][data-styled-version="5.3.9"]';
    L = new RegExp("^" + A + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
    F = function(e2, t2, n2) {
      for (var r2, o2 = n2.split(","), s2 = 0, i2 = o2.length; s2 < i2; s2++)
        (r2 = o2[s2]) && e2.registerName(t2, r2);
    };
    Y = function(e2, t2) {
      for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o2 = 0, s2 = n2.length; o2 < s2; o2++) {
        var i2 = n2[o2].trim();
        if (i2) {
          var a2 = i2.match(L);
          if (a2) {
            var c2 = 0 | parseInt(a2[1], 10), u2 = a2[2];
            0 !== c2 && (M(u2, c2), F(e2, u2, a2[3]), e2.getTag().insertRules(c2, r2)), r2.length = 0;
          } else
            r2.push(i2);
        }
      }
    };
    q = function() {
      return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
    };
    H = function(e2) {
      var t2 = document.head, n2 = e2 || t2, r2 = document.createElement("style"), o2 = function(e3) {
        for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {
          var r3 = t3[n3];
          if (r3 && 1 === r3.nodeType && r3.hasAttribute(A))
            return r3;
        }
      }(n2), s2 = void 0 !== o2 ? o2.nextSibling : null;
      r2.setAttribute(A, "active"), r2.setAttribute("data-styled-version", "5.3.9");
      var i2 = q();
      return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, s2), r2;
    };
    $ = function() {
      function e2(e3) {
        var t3 = this.element = H(e3);
        t3.appendChild(document.createTextNode("")), this.sheet = function(e4) {
          if (e4.sheet)
            return e4.sheet;
          for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
            var o2 = t4[n2];
            if (o2.ownerNode === e4)
              return o2;
          }
          j(17);
        }(t3), this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        try {
          return this.sheet.insertRule(t3, e3), this.length++, true;
        } catch (e4) {
          return false;
        }
      }, t2.deleteRule = function(e3) {
        this.sheet.deleteRule(e3), this.length--;
      }, t2.getRule = function(e3) {
        var t3 = this.sheet.cssRules[e3];
        return void 0 !== t3 && "string" == typeof t3.cssText ? t3.cssText : "";
      }, e2;
    }();
    W = function() {
      function e2(e3) {
        var t3 = this.element = H(e3);
        this.nodes = t3.childNodes, this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        if (e3 <= this.length && e3 >= 0) {
          var n2 = document.createTextNode(t3), r2 = this.nodes[e3];
          return this.element.insertBefore(n2, r2 || null), this.length++, true;
        }
        return false;
      }, t2.deleteRule = function(e3) {
        this.element.removeChild(this.nodes[e3]), this.length--;
      }, t2.getRule = function(e3) {
        return e3 < this.length ? this.nodes[e3].textContent : "";
      }, e2;
    }();
    U = function() {
      function e2(e3) {
        this.rules = [], this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
      }, t2.deleteRule = function(e3) {
        this.rules.splice(e3, 1), this.length--;
      }, t2.getRule = function(e3) {
        return e3 < this.length ? this.rules[e3] : "";
      }, e2;
    }();
    J = I;
    X = { isServer: !I, useCSSOMInjection: !P };
    Z = function() {
      function e2(e3, t3, n2) {
        void 0 === e3 && (e3 = E), void 0 === t3 && (t3 = {}), this.options = v({}, X, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && I && J && (J = false, function(e4) {
          for (var t4 = document.querySelectorAll(G), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
            var o2 = t4[n3];
            o2 && "active" !== o2.getAttribute(A) && (Y(e4, o2), o2.parentNode && o2.parentNode.removeChild(o2));
          }
        }(this));
      }
      e2.registerId = function(e3) {
        return B(e3);
      };
      var t2 = e2.prototype;
      return t2.reconstructWithOptions = function(t3, n2) {
        return void 0 === n2 && (n2 = true), new e2(v({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
      }, t2.allocateGSInstance = function(e3) {
        return this.gs[e3] = (this.gs[e3] || 0) + 1;
      }, t2.getTag = function() {
        return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o2 = t3.target, e3 = n2 ? new U(o2) : r2 ? new $(o2) : new W(o2), new T(e3)));
        var e3, t3, n2, r2, o2;
      }, t2.hasNameForId = function(e3, t3) {
        return this.names.has(e3) && this.names.get(e3).has(t3);
      }, t2.registerName = function(e3, t3) {
        if (B(e3), this.names.has(e3))
          this.names.get(e3).add(t3);
        else {
          var n2 = /* @__PURE__ */ new Set();
          n2.add(t3), this.names.set(e3, n2);
        }
      }, t2.insertRules = function(e3, t3, n2) {
        this.registerName(e3, t3), this.getTag().insertRules(B(e3), n2);
      }, t2.clearNames = function(e3) {
        this.names.has(e3) && this.names.get(e3).clear();
      }, t2.clearRules = function(e3) {
        this.getTag().clearGroup(B(e3)), this.clearNames(e3);
      }, t2.clearTag = function() {
        this.tag = void 0;
      }, t2.toString = function() {
        return function(e3) {
          for (var t3 = e3.getTag(), n2 = t3.length, r2 = "", o2 = 0; o2 < n2; o2++) {
            var s2 = z(o2);
            if (void 0 !== s2) {
              var i2 = e3.names.get(s2), a2 = t3.getGroup(o2);
              if (i2 && a2 && i2.size) {
                var c2 = A + ".g" + o2 + '[id="' + s2 + '"]', u2 = "";
                void 0 !== i2 && i2.forEach(function(e4) {
                  e4.length > 0 && (u2 += e4 + ",");
                }), r2 += "" + a2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
              }
            }
          }
          return r2;
        }(this);
      }, e2;
    }();
    K = /(a)(d)/gi;
    Q = function(e2) {
      return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
    };
    te = function(e2, t2) {
      for (var n2 = t2.length; n2; )
        e2 = 33 * e2 ^ t2.charCodeAt(--n2);
      return e2;
    };
    ne = function(e2) {
      return te(5381, e2);
    };
    oe = ne("5.3.9");
    se = function() {
      function e2(e3, t2, n2) {
        this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = te(oe, t2), this.baseStyle = n2, Z.registerId(t2);
      }
      return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
        var r2 = this.componentId, o2 = [];
        if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash)
          if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId))
            o2.push(this.staticRulesId);
          else {
            var s2 = Ne(this.rules, e3, t2, n2).join(""), i2 = ee(te(this.baseHash, s2) >>> 0);
            if (!t2.hasNameForId(r2, i2)) {
              var a2 = n2(s2, "." + i2, void 0, r2);
              t2.insertRules(r2, i2, a2);
            }
            o2.push(i2), this.staticRulesId = i2;
          }
        else {
          for (var c2 = this.rules.length, u2 = te(this.baseHash, n2.hash), l2 = "", d2 = 0; d2 < c2; d2++) {
            var h2 = this.rules[d2];
            if ("string" == typeof h2)
              l2 += h2, u2 = te(u2, h2 + d2);
            else if (h2) {
              var p = Ne(h2, e3, t2, n2), f = Array.isArray(p) ? p.join("") : p;
              u2 = te(u2, f + d2), l2 += f;
            }
          }
          if (l2) {
            var m = ee(u2 >>> 0);
            if (!t2.hasNameForId(r2, m)) {
              var y2 = n2(l2, "." + m, void 0, r2);
              t2.insertRules(r2, m, y2);
            }
            o2.push(m);
          }
        }
        return o2.join(" ");
      }, e2;
    }();
    ie = /^\s*\/\/.*$/gm;
    ae = [":", "[", ".", "#"];
    ue = import_react.default.createContext();
    le = ue.Consumer;
    de = import_react.default.createContext();
    he = (de.Consumer, new Z());
    pe = ce();
    ve = function() {
      function e2(e3, t2) {
        var n2 = this;
        this.inject = function(e4, t3) {
          void 0 === t3 && (t3 = pe);
          var r2 = n2.name + t3.hash;
          e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
        }, this.toString = function() {
          return j(12, String(n2.name));
        }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t2;
      }
      return e2.prototype.getName = function(e3) {
        return void 0 === e3 && (e3 = pe), this.name + e3.hash;
      }, e2;
    }();
    ge = /([A-Z])/;
    Se = /([A-Z])/g;
    we = /^ms-/;
    Ee = function(e2) {
      return "-" + e2.toLowerCase();
    };
    _e = function(e2) {
      return null == e2 || false === e2 || "" === e2;
    };
    Ae = function(e2) {
      return Array.isArray(e2) && (e2.isCss = true), e2;
    };
    Ie = /invalid hook call/i;
    Pe = /* @__PURE__ */ new Set();
    Oe = function(e2, t2) {
      if (true) {
        var n2 = "The component " + e2 + (t2 ? ' with the id of "' + t2 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r2 = console.error;
        try {
          var o2 = true;
          console.error = function(e3) {
            if (Ie.test(e3))
              o2 = false, Pe.delete(n2);
            else {
              for (var t3 = arguments.length, s2 = new Array(t3 > 1 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++)
                s2[i2 - 1] = arguments[i2];
              r2.apply(void 0, [e3].concat(s2));
            }
          }, (0, import_react.useRef)(), o2 && !Pe.has(n2) && (console.warn(n2), Pe.add(n2));
        } catch (e3) {
          Ie.test(e3.message) && Pe.delete(n2);
        } finally {
          console.error = r2;
        }
      }
    };
    Re = function(e2, t2, n2) {
      return void 0 === n2 && (n2 = E), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
    };
    De = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
    je = /(^-|-$)/g;
    xe = function(e2) {
      return ee(ne(e2) >>> 0);
    };
    Ve = function(e2) {
      return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
    };
    Be = function(e2) {
      return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
    };
    Ge = import_react.default.createContext();
    Le = Ge.Consumer;
    Ye = {};
    He = function(e2) {
      return function e3(t2, r2, o2) {
        if (void 0 === o2 && (o2 = E), !(0, import_react_is.isValidElementType)(r2))
          return j(1, String(r2));
        var s2 = function() {
          return t2(r2, o2, Ce.apply(void 0, arguments));
        };
        return s2.withConfig = function(n2) {
          return e3(t2, r2, v({}, o2, {}, n2));
        }, s2.attrs = function(n2) {
          return e3(t2, r2, v({}, o2, { attrs: Array.prototype.concat(o2.attrs, n2).filter(Boolean) }));
        }, s2;
      }(qe, e2);
    };
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
      He[e2] = He(e2);
    });
    $e = function() {
      function e2(e3, t3) {
        this.rules = e3, this.componentId = t3, this.isStatic = re(e3), Z.registerId(this.componentId + 1);
      }
      var t2 = e2.prototype;
      return t2.createStyles = function(e3, t3, n2, r2) {
        var o2 = r2(Ne(this.rules, t3, n2, r2).join(""), ""), s2 = this.componentId + e3;
        n2.insertRules(s2, s2, o2);
      }, t2.removeStyles = function(e3, t3) {
        t3.clearRules(this.componentId + e3);
      }, t2.renderStyles = function(e3, t3, n2, r2) {
        e3 > 2 && Z.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, r2);
      }, e2;
    }();
    Je = function() {
      function e2() {
        var e3 = this;
        this._emitSheetCSS = function() {
          var t3 = e3.instance.toString();
          if (!t3)
            return "";
          var n2 = q();
          return "<style " + [n2 && 'nonce="' + n2 + '"', A + '="true"', 'data-styled-version="5.3.9"'].filter(Boolean).join(" ") + ">" + t3 + "</style>";
        }, this.getStyleTags = function() {
          return e3.sealed ? j(2) : e3._emitSheetCSS();
        }, this.getStyleElement = function() {
          var t3;
          if (e3.sealed)
            return j(2);
          var n2 = ((t3 = {})[A] = "", t3["data-styled-version"] = "5.3.9", t3.dangerouslySetInnerHTML = { __html: e3.instance.toString() }, t3), o2 = q();
          return o2 && (n2.nonce = o2), [import_react.default.createElement("style", v({}, n2, { key: "sc-0-0" }))];
        }, this.seal = function() {
          e3.sealed = true;
        }, this.instance = new Z({ isServer: true }), this.sealed = false;
      }
      var t2 = e2.prototype;
      return t2.collectStyles = function(e3) {
        return this.sealed ? j(2) : import_react.default.createElement(ye, { sheet: this.instance }, e3);
      }, t2.interleaveWithNodeStream = function(e3) {
        return j(3);
      }, e2;
    }();
    Xe = function(e2) {
      var t2 = import_react.default.forwardRef(function(t3, n2) {
        var o2 = (0, import_react.useContext)(Ge), i2 = e2.defaultProps, a2 = Re(t3, o2, i2);
        return void 0 === a2 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + _(e2) + '"'), import_react.default.createElement(e2, v({}, t3, { theme: a2, ref: n2 }));
      });
      return (0, import_hoist_non_react_statics.default)(t2, e2), t2.displayName = "WithTheme(" + _(e2) + ")", t2;
    };
    Ze = function() {
      return (0, import_react.useContext)(Ge);
    };
    Ke = { StyleSheet: Z, masterSheet: he };
    "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
    styled_components_browser_esm_default = He;
  }
});

// node_modules/react-doc-viewer/build/state/actions.js
var require_actions = __commonJS({
  "node_modules/react-doc-viewer/build/state/actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setMainConfig = exports2.SET_MAIN_CONFIG = exports2.setRendererRect = exports2.SET_RENDERER_RECT = exports2.updateCurrentDocument = exports2.UPDATE_CURRENT_DOCUMENT = exports2.previousDocument = exports2.PREVIOUS_DOCUMENT = exports2.nextDocument = exports2.NEXT_DOCUMENT = exports2.setDocumentLoading = exports2.SET_DOCUMENT_LOADING = exports2.setAllDocuments = exports2.SET_ALL_DOCUMENTS = void 0;
    exports2.SET_ALL_DOCUMENTS = "SET_ALL_DOCUMENTS";
    exports2.setAllDocuments = function(documents) {
      return {
        type: exports2.SET_ALL_DOCUMENTS,
        documents
      };
    };
    exports2.SET_DOCUMENT_LOADING = "SET_DOCUMENT_LOADING";
    exports2.setDocumentLoading = function(value) {
      return {
        type: exports2.SET_DOCUMENT_LOADING,
        value
      };
    };
    exports2.NEXT_DOCUMENT = "NEXT_DOCUMENT";
    exports2.nextDocument = function() {
      return { type: exports2.NEXT_DOCUMENT };
    };
    exports2.PREVIOUS_DOCUMENT = "PREVIOUS_DOCUMENT";
    exports2.previousDocument = function() {
      return {
        type: exports2.PREVIOUS_DOCUMENT
      };
    };
    exports2.UPDATE_CURRENT_DOCUMENT = "UPDATE_CURRENT_DOCUMENT";
    exports2.updateCurrentDocument = function(document2) {
      return { type: exports2.UPDATE_CURRENT_DOCUMENT, document: document2 };
    };
    exports2.SET_RENDERER_RECT = "SET_RENDERER_RECT";
    exports2.setRendererRect = function(rect) {
      return {
        type: exports2.SET_RENDERER_RECT,
        rect
      };
    };
    exports2.SET_MAIN_CONFIG = "SET_MAIN_CONFIG";
    exports2.setMainConfig = function(config) {
      return {
        type: exports2.SET_MAIN_CONFIG,
        config
      };
    };
  }
});

// node_modules/react-doc-viewer/build/state/reducer.js
var require_reducer = __commonJS({
  "node_modules/react-doc-viewer/build/state/reducer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mainStateReducer = exports2.initialState = void 0;
    var actions_1 = require_actions();
    exports2.initialState = {
      currentFileNo: 0,
      documents: [],
      documentLoading: true,
      currentDocument: void 0,
      rendererRect: void 0,
      config: {},
      pluginRenderers: []
    };
    exports2.mainStateReducer = function(state, action) {
      if (state === void 0) {
        state = exports2.initialState;
      }
      switch (action.type) {
        case actions_1.SET_ALL_DOCUMENTS: {
          var documents = action.documents;
          return __assign(__assign({}, state), { documents, currentDocument: documents[0] || null });
        }
        case actions_1.SET_DOCUMENT_LOADING: {
          var value = action.value;
          return __assign(__assign({}, state), { documentLoading: value });
        }
        case actions_1.NEXT_DOCUMENT: {
          if (state.currentFileNo >= state.documents.length - 1)
            return state;
          var nextDocumentNo = state.currentFileNo + 1;
          return __assign(__assign({}, state), { currentFileNo: nextDocumentNo, currentDocument: state.documents[nextDocumentNo], documentLoading: true });
        }
        case actions_1.PREVIOUS_DOCUMENT: {
          if (state.currentFileNo <= 0)
            return state;
          var prevDocumentNo = state.currentFileNo - 1;
          return __assign(__assign({}, state), { currentFileNo: state.currentFileNo - 1, currentDocument: state.documents[prevDocumentNo], documentLoading: true });
        }
        case actions_1.UPDATE_CURRENT_DOCUMENT: {
          var document_1 = action.document;
          return __assign(__assign({}, state), { currentDocument: document_1 });
        }
        case actions_1.SET_RENDERER_RECT: {
          var rect = action.rect;
          return __assign(__assign({}, state), { rendererRect: rect });
        }
        case actions_1.SET_MAIN_CONFIG: {
          var config = action.config;
          return __assign(__assign({}, state), { config });
        }
        default:
          return state;
      }
    };
  }
});

// node_modules/react-doc-viewer/build/state/index.js
var require_state = __commonJS({
  "node_modules/react-doc-viewer/build/state/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AppProvider = exports2.DocViewerContext = void 0;
    var react_1 = __importStar(require_react());
    var actions_1 = require_actions();
    var reducer_1 = require_reducer();
    var DocViewerContext = react_1.createContext({ state: reducer_1.initialState, dispatch: function() {
      return null;
    } });
    exports2.DocViewerContext = DocViewerContext;
    var AppProvider = function(props) {
      var children = props.children, documents = props.documents, config = props.config, pluginRenderers = props.pluginRenderers;
      var _a = react_1.useReducer(reducer_1.mainStateReducer, __assign(__assign({}, reducer_1.initialState), {
        documents: documents || [],
        currentDocument: documents && documents.length ? documents[0] : void 0,
        config,
        pluginRenderers
      })), state = _a[0], dispatch = _a[1];
      react_1.useEffect(function() {
        dispatch(actions_1.setAllDocuments(documents));
        config && dispatch(actions_1.setMainConfig(config));
      }, [documents]);
      return react_1.default.createElement(DocViewerContext.Provider, { value: { state, dispatch } }, children);
    };
    exports2.AppProvider = AppProvider;
  }
});

// node_modules/react-doc-viewer/build/components/common/Button.js
var require_Button = __commonJS({
  "node_modules/react-doc-viewer/build/components/common/Button.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ButtonSecondary = exports2.ButtonPrimary = exports2.LinkButton = exports2.Button = exports2.ButtonSecondaryStyle = exports2.ButtonPrimaryStyle = void 0;
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    exports2.ButtonPrimaryStyle = styled_components_1.css(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  background-color: ", ";\n  color: ", ";\n"], ["\n  background-color: ", ";\n  color: ", ";\n"])), function(props) {
      return props.theme.primary;
    }, function(props) {
      return props.theme.text_primary;
    });
    exports2.ButtonSecondaryStyle = styled_components_1.css(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  background-color: ", ";\n  color: ", ";\n"], ["\n  background-color: ", ";\n  color: ", ";\n"])), function(props) {
      return props.theme.secondary;
    }, function(props) {
      return props.theme.text_secondary;
    });
    exports2.Button = styled_components_1.default.button(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  ", "\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 35px;\n  height: 35px;\n  padding: 0;\n  margin: 0 0 0 5px;\n  text-align: center;\n  font-size: 18px;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  opacity: ", ";\n  pointer-events: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"], ["\n  ", "\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 35px;\n  height: 35px;\n  padding: 0;\n  margin: 0 0 0 5px;\n  text-align: center;\n  font-size: 18px;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  opacity: ", ";\n  pointer-events: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"])), exports2.ButtonPrimaryStyle, function(props) {
      return props.disabled ? 0.4 : 1;
    }, function(props) {
      return props.disabled ? "none" : "all";
    });
    exports2.LinkButton = styled_components_1.default.a(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  background-color: ", ";\n  color: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  width: 35px;\n  height: 35px;\n  font-size: 18px;\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"], ["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  background-color: ", ";\n  color: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  width: 35px;\n  height: 35px;\n  font-size: 18px;\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"])), function(props) {
      return props.theme.primary;
    }, function(props) {
      return props.theme.text_primary;
    });
    exports2.ButtonPrimary = styled_components_1.default(exports2.Button)(templateObject_5 || (templateObject_5 = __makeTemplateObject([""], [""])));
    exports2.ButtonSecondary = styled_components_1.default(exports2.Button)(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), exports2.ButtonSecondaryStyle);
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
    var templateObject_5;
    var templateObject_6;
  }
});

// node_modules/react-doc-viewer/build/components/icons/index.js
var require_icons = __commonJS({
  "node_modules/react-doc-viewer/build/components/icons/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoadingIcon = exports2.NextDocIcon = exports2.PrevDocIcon = void 0;
    var react_1 = __importDefault(require_react());
    exports2.PrevDocIcon = function(props) {
      return react_1.default.createElement(DocNavIcon, __assign({}, props));
    };
    exports2.NextDocIcon = function(props) {
      return react_1.default.createElement(DocNavIcon, __assign({}, props, { reverse: true }));
    };
    var DocNavIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, id: "arrow_left", version: "1.1", viewBox: "0 0 32 32", xmlSpace: "preserve" },
        react_1.default.createElement("path", { clipRule: "evenodd", d: "M31.106,15H3.278l8.325-8.293  c0.391-0.391,0.391-1.024,0-1.414c-0.391-0.391-1.024-0.391-1.414,0l-9.9,9.899c-0.385,0.385-0.385,1.029,0,1.414l9.9,9.9  c0.391,0.391,1.024,0.391,1.414,0c0.391-0.391,0.391-1.024,0-1.414L3.278,17h27.828c0.552,0,1-0.448,1-1  C32.106,15.448,31.658,15,31.106,15z", fill: color || "#aaa", fillRule: "evenodd", id: "Arrow_Back" })
      );
    };
    exports2.LoadingIcon = function(props) {
      var color = props.color, size = props.size;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", version: "1.1", id: "Icons", viewBox: "0 0 32 32", xmlSpace: "preserve", style: { alignSelf: "center", justifySelf: "center" } },
        react_1.default.createElement(
          "g",
          null,
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M16,2c-0.6,0-1,0.4-1,1v5c0,0.6,0.4,1,1,1s1-0.4,1-1V3C17,2.4,16.6,2,16,2z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M7.5,6.1c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l3.5,3.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.5,6.1\n		z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M9,16c0-0.6-0.4-1-1-1H3c-0.6,0-1,0.4-1,1s0.4,1,1,1h5C8.6,17,9,16.6,9,16z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M9.6,20.9l-3.5,3.5c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l3.5-3.5c0.4-0.4,0.4-1,0-1.4\n		S10,20.6,9.6,20.9z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M16,23c-0.6,0-1,0.4-1,1v5c0,0.6,0.4,1,1,1s1-0.4,1-1v-5C17,23.4,16.6,23,16,23z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M22.4,20.9c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l3.5,3.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4\n		L22.4,20.9z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M29,15h-5c-0.6,0-1,0.4-1,1s0.4,1,1,1h5c0.6,0,1-0.4,1-1S29.6,15,29,15z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M21.7,11.3c0.3,0,0.5-0.1,0.7-0.3l3.5-3.5c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-3.5,3.5c-0.4,0.4-0.4,1,0,1.4\n		C21.1,11.2,21.4,11.3,21.7,11.3z" })
        )
      );
    };
  }
});

// node_modules/react-doc-viewer/build/components/DocumentNav.js
var require_DocumentNav = __commonJS({
  "node_modules/react-doc-viewer/build/components/DocumentNav.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentNav = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    var actions_1 = require_actions();
    var Button_1 = require_Button();
    var icons_1 = require_icons();
    exports2.DocumentNav = function() {
      var _a = react_1.useContext(state_1.DocViewerContext), _b = _a.state, currentDocument = _b.currentDocument, currentFileNo = _b.currentFileNo, documents = _b.documents, dispatch = _a.dispatch;
      if (documents.length <= 1 || !currentDocument)
        return null;
      var fileName = currentDocument.uri;
      var splitURL = fileName.split("/");
      if (splitURL.length) {
        fileName = splitURL[splitURL.length - 1];
      }
      return react_1.default.createElement(
        Container,
        { id: "doc-nav" },
        react_1.default.createElement(
          "p",
          { id: "doc-nav-info" },
          "Doc ",
          currentFileNo + 1,
          " of ",
          documents.length
        ),
        react_1.default.createElement(
          ButtonPrev,
          { id: "doc-nav-prev", onClick: function() {
            return dispatch(actions_1.previousDocument());
          }, disabled: currentFileNo === 0 },
          react_1.default.createElement(icons_1.PrevDocIcon, { color: "#fff", size: "60%" })
        ),
        react_1.default.createElement(
          ButtonNext,
          { id: "doc-nav-next", onClick: function() {
            return dispatch(actions_1.nextDocument());
          }, disabled: currentFileNo >= documents.length - 1 },
          react_1.default.createElement(icons_1.NextDocIcon, { color: "#fff", size: "60%" })
        )
      );
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  min-width: 150px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  margin: 0 10px;\n  color: ", ";\n"], ["\n  min-width: 150px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  margin: 0 10px;\n  color: ", ";\n"])), function(props) {
      return props.theme.text_primary;
    });
    var ButtonPrev = styled_components_1.default(Button_1.ButtonSecondary)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px 0 10px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px 0 10px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var ButtonNext = styled_components_1.default(ButtonPrev)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  margin: 0 5px;\n"], ["\n  margin: 0 5px;\n"])));
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
  }
});

// node_modules/react-doc-viewer/build/components/FileName.js
var require_FileName = __commonJS({
  "node_modules/react-doc-viewer/build/components/FileName.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileName = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    exports2.FileName = function() {
      var _a, _b;
      var _c = react_1.useContext(state_1.DocViewerContext).state, config = _c.config, currentDocument = _c.currentDocument;
      if (!currentDocument || ((_a = config === null || config === void 0 ? void 0 : config.header) === null || _a === void 0 ? void 0 : _a.disableFileName))
        return null;
      var fileName = currentDocument.uri || "";
      fileName = decodeURI(fileName);
      if (!((_b = config === null || config === void 0 ? void 0 : config.header) === null || _b === void 0 ? void 0 : _b.retainURLParams)) {
        fileName = fileName.split("?")[0];
      }
      var splitURL = fileName.split("/");
      if (splitURL.length) {
        fileName = splitURL[splitURL.length - 1];
      }
      return react_1.default.createElement(Container, { id: "file-name", "data-testid": "file-name" }, fileName);
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  flex: 1;\n  text-align: left;\n  color: ", ";\n  font-weight: bold;\n  margin: 0 10px;\n  overflow: hidden;\n"], ["\n  flex: 1;\n  text-align: left;\n  color: ", ";\n  font-weight: bold;\n  margin: 0 10px;\n  overflow: hidden;\n"])), function(props) {
      return props.theme.text_primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/components/HeaderBar.js
var require_HeaderBar = __commonJS({
  "node_modules/react-doc-viewer/build/components/HeaderBar.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeaderBar = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    var actions_1 = require_actions();
    var DocumentNav_1 = require_DocumentNav();
    var FileName_1 = require_FileName();
    exports2.HeaderBar = function() {
      var _a, _b, _c;
      var _d = react_1.useContext(state_1.DocViewerContext), state = _d.state, dispatch = _d.dispatch;
      var config = state.config;
      if ((_a = config === null || config === void 0 ? void 0 : config.header) === null || _a === void 0 ? void 0 : _a.disableHeader)
        return null;
      var override = (_c = (_b = config === null || config === void 0 ? void 0 : config.header) === null || _b === void 0 ? void 0 : _b.overrideComponent) === null || _c === void 0 ? void 0 : _c.call(_b, state, function() {
        return dispatch(actions_1.previousDocument());
      }, function() {
        return dispatch(actions_1.nextDocument());
      });
      if (override) {
        return override;
      } else {
        return react_1.default.createElement(
          Container,
          { id: "header-bar", "data-testid": "header-bar" },
          react_1.default.createElement(FileName_1.FileName, null),
          react_1.default.createElement(DocumentNav_1.DocumentNav, null)
        );
      }
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  z-index: 1;\n  padding: 0 10px;\n  background-color: ", ";\n  font-size: 16px;\n  min-height: 50px;\n\n  @media (max-width: 768px) {\n    min-height: 30px;\n    padding: 5px;\n    font-size: 10px;\n  }\n"], ["\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  z-index: 1;\n  padding: 0 10px;\n  background-color: ", ";\n  font-size: 16px;\n  min-height: 50px;\n\n  @media (max-width: 768px) {\n    min-height: 30px;\n    padding: 5px;\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/utils/fileLoaders.js
var require_fileLoaders = __commonJS({
  "node_modules/react-doc-viewer/build/utils/fileLoaders.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultFileLoader = exports2.binaryStringFileLoader = exports2.textFileLoader = exports2.dataURLFileLoader = exports2.arrayBufferFileLoader = void 0;
    var _fileLoader = function(_a) {
      var documentURI = _a.documentURI, signal = _a.signal, fileLoaderComplete = _a.fileLoaderComplete, readerTypeFunction = _a.readerTypeFunction;
      return fetch(documentURI, { signal }).then(function(res) {
        return __awaiter(void 0, void 0, void 0, function() {
          var blob, fileReader;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, res.blob()];
              case 1:
                blob = _a2.sent();
                fileReader = new FileReader();
                fileReader.addEventListener("loadend", function() {
                  return fileLoaderComplete(fileReader);
                });
                switch (readerTypeFunction) {
                  case "arrayBuffer":
                    fileReader.readAsArrayBuffer(blob);
                    break;
                  case "binaryString":
                    fileReader.readAsBinaryString(blob);
                    break;
                  case "dataURL":
                    fileReader.readAsDataURL(blob);
                    break;
                  case "text":
                    fileReader.readAsText(blob);
                    break;
                  default:
                    break;
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }).catch(function(e2) {
        return e2;
      });
    };
    exports2.arrayBufferFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "arrayBuffer" }));
    };
    exports2.dataURLFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "dataURL" }));
    };
    exports2.textFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "text" }));
    };
    exports2.binaryStringFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "binaryString" }));
    };
    exports2.defaultFileLoader = exports2.dataURLFileLoader;
  }
});

// node_modules/react-doc-viewer/build/utils/useRendererSelector.js
var require_useRendererSelector = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useRendererSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useRendererSelector = void 0;
    var react_1 = require_react();
    var state_1 = require_state();
    exports2.useRendererSelector = function() {
      var _a = react_1.useContext(state_1.DocViewerContext).state, currentDocument = _a.currentDocument, pluginRenderers = _a.pluginRenderers;
      var _b = react_1.useState(), CurrentRenderer = _b[0], setCurrentRenderer = _b[1];
      react_1.useEffect(function() {
        if (!currentDocument)
          return;
        if (!currentDocument.fileType) {
          setCurrentRenderer(void 0);
          return;
        }
        var matchingRenderers = [];
        pluginRenderers === null || pluginRenderers === void 0 ? void 0 : pluginRenderers.map(function(r2) {
          if (currentDocument.fileType === void 0)
            return;
          if (r2.fileTypes.indexOf(currentDocument.fileType) >= 0) {
            matchingRenderers.push(r2);
          }
        });
        var SelectedRenderer = matchingRenderers.sort(function(a2, b2) {
          return b2.weight - a2.weight;
        })[0];
        if (SelectedRenderer && SelectedRenderer !== void 0) {
          setCurrentRenderer(function() {
            return SelectedRenderer;
          });
        } else {
          setCurrentRenderer(null);
        }
      }, [currentDocument]);
      return { CurrentRenderer };
    };
  }
});

// node_modules/react-doc-viewer/build/utils/useDocumentLoader.js
var require_useDocumentLoader = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useDocumentLoader.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useDocumentLoader = void 0;
    var react_1 = require_react();
    var state_1 = require_state();
    var actions_1 = require_actions();
    var fileLoaders_1 = require_fileLoaders();
    var useRendererSelector_1 = require_useRendererSelector();
    exports2.useDocumentLoader = function() {
      var _a = react_1.useContext(state_1.DocViewerContext), state = _a.state, dispatch = _a.dispatch;
      var currentFileNo = state.currentFileNo, currentDocument = state.currentDocument;
      var CurrentRenderer = useRendererSelector_1.useRendererSelector().CurrentRenderer;
      var documentURI = (currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri) || "";
      react_1.useEffect(
        function() {
          if (!currentDocument)
            return;
          if (currentDocument.fileType !== void 0)
            return;
          var controller = new AbortController();
          var signal = controller.signal;
          fetch(documentURI, { method: "HEAD", signal }).then(function(response) {
            var contentTypeRaw = response.headers.get("content-type");
            var contentTypes = (contentTypeRaw === null || contentTypeRaw === void 0 ? void 0 : contentTypeRaw.split(";")) || [];
            var contentType = contentTypes.length ? contentTypes[0] : void 0;
            dispatch(actions_1.updateCurrentDocument(__assign(__assign({}, currentDocument), { fileType: contentType || void 0 })));
          });
          return function() {
            controller.abort();
          };
        },
        // eslint ignore added, because a warning appears for dispatch to
        // be a dependancy of the useEffect
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [currentFileNo, documentURI]
      );
      react_1.useEffect(function() {
        var _a2;
        if (!currentDocument || CurrentRenderer === void 0)
          return;
        var controller = new AbortController();
        var signal = controller.signal;
        var fileLoaderComplete = function(fileReader) {
          if (!currentDocument || !fileReader) {
            dispatch(actions_1.setDocumentLoading(false));
            return;
          }
          var updatedDocument = __assign({}, currentDocument);
          if (fileReader.result !== null) {
            updatedDocument.fileData = fileReader.result;
          }
          dispatch(actions_1.updateCurrentDocument(updatedDocument));
          dispatch(actions_1.setDocumentLoading(false));
        };
        if (CurrentRenderer === null) {
          dispatch(actions_1.setDocumentLoading(false));
        } else if (CurrentRenderer.fileLoader !== void 0) {
          (_a2 = CurrentRenderer.fileLoader) === null || _a2 === void 0 ? void 0 : _a2.call(CurrentRenderer, { documentURI, signal, fileLoaderComplete });
        } else {
          fileLoaders_1.defaultFileLoader({ documentURI, signal, fileLoaderComplete });
        }
        return function() {
          controller.abort();
        };
      }, [CurrentRenderer]);
      return { state, dispatch, CurrentRenderer };
    };
  }
});

// node_modules/react-doc-viewer/build/utils/useWindowSize.js
var require_useWindowSize = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useWindowSize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useWindowSize = void 0;
    var react_1 = require_react();
    exports2.useWindowSize = function() {
      var _a = react_1.useState({
        width: void 0,
        height: void 0
      }), windowSize = _a[0], setWindowSize = _a[1];
      react_1.useEffect(function() {
        function handleResize() {
          setWindowSize({
            width: window.innerWidth,
            height: window.innerHeight
          });
        }
        window.addEventListener("resize", handleResize);
        handleResize();
        return function() {
          return window.removeEventListener("resize", handleResize);
        };
      }, []);
      return windowSize;
    };
  }
});

// node_modules/react-doc-viewer/build/components/common/index.js
var require_common = __commonJS({
  "node_modules/react-doc-viewer/build/components/common/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Button(), exports2);
  }
});

// node_modules/react-doc-viewer/build/components/ProxyRenderer.js
var require_ProxyRenderer = __commonJS({
  "node_modules/react-doc-viewer/build/components/ProxyRenderer.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyRenderer = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var actions_1 = require_actions();
    var useDocumentLoader_1 = require_useDocumentLoader();
    var useWindowSize_1 = require_useWindowSize();
    var common_1 = require_common();
    var icons_1 = require_icons();
    exports2.ProxyRenderer = function() {
      var _a = useDocumentLoader_1.useDocumentLoader(), state = _a.state, dispatch = _a.dispatch, CurrentRenderer = _a.CurrentRenderer;
      var documents = state.documents, documentLoading = state.documentLoading, currentDocument = state.currentDocument;
      var size = useWindowSize_1.useWindowSize();
      var containerRef = react_1.useCallback(
        function(node) {
          node && dispatch(actions_1.setRendererRect(node === null || node === void 0 ? void 0 : node.getBoundingClientRect()));
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [size]
      );
      var Contents = function() {
        if (!documents.length) {
          return react_1.default.createElement("div", { id: "no-documents" });
        } else if (documentLoading) {
          return react_1.default.createElement(
            LoadingContainer,
            { id: "loading-renderer", "data-testid": "loading-renderer" },
            react_1.default.createElement(
              LoadingIconContainer,
              null,
              react_1.default.createElement(icons_1.LoadingIcon, { color: "#444", size: 40 })
            )
          );
        } else {
          if (CurrentRenderer) {
            return react_1.default.createElement(CurrentRenderer, { mainState: state });
          } else if (CurrentRenderer === void 0) {
            return null;
          } else {
            return react_1.default.createElement(
              "div",
              { id: "no-renderer", "data-testid": "no-renderer" },
              "No Renderer for file type ",
              currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileType,
              react_1.default.createElement(DownloadButton, { id: "no-renderer-download", href: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri, download: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri }, "Download File")
            );
          }
        }
      };
      return react_1.default.createElement(
        Container,
        { id: "proxy-renderer", ref: containerRef },
        react_1.default.createElement(Contents, null)
      );
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  overflow-y: auto;\n"], ["\n  display: flex;\n  flex: 1;\n  overflow-y: auto;\n"])));
    var LoadingContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  height: 75px;\n  align-items: center;\n  justify-content: center;\n"], ["\n  display: flex;\n  flex: 1;\n  height: 75px;\n  align-items: center;\n  justify-content: center;\n"])));
    var spinAnim = styled_components_1.keyframes(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"], ["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"])));
    var LoadingIconContainer = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  animation-name: ", ";\n  animation-duration: 4s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n"], ["\n  animation-name: ", ";\n  animation-duration: 4s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n"])), spinAnim);
    var DownloadButton = styled_components_1.default(common_1.LinkButton)(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n  width: 130px;\n  height: 30px;\n  background-color: ", ";\n  @media (max-width: 768px) {\n    width: 125px;\n    height: 25px;\n  }\n"], ["\n  width: 130px;\n  height: 30px;\n  background-color: ", ";\n  @media (max-width: 768px) {\n    width: 125px;\n    height: 25px;\n  }\n"])), function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
    var templateObject_5;
  }
});

// node_modules/react-doc-viewer/build/plugins/image/index.js
var require_image = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/image/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var ImageProxyRenderer = function(props) {
      var currentDocument = props.mainState.currentDocument, children = props.children;
      if (!currentDocument)
        return null;
      return react_1.default.createElement(Container, __assign({ id: "image-renderer" }, props), children || react_1.default.createElement(Img, { id: "image-img", src: currentDocument.fileData }));
    };
    exports2.default = ImageProxyRenderer;
    ImageProxyRenderer.fileTypes = [];
    ImageProxyRenderer.weight = 0;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  background-color: #fff;\n"], ["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  background-color: #fff;\n"])));
    var Img = styled_components_1.default.img(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  max-width: 95%;\n  max-height: 95%;\n"], ["\n  max-width: 95%;\n  max-height: 95%;\n"])));
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/bmp/index.js
var require_bmp = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/bmp/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var image_1 = __importDefault(require_image());
    var BMPRenderer = function(props) {
      return react_1.default.createElement(image_1.default, __assign({}, props));
    };
    BMPRenderer.fileTypes = ["bmp", "image/bmp"];
    BMPRenderer.weight = 0;
    exports2.default = BMPRenderer;
  }
});

// node_modules/react-doc-viewer/build/plugins/html/index.js
var require_html = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/html/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var HTMLRenderer = function(_a) {
      var currentDocument = _a.mainState.currentDocument;
      react_1.useEffect(function() {
        var b64String = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData;
        var bodyBase64 = (b64String === null || b64String === void 0 ? void 0 : b64String.replace("data:text/html;base64,", "")) || "";
        var body = window.atob(bodyBase64);
        var iframeCont = document.getElementById("html-body");
        var iframe = (iframeCont === null || iframeCont === void 0 ? void 0 : iframeCont.contentWindow) && iframeCont.contentWindow;
        if (!iframe)
          return;
        var iframeDoc = iframe.document;
        iframeDoc.open();
        iframeDoc.write("" + body);
        iframeDoc.close();
      }, []);
      return react_1.default.createElement(
        Container,
        { id: "html-renderer" },
        react_1.default.createElement(BodyIFrame, { id: "html-body", sandbox: "allow-same-origin" })
      );
    };
    exports2.default = HTMLRenderer;
    HTMLRenderer.fileTypes = ["htm", "html", "text/htm", "text/html"];
    HTMLRenderer.weight = 0;
    HTMLRenderer.fileLoader = fileLoaders_1.dataURLFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"])));
    var BodyIFrame = styled_components_1.default.iframe(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"], ["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/jpg/index.js
var require_jpg = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/jpg/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var image_1 = __importDefault(require_image());
    var JPGRenderer = function(props) {
      return react_1.default.createElement(image_1.default, __assign({}, props));
    };
    JPGRenderer.fileTypes = ["jpg", "jpeg", "image/jpg", "image/jpeg"];
    JPGRenderer.weight = 0;
    exports2.default = JPGRenderer;
  }
});

// node_modules/react-doc-viewer/build/plugins/msdoc/index.js
var require_msdoc = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/msdoc/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s2 += arguments[i2].length;
      for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var MSDocRenderer = function(_a) {
      var currentDocument = _a.mainState.currentDocument;
      if (!currentDocument)
        return null;
      return react_1.default.createElement(
        Container,
        { id: "msdoc-renderer" },
        react_1.default.createElement(IFrame, { id: "msdoc-iframe", title: "msdoc-iframe", src: "https://view.officeapps.live.com/op/embed.aspx?src=" + encodeURIComponent(currentDocument.uri), frameBorder: "0" })
      );
    };
    exports2.default = MSDocRenderer;
    var MSDocFTMaps = {
      doc: ["doc", "application/msword"],
      docx: [
        "docx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
      ],
      xls: ["xls", "application/vnd.ms-excel"],
      xlsx: [
        "xlsx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
      ],
      ppt: ["ppt", "application/vnd.ms-powerpoint"],
      pptx: [
        "pptx",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation"
      ]
    };
    MSDocRenderer.fileTypes = __spreadArrays(MSDocFTMaps.doc, MSDocFTMaps.docx, MSDocFTMaps.xls, MSDocFTMaps.xlsx, MSDocFTMaps.ppt, MSDocFTMaps.pptx);
    MSDocRenderer.weight = 0;
    MSDocRenderer.fileLoader = function(_a) {
      var fileLoaderComplete = _a.fileLoaderComplete;
      return fileLoaderComplete();
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  width: 100%;\n"], ["\n  width: 100%;\n"])));
    var IFrame = styled_components_1.default.iframe(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  border: 0;\n"], ["\n  width: 100%;\n  height: 100%;\n  border: 0;\n"])));
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/wl-msg-reader/lib/DataStream.js
var require_DataStream = __commonJS({
  "node_modules/wl-msg-reader/lib/DataStream.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory();
      } else {
        root.DataStream = factory();
      }
    })(exports2, function() {
      var DataStream = function(arrayBuffer, byteOffset, endianness) {
        this._byteOffset = byteOffset || 0;
        if (arrayBuffer instanceof ArrayBuffer) {
          this.buffer = arrayBuffer;
        } else if (typeof arrayBuffer == "object") {
          this.dataView = arrayBuffer;
          if (byteOffset) {
            this._byteOffset += byteOffset;
          }
        } else {
          this.buffer = new ArrayBuffer(arrayBuffer || 1);
        }
        this.position = 0;
        this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;
      };
      DataStream.prototype = {};
      if (Uint8Array.prototype.BYTES_PER_ELEMENT === void 0) {
        Uint8Array.prototype.BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT;
        Int8Array.prototype.BYTES_PER_ELEMENT = Int8Array.BYTES_PER_ELEMENT;
        Uint8ClampedArray.prototype.BYTES_PER_ELEMENT = Uint8ClampedArray.BYTES_PER_ELEMENT;
        Uint16Array.prototype.BYTES_PER_ELEMENT = Uint16Array.BYTES_PER_ELEMENT;
        Int16Array.prototype.BYTES_PER_ELEMENT = Int16Array.BYTES_PER_ELEMENT;
        Uint32Array.prototype.BYTES_PER_ELEMENT = Uint32Array.BYTES_PER_ELEMENT;
        Int32Array.prototype.BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT;
        Float64Array.prototype.BYTES_PER_ELEMENT = Float64Array.BYTES_PER_ELEMENT;
      }
      DataStream.prototype.save = function(filename) {
        var blob = new Blob(this.buffer);
        var URL2 = window.webkitURL || window.URL;
        if (URL2 && URL2.createObjectURL) {
          var url = URL2.createObjectURL(blob);
          var a2 = document.createElement("a");
          a2.setAttribute("href", url);
          a2.setAttribute("download", filename);
          a2.click();
          URL2.revokeObjectURL(url);
        } else {
          throw "DataStream.save: Can't create object URL.";
        }
      };
      DataStream.BIG_ENDIAN = false;
      DataStream.LITTLE_ENDIAN = true;
      DataStream.prototype._dynamicSize = true;
      Object.defineProperty(
        DataStream.prototype,
        "dynamicSize",
        {
          get: function() {
            return this._dynamicSize;
          },
          set: function(v2) {
            if (!v2) {
              this._trimAlloc();
            }
            this._dynamicSize = v2;
          }
        }
      );
      DataStream.prototype._byteLength = 0;
      Object.defineProperty(
        DataStream.prototype,
        "byteLength",
        {
          get: function() {
            return this._byteLength - this._byteOffset;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "buffer",
        {
          get: function() {
            this._trimAlloc();
            return this._buffer;
          },
          set: function(v2) {
            this._buffer = v2;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._buffer.byteLength;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "byteOffset",
        {
          get: function() {
            return this._byteOffset;
          },
          set: function(v2) {
            this._byteOffset = v2;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._buffer.byteLength;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "dataView",
        {
          get: function() {
            return this._dataView;
          },
          set: function(v2) {
            this._byteOffset = v2.byteOffset;
            this._buffer = v2.buffer;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._byteOffset + v2.byteLength;
          }
        }
      );
      DataStream.prototype._realloc = function(extra) {
        if (!this._dynamicSize) {
          return;
        }
        var req = this._byteOffset + this.position + extra;
        var blen = this._buffer.byteLength;
        if (req <= blen) {
          if (req > this._byteLength) {
            this._byteLength = req;
          }
          return;
        }
        if (blen < 1) {
          blen = 1;
        }
        while (req > blen) {
          blen *= 2;
        }
        var buf = new ArrayBuffer(blen);
        var src = new Uint8Array(this._buffer);
        var dst = new Uint8Array(buf, 0, src.length);
        dst.set(src);
        this.buffer = buf;
        this._byteLength = req;
      };
      DataStream.prototype._trimAlloc = function() {
        if (this._byteLength == this._buffer.byteLength) {
          return;
        }
        var buf = new ArrayBuffer(this._byteLength);
        var dst = new Uint8Array(buf);
        var src = new Uint8Array(this._buffer, 0, dst.length);
        dst.set(src);
        this.buffer = buf;
      };
      DataStream.prototype.seek = function(pos) {
        var npos = Math.max(0, Math.min(this.byteLength, pos));
        this.position = isNaN(npos) || !isFinite(npos) ? 0 : npos;
      };
      DataStream.prototype.isEof = function() {
        return this.position >= this.byteLength;
      };
      DataStream.prototype.mapInt32Array = function(length, e2) {
        this._realloc(length * 4);
        var arr = new Int32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.mapInt16Array = function(length, e2) {
        this._realloc(length * 2);
        var arr = new Int16Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 2;
        return arr;
      };
      DataStream.prototype.mapInt8Array = function(length) {
        this._realloc(length * 1);
        var arr = new Int8Array(this._buffer, this.byteOffset + this.position, length);
        this.position += length * 1;
        return arr;
      };
      DataStream.prototype.mapUint32Array = function(length, e2) {
        this._realloc(length * 4);
        var arr = new Uint32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.mapUint16Array = function(length, e2) {
        this._realloc(length * 2);
        var arr = new Uint16Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 2;
        return arr;
      };
      DataStream.prototype.mapUint8Array = function(length) {
        this._realloc(length * 1);
        var arr = new Uint8Array(this._buffer, this.byteOffset + this.position, length);
        this.position += length * 1;
        return arr;
      };
      DataStream.prototype.mapFloat64Array = function(length, e2) {
        this._realloc(length * 8);
        var arr = new Float64Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 8;
        return arr;
      };
      DataStream.prototype.mapFloat32Array = function(length, e2) {
        this._realloc(length * 4);
        var arr = new Float32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.readInt32Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Int32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readInt16Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 2 : length;
        var arr = new Int16Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readInt8Array = function(length) {
        length = length == null ? this.byteLength - this.position : length;
        var arr = new Int8Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint32Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Uint32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint16Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 2 : length;
        var arr = new Uint16Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint8Array = function(length) {
        length = length == null ? this.byteLength - this.position : length;
        var arr = new Uint8Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readFloat64Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 8 : length;
        var arr = new Float64Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readFloat32Array = function(length, e2) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Float32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e2 == null ? this.endianness : e2);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.writeInt32Array = function(arr, e2) {
        this._realloc(arr.length * 4);
        if (arr instanceof Int32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt32Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeInt32(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.writeInt16Array = function(arr, e2) {
        this._realloc(arr.length * 2);
        if (arr instanceof Int16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt16Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeInt16(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.writeInt8Array = function(arr) {
        this._realloc(arr.length * 1);
        if (arr instanceof Int8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt8Array(arr.length);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeInt8(arr[i2]);
          }
        }
      };
      DataStream.prototype.writeUint32Array = function(arr, e2) {
        this._realloc(arr.length * 4);
        if (arr instanceof Uint32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint32Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeUint32(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.writeUint16Array = function(arr, e2) {
        this._realloc(arr.length * 2);
        if (arr instanceof Uint16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint16Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeUint16(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.writeUint8Array = function(arr) {
        this._realloc(arr.length * 1);
        if (arr instanceof Uint8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint8Array(arr.length);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeUint8(arr[i2]);
          }
        }
      };
      DataStream.prototype.writeFloat64Array = function(arr, e2) {
        this._realloc(arr.length * 8);
        if (arr instanceof Float64Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapFloat64Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeFloat64(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.writeFloat32Array = function(arr, e2) {
        this._realloc(arr.length * 4);
        if (arr instanceof Float32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapFloat32Array(arr.length, e2);
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            this.writeFloat32(arr[i2], e2);
          }
        }
      };
      DataStream.prototype.readInt32 = function(e2) {
        var v2 = this._dataView.getInt32(this.position, e2 == null ? this.endianness : e2);
        this.position += 4;
        return v2;
      };
      DataStream.prototype.readInt = function(offset) {
        this.seek(offset);
        return this.readInt32();
      };
      DataStream.prototype.readInt16 = function(e2) {
        var v2 = this._dataView.getInt16(this.position, e2 == null ? this.endianness : e2);
        this.position += 2;
        return v2;
      };
      DataStream.prototype.readShort = function(offset) {
        this.seek(offset);
        return this.readInt16();
      };
      DataStream.prototype.readInt8 = function() {
        var v2 = this._dataView.getInt8(this.position);
        this.position += 1;
        return v2;
      };
      DataStream.prototype.readByte = function(offset) {
        this.seek(offset);
        return this.readInt8();
      };
      DataStream.prototype.readUint32 = function(e2) {
        var v2 = this._dataView.getUint32(this.position, e2 == null ? this.endianness : e2);
        this.position += 4;
        return v2;
      };
      DataStream.prototype.readUint16 = function(e2) {
        var v2 = this._dataView.getUint16(this.position, e2 == null ? this.endianness : e2);
        this.position += 2;
        return v2;
      };
      DataStream.prototype.readUint8 = function() {
        var v2 = this._dataView.getUint8(this.position);
        this.position += 1;
        return v2;
      };
      DataStream.prototype.readFloat32 = function(e2) {
        var v2 = this._dataView.getFloat32(this.position, e2 == null ? this.endianness : e2);
        this.position += 4;
        return v2;
      };
      DataStream.prototype.readFloat64 = function(e2) {
        var v2 = this._dataView.getFloat64(this.position, e2 == null ? this.endianness : e2);
        this.position += 8;
        return v2;
      };
      DataStream.prototype.writeInt32 = function(v2, e2) {
        this._realloc(4);
        this._dataView.setInt32(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 4;
      };
      DataStream.prototype.writeInt16 = function(v2, e2) {
        this._realloc(2);
        this._dataView.setInt16(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 2;
      };
      DataStream.prototype.writeInt8 = function(v2) {
        this._realloc(1);
        this._dataView.setInt8(this.position, v2);
        this.position += 1;
      };
      DataStream.prototype.writeUint32 = function(v2, e2) {
        this._realloc(4);
        this._dataView.setUint32(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 4;
      };
      DataStream.prototype.writeUint16 = function(v2, e2) {
        this._realloc(2);
        this._dataView.setUint16(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 2;
      };
      DataStream.prototype.writeUint8 = function(v2) {
        this._realloc(1);
        this._dataView.setUint8(this.position, v2);
        this.position += 1;
      };
      DataStream.prototype.writeFloat32 = function(v2, e2) {
        this._realloc(4);
        this._dataView.setFloat32(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 4;
      };
      DataStream.prototype.writeFloat64 = function(v2, e2) {
        this._realloc(8);
        this._dataView.setFloat64(this.position, v2, e2 == null ? this.endianness : e2);
        this.position += 8;
      };
      DataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;
      DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {
        var dstU8 = new Uint8Array(dst, dstOffset, byteLength);
        var srcU8 = new Uint8Array(src, srcOffset, byteLength);
        dstU8.set(srcU8);
      };
      DataStream.arrayToNative = function(array, arrayIsLittleEndian) {
        if (arrayIsLittleEndian == this.endianness) {
          return array;
        } else {
          return this.flipArrayEndianness(array);
        }
      };
      DataStream.nativeToEndian = function(array, littleEndian) {
        if (this.endianness == littleEndian) {
          return array;
        } else {
          return this.flipArrayEndianness(array);
        }
      };
      DataStream.flipArrayEndianness = function(array) {
        var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        for (var i2 = 0; i2 < array.byteLength; i2 += array.BYTES_PER_ELEMENT) {
          for (var j2 = i2 + array.BYTES_PER_ELEMENT - 1, k2 = i2; j2 > k2; j2--, k2++) {
            var tmp = u8[k2];
            u8[k2] = u8[j2];
            u8[j2] = tmp;
          }
        }
        return array;
      };
      DataStream.createStringFromArray = function(array) {
        var str = "";
        for (var i2 = 0; i2 < array.length; i2++) {
          str += String.fromCharCode(array[i2]);
        }
        return str;
      };
      DataStream.prototype.failurePosition = 0;
      DataStream.prototype.readStruct = function(structDefinition) {
        var struct = {}, t2, v2, n2;
        var p = this.position;
        for (var i2 = 0; i2 < structDefinition.length; i2 += 2) {
          t2 = structDefinition[i2 + 1];
          v2 = this.readType(t2, struct);
          if (v2 == null) {
            if (this.failurePosition == 0) {
              this.failurePosition = this.position;
            }
            this.position = p;
            return null;
          }
          struct[structDefinition[i2]] = v2;
        }
        return struct;
      };
      DataStream.prototype.readUCS2String = function(length, endianness) {
        return DataStream.createStringFromArray(this.readUint16Array(length, endianness));
      };
      DataStream.prototype.readStringAt = function(offset, length) {
        this.seek(offset);
        return this.readUCS2String(length);
      };
      DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {
        if (lengthOverride == null) {
          lengthOverride = str.length;
        }
        for (var i2 = 0; i2 < str.length && i2 < lengthOverride; i2++) {
          this.writeUint16(str.charCodeAt(i2), endianness);
        }
        for (; i2 < lengthOverride; i2++) {
          this.writeUint16(0);
        }
      };
      DataStream.prototype.readString = function(length, encoding) {
        if (encoding == null || encoding == "ASCII") {
          return DataStream.createStringFromArray(this.mapUint8Array(length == null ? this.byteLength - this.position : length));
        } else {
          return new TextDecoder(encoding).decode(this.mapUint8Array(length));
        }
      };
      DataStream.prototype.writeString = function(s2, encoding, length) {
        if (encoding == null || encoding == "ASCII") {
          if (length != null) {
            var i2 = 0;
            var len = Math.min(s2.length, length);
            for (i2 = 0; i2 < len; i2++) {
              this.writeUint8(s2.charCodeAt(i2));
            }
            for (; i2 < length; i2++) {
              this.writeUint8(0);
            }
          } else {
            for (var i2 = 0; i2 < s2.length; i2++) {
              this.writeUint8(s2.charCodeAt(i2));
            }
          }
        } else {
          this.writeUint8Array(new TextEncoder(encoding).encode(s2.substring(0, length)));
        }
      };
      DataStream.prototype.readCString = function(length) {
        var blen = this.byteLength - this.position;
        var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);
        var len = blen;
        if (length != null) {
          len = Math.min(length, blen);
        }
        for (var i2 = 0; i2 < len && u8[i2] != 0; i2++)
          ;
        var s2 = DataStream.createStringFromArray(this.mapUint8Array(i2));
        if (length != null) {
          this.position += len - i2;
        } else if (i2 != blen) {
          this.position += 1;
        }
        return s2;
      };
      DataStream.prototype.writeCString = function(s2, length) {
        if (length != null) {
          var i2 = 0;
          var len = Math.min(s2.length, length);
          for (i2 = 0; i2 < len; i2++) {
            this.writeUint8(s2.charCodeAt(i2));
          }
          for (; i2 < length; i2++) {
            this.writeUint8(0);
          }
        } else {
          for (var i2 = 0; i2 < s2.length; i2++) {
            this.writeUint8(s2.charCodeAt(i2));
          }
          this.writeUint8(0);
        }
      };
      DataStream.prototype.readType = function(t2, struct) {
        if (typeof t2 == "function") {
          return t2(this, struct);
        } else if (typeof t2 == "object" && !(t2 instanceof Array)) {
          return t2.get(this, struct);
        } else if (t2 instanceof Array && t2.length != 3) {
          return this.readStruct(t2, struct);
        }
        var v2 = null;
        var lengthOverride = null;
        var charset = "ASCII";
        var pos = this.position;
        var len;
        if (typeof t2 == "string" && /:/.test(t2)) {
          var tp = t2.split(":");
          t2 = tp[0];
          len = tp[1];
          if (struct[len] != null) {
            lengthOverride = parseInt(struct[len]);
          } else {
            lengthOverride = parseInt(tp[1]);
          }
        }
        if (typeof t2 == "string" && /,/.test(t2)) {
          var tp = t2.split(",");
          t2 = tp[0];
          charset = parseInt(tp[1]);
        }
        switch (t2) {
          case "uint8":
            v2 = this.readUint8();
            break;
          case "int8":
            v2 = this.readInt8();
            break;
          case "uint16":
            v2 = this.readUint16(this.endianness);
            break;
          case "int16":
            v2 = this.readInt16(this.endianness);
            break;
          case "uint32":
            v2 = this.readUint32(this.endianness);
            break;
          case "int32":
            v2 = this.readInt32(this.endianness);
            break;
          case "float32":
            v2 = this.readFloat32(this.endianness);
            break;
          case "float64":
            v2 = this.readFloat64(this.endianness);
            break;
          case "uint16be":
            v2 = this.readUint16(DataStream.BIG_ENDIAN);
            break;
          case "int16be":
            v2 = this.readInt16(DataStream.BIG_ENDIAN);
            break;
          case "uint32be":
            v2 = this.readUint32(DataStream.BIG_ENDIAN);
            break;
          case "int32be":
            v2 = this.readInt32(DataStream.BIG_ENDIAN);
            break;
          case "float32be":
            v2 = this.readFloat32(DataStream.BIG_ENDIAN);
            break;
          case "float64be":
            v2 = this.readFloat64(DataStream.BIG_ENDIAN);
            break;
          case "uint16le":
            v2 = this.readUint16(DataStream.LITTLE_ENDIAN);
            break;
          case "int16le":
            v2 = this.readInt16(DataStream.LITTLE_ENDIAN);
            break;
          case "uint32le":
            v2 = this.readUint32(DataStream.LITTLE_ENDIAN);
            break;
          case "int32le":
            v2 = this.readInt32(DataStream.LITTLE_ENDIAN);
            break;
          case "float32le":
            v2 = this.readFloat32(DataStream.LITTLE_ENDIAN);
            break;
          case "float64le":
            v2 = this.readFloat64(DataStream.LITTLE_ENDIAN);
            break;
          case "cstring":
            v2 = this.readCString(lengthOverride);
            break;
          case "string":
            v2 = this.readString(lengthOverride, charset);
            break;
          case "u16string":
            v2 = this.readUCS2String(lengthOverride, this.endianness);
            break;
          case "u16stringle":
            v2 = this.readUCS2String(lengthOverride, DataStream.LITTLE_ENDIAN);
            break;
          case "u16stringbe":
            v2 = this.readUCS2String(lengthOverride, DataStream.BIG_ENDIAN);
            break;
          default:
            if (t2.length == 3) {
              var ta = t2[1];
              var len = t2[2];
              var length = 0;
              if (typeof len == "function") {
                length = len(struct, this, t2);
              } else if (typeof len == "string" && struct[len] != null) {
                length = parseInt(struct[len]);
              } else {
                length = parseInt(len);
              }
              if (typeof ta == "string") {
                var tap = ta.replace(/(le|be)$/, "");
                var endianness = null;
                if (/le$/.test(ta)) {
                  endianness = DataStream.LITTLE_ENDIAN;
                } else if (/be$/.test(ta)) {
                  endianness = DataStream.BIG_ENDIAN;
                }
                if (len == "*") {
                  length = null;
                }
                switch (tap) {
                  case "uint8":
                    v2 = this.readUint8Array(length);
                    break;
                  case "uint16":
                    v2 = this.readUint16Array(length, endianness);
                    break;
                  case "uint32":
                    v2 = this.readUint32Array(length, endianness);
                    break;
                  case "int8":
                    v2 = this.readInt8Array(length);
                    break;
                  case "int16":
                    v2 = this.readInt16Array(length, endianness);
                    break;
                  case "int32":
                    v2 = this.readInt32Array(length, endianness);
                    break;
                  case "float32":
                    v2 = this.readFloat32Array(length, endianness);
                    break;
                  case "float64":
                    v2 = this.readFloat64Array(length, endianness);
                    break;
                  case "cstring":
                  case "utf16string":
                  case "string":
                    if (length == null) {
                      v2 = [];
                      while (!this.isEof()) {
                        var u2 = this.readType(ta, struct);
                        if (u2 == null)
                          break;
                        v2.push(u2);
                      }
                    } else {
                      v2 = new Array(length);
                      for (var i2 = 0; i2 < length; i2++) {
                        v2[i2] = this.readType(ta, struct);
                      }
                    }
                    break;
                }
              } else {
                if (len == "*") {
                  v2 = [];
                  this.buffer;
                  while (true) {
                    var p = this.position;
                    try {
                      var o2 = this.readType(ta, struct);
                      if (o2 == null) {
                        this.position = p;
                        break;
                      }
                      v2.push(o2);
                    } catch (e2) {
                      this.position = p;
                      break;
                    }
                  }
                } else {
                  v2 = new Array(length);
                  for (var i2 = 0; i2 < length; i2++) {
                    var u2 = this.readType(ta, struct);
                    if (u2 == null)
                      return null;
                    v2[i2] = u2;
                  }
                }
              }
              break;
            }
        }
        if (lengthOverride != null) {
          this.position = pos + lengthOverride;
        }
        return v2;
      };
      DataStream.prototype.writeStruct = function(structDefinition, struct) {
        for (var i2 = 0; i2 < structDefinition.length; i2 += 2) {
          var t2 = structDefinition[i2 + 1];
          this.writeType(t2, struct[structDefinition[i2]], struct);
        }
      };
      DataStream.prototype.writeType = function(t2, v2, struct) {
        if (typeof t2 == "function") {
          return t2(this, v2);
        } else if (typeof t2 == "object" && !(t2 instanceof Array)) {
          return t2.set(this, v2, struct);
        }
        var lengthOverride = null;
        var charset = "ASCII";
        var pos = this.position;
        if (typeof t2 == "string" && /:/.test(t2)) {
          var tp = t2.split(":");
          t2 = tp[0];
          lengthOverride = parseInt(tp[1]);
        }
        if (typeof t2 == "string" && /,/.test(t2)) {
          var tp = t2.split(",");
          t2 = tp[0];
          charset = parseInt(tp[1]);
        }
        switch (t2) {
          case "uint8":
            this.writeUint8(v2);
            break;
          case "int8":
            this.writeInt8(v2);
            break;
          case "uint16":
            this.writeUint16(v2, this.endianness);
            break;
          case "int16":
            this.writeInt16(v2, this.endianness);
            break;
          case "uint32":
            this.writeUint32(v2, this.endianness);
            break;
          case "int32":
            this.writeInt32(v2, this.endianness);
            break;
          case "float32":
            this.writeFloat32(v2, this.endianness);
            break;
          case "float64":
            this.writeFloat64(v2, this.endianness);
            break;
          case "uint16be":
            this.writeUint16(v2, DataStream.BIG_ENDIAN);
            break;
          case "int16be":
            this.writeInt16(v2, DataStream.BIG_ENDIAN);
            break;
          case "uint32be":
            this.writeUint32(v2, DataStream.BIG_ENDIAN);
            break;
          case "int32be":
            this.writeInt32(v2, DataStream.BIG_ENDIAN);
            break;
          case "float32be":
            this.writeFloat32(v2, DataStream.BIG_ENDIAN);
            break;
          case "float64be":
            this.writeFloat64(v2, DataStream.BIG_ENDIAN);
            break;
          case "uint16le":
            this.writeUint16(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "int16le":
            this.writeInt16(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "uint32le":
            this.writeUint32(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "int32le":
            this.writeInt32(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "float32le":
            this.writeFloat32(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "float64le":
            this.writeFloat64(v2, DataStream.LITTLE_ENDIAN);
            break;
          case "cstring":
            this.writeCString(v2, lengthOverride);
            break;
          case "string":
            this.writeString(v2, charset, lengthOverride);
            break;
          case "u16string":
            this.writeUCS2String(v2, this.endianness, lengthOverride);
            break;
          case "u16stringle":
            this.writeUCS2String(v2, DataStream.LITTLE_ENDIAN, lengthOverride);
            break;
          case "u16stringbe":
            this.writeUCS2String(v2, DataStream.BIG_ENDIAN, lengthOverride);
            break;
          default:
            if (t2.length == 3) {
              var ta = t2[1];
              for (var i2 = 0; i2 < v2.length; i2++) {
                this.writeType(ta, v2[i2]);
              }
              break;
            } else {
              this.writeStruct(t2, v2);
              break;
            }
        }
        if (lengthOverride != null) {
          this.position = pos;
          this._realloc(lengthOverride);
          this.position = pos + lengthOverride;
        }
      };
      return DataStream;
    });
  }
});

// node_modules/wl-msg-reader/lib/msg.reader.js
var require_msg_reader = __commonJS({
  "node_modules/wl-msg-reader/lib/msg.reader.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["./DataStream"], factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory(require_DataStream());
      } else {
        root.MSGReader = factory(root.DataStream);
      }
    })(exports2, function(DataStream) {
      var CONST = {
        FILE_HEADER: uInt2int([208, 207, 17, 224, 161, 177, 26, 225]),
        MSG: {
          UNUSED_BLOCK: -1,
          END_OF_CHAIN: -2,
          S_BIG_BLOCK_SIZE: 512,
          S_BIG_BLOCK_MARK: 9,
          L_BIG_BLOCK_SIZE: 4096,
          L_BIG_BLOCK_MARK: 12,
          SMALL_BLOCK_SIZE: 64,
          BIG_BLOCK_MIN_DOC_SIZE: 4096,
          HEADER: {
            PROPERTY_START_OFFSET: 48,
            BAT_START_OFFSET: 76,
            BAT_COUNT_OFFSET: 44,
            SBAT_START_OFFSET: 60,
            SBAT_COUNT_OFFSET: 64,
            XBAT_START_OFFSET: 68,
            XBAT_COUNT_OFFSET: 72
          },
          PROP: {
            NO_INDEX: -1,
            PROPERTY_SIZE: 128,
            NAME_SIZE_OFFSET: 64,
            MAX_NAME_LENGTH: (
              /*NAME_SIZE_OFFSET*/
              64 / 2 - 1
            ),
            TYPE_OFFSET: 66,
            PREVIOUS_PROPERTY_OFFSET: 68,
            NEXT_PROPERTY_OFFSET: 72,
            CHILD_PROPERTY_OFFSET: 76,
            START_BLOCK_OFFSET: 116,
            SIZE_OFFSET: 120,
            TYPE_ENUM: {
              DIRECTORY: 1,
              DOCUMENT: 2,
              ROOT: 5
            }
          },
          FIELD: {
            PREFIX: {
              ATTACHMENT: "__attach_version1.0",
              RECIPIENT: "__recip_version1.0",
              DOCUMENT: "__substg1."
            },
            // example (use fields as needed)
            NAME_MAPPING: {
              // email specific
              "0037": "subject",
              "0c1a": "senderName",
              "5d02": "senderEmail",
              "1000": "body",
              "007d": "headers",
              // attachment specific
              "3703": "extension",
              "3704": "fileNameShort",
              "3707": "fileName",
              "3712": "pidContentId",
              // recipient specific
              "3001": "name",
              "39fe": "email"
            },
            CLASS_MAPPING: {
              ATTACHMENT_DATA: "3701"
            },
            TYPE_MAPPING: {
              "001e": "string",
              "001f": "unicode",
              "0102": "binary"
            },
            DIR_TYPE: {
              INNER_MSG: "000d"
            }
          }
        }
      };
      function arraysEqual(a2, b2) {
        if (a2 === b2)
          return true;
        if (a2 == null || b2 == null)
          return false;
        if (a2.length != b2.length)
          return false;
        for (var i2 = 0; i2 < a2.length; i2++) {
          if (a2[i2] !== b2[i2])
            return false;
        }
        return true;
      }
      function uInt2int(data) {
        var result = new Array(data.length);
        for (var i2 = 0; i2 < data.length; i2++) {
          result[i2] = data[i2] << 24 >> 24;
        }
        return result;
      }
      function isMSGFile(ds) {
        ds.seek(0);
        return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));
      }
      function getBlockOffsetAt(msgData, offset) {
        return (offset + 1) * msgData.bigBlockSize;
      }
      function getBlockAt(ds, msgData, offset) {
        var startOffset = getBlockOffsetAt(msgData, offset);
        ds.seek(startOffset);
        return ds.readInt32Array(msgData.bigBlockLength);
      }
      function getNextBlockInner(ds, msgData, offset, blockOffsetData) {
        var currentBlock = Math.floor(offset / msgData.bigBlockLength);
        var currentBlockIndex = offset % msgData.bigBlockLength;
        var startBlockOffset = blockOffsetData[currentBlock];
        return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];
      }
      function getNextBlock(ds, msgData, offset) {
        return getNextBlockInner(ds, msgData, offset, msgData.batData);
      }
      function getNextBlockSmall(ds, msgData, offset) {
        return getNextBlockInner(ds, msgData, offset, msgData.sbatData);
      }
      function parseMsgData(ds) {
        var msgData = headerData(ds);
        msgData.batData = batData(ds, msgData);
        msgData.sbatData = sbatData(ds, msgData);
        if (msgData.xbatCount > 0) {
          xbatData(ds, msgData);
        }
        msgData.propertyData = propertyData(ds, msgData);
        msgData.fieldsData = fieldsData(ds, msgData);
        return msgData;
      }
      function headerData(ds) {
        var headerData2 = {};
        headerData2.bigBlockSize = ds.readByte(
          /*const position*/
          30
        ) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;
        headerData2.bigBlockLength = headerData2.bigBlockSize / 4;
        headerData2.xBlockLength = headerData2.bigBlockLength - 1;
        headerData2.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);
        headerData2.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);
        headerData2.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);
        headerData2.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);
        headerData2.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);
        headerData2.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);
        return headerData2;
      }
      function batCountInHeader(msgData) {
        var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;
        return Math.min(msgData.batCount, maxBatsInHeader);
      }
      function batData(ds, msgData) {
        var result = new Array(batCountInHeader(msgData));
        ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);
        for (var i2 = 0; i2 < result.length; i2++) {
          result[i2] = ds.readInt32();
        }
        return result;
      }
      function sbatData(ds, msgData) {
        var result = [];
        var startIndex = msgData.sbatStart;
        for (var i2 = 0; i2 < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i2++) {
          result.push(startIndex);
          startIndex = getNextBlock(ds, msgData, startIndex);
        }
        return result;
      }
      function xbatData(ds, msgData) {
        var batCount = batCountInHeader(msgData);
        var batCountTotal = msgData.batCount;
        var remainingBlocks = batCountTotal - batCount;
        var nextBlockAt = msgData.xbatStart;
        for (var i2 = 0; i2 < msgData.xbatCount; i2++) {
          var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);
          nextBlockAt = xBatBlock[msgData.xBlockLength];
          var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);
          for (var j2 = 0; j2 < blocksToProcess; j2++) {
            var blockStartAt = xBatBlock[j2];
            if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {
              break;
            }
            msgData.batData.push(blockStartAt);
          }
          remainingBlocks -= blocksToProcess;
        }
      }
      function propertyData(ds, msgData) {
        var props = [];
        var currentOffset = msgData.propertyStart;
        while (currentOffset != CONST.MSG.END_OF_CHAIN) {
          convertBlockToProperties(ds, msgData, currentOffset, props);
          currentOffset = getNextBlock(ds, msgData, currentOffset);
        }
        createPropertyHierarchy(
          props,
          /*property with index 0 (zero) always as root*/
          props[0]
        );
        return props;
      }
      function convertName(ds, offset) {
        var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);
        if (nameLength < 1) {
          return "";
        } else {
          return ds.readStringAt(offset, nameLength / 2);
        }
      }
      function convertProperty(ds, index, offset) {
        return {
          index,
          type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),
          name: convertName(ds, offset),
          // hierarchy
          previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),
          nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),
          childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),
          // data offset
          startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),
          sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)
        };
      }
      function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {
        var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;
        var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);
        for (var i2 = 0; i2 < propertyCount; i2++) {
          var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);
          switch (propertyType) {
            case CONST.MSG.PROP.TYPE_ENUM.ROOT:
            case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:
            case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:
              props.push(convertProperty(ds, props.length, propertyOffset));
              break;
            default:
              props.push(null);
          }
          propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;
        }
      }
      function createPropertyHierarchy(props, nodeProperty) {
        if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {
          return;
        }
        nodeProperty.children = [];
        var children = [nodeProperty.childProperty];
        while (children.length != 0) {
          var currentIndex = children.shift();
          var current = props[currentIndex];
          if (current == null) {
            continue;
          }
          nodeProperty.children.push(currentIndex);
          if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
            createPropertyHierarchy(props, current);
          }
          if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {
            children.push(current.previousProperty);
          }
          if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {
            children.push(current.nextProperty);
          }
        }
      }
      function fieldsData(ds, msgData) {
        var fields = {
          attachments: [],
          recipients: []
        };
        fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);
        return fields;
      }
      function fieldsDataDir(ds, msgData, dirProperty, fields) {
        if (dirProperty.children && dirProperty.children.length > 0) {
          for (var i2 = 0; i2 < dirProperty.children.length; i2++) {
            var childProperty = msgData.propertyData[dirProperty.children[i2]];
            if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
              fieldsDataDirInner(ds, msgData, childProperty, fields);
            } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {
              fieldsDataDocument(ds, msgData, childProperty, fields);
            }
          }
        }
      }
      function fieldsDataDirInner(ds, msgData, dirProperty, fields) {
        if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {
          var attachmentField = {};
          fields.attachments.push(attachmentField);
          fieldsDataDir(ds, msgData, dirProperty, attachmentField);
        } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {
          var recipientField = {};
          fields.recipients.push(recipientField);
          fieldsDataDir(ds, msgData, dirProperty, recipientField);
        } else {
          var childFieldType = getFieldType(dirProperty);
          if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {
            fieldsDataDir(ds, msgData, dirProperty, fields);
          } else {
            fields.innerMsgContent = true;
          }
        }
      }
      function fieldsDataDocument(ds, msgData, documentProperty, fields) {
        var value = documentProperty.name.substring(12).toLowerCase();
        var fieldClass = value.substring(0, 4);
        var fieldType = value.substring(4, 8);
        var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];
        if (fieldName) {
          fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);
        }
        if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {
          fields["dataId"] = documentProperty.index;
          fields["contentLength"] = documentProperty.sizeBlock;
        }
      }
      function getFieldType(fieldProperty) {
        var value = fieldProperty.name.substring(12).toLowerCase();
        return value.substring(4, 8);
      }
      var extractorFieldValue = {
        sbat: {
          "extractor": function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {
            var chain = getChainByBlockSmall(ds, msgData, fieldProperty);
            if (chain.length == 1) {
              return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);
            } else if (chain.length > 1) {
              return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);
            }
            return null;
          },
          dataType: {
            "string": function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds.seek(blockStartOffset + bigBlockOffset);
              return ds.readString(blockSize);
            },
            "unicode": function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds.seek(blockStartOffset + bigBlockOffset);
              return ds.readUCS2String(blockSize / 2);
            },
            "binary": function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds.seek(blockStartOffset + bigBlockOffset);
              var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);
              return ds.readUint8Array(toReadLength);
            }
          }
        },
        bat: {
          "extractor": function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {
            var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);
            ds.seek(offset);
            return dataTypeExtractor(ds, fieldProperty);
          },
          dataType: {
            "string": function extractSbatString(ds, fieldProperty) {
              return ds.readString(fieldProperty.sizeBlock);
            },
            "unicode": function extractSbatUnicode(ds, fieldProperty) {
              return ds.readUCS2String(fieldProperty.sizeBlock / 2);
            },
            "binary": function extractSbatBinary(ds, fieldProperty) {
              return ds.readUint8Array(fieldProperty.sizeBlock);
            }
          }
        }
      };
      function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {
        var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;
        var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);
        var bigBlockOffset = byteOffset % msgData.bigBlockSize;
        var rootProp = msgData.propertyData[0];
        var nextBlock = rootProp.startBlock;
        for (var i2 = 0; i2 < bigBlockNumber; i2++) {
          nextBlock = getNextBlock(ds, msgData, nextBlock);
        }
        var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);
        return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);
      }
      function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {
        var resultData = new Int8Array(fieldProperty.sizeBlock);
        for (var i2 = 0, idx = 0; i2 < chain.length; i2++) {
          var data = readDataByBlockSmall(ds, msgData, chain[i2], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);
          for (var j2 = 0; j2 < data.length; j2++) {
            resultData[idx++] = data[j2];
          }
        }
        var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);
        return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);
      }
      function getChainByBlockSmall(ds, msgData, fieldProperty) {
        var blockChain = [];
        var nextBlockSmall = fieldProperty.startBlock;
        while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {
          blockChain.push(nextBlockSmall);
          nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);
        }
        return blockChain;
      }
      function getFieldValue(ds, msgData, fieldProperty, type) {
        var value = null;
        var valueExtractor = fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;
        var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];
        if (dataTypeExtractor) {
          value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);
        }
        return value;
      }
      var MSGReader = function(arrayBuffer) {
        this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);
      };
      MSGReader.prototype = {
        /**
             Converts bytes to fields information
        
             @return {Object} The fields data for MSG file
             */
        getFileData: function() {
          if (!isMSGFile(this.ds)) {
            return { error: "Unsupported file type!" };
          }
          if (this.fileData == null) {
            this.fileData = parseMsgData(this.ds);
          }
          return this.fileData.fieldsData;
        },
        /**
             Reads an attachment content by key/ID
        
             @return {Object} The attachment for specific attachment key
             */
        getAttachment: function(attach) {
          var attachData = typeof attach === "number" ? this.fileData.fieldsData.attachments[attach] : attach;
          var fieldProperty = this.fileData.propertyData[attachData.dataId];
          var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));
          return { fileName: attachData.fileName, content: fieldData };
        }
      };
      return MSGReader;
    });
  }
});

// node_modules/wl-msg-reader/index.js
var require_wl_msg_reader = __commonJS({
  "node_modules/wl-msg-reader/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataStream = require_DataStream();
    exports2.MSGReader = require_msg_reader();
  }
});

// node_modules/react-doc-viewer/build/plugins/msg/index.js
var require_msg = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/msg/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var wl_msg_reader_1 = require_wl_msg_reader();
    var fileLoaders_1 = require_fileLoaders();
    var MSGRenderer = function(_a) {
      var _b;
      var currentDocument = _a.mainState.currentDocument;
      var _c = react_1.useState(), fileData = _c[0], setFileData = _c[1];
      react_1.useEffect(function() {
        if (!currentDocument || !currentDocument.fileData)
          return;
        var _fd = new wl_msg_reader_1.MSGReader(currentDocument.fileData).getFileData();
        setFileData(_fd);
      }, [currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData]);
      react_1.useEffect(function() {
        if (!fileData || fileData.hasOwnProperty("error"))
          return;
        var iframeCont = document.getElementById("msg-body");
        var iframe = (iframeCont === null || iframeCont === void 0 ? void 0 : iframeCont.contentWindow) && iframeCont.contentWindow;
        if (!iframe)
          return;
        var iframeDoc = iframe.document;
        var body = fileData.body.replace(/(\r\n|\n|\r)/gm, "<br />");
        iframeDoc.open();
        iframeDoc.write("" + body);
        iframeDoc.close();
      }, [fileData]);
      if (!fileData || fileData.hasOwnProperty("error")) {
        return react_1.default.createElement("span", null, (_b = fileData) === null || _b === void 0 ? void 0 : _b.error);
      }
      var _d = fileData, recipients = _d.recipients, subject = _d.subject, senderEmail = _d.senderEmail, senderName = _d.senderName;
      return react_1.default.createElement(
        Container,
        { id: "msg-renderer" },
        react_1.default.createElement("h2", { id: "msg-subject-title", style: { marginBottom: 0 } }, subject),
        react_1.default.createElement(Sender, { name: senderName, email: senderEmail }),
        react_1.default.createElement(
          RecipientContainer,
          { id: "msg-recipient" },
          react_1.default.createElement("h3", { id: "msg-recipient-title" }, "Recipients"),
          react_1.default.createElement("ul", { id: "msg-recipient-ul" }, recipients.map(function(r2, i2) {
            return react_1.default.createElement(
              "li",
              { key: i2, id: "msg-recipient-li" },
              react_1.default.createElement("span", { id: "msg-recipient-name" }, r2.name),
              r2.hasOwnProperty("email") && react_1.default.createElement(
                "span",
                { id: "msg-recipient-email" },
                " - ",
                r2.email
              )
            );
          }))
        ),
        react_1.default.createElement(BodyIFrame, { id: "msg-body", sandbox: "allow-same-origin" })
      );
    };
    var Sender = function(_a) {
      var name = _a.name, email = _a.email;
      if (!name && !email)
        return null;
      return react_1.default.createElement(
        SenderContainer,
        { id: "msg-sender" },
        react_1.default.createElement("h3", { id: "msg-sender-title" }, "Sender"),
        name !== void 0 && react_1.default.createElement("div", { id: "msg-sender-name" }, name),
        email !== void 0 && react_1.default.createElement("div", { id: "msg-sender-email" }, email)
      );
    };
    exports2.default = MSGRenderer;
    MSGRenderer.fileTypes = ["msg", "application/vnd.ms-outlook"];
    MSGRenderer.weight = 0;
    MSGRenderer.fileLoader = fileLoaders_1.arrayBufferFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"])));
    var SenderContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  padding: 0 15px 15px 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"], ["\n  padding: 0 15px 15px 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var RecipientContainer = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  padding: 0 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"], ["\n  padding: 0 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var BodyIFrame = styled_components_1.default.iframe(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"], ["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
  }
});

// node_modules/pdfjs-dist/build/pdf.worker.js
var require_pdf_worker = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.worker.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf.worker", [], factory);
      else if (typeof exports2 === "object")
        exports2["pdfjs-dist/build/pdf.worker"] = factory();
      else
        root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__2(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __w_pdfjs_require__2);
            module3.l = true;
            return module3.exports;
          }
          __w_pdfjs_require__2.m = modules;
          __w_pdfjs_require__2.c = installedModules;
          __w_pdfjs_require__2.d = function(exports3, name, getter) {
            if (!__w_pdfjs_require__2.o(exports3, name)) {
              Object.defineProperty(exports3, name, { enumerable: true, get: getter });
            }
          };
          __w_pdfjs_require__2.r = function(exports3) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports3, "__esModule", { value: true });
          };
          __w_pdfjs_require__2.t = function(value, mode) {
            if (mode & 1)
              value = __w_pdfjs_require__2(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __w_pdfjs_require__2.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __w_pdfjs_require__2.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __w_pdfjs_require__2.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __w_pdfjs_require__2.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__2.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__2.p = "";
          return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            const pdfjsVersion = "2.4.456";
            const pdfjsBuild = "228a591c";
            const pdfjsCoreWorker = __w_pdfjs_require__2(1);
            exports3.WorkerMessageHandler = pdfjsCoreWorker.WorkerMessageHandler;
          },
          /* 1 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.WorkerMessageHandler = exports3.WorkerTask = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _pdf_manager = __w_pdfjs_require__2(5);
            var _is_node2 = __w_pdfjs_require__2(44);
            var _message_handler2 = __w_pdfjs_require__2(45);
            var _worker_stream = __w_pdfjs_require__2(46);
            var _core_utils = __w_pdfjs_require__2(7);
            var WorkerTask = function WorkerTaskClosure() {
              function WorkerTask2(name) {
                this.name = name;
                this.terminated = false;
                this._capability = (0, _util2.createPromiseCapability)();
              }
              WorkerTask2.prototype = {
                get finished() {
                  return this._capability.promise;
                },
                finish() {
                  this._capability.resolve();
                },
                terminate() {
                  this.terminated = true;
                },
                ensureNotTerminated() {
                  if (this.terminated) {
                    throw new Error("Worker task was terminated");
                  }
                }
              };
              return WorkerTask2;
            }();
            exports3.WorkerTask = WorkerTask;
            var WorkerMessageHandler = {
              setup(handler, port) {
                var testMessageProcessed = false;
                handler.on("test", function wphSetupTest(data) {
                  if (testMessageProcessed) {
                    return;
                  }
                  testMessageProcessed = true;
                  if (!(data instanceof Uint8Array)) {
                    handler.send("test", null);
                    return;
                  }
                  const supportTransfers = data[0] === 255;
                  handler.postMessageTransfers = supportTransfers;
                  handler.send("test", {
                    supportTransfers
                  });
                });
                handler.on("configure", function wphConfigure(data) {
                  (0, _util2.setVerbosityLevel)(data.verbosity);
                });
                handler.on("GetDocRequest", function wphSetupDoc(data) {
                  return WorkerMessageHandler.createDocumentHandler(data, port);
                });
              },
              createDocumentHandler(docParams, port) {
                var pdfManager;
                var terminated = false;
                var cancelXHRs = null;
                var WorkerTasks = [];
                const verbosity = (0, _util2.getVerbosityLevel)();
                const apiVersion = docParams.apiVersion;
                const workerVersion = "2.4.456";
                if (apiVersion !== workerVersion) {
                  throw new Error(`The API version "${apiVersion}" does not match the Worker version "${workerVersion}".`);
                }
                const enumerableProperties = [];
                for (const property in []) {
                  enumerableProperties.push(property);
                }
                if (enumerableProperties.length) {
                  throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
                }
                var docId = docParams.docId;
                var docBaseUrl = docParams.docBaseUrl;
                var workerHandlerName = docParams.docId + "_worker";
                var handler = new _message_handler2.MessageHandler(workerHandlerName, docId, port);
                handler.postMessageTransfers = docParams.postMessageTransfers;
                function ensureNotTerminated() {
                  if (terminated) {
                    throw new Error("Worker was terminated");
                  }
                }
                function startWorkerTask(task) {
                  WorkerTasks.push(task);
                }
                function finishWorkerTask(task) {
                  task.finish();
                  var i2 = WorkerTasks.indexOf(task);
                  WorkerTasks.splice(i2, 1);
                }
                async function loadDocument(recoveryMode) {
                  await pdfManager.ensureDoc("checkHeader");
                  await pdfManager.ensureDoc("parseStartXRef");
                  await pdfManager.ensureDoc("parse", [recoveryMode]);
                  if (!recoveryMode) {
                    await pdfManager.ensureDoc("checkFirstPage");
                  }
                  const [numPages, fingerprint] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprint")]);
                  return {
                    numPages,
                    fingerprint
                  };
                }
                function getPdfManager(data, evaluatorOptions) {
                  var pdfManagerCapability = (0, _util2.createPromiseCapability)();
                  var pdfManager2;
                  var source = data.source;
                  if (source.data) {
                    try {
                      pdfManager2 = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, evaluatorOptions, docBaseUrl);
                      pdfManagerCapability.resolve(pdfManager2);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                    }
                    return pdfManagerCapability.promise;
                  }
                  var pdfStream, cachedChunks = [];
                  try {
                    pdfStream = new _worker_stream.PDFWorkerStream(handler);
                  } catch (ex) {
                    pdfManagerCapability.reject(ex);
                    return pdfManagerCapability.promise;
                  }
                  var fullRequest = pdfStream.getFullReader();
                  fullRequest.headersReady.then(function() {
                    if (!fullRequest.isRangeSupported) {
                      return;
                    }
                    var disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
                    pdfManager2 = new _pdf_manager.NetworkPdfManager(docId, pdfStream, {
                      msgHandler: handler,
                      password: source.password,
                      length: fullRequest.contentLength,
                      disableAutoFetch,
                      rangeChunkSize: source.rangeChunkSize
                    }, evaluatorOptions, docBaseUrl);
                    for (let i2 = 0; i2 < cachedChunks.length; i2++) {
                      pdfManager2.sendProgressiveData(cachedChunks[i2]);
                    }
                    cachedChunks = [];
                    pdfManagerCapability.resolve(pdfManager2);
                    cancelXHRs = null;
                  }).catch(function(reason) {
                    pdfManagerCapability.reject(reason);
                    cancelXHRs = null;
                  });
                  var loaded = 0;
                  var flushChunks = function() {
                    var pdfFile = (0, _util2.arraysToBytes)(cachedChunks);
                    if (source.length && pdfFile.length !== source.length) {
                      (0, _util2.warn)("reported HTTP length is different from actual");
                    }
                    try {
                      pdfManager2 = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, docBaseUrl);
                      pdfManagerCapability.resolve(pdfManager2);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                    }
                    cachedChunks = [];
                  };
                  var readPromise = new Promise(function(resolve, reject) {
                    var readChunk = function(chunk) {
                      try {
                        ensureNotTerminated();
                        if (chunk.done) {
                          if (!pdfManager2) {
                            flushChunks();
                          }
                          cancelXHRs = null;
                          return;
                        }
                        var data2 = chunk.value;
                        loaded += (0, _util2.arrayByteLength)(data2);
                        if (!fullRequest.isStreamingSupported) {
                          handler.send("DocProgress", {
                            loaded,
                            total: Math.max(loaded, fullRequest.contentLength || 0)
                          });
                        }
                        if (pdfManager2) {
                          pdfManager2.sendProgressiveData(data2);
                        } else {
                          cachedChunks.push(data2);
                        }
                        fullRequest.read().then(readChunk, reject);
                      } catch (e2) {
                        reject(e2);
                      }
                    };
                    fullRequest.read().then(readChunk, reject);
                  });
                  readPromise.catch(function(e2) {
                    pdfManagerCapability.reject(e2);
                    cancelXHRs = null;
                  });
                  cancelXHRs = function(reason) {
                    pdfStream.cancelAllRequests(reason);
                  };
                  return pdfManagerCapability.promise;
                }
                function setupDoc(data) {
                  function onSuccess(doc) {
                    ensureNotTerminated();
                    handler.send("GetDoc", {
                      pdfInfo: doc
                    });
                  }
                  function onFailure(ex) {
                    ensureNotTerminated();
                    if (ex instanceof _util2.PasswordException) {
                      var task = new WorkerTask(`PasswordException: response ${ex.code}`);
                      startWorkerTask(task);
                      handler.sendWithPromise("PasswordRequest", ex).then(function(data2) {
                        finishWorkerTask(task);
                        pdfManager.updatePassword(data2.password);
                        pdfManagerReady();
                      }).catch(function() {
                        finishWorkerTask(task);
                        handler.send("DocException", ex);
                      });
                    } else if (ex instanceof _util2.InvalidPDFException || ex instanceof _util2.MissingPDFException || ex instanceof _util2.UnexpectedResponseException || ex instanceof _util2.UnknownErrorException) {
                      handler.send("DocException", ex);
                    } else {
                      handler.send("DocException", new _util2.UnknownErrorException(ex.message, ex.toString()));
                    }
                  }
                  function pdfManagerReady() {
                    ensureNotTerminated();
                    loadDocument(false).then(onSuccess, function loadFailure(ex) {
                      ensureNotTerminated();
                      if (!(ex instanceof _core_utils.XRefParseException)) {
                        onFailure(ex);
                        return;
                      }
                      pdfManager.requestLoadedStream();
                      pdfManager.onLoadedStream().then(function() {
                        ensureNotTerminated();
                        loadDocument(true).then(onSuccess, onFailure);
                      });
                    }, onFailure);
                  }
                  ensureNotTerminated();
                  var evaluatorOptions = {
                    forceDataSchema: data.disableCreateObjectURL,
                    maxImageSize: data.maxImageSize,
                    disableFontFace: data.disableFontFace,
                    nativeImageDecoderSupport: data.nativeImageDecoderSupport,
                    ignoreErrors: data.ignoreErrors,
                    isEvalSupported: data.isEvalSupported
                  };
                  getPdfManager(data, evaluatorOptions).then(function(newPdfManager) {
                    if (terminated) {
                      newPdfManager.terminate(new _util2.AbortException("Worker was terminated."));
                      throw new Error("Worker was terminated");
                    }
                    pdfManager = newPdfManager;
                    pdfManager.onLoadedStream().then(function(stream) {
                      handler.send("DataLoaded", {
                        length: stream.bytes.byteLength
                      });
                    });
                  }).then(pdfManagerReady, onFailure);
                }
                handler.on("GetPage", function wphSetupGetPage(data) {
                  return pdfManager.getPage(data.pageIndex).then(function(page) {
                    return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function([rotate, ref, userUnit, view]) {
                      return {
                        rotate,
                        ref,
                        userUnit,
                        view
                      };
                    });
                  });
                });
                handler.on("GetPageIndex", function wphSetupGetPageIndex(data) {
                  var ref = _primitives.Ref.get(data.ref.num, data.ref.gen);
                  var catalog = pdfManager.pdfDocument.catalog;
                  return catalog.getPageIndex(ref);
                });
                handler.on("GetDestinations", function wphSetupGetDestinations(data) {
                  return pdfManager.ensureCatalog("destinations");
                });
                handler.on("GetDestination", function wphSetupGetDestination(data) {
                  return pdfManager.ensureCatalog("getDestination", [data.id]);
                });
                handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
                  return pdfManager.ensureCatalog("pageLabels");
                });
                handler.on("GetPageLayout", function wphSetupGetPageLayout(data) {
                  return pdfManager.ensureCatalog("pageLayout");
                });
                handler.on("GetPageMode", function wphSetupGetPageMode(data) {
                  return pdfManager.ensureCatalog("pageMode");
                });
                handler.on("GetViewerPreferences", function(data) {
                  return pdfManager.ensureCatalog("viewerPreferences");
                });
                handler.on("GetOpenAction", function(data) {
                  return pdfManager.ensureCatalog("openAction");
                });
                handler.on("GetAttachments", function wphSetupGetAttachments(data) {
                  return pdfManager.ensureCatalog("attachments");
                });
                handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
                  return pdfManager.ensureCatalog("javaScript");
                });
                handler.on("GetOutline", function wphSetupGetOutline(data) {
                  return pdfManager.ensureCatalog("documentOutline");
                });
                handler.on("GetPermissions", function(data) {
                  return pdfManager.ensureCatalog("permissions");
                });
                handler.on("GetMetadata", function wphSetupGetMetadata(data) {
                  return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
                });
                handler.on("GetData", function wphSetupGetData(data) {
                  pdfManager.requestLoadedStream();
                  return pdfManager.onLoadedStream().then(function(stream) {
                    return stream.bytes;
                  });
                });
                handler.on("GetStats", function wphSetupGetStats(data) {
                  return pdfManager.pdfDocument.xref.stats;
                });
                handler.on("GetAnnotations", function({
                  pageIndex,
                  intent
                }) {
                  return pdfManager.getPage(pageIndex).then(function(page) {
                    return page.getAnnotationsData(intent);
                  });
                });
                handler.on("GetOperatorList", function wphSetupRenderPage(data, sink) {
                  var pageIndex = data.pageIndex;
                  pdfManager.getPage(pageIndex).then(function(page) {
                    var task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
                    startWorkerTask(task);
                    const start = verbosity >= _util2.VerbosityLevel.INFOS ? Date.now() : 0;
                    page.getOperatorList({
                      handler,
                      sink,
                      task,
                      intent: data.intent,
                      renderInteractiveForms: data.renderInteractiveForms
                    }).then(function(operatorListInfo) {
                      finishWorkerTask(task);
                      if (start) {
                        (0, _util2.info)(`page=${pageIndex + 1} - getOperatorList: time=${Date.now() - start}ms, len=${operatorListInfo.length}`);
                      }
                      sink.close();
                    }, function(reason) {
                      finishWorkerTask(task);
                      if (task.terminated) {
                        return;
                      }
                      handler.send("UnsupportedFeature", {
                        featureId: _util2.UNSUPPORTED_FEATURES.unknown
                      });
                      sink.error(reason);
                    });
                  });
                }, this);
                handler.on("GetTextContent", function wphExtractText(data, sink) {
                  var pageIndex = data.pageIndex;
                  sink.onPull = function(desiredSize) {
                  };
                  sink.onCancel = function(reason) {
                  };
                  pdfManager.getPage(pageIndex).then(function(page) {
                    var task = new WorkerTask("GetTextContent: page " + pageIndex);
                    startWorkerTask(task);
                    const start = verbosity >= _util2.VerbosityLevel.INFOS ? Date.now() : 0;
                    page.extractTextContent({
                      handler,
                      task,
                      sink,
                      normalizeWhitespace: data.normalizeWhitespace,
                      combineTextItems: data.combineTextItems
                    }).then(function() {
                      finishWorkerTask(task);
                      if (start) {
                        (0, _util2.info)(`page=${pageIndex + 1} - getTextContent: time=${Date.now() - start}ms`);
                      }
                      sink.close();
                    }, function(reason) {
                      finishWorkerTask(task);
                      if (task.terminated) {
                        return;
                      }
                      sink.error(reason);
                    });
                  });
                });
                handler.on("FontFallback", function(data) {
                  return pdfManager.fontFallback(data.id, handler);
                });
                handler.on("Cleanup", function wphCleanup(data) {
                  return pdfManager.cleanup();
                });
                handler.on("Terminate", function wphTerminate(data) {
                  terminated = true;
                  const waitOn = [];
                  if (pdfManager) {
                    pdfManager.terminate(new _util2.AbortException("Worker was terminated."));
                    const cleanupPromise = pdfManager.cleanup();
                    waitOn.push(cleanupPromise);
                    pdfManager = null;
                  } else {
                    (0, _primitives.clearPrimitiveCaches)();
                  }
                  if (cancelXHRs) {
                    cancelXHRs(new _util2.AbortException("Worker was terminated."));
                  }
                  WorkerTasks.forEach(function(task) {
                    waitOn.push(task.finished);
                    task.terminate();
                  });
                  return Promise.all(waitOn).then(function() {
                    handler.destroy();
                    handler = null;
                  });
                });
                handler.on("Ready", function wphReady(data) {
                  setupDoc(docParams);
                  docParams = null;
                });
                return workerHandlerName;
              },
              initializeFromPort(port) {
                var handler = new _message_handler2.MessageHandler("worker", "main", port);
                WorkerMessageHandler.setup(handler, port);
                handler.send("ready", null);
              }
            };
            exports3.WorkerMessageHandler = WorkerMessageHandler;
            function isMessagePort(maybePort) {
              return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
            }
            if (typeof window === "undefined" && !_is_node2.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
              WorkerMessageHandler.initializeFromPort(self);
            }
          },
          /* 2 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.arrayByteLength = arrayByteLength;
            exports3.arraysToBytes = arraysToBytes;
            exports3.assert = assert;
            exports3.bytesToString = bytesToString;
            exports3.createPromiseCapability = createPromiseCapability;
            exports3.getVerbosityLevel = getVerbosityLevel;
            exports3.info = info;
            exports3.isArrayBuffer = isArrayBuffer3;
            exports3.isArrayEqual = isArrayEqual;
            exports3.isBool = isBool;
            exports3.isEmptyObj = isEmptyObj;
            exports3.isNum = isNum;
            exports3.isString = isString3;
            exports3.isSameOrigin = isSameOrigin;
            exports3.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports3.removeNullCharacters = removeNullCharacters;
            exports3.setVerbosityLevel = setVerbosityLevel;
            exports3.shadow = shadow;
            exports3.string32 = string32;
            exports3.stringToBytes = stringToBytes;
            exports3.stringToPDFString = stringToPDFString;
            exports3.stringToUTF8String = stringToUTF8String;
            exports3.utf8StringToString = utf8StringToString;
            exports3.warn = warn;
            exports3.unreachable = unreachable;
            exports3.IsEvalSupportedCached = exports3.IsLittleEndianCached = exports3.createObjectURL = exports3.FormatError = exports3.Util = exports3.UnknownErrorException = exports3.UnexpectedResponseException = exports3.TextRenderingMode = exports3.StreamType = exports3.PermissionFlag = exports3.PasswordResponses = exports3.PasswordException = exports3.NativeImageDecoding = exports3.MissingPDFException = exports3.InvalidPDFException = exports3.AbortException = exports3.CMapCompressionType = exports3.ImageKind = exports3.FontType = exports3.AnnotationType = exports3.AnnotationStateModelType = exports3.AnnotationReviewState = exports3.AnnotationReplyType = exports3.AnnotationMarkedState = exports3.AnnotationFlag = exports3.AnnotationFieldFlag = exports3.AnnotationBorderStyleType = exports3.UNSUPPORTED_FEATURES = exports3.VerbosityLevel = exports3.OPS = exports3.IDENTITY_MATRIX = exports3.FONT_IDENTITY_MATRIX = exports3.BaseException = void 0;
            __w_pdfjs_require__2(3);
            const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports3.IDENTITY_MATRIX = IDENTITY_MATRIX;
            const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports3.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            const NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            exports3.NativeImageDecoding = NativeImageDecoding;
            const PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports3.PermissionFlag = PermissionFlag;
            const TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports3.TextRenderingMode = TextRenderingMode;
            const ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports3.ImageKind = ImageKind;
            const AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports3.AnnotationType = AnnotationType;
            const AnnotationStateModelType = {
              MARKED: "Marked",
              REVIEW: "Review"
            };
            exports3.AnnotationStateModelType = AnnotationStateModelType;
            const AnnotationMarkedState = {
              MARKED: "Marked",
              UNMARKED: "Unmarked"
            };
            exports3.AnnotationMarkedState = AnnotationMarkedState;
            const AnnotationReviewState = {
              ACCEPTED: "Accepted",
              REJECTED: "Rejected",
              CANCELLED: "Cancelled",
              COMPLETED: "Completed",
              NONE: "None"
            };
            exports3.AnnotationReviewState = AnnotationReviewState;
            const AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports3.AnnotationReplyType = AnnotationReplyType;
            const AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports3.AnnotationFlag = AnnotationFlag;
            const AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports3.AnnotationFieldFlag = AnnotationFieldFlag;
            const AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports3.AnnotationBorderStyleType = AnnotationBorderStyleType;
            const StreamType = {
              UNKNOWN: "UNKNOWN",
              FLATE: "FLATE",
              LZW: "LZW",
              DCT: "DCT",
              JPX: "JPX",
              JBIG: "JBIG",
              A85: "A85",
              AHX: "AHX",
              CCF: "CCF",
              RLX: "RLX"
            };
            exports3.StreamType = StreamType;
            const FontType = {
              UNKNOWN: "UNKNOWN",
              TYPE1: "TYPE1",
              TYPE1C: "TYPE1C",
              CIDFONTTYPE0: "CIDFONTTYPE0",
              CIDFONTTYPE0C: "CIDFONTTYPE0C",
              TRUETYPE: "TRUETYPE",
              CIDFONTTYPE2: "CIDFONTTYPE2",
              TYPE3: "TYPE3",
              OPENTYPE: "OPENTYPE",
              TYPE0: "TYPE0",
              MMTYPE1: "MMTYPE1"
            };
            exports3.FontType = FontType;
            const VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports3.VerbosityLevel = VerbosityLevel;
            const CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            exports3.CMapCompressionType = CMapCompressionType;
            const OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports3.OPS = OPS;
            const UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            exports3.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            const PasswordResponses2 = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports3.PasswordResponses = PasswordResponses2;
            let verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log(`Info: ${msg}`);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log(`Warning: ${msg}`);
              }
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            function isSameOrigin(baseUrl, otherUrl) {
              let base;
              try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e2) {
                return false;
              }
              const other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function _isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            const BaseException = function BaseExceptionClosure() {
              function BaseException2(message) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = this.constructor.name;
              }
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }();
            exports3.BaseException = BaseException;
            class PasswordException extends BaseException {
              constructor(msg, code) {
                super(msg);
                this.code = code;
              }
            }
            exports3.PasswordException = PasswordException;
            class UnknownErrorException extends BaseException {
              constructor(msg, details) {
                super(msg);
                this.details = details;
              }
            }
            exports3.UnknownErrorException = UnknownErrorException;
            class InvalidPDFException extends BaseException {
            }
            exports3.InvalidPDFException = InvalidPDFException;
            class MissingPDFException extends BaseException {
            }
            exports3.MissingPDFException = MissingPDFException;
            class UnexpectedResponseException extends BaseException {
              constructor(msg, status) {
                super(msg);
                this.status = status;
              }
            }
            exports3.UnexpectedResponseException = UnexpectedResponseException;
            class FormatError extends BaseException {
            }
            exports3.FormatError = FormatError;
            class AbortException extends BaseException {
            }
            exports3.AbortException = AbortException;
            const NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && typeof bytes === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              const length = bytes.length;
              const MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              const strBuf = [];
              for (let i2 = 0; i2 < length; i2 += MAX_ARGUMENT_COUNT) {
                const chunkEnd = Math.min(i2 + MAX_ARGUMENT_COUNT, length);
                const chunk = bytes.subarray(i2, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              const length = str.length;
              const bytes = new Uint8Array(length);
              for (let i2 = 0; i2 < length; ++i2) {
                bytes[i2] = str.charCodeAt(i2) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              const length = arr.length;
              if (length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              let resultLength = 0;
              for (let i2 = 0; i2 < length; i2++) {
                resultLength += arrayByteLength(arr[i2]);
              }
              let pos = 0;
              const data = new Uint8Array(resultLength);
              for (let i2 = 0; i2 < length; i2++) {
                let item = arr[i2];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                const itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function isLittleEndian() {
              const buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              const view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            const IsLittleEndianCached = {
              get value() {
                return shadow(this, "value", isLittleEndian());
              }
            };
            exports3.IsLittleEndianCached = IsLittleEndianCached;
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e2) {
                return false;
              }
            }
            const IsEvalSupportedCached = {
              get value() {
                return shadow(this, "value", isEvalSupported());
              }
            };
            exports3.IsEvalSupportedCached = IsEvalSupportedCached;
            const rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
            class Util {
              static makeCssRgb(r2, g2, b2) {
                rgbBuf[1] = r2;
                rgbBuf[3] = g2;
                rgbBuf[5] = b2;
                return rgbBuf.join("");
              }
              static transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
              static applyTransform(p, m) {
                const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              }
              static applyInverseTransform(p, m) {
                const d2 = m[0] * m[3] - m[1] * m[2];
                const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d2;
                const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d2;
                return [xt, yt];
              }
              static getAxialAlignedBoundingBox(r2, m) {
                const p1 = Util.applyTransform(r2, m);
                const p2 = Util.applyTransform(r2.slice(2, 4), m);
                const p3 = Util.applyTransform([r2[0], r2[3]], m);
                const p4 = Util.applyTransform([r2[2], r2[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
              static inverseTransform(m) {
                const d2 = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d2, -m[1] / d2, -m[2] / d2, m[0] / d2, (m[2] * m[5] - m[4] * m[3]) / d2, (m[4] * m[1] - m[5] * m[0]) / d2];
              }
              static apply3dTransform(m, v2) {
                return [m[0] * v2[0] + m[1] * v2[1] + m[2] * v2[2], m[3] * v2[0] + m[4] * v2[1] + m[5] * v2[2], m[6] * v2[0] + m[7] * v2[1] + m[8] * v2[2]];
              }
              static singularValueDecompose2dScale(m) {
                const transpose = [m[0], m[2], m[1], m[3]];
                const a2 = m[0] * transpose[0] + m[1] * transpose[2];
                const b2 = m[0] * transpose[1] + m[1] * transpose[3];
                const c2 = m[2] * transpose[0] + m[3] * transpose[2];
                const d2 = m[2] * transpose[1] + m[3] * transpose[3];
                const first = (a2 + d2) / 2;
                const second = Math.sqrt((a2 + d2) * (a2 + d2) - 4 * (a2 * d2 - c2 * b2)) / 2;
                const sx = first + second || 1;
                const sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
              static normalizeRect(rect) {
                const r2 = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r2[0] = rect[2];
                  r2[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r2[1] = rect[3];
                  r2[3] = rect[1];
                }
                return r2;
              }
              static intersect(rect1, rect2) {
                function compare(a2, b2) {
                  return a2 - b2;
                }
                const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                const result = [];
                rect1 = Util.normalizeRect(rect1);
                rect2 = Util.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return null;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return null;
                }
                return result;
              }
            }
            exports3.Util = Util;
            const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              const length = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (let i2 = 2; i2 < length; i2 += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i2) << 8 | str.charCodeAt(i2 + 1)));
                }
              } else if (str[0] === "ÿ" && str[1] === "þ") {
                for (let i2 = 2; i2 < length; i2 += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i2 + 1) << 8 | str.charCodeAt(i2)));
                }
              } else {
                for (let i2 = 0; i2 < length; ++i2) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i2)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i2));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (const key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v2) {
              return typeof v2 === "boolean";
            }
            function isNum(v2) {
              return typeof v2 === "number";
            }
            function isString3(v2) {
              return typeof v2 === "string";
            }
            function isArrayBuffer3(v2) {
              return typeof v2 === "object" && v2 !== null && v2.byteLength !== void 0;
            }
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              return arr1.every(function(element, index) {
                return element === arr2[index];
              });
            }
            function createPromiseCapability() {
              const capability = /* @__PURE__ */ Object.create(null);
              let isSettled = false;
              Object.defineProperty(capability, "settled", {
                get() {
                  return isSettled;
                }
              });
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = function(data) {
                  isSettled = true;
                  resolve(data);
                };
                capability.reject = function(reason) {
                  isSettled = true;
                  reject(reason);
                };
              });
              return capability;
            }
            const createObjectURL = function createObjectURLClosure() {
              const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType, forceDataSchema = false) {
                if (!forceDataSchema && URL.createObjectURL) {
                  const blob = new Blob([data], {
                    type: contentType
                  });
                  return URL.createObjectURL(blob);
                }
                let buffer = `data:${contentType};base64,`;
                for (let i2 = 0, ii = data.length; i2 < ii; i2 += 3) {
                  const b1 = data[i2] & 255;
                  const b2 = data[i2 + 1] & 255;
                  const b3 = data[i2 + 2] & 255;
                  const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  const d3 = i2 + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  const d4 = i2 + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            exports3.createObjectURL = createObjectURL;
          },
          /* 3 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            ;
          },
          /* 4 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.clearPrimitiveCaches = clearPrimitiveCaches;
            exports3.isEOF = isEOF;
            exports3.isCmd = isCmd;
            exports3.isDict = isDict;
            exports3.isName = isName;
            exports3.isRef = isRef;
            exports3.isRefsEqual = isRefsEqual;
            exports3.isStream = isStream;
            exports3.RefSetCache = exports3.RefSet = exports3.Ref = exports3.Name = exports3.Dict = exports3.Cmd = exports3.EOF = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var EOF = {};
            exports3.EOF = EOF;
            var Name = function NameClosure() {
              let nameCache = /* @__PURE__ */ Object.create(null);
              function Name2(name) {
                this.name = name;
              }
              Name2.prototype = {};
              Name2.get = function Name_get(name) {
                var nameValue = nameCache[name];
                return nameValue ? nameValue : nameCache[name] = new Name2(name);
              };
              Name2._clearCache = function() {
                nameCache = /* @__PURE__ */ Object.create(null);
              };
              return Name2;
            }();
            exports3.Name = Name;
            var Cmd = function CmdClosure() {
              let cmdCache = /* @__PURE__ */ Object.create(null);
              function Cmd2(cmd) {
                this.cmd = cmd;
              }
              Cmd2.prototype = {};
              Cmd2.get = function Cmd_get(cmd) {
                var cmdValue = cmdCache[cmd];
                return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
              };
              Cmd2._clearCache = function() {
                cmdCache = /* @__PURE__ */ Object.create(null);
              };
              return Cmd2;
            }();
            exports3.Cmd = Cmd;
            var Dict = function DictClosure() {
              var nonSerializable = function nonSerializableClosure() {
                return nonSerializable;
              };
              function Dict2(xref) {
                this._map = /* @__PURE__ */ Object.create(null);
                this.xref = xref;
                this.objId = null;
                this.suppressEncryption = false;
                this.__nonSerializable__ = nonSerializable;
              }
              Dict2.prototype = {
                assignXref: function Dict_assignXref(newXref) {
                  this.xref = newXref;
                },
                get(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref2 && this.xref) {
                    return this.xref.fetch(value, this.suppressEncryption);
                  }
                  return value;
                },
                async getAsync(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref2 && this.xref) {
                    return this.xref.fetchAsync(value, this.suppressEncryption);
                  }
                  return value;
                },
                getArray(key1, key2, key3) {
                  let value = this.get(key1, key2, key3);
                  if (!Array.isArray(value) || !this.xref) {
                    return value;
                  }
                  value = value.slice();
                  for (let i2 = 0, ii = value.length; i2 < ii; i2++) {
                    if (!(value[i2] instanceof Ref2)) {
                      continue;
                    }
                    value[i2] = this.xref.fetch(value[i2], this.suppressEncryption);
                  }
                  return value;
                },
                getRaw: function Dict_getRaw(key) {
                  return this._map[key];
                },
                getKeys: function Dict_getKeys() {
                  return Object.keys(this._map);
                },
                set: function Dict_set(key, value) {
                  this._map[key] = value;
                },
                has: function Dict_has(key) {
                  return this._map[key] !== void 0;
                },
                forEach: function Dict_forEach(callback) {
                  for (var key in this._map) {
                    callback(key, this.get(key));
                  }
                }
              };
              Dict2.empty = new Dict2(null);
              Dict2.merge = function(xref, dictArray) {
                const mergedDict = new Dict2(xref);
                for (let i2 = 0, ii = dictArray.length; i2 < ii; i2++) {
                  const dict = dictArray[i2];
                  if (!isDict(dict)) {
                    continue;
                  }
                  for (const keyName in dict._map) {
                    if (mergedDict._map[keyName] !== void 0) {
                      continue;
                    }
                    mergedDict._map[keyName] = dict._map[keyName];
                  }
                }
                return mergedDict;
              };
              return Dict2;
            }();
            exports3.Dict = Dict;
            var Ref2 = function RefClosure() {
              let refCache = /* @__PURE__ */ Object.create(null);
              function Ref3(num, gen) {
                this.num = num;
                this.gen = gen;
              }
              Ref3.prototype = {
                toString: function Ref_toString() {
                  if (this.gen === 0) {
                    return `${this.num}R`;
                  }
                  return `${this.num}R${this.gen}`;
                }
              };
              Ref3.get = function(num, gen) {
                const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
                const refValue = refCache[key];
                return refValue ? refValue : refCache[key] = new Ref3(num, gen);
              };
              Ref3._clearCache = function() {
                refCache = /* @__PURE__ */ Object.create(null);
              };
              return Ref3;
            }();
            exports3.Ref = Ref2;
            var RefSet = function RefSetClosure() {
              function RefSet2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSet2.prototype = {
                has: function RefSet_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSet_put(ref) {
                  this.dict[ref.toString()] = true;
                },
                remove: function RefSet_remove(ref) {
                  delete this.dict[ref.toString()];
                }
              };
              return RefSet2;
            }();
            exports3.RefSet = RefSet;
            var RefSetCache = function RefSetCacheClosure() {
              function RefSetCache2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSetCache2.prototype = {
                get: function RefSetCache_get(ref) {
                  return this.dict[ref.toString()];
                },
                has: function RefSetCache_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSetCache_put(ref, obj) {
                  this.dict[ref.toString()] = obj;
                },
                putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                  this.dict[ref.toString()] = this.get(aliasRef);
                },
                forEach: function RefSetCache_forEach(callback) {
                  for (const i2 in this.dict) {
                    callback(this.dict[i2]);
                  }
                },
                clear: function RefSetCache_clear() {
                  this.dict = /* @__PURE__ */ Object.create(null);
                }
              };
              return RefSetCache2;
            }();
            exports3.RefSetCache = RefSetCache;
            function isEOF(v2) {
              return v2 === EOF;
            }
            function isName(v2, name) {
              return v2 instanceof Name && (name === void 0 || v2.name === name);
            }
            function isCmd(v2, cmd) {
              return v2 instanceof Cmd && (cmd === void 0 || v2.cmd === cmd);
            }
            function isDict(v2, type) {
              return v2 instanceof Dict && (type === void 0 || isName(v2.get("Type"), type));
            }
            function isRef(v2) {
              return v2 instanceof Ref2;
            }
            function isRefsEqual(v1, v2) {
              return v1.num === v2.num && v1.gen === v2.gen;
            }
            function isStream(v2) {
              return typeof v2 === "object" && v2 !== null && v2.getBytes !== void 0;
            }
            function clearPrimitiveCaches() {
              Cmd._clearCache();
              Name._clearCache();
              Ref2._clearCache();
            }
          },
          /* 5 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.NetworkPdfManager = exports3.LocalPdfManager = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _chunked_stream = __w_pdfjs_require__2(6);
            var _core_utils = __w_pdfjs_require__2(7);
            var _document = __w_pdfjs_require__2(8);
            var _stream = __w_pdfjs_require__2(11);
            class BasePdfManager {
              constructor() {
                if (this.constructor === BasePdfManager) {
                  (0, _util2.unreachable)("Cannot initialize BasePdfManager.");
                }
              }
              get docId() {
                return this._docId;
              }
              get password() {
                return this._password;
              }
              get docBaseUrl() {
                let docBaseUrl = null;
                if (this._docBaseUrl) {
                  const absoluteUrl = (0, _util2.createValidAbsoluteUrl)(this._docBaseUrl);
                  if (absoluteUrl) {
                    docBaseUrl = absoluteUrl.href;
                  } else {
                    (0, _util2.warn)(`Invalid absolute docBaseUrl: "${this._docBaseUrl}".`);
                  }
                }
                return (0, _util2.shadow)(this, "docBaseUrl", docBaseUrl);
              }
              onLoadedStream() {
                (0, _util2.unreachable)("Abstract method `onLoadedStream` called");
              }
              ensureDoc(prop, args) {
                return this.ensure(this.pdfDocument, prop, args);
              }
              ensureXRef(prop, args) {
                return this.ensure(this.pdfDocument.xref, prop, args);
              }
              ensureCatalog(prop, args) {
                return this.ensure(this.pdfDocument.catalog, prop, args);
              }
              getPage(pageIndex) {
                return this.pdfDocument.getPage(pageIndex);
              }
              fontFallback(id, handler) {
                return this.pdfDocument.fontFallback(id, handler);
              }
              cleanup() {
                return this.pdfDocument.cleanup();
              }
              async ensure(obj, prop, args) {
                (0, _util2.unreachable)("Abstract method `ensure` called");
              }
              requestRange(begin, end) {
                (0, _util2.unreachable)("Abstract method `requestRange` called");
              }
              requestLoadedStream() {
                (0, _util2.unreachable)("Abstract method `requestLoadedStream` called");
              }
              sendProgressiveData(chunk) {
                (0, _util2.unreachable)("Abstract method `sendProgressiveData` called");
              }
              updatePassword(password) {
                this._password = password;
              }
              terminate(reason) {
                (0, _util2.unreachable)("Abstract method `terminate` called");
              }
            }
            class LocalPdfManager extends BasePdfManager {
              constructor(docId, data, password, evaluatorOptions, docBaseUrl) {
                super();
                this._docId = docId;
                this._password = password;
                this._docBaseUrl = docBaseUrl;
                this.evaluatorOptions = evaluatorOptions;
                const stream = new _stream.Stream(data);
                this.pdfDocument = new _document.PDFDocument(this, stream);
                this._loadedStreamPromise = Promise.resolve(stream);
              }
              async ensure(obj, prop, args) {
                const value = obj[prop];
                if (typeof value === "function") {
                  return value.apply(obj, args);
                }
                return value;
              }
              requestRange(begin, end) {
                return Promise.resolve();
              }
              requestLoadedStream() {
              }
              onLoadedStream() {
                return this._loadedStreamPromise;
              }
              terminate(reason) {
              }
            }
            exports3.LocalPdfManager = LocalPdfManager;
            class NetworkPdfManager extends BasePdfManager {
              constructor(docId, pdfNetworkStream, args, evaluatorOptions, docBaseUrl) {
                super();
                this._docId = docId;
                this._password = args.password;
                this._docBaseUrl = docBaseUrl;
                this.msgHandler = args.msgHandler;
                this.evaluatorOptions = evaluatorOptions;
                this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, {
                  msgHandler: args.msgHandler,
                  length: args.length,
                  disableAutoFetch: args.disableAutoFetch,
                  rangeChunkSize: args.rangeChunkSize
                });
                this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
              }
              async ensure(obj, prop, args) {
                try {
                  const value = obj[prop];
                  if (typeof value === "function") {
                    return value.apply(obj, args);
                  }
                  return value;
                } catch (ex) {
                  if (!(ex instanceof _core_utils.MissingDataException)) {
                    throw ex;
                  }
                  await this.requestRange(ex.begin, ex.end);
                  return this.ensure(obj, prop, args);
                }
              }
              requestRange(begin, end) {
                return this.streamManager.requestRange(begin, end);
              }
              requestLoadedStream() {
                this.streamManager.requestAllChunks();
              }
              sendProgressiveData(chunk) {
                this.streamManager.onReceiveData({
                  chunk
                });
              }
              onLoadedStream() {
                return this.streamManager.onLoadedStream();
              }
              terminate(reason) {
                this.streamManager.abort(reason);
              }
            }
            exports3.NetworkPdfManager = NetworkPdfManager;
          },
          /* 6 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ChunkedStreamManager = exports3.ChunkedStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _core_utils = __w_pdfjs_require__2(7);
            class ChunkedStream {
              constructor(length, chunkSize, manager) {
                this.bytes = new Uint8Array(length);
                this.start = 0;
                this.pos = 0;
                this.end = length;
                this.chunkSize = chunkSize;
                this.loadedChunks = [];
                this.numChunksLoaded = 0;
                this.numChunks = Math.ceil(length / chunkSize);
                this.manager = manager;
                this.progressiveDataLength = 0;
                this.lastSuccessfulEnsureByteChunk = -1;
              }
              getMissingChunks() {
                const chunks = [];
                for (let chunk = 0, n2 = this.numChunks; chunk < n2; ++chunk) {
                  if (!this.loadedChunks[chunk]) {
                    chunks.push(chunk);
                  }
                }
                return chunks;
              }
              getBaseStreams() {
                return [this];
              }
              allChunksLoaded() {
                return this.numChunksLoaded === this.numChunks;
              }
              onReceiveData(begin, chunk) {
                const chunkSize = this.chunkSize;
                if (begin % chunkSize !== 0) {
                  throw new Error(`Bad begin offset: ${begin}`);
                }
                const end = begin + chunk.byteLength;
                if (end % chunkSize !== 0 && end !== this.bytes.length) {
                  throw new Error(`Bad end offset: ${end}`);
                }
                this.bytes.set(new Uint8Array(chunk), begin);
                const beginChunk = Math.floor(begin / chunkSize);
                const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                  if (!this.loadedChunks[curChunk]) {
                    this.loadedChunks[curChunk] = true;
                    ++this.numChunksLoaded;
                  }
                }
              }
              onReceiveProgressiveData(data) {
                let position = this.progressiveDataLength;
                const beginChunk = Math.floor(position / this.chunkSize);
                this.bytes.set(new Uint8Array(data), position);
                position += data.byteLength;
                this.progressiveDataLength = position;
                const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                  if (!this.loadedChunks[curChunk]) {
                    this.loadedChunks[curChunk] = true;
                    ++this.numChunksLoaded;
                  }
                }
              }
              ensureByte(pos) {
                if (pos < this.progressiveDataLength) {
                  return;
                }
                const chunk = Math.floor(pos / this.chunkSize);
                if (chunk === this.lastSuccessfulEnsureByteChunk) {
                  return;
                }
                if (!this.loadedChunks[chunk]) {
                  throw new _core_utils.MissingDataException(pos, pos + 1);
                }
                this.lastSuccessfulEnsureByteChunk = chunk;
              }
              ensureRange(begin, end) {
                if (begin >= end) {
                  return;
                }
                if (end <= this.progressiveDataLength) {
                  return;
                }
                const chunkSize = this.chunkSize;
                const beginChunk = Math.floor(begin / chunkSize);
                const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                  if (!this.loadedChunks[chunk]) {
                    throw new _core_utils.MissingDataException(begin, end);
                  }
                }
              }
              nextEmptyChunk(beginChunk) {
                const numChunks = this.numChunks;
                for (let i2 = 0; i2 < numChunks; ++i2) {
                  const chunk = (beginChunk + i2) % numChunks;
                  if (!this.loadedChunks[chunk]) {
                    return chunk;
                  }
                }
                return null;
              }
              hasChunk(chunk) {
                return !!this.loadedChunks[chunk];
              }
              get length() {
                return this.end - this.start;
              }
              get isEmpty() {
                return this.length === 0;
              }
              getByte() {
                const pos = this.pos;
                if (pos >= this.end) {
                  return -1;
                }
                if (pos >= this.progressiveDataLength) {
                  this.ensureByte(pos);
                }
                return this.bytes[this.pos++];
              }
              getUint16() {
                const b0 = this.getByte();
                const b1 = this.getByte();
                if (b0 === -1 || b1 === -1) {
                  return -1;
                }
                return (b0 << 8) + b1;
              }
              getInt32() {
                const b0 = this.getByte();
                const b1 = this.getByte();
                const b2 = this.getByte();
                const b3 = this.getByte();
                return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
              }
              getBytes(length, forceClamped = false) {
                const bytes = this.bytes;
                const pos = this.pos;
                const strEnd = this.end;
                if (!length) {
                  if (strEnd > this.progressiveDataLength) {
                    this.ensureRange(pos, strEnd);
                  }
                  const subarray2 = bytes.subarray(pos, strEnd);
                  return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
                }
                let end = pos + length;
                if (end > strEnd) {
                  end = strEnd;
                }
                if (end > this.progressiveDataLength) {
                  this.ensureRange(pos, end);
                }
                this.pos = end;
                const subarray = bytes.subarray(pos, end);
                return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
              }
              peekByte() {
                const peekedByte = this.getByte();
                if (peekedByte !== -1) {
                  this.pos--;
                }
                return peekedByte;
              }
              peekBytes(length, forceClamped = false) {
                const bytes = this.getBytes(length, forceClamped);
                this.pos -= bytes.length;
                return bytes;
              }
              getByteRange(begin, end) {
                if (begin < 0) {
                  begin = 0;
                }
                if (end > this.end) {
                  end = this.end;
                }
                if (end > this.progressiveDataLength) {
                  this.ensureRange(begin, end);
                }
                return this.bytes.subarray(begin, end);
              }
              skip(n2) {
                if (!n2) {
                  n2 = 1;
                }
                this.pos += n2;
              }
              reset() {
                this.pos = this.start;
              }
              moveStart() {
                this.start = this.pos;
              }
              makeSubStream(start, length, dict) {
                if (length) {
                  if (start + length > this.progressiveDataLength) {
                    this.ensureRange(start, start + length);
                  }
                } else {
                  if (start >= this.progressiveDataLength) {
                    this.ensureByte(start);
                  }
                }
                function ChunkedStreamSubstream() {
                }
                ChunkedStreamSubstream.prototype = Object.create(this);
                ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                  const chunkSize = this.chunkSize;
                  const beginChunk = Math.floor(this.start / chunkSize);
                  const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                  const missingChunks = [];
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!this.loadedChunks[chunk]) {
                      missingChunks.push(chunk);
                    }
                  }
                  return missingChunks;
                };
                ChunkedStreamSubstream.prototype.allChunksLoaded = function() {
                  if (this.numChunksLoaded === this.numChunks) {
                    return true;
                  }
                  return this.getMissingChunks().length === 0;
                };
                const subStream = new ChunkedStreamSubstream();
                subStream.pos = subStream.start = start;
                subStream.end = start + length || this.end;
                subStream.dict = dict;
                return subStream;
              }
            }
            exports3.ChunkedStream = ChunkedStream;
            class ChunkedStreamManager {
              constructor(pdfNetworkStream, args) {
                this.length = args.length;
                this.chunkSize = args.rangeChunkSize;
                this.stream = new ChunkedStream(this.length, this.chunkSize, this);
                this.pdfNetworkStream = pdfNetworkStream;
                this.disableAutoFetch = args.disableAutoFetch;
                this.msgHandler = args.msgHandler;
                this.currRequestId = 0;
                this.chunksNeededByRequest = /* @__PURE__ */ Object.create(null);
                this.requestsByChunk = /* @__PURE__ */ Object.create(null);
                this.promisesByRequest = /* @__PURE__ */ Object.create(null);
                this.progressiveDataLength = 0;
                this.aborted = false;
                this._loadedStreamCapability = (0, _util2.createPromiseCapability)();
              }
              onLoadedStream() {
                return this._loadedStreamCapability.promise;
              }
              sendRequest(begin, end) {
                const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                if (!rangeReader.isStreamingSupported) {
                  rangeReader.onProgress = this.onProgress.bind(this);
                }
                let chunks = [], loaded = 0;
                const promise = new Promise((resolve, reject) => {
                  const readChunk = (chunk) => {
                    try {
                      if (!chunk.done) {
                        const data = chunk.value;
                        chunks.push(data);
                        loaded += (0, _util2.arrayByteLength)(data);
                        if (rangeReader.isStreamingSupported) {
                          this.onProgress({
                            loaded
                          });
                        }
                        rangeReader.read().then(readChunk, reject);
                        return;
                      }
                      const chunkData = (0, _util2.arraysToBytes)(chunks);
                      chunks = null;
                      resolve(chunkData);
                    } catch (e2) {
                      reject(e2);
                    }
                  };
                  rangeReader.read().then(readChunk, reject);
                });
                promise.then((data) => {
                  if (this.aborted) {
                    return;
                  }
                  this.onReceiveData({
                    chunk: data,
                    begin
                  });
                });
              }
              requestAllChunks() {
                const missingChunks = this.stream.getMissingChunks();
                this._requestChunks(missingChunks);
                return this._loadedStreamCapability.promise;
              }
              _requestChunks(chunks) {
                const requestId = this.currRequestId++;
                const chunksNeeded = /* @__PURE__ */ Object.create(null);
                this.chunksNeededByRequest[requestId] = chunksNeeded;
                for (const chunk of chunks) {
                  if (!this.stream.hasChunk(chunk)) {
                    chunksNeeded[chunk] = true;
                  }
                }
                if ((0, _util2.isEmptyObj)(chunksNeeded)) {
                  return Promise.resolve();
                }
                const capability = (0, _util2.createPromiseCapability)();
                this.promisesByRequest[requestId] = capability;
                const chunksToRequest = [];
                for (let chunk in chunksNeeded) {
                  chunk = chunk | 0;
                  if (!(chunk in this.requestsByChunk)) {
                    this.requestsByChunk[chunk] = [];
                    chunksToRequest.push(chunk);
                  }
                  this.requestsByChunk[chunk].push(requestId);
                }
                if (!chunksToRequest.length) {
                  return capability.promise;
                }
                const groupedChunksToRequest = this.groupChunks(chunksToRequest);
                for (const groupedChunk of groupedChunksToRequest) {
                  const begin = groupedChunk.beginChunk * this.chunkSize;
                  const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                  this.sendRequest(begin, end);
                }
                return capability.promise;
              }
              getStream() {
                return this.stream;
              }
              requestRange(begin, end) {
                end = Math.min(end, this.length);
                const beginChunk = this.getBeginChunk(begin);
                const endChunk = this.getEndChunk(end);
                const chunks = [];
                for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                  chunks.push(chunk);
                }
                return this._requestChunks(chunks);
              }
              requestRanges(ranges = []) {
                const chunksToRequest = [];
                for (const range of ranges) {
                  const beginChunk = this.getBeginChunk(range.begin);
                  const endChunk = this.getEndChunk(range.end);
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!chunksToRequest.includes(chunk)) {
                      chunksToRequest.push(chunk);
                    }
                  }
                }
                chunksToRequest.sort(function(a2, b2) {
                  return a2 - b2;
                });
                return this._requestChunks(chunksToRequest);
              }
              groupChunks(chunks) {
                const groupedChunks = [];
                let beginChunk = -1;
                let prevChunk = -1;
                for (let i2 = 0, ii = chunks.length; i2 < ii; ++i2) {
                  const chunk = chunks[i2];
                  if (beginChunk < 0) {
                    beginChunk = chunk;
                  }
                  if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                    groupedChunks.push({
                      beginChunk,
                      endChunk: prevChunk + 1
                    });
                    beginChunk = chunk;
                  }
                  if (i2 + 1 === chunks.length) {
                    groupedChunks.push({
                      beginChunk,
                      endChunk: chunk + 1
                    });
                  }
                  prevChunk = chunk;
                }
                return groupedChunks;
              }
              onProgress(args) {
                this.msgHandler.send("DocProgress", {
                  loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
                  total: this.length
                });
              }
              onReceiveData(args) {
                const chunk = args.chunk;
                const isProgressive = args.begin === void 0;
                const begin = isProgressive ? this.progressiveDataLength : args.begin;
                const end = begin + chunk.byteLength;
                const beginChunk = Math.floor(begin / this.chunkSize);
                const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                if (isProgressive) {
                  this.stream.onReceiveProgressiveData(chunk);
                  this.progressiveDataLength = end;
                } else {
                  this.stream.onReceiveData(begin, chunk);
                }
                if (this.stream.allChunksLoaded()) {
                  this._loadedStreamCapability.resolve(this.stream);
                }
                const loadedRequests = [];
                for (let chunk2 = beginChunk; chunk2 < endChunk; ++chunk2) {
                  const requestIds = this.requestsByChunk[chunk2] || [];
                  delete this.requestsByChunk[chunk2];
                  for (const requestId of requestIds) {
                    const chunksNeeded = this.chunksNeededByRequest[requestId];
                    if (chunk2 in chunksNeeded) {
                      delete chunksNeeded[chunk2];
                    }
                    if (!(0, _util2.isEmptyObj)(chunksNeeded)) {
                      continue;
                    }
                    loadedRequests.push(requestId);
                  }
                }
                if (!this.disableAutoFetch && (0, _util2.isEmptyObj)(this.requestsByChunk)) {
                  let nextEmptyChunk;
                  if (this.stream.numChunksLoaded === 1) {
                    const lastChunk = this.stream.numChunks - 1;
                    if (!this.stream.hasChunk(lastChunk)) {
                      nextEmptyChunk = lastChunk;
                    }
                  } else {
                    nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                  }
                  if (Number.isInteger(nextEmptyChunk)) {
                    this._requestChunks([nextEmptyChunk]);
                  }
                }
                for (const requestId of loadedRequests) {
                  const capability = this.promisesByRequest[requestId];
                  delete this.promisesByRequest[requestId];
                  capability.resolve();
                }
                this.msgHandler.send("DocProgress", {
                  loaded: this.stream.numChunksLoaded * this.chunkSize,
                  total: this.length
                });
              }
              onError(err) {
                this._loadedStreamCapability.reject(err);
              }
              getBeginChunk(begin) {
                return Math.floor(begin / this.chunkSize);
              }
              getEndChunk(end) {
                return Math.floor((end - 1) / this.chunkSize) + 1;
              }
              abort(reason) {
                this.aborted = true;
                if (this.pdfNetworkStream) {
                  this.pdfNetworkStream.cancelAllRequests(reason);
                }
                for (const requestId in this.promisesByRequest) {
                  this.promisesByRequest[requestId].reject(reason);
                }
              }
            }
            exports3.ChunkedStreamManager = ChunkedStreamManager;
          },
          /* 7 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getLookupTableFactory = getLookupTableFactory;
            exports3.getInheritableProperty = getInheritableProperty;
            exports3.toRomanNumerals = toRomanNumerals;
            exports3.log2 = log2;
            exports3.readInt8 = readInt8;
            exports3.readUint16 = readUint16;
            exports3.readUint32 = readUint32;
            exports3.isWhiteSpace = isWhiteSpace;
            exports3.XRefParseException = exports3.XRefEntryException = exports3.MissingDataException = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            function getLookupTableFactory(initializer) {
              let lookup;
              return function() {
                if (initializer) {
                  lookup = /* @__PURE__ */ Object.create(null);
                  initializer(lookup);
                  initializer = null;
                }
                return lookup;
              };
            }
            class MissingDataException extends _util2.BaseException {
              constructor(begin, end) {
                super(`Missing data [${begin}, ${end})`);
                this.begin = begin;
                this.end = end;
              }
            }
            exports3.MissingDataException = MissingDataException;
            class XRefEntryException extends _util2.BaseException {
            }
            exports3.XRefEntryException = XRefEntryException;
            class XRefParseException extends _util2.BaseException {
            }
            exports3.XRefParseException = XRefParseException;
            function getInheritableProperty({
              dict,
              key,
              getArray = false,
              stopWhenFound = true
            }) {
              const LOOP_LIMIT = 100;
              let loopCount = 0;
              let values;
              while (dict) {
                const value = getArray ? dict.getArray(key) : dict.get(key);
                if (value !== void 0) {
                  if (stopWhenFound) {
                    return value;
                  }
                  if (!values) {
                    values = [];
                  }
                  values.push(value);
                }
                if (++loopCount > LOOP_LIMIT) {
                  (0, _util2.warn)(`getInheritableProperty: maximum loop count exceeded for "${key}"`);
                  break;
                }
                dict = dict.get("Parent");
              }
              return values;
            }
            const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
            function toRomanNumerals(number, lowerCase = false) {
              (0, _util2.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
              const romanBuf = [];
              let pos;
              while (number >= 1e3) {
                number -= 1e3;
                romanBuf.push("M");
              }
              pos = number / 100 | 0;
              number %= 100;
              romanBuf.push(ROMAN_NUMBER_MAP[pos]);
              pos = number / 10 | 0;
              number %= 10;
              romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
              romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
              const romanStr = romanBuf.join("");
              return lowerCase ? romanStr.toLowerCase() : romanStr;
            }
            function log2(x2) {
              if (x2 <= 0) {
                return 0;
              }
              return Math.ceil(Math.log2(x2));
            }
            function readInt8(data, offset) {
              return data[offset] << 24 >> 24;
            }
            function readUint16(data, offset) {
              return data[offset] << 8 | data[offset + 1];
            }
            function readUint32(data, offset) {
              return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
            }
            function isWhiteSpace(ch) {
              return ch === 32 || ch === 9 || ch === 13 || ch === 10;
            }
          },
          /* 8 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFDocument = exports3.Page = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _obj = __w_pdfjs_require__2(9);
            var _primitives = __w_pdfjs_require__2(4);
            var _core_utils = __w_pdfjs_require__2(7);
            var _stream = __w_pdfjs_require__2(11);
            var _annotation = __w_pdfjs_require__2(23);
            var _crypto = __w_pdfjs_require__2(21);
            var _parser = __w_pdfjs_require__2(10);
            var _operator_list = __w_pdfjs_require__2(24);
            var _evaluator = __w_pdfjs_require__2(25);
            var _function = __w_pdfjs_require__2(39);
            const DEFAULT_USER_UNIT = 1;
            const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
            function isAnnotationRenderable(annotation, intent) {
              return intent === "display" && annotation.viewable || intent === "print" && annotation.printable;
            }
            class Page2 {
              constructor({
                pdfManager,
                xref,
                pageIndex,
                pageDict,
                ref,
                fontCache,
                builtInCMapCache,
                pdfFunctionFactory
              }) {
                this.pdfManager = pdfManager;
                this.pageIndex = pageIndex;
                this.pageDict = pageDict;
                this.xref = xref;
                this.ref = ref;
                this.fontCache = fontCache;
                this.builtInCMapCache = builtInCMapCache;
                this.pdfFunctionFactory = pdfFunctionFactory;
                this.evaluatorOptions = pdfManager.evaluatorOptions;
                this.resourcesPromise = null;
                const idCounters = {
                  obj: 0
                };
                this.idFactory = {
                  createObjId() {
                    return `p${pageIndex}_${++idCounters.obj}`;
                  },
                  getDocId() {
                    return `g_${pdfManager.docId}`;
                  }
                };
              }
              _getInheritableProperty(key, getArray = false) {
                const value = (0, _core_utils.getInheritableProperty)({
                  dict: this.pageDict,
                  key,
                  getArray,
                  stopWhenFound: false
                });
                if (!Array.isArray(value)) {
                  return value;
                }
                if (value.length === 1 || !(0, _primitives.isDict)(value[0])) {
                  return value[0];
                }
                return _primitives.Dict.merge(this.xref, value);
              }
              get content() {
                return this.pageDict.get("Contents");
              }
              get resources() {
                return (0, _util2.shadow)(this, "resources", this._getInheritableProperty("Resources") || _primitives.Dict.empty);
              }
              _getBoundingBox(name) {
                const box = this._getInheritableProperty(name, true);
                if (Array.isArray(box) && box.length === 4) {
                  if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                    return box;
                  }
                  (0, _util2.warn)(`Empty /${name} entry.`);
                }
                return null;
              }
              get mediaBox() {
                return (0, _util2.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
              }
              get cropBox() {
                return (0, _util2.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
              }
              get userUnit() {
                let obj = this.pageDict.get("UserUnit");
                if (!(0, _util2.isNum)(obj) || obj <= 0) {
                  obj = DEFAULT_USER_UNIT;
                }
                return (0, _util2.shadow)(this, "userUnit", obj);
              }
              get view() {
                const {
                  cropBox,
                  mediaBox
                } = this;
                let view;
                if (cropBox === mediaBox || (0, _util2.isArrayEqual)(cropBox, mediaBox)) {
                  view = mediaBox;
                } else {
                  const box = _util2.Util.intersect(cropBox, mediaBox);
                  if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                    view = box;
                  } else {
                    (0, _util2.warn)("Empty /CropBox and /MediaBox intersection.");
                  }
                }
                return (0, _util2.shadow)(this, "view", view || mediaBox);
              }
              get rotate() {
                let rotate = this._getInheritableProperty("Rotate") || 0;
                if (rotate % 90 !== 0) {
                  rotate = 0;
                } else if (rotate >= 360) {
                  rotate = rotate % 360;
                } else if (rotate < 0) {
                  rotate = (rotate % 360 + 360) % 360;
                }
                return (0, _util2.shadow)(this, "rotate", rotate);
              }
              getContentStream() {
                const content = this.content;
                let stream;
                if (Array.isArray(content)) {
                  const xref = this.xref;
                  const streams = [];
                  for (const stream2 of content) {
                    streams.push(xref.fetchIfRef(stream2));
                  }
                  stream = new _stream.StreamsSequenceStream(streams);
                } else if ((0, _primitives.isStream)(content)) {
                  stream = content;
                } else {
                  stream = new _stream.NullStream();
                }
                return stream;
              }
              loadResources(keys) {
                if (!this.resourcesPromise) {
                  this.resourcesPromise = this.pdfManager.ensure(this, "resources");
                }
                return this.resourcesPromise.then(() => {
                  const objectLoader = new _obj.ObjectLoader(this.resources, keys, this.xref);
                  return objectLoader.load();
                });
              }
              getOperatorList({
                handler,
                sink,
                task,
                intent,
                renderInteractiveForms
              }) {
                const contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                const partialEvaluator = new _evaluator.PartialEvaluator({
                  xref: this.xref,
                  handler,
                  pageIndex: this.pageIndex,
                  idFactory: this.idFactory,
                  fontCache: this.fontCache,
                  builtInCMapCache: this.builtInCMapCache,
                  options: this.evaluatorOptions,
                  pdfFunctionFactory: this.pdfFunctionFactory
                });
                const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                const pageListPromise = dataPromises.then(([contentStream]) => {
                  const opList = new _operator_list.OperatorList(intent, sink, this.pageIndex);
                  handler.send("StartRenderPage", {
                    transparency: partialEvaluator.hasBlendModes(this.resources),
                    pageIndex: this.pageIndex,
                    intent
                  });
                  return partialEvaluator.getOperatorList({
                    stream: contentStream,
                    task,
                    resources: this.resources,
                    operatorList: opList
                  }).then(function() {
                    return opList;
                  });
                });
                return Promise.all([pageListPromise, this._parsedAnnotations]).then(function([pageOpList, annotations]) {
                  if (annotations.length === 0) {
                    pageOpList.flush(true);
                    return {
                      length: pageOpList.totalLength
                    };
                  }
                  const opListPromises = [];
                  for (const annotation of annotations) {
                    if (isAnnotationRenderable(annotation, intent)) {
                      opListPromises.push(annotation.getOperatorList(partialEvaluator, task, renderInteractiveForms));
                    }
                  }
                  return Promise.all(opListPromises).then(function(opLists) {
                    pageOpList.addOp(_util2.OPS.beginAnnotations, []);
                    for (const opList of opLists) {
                      pageOpList.addOpList(opList);
                    }
                    pageOpList.addOp(_util2.OPS.endAnnotations, []);
                    pageOpList.flush(true);
                    return {
                      length: pageOpList.totalLength
                    };
                  });
                });
              }
              extractTextContent({
                handler,
                task,
                normalizeWhitespace,
                sink,
                combineTextItems
              }) {
                const contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                const resourcesPromise = this.loadResources(["ExtGState", "XObject", "Font"]);
                const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                return dataPromises.then(([contentStream]) => {
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this.idFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    options: this.evaluatorOptions,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  });
                  return partialEvaluator.getTextContent({
                    stream: contentStream,
                    task,
                    resources: this.resources,
                    normalizeWhitespace,
                    combineTextItems,
                    sink
                  });
                });
              }
              getAnnotationsData(intent) {
                return this._parsedAnnotations.then(function(annotations) {
                  const annotationsData = [];
                  for (let i2 = 0, ii = annotations.length; i2 < ii; i2++) {
                    if (!intent || isAnnotationRenderable(annotations[i2], intent)) {
                      annotationsData.push(annotations[i2].data);
                    }
                  }
                  return annotationsData;
                });
              }
              get annotations() {
                return (0, _util2.shadow)(this, "annotations", this._getInheritableProperty("Annots") || []);
              }
              get _parsedAnnotations() {
                const parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(() => {
                  const annotationRefs = this.annotations;
                  const annotationPromises = [];
                  for (let i2 = 0, ii = annotationRefs.length; i2 < ii; i2++) {
                    annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRefs[i2], this.pdfManager, this.idFactory));
                  }
                  return Promise.all(annotationPromises).then(function(annotations) {
                    return annotations.filter(function isDefined3(annotation) {
                      return !!annotation;
                    });
                  }, function(reason) {
                    (0, _util2.warn)(`_parsedAnnotations: "${reason}".`);
                    return [];
                  });
                });
                return (0, _util2.shadow)(this, "_parsedAnnotations", parsedAnnotations);
              }
            }
            exports3.Page = Page2;
            const PDF_HEADER_SIGNATURE = new Uint8Array([37, 80, 68, 70, 45]);
            const STARTXREF_SIGNATURE = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
            const ENDOBJ_SIGNATURE = new Uint8Array([101, 110, 100, 111, 98, 106]);
            const FINGERPRINT_FIRST_BYTES = 1024;
            const EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
            const PDF_HEADER_VERSION_REGEXP = /^[1-9]\.[0-9]$/;
            function find(stream, signature, limit = 1024, backwards = false) {
              const signatureLength = signature.length;
              const scanBytes = stream.peekBytes(limit);
              const scanLength = scanBytes.length - signatureLength;
              if (scanLength <= 0) {
                return false;
              }
              if (backwards) {
                const signatureEnd = signatureLength - 1;
                let pos = scanBytes.length - 1;
                while (pos >= signatureEnd) {
                  let j2 = 0;
                  while (j2 < signatureLength && scanBytes[pos - j2] === signature[signatureEnd - j2]) {
                    j2++;
                  }
                  if (j2 >= signatureLength) {
                    stream.pos += pos - signatureEnd;
                    return true;
                  }
                  pos--;
                }
              } else {
                let pos = 0;
                while (pos <= scanLength) {
                  let j2 = 0;
                  while (j2 < signatureLength && scanBytes[pos + j2] === signature[j2]) {
                    j2++;
                  }
                  if (j2 >= signatureLength) {
                    stream.pos += pos;
                    return true;
                  }
                  pos++;
                }
              }
              return false;
            }
            class PDFDocument {
              constructor(pdfManager, arg) {
                let stream;
                if ((0, _primitives.isStream)(arg)) {
                  stream = arg;
                } else if ((0, _util2.isArrayBuffer)(arg)) {
                  stream = new _stream.Stream(arg);
                } else {
                  throw new Error("PDFDocument: Unknown argument type");
                }
                if (stream.length <= 0) {
                  throw new _util2.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
                }
                this.pdfManager = pdfManager;
                this.stream = stream;
                this.xref = new _obj.XRef(stream, pdfManager);
                this.pdfFunctionFactory = new _function.PDFFunctionFactory({
                  xref: this.xref,
                  isEvalSupported: pdfManager.evaluatorOptions.isEvalSupported
                });
                this._pagePromises = [];
              }
              parse(recoveryMode) {
                this.setup(recoveryMode);
                const version2 = this.catalog.catDict.get("Version");
                if ((0, _primitives.isName)(version2)) {
                  this.pdfFormatVersion = version2.name;
                }
                try {
                  this.acroForm = this.catalog.catDict.get("AcroForm");
                  if (this.acroForm) {
                    this.xfa = this.acroForm.get("XFA");
                    const fields = this.acroForm.get("Fields");
                    if ((!Array.isArray(fields) || fields.length === 0) && !this.xfa) {
                      this.acroForm = null;
                    }
                  }
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.info)("Cannot fetch AcroForm entry; assuming no AcroForms are present");
                  this.acroForm = null;
                }
                try {
                  const collection = this.catalog.catDict.get("Collection");
                  if ((0, _primitives.isDict)(collection) && collection.getKeys().length > 0) {
                    this.collection = collection;
                  }
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.info)("Cannot fetch Collection dictionary.");
                }
              }
              get linearization() {
                let linearization = null;
                try {
                  linearization = _parser.Linearization.create(this.stream);
                } catch (err) {
                  if (err instanceof _core_utils.MissingDataException) {
                    throw err;
                  }
                  (0, _util2.info)(err);
                }
                return (0, _util2.shadow)(this, "linearization", linearization);
              }
              get startXRef() {
                const stream = this.stream;
                let startXRef = 0;
                if (this.linearization) {
                  stream.reset();
                  if (find(stream, ENDOBJ_SIGNATURE)) {
                    startXRef = stream.pos + 6 - stream.start;
                  }
                } else {
                  const step = 1024;
                  const startXRefLength = STARTXREF_SIGNATURE.length;
                  let found = false, pos = stream.end;
                  while (!found && pos > 0) {
                    pos -= step - startXRefLength;
                    if (pos < 0) {
                      pos = 0;
                    }
                    stream.pos = pos;
                    found = find(stream, STARTXREF_SIGNATURE, step, true);
                  }
                  if (found) {
                    stream.skip(9);
                    let ch;
                    do {
                      ch = stream.getByte();
                    } while ((0, _core_utils.isWhiteSpace)(ch));
                    let str = "";
                    while (ch >= 32 && ch <= 57) {
                      str += String.fromCharCode(ch);
                      ch = stream.getByte();
                    }
                    startXRef = parseInt(str, 10);
                    if (isNaN(startXRef)) {
                      startXRef = 0;
                    }
                  }
                }
                return (0, _util2.shadow)(this, "startXRef", startXRef);
              }
              checkHeader() {
                const stream = this.stream;
                stream.reset();
                if (!find(stream, PDF_HEADER_SIGNATURE)) {
                  return;
                }
                stream.moveStart();
                const MAX_PDF_VERSION_LENGTH = 12;
                let version2 = "", ch;
                while ((ch = stream.getByte()) > 32) {
                  if (version2.length >= MAX_PDF_VERSION_LENGTH) {
                    break;
                  }
                  version2 += String.fromCharCode(ch);
                }
                if (!this.pdfFormatVersion) {
                  this.pdfFormatVersion = version2.substring(5);
                }
              }
              parseStartXRef() {
                this.xref.setStartXRef(this.startXRef);
              }
              setup(recoveryMode) {
                this.xref.parse(recoveryMode);
                this.catalog = new _obj.Catalog(this.pdfManager, this.xref);
              }
              get numPages() {
                const linearization = this.linearization;
                const num = linearization ? linearization.numPages : this.catalog.numPages;
                return (0, _util2.shadow)(this, "numPages", num);
              }
              get documentInfo() {
                const DocumentInfoValidators = {
                  Title: _util2.isString,
                  Author: _util2.isString,
                  Subject: _util2.isString,
                  Keywords: _util2.isString,
                  Creator: _util2.isString,
                  Producer: _util2.isString,
                  CreationDate: _util2.isString,
                  ModDate: _util2.isString,
                  Trapped: _primitives.isName
                };
                let version2 = this.pdfFormatVersion;
                if (typeof version2 !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version2)) {
                  (0, _util2.warn)(`Invalid PDF header version number: ${version2}`);
                  version2 = null;
                }
                const docInfo = {
                  PDFFormatVersion: version2,
                  IsLinearized: !!this.linearization,
                  IsAcroFormPresent: !!this.acroForm,
                  IsXFAPresent: !!this.xfa,
                  IsCollectionPresent: !!this.collection
                };
                let infoDict;
                try {
                  infoDict = this.xref.trailer.get("Info");
                } catch (err) {
                  if (err instanceof _core_utils.MissingDataException) {
                    throw err;
                  }
                  (0, _util2.info)("The document information dictionary is invalid.");
                }
                if ((0, _primitives.isDict)(infoDict)) {
                  for (const key of infoDict.getKeys()) {
                    const value = infoDict.get(key);
                    if (DocumentInfoValidators[key]) {
                      if (DocumentInfoValidators[key](value)) {
                        docInfo[key] = typeof value !== "string" ? value : (0, _util2.stringToPDFString)(value);
                      } else {
                        (0, _util2.info)(`Bad value in document info for "${key}".`);
                      }
                    } else if (typeof key === "string") {
                      let customValue;
                      if ((0, _util2.isString)(value)) {
                        customValue = (0, _util2.stringToPDFString)(value);
                      } else if ((0, _primitives.isName)(value) || (0, _util2.isNum)(value) || (0, _util2.isBool)(value)) {
                        customValue = value;
                      } else {
                        (0, _util2.info)(`Unsupported value in document info for (custom) "${key}".`);
                        continue;
                      }
                      if (!docInfo["Custom"]) {
                        docInfo["Custom"] = /* @__PURE__ */ Object.create(null);
                      }
                      docInfo["Custom"][key] = customValue;
                    }
                  }
                }
                return (0, _util2.shadow)(this, "documentInfo", docInfo);
              }
              get fingerprint() {
                let hash;
                const idArray = this.xref.trailer.get("ID");
                if (Array.isArray(idArray) && idArray[0] && (0, _util2.isString)(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
                  hash = (0, _util2.stringToBytes)(idArray[0]);
                } else {
                  hash = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                }
                const fingerprintBuf = [];
                for (let i2 = 0, ii = hash.length; i2 < ii; i2++) {
                  const hex = hash[i2].toString(16);
                  fingerprintBuf.push(hex.padStart(2, "0"));
                }
                return (0, _util2.shadow)(this, "fingerprint", fingerprintBuf.join(""));
              }
              _getLinearizationPage(pageIndex) {
                const {
                  catalog,
                  linearization
                } = this;
                (0, _util2.assert)(linearization && linearization.pageFirst === pageIndex);
                const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
                return this.xref.fetchAsync(ref).then((obj) => {
                  if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Type") && obj.has("Contents")) {
                    if (ref && !catalog.pageKidsCountCache.has(ref)) {
                      catalog.pageKidsCountCache.put(ref, 1);
                    }
                    return [obj, ref];
                  }
                  throw new _util2.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
                }).catch((reason) => {
                  (0, _util2.info)(reason);
                  return catalog.getPageDict(pageIndex);
                });
              }
              getPage(pageIndex) {
                if (this._pagePromises[pageIndex] !== void 0) {
                  return this._pagePromises[pageIndex];
                }
                const {
                  catalog,
                  linearization
                } = this;
                const promise = linearization && linearization.pageFirst === pageIndex ? this._getLinearizationPage(pageIndex) : catalog.getPageDict(pageIndex);
                return this._pagePromises[pageIndex] = promise.then(([pageDict, ref]) => {
                  return new Page2({
                    pdfManager: this.pdfManager,
                    xref: this.xref,
                    pageIndex,
                    pageDict,
                    ref,
                    fontCache: catalog.fontCache,
                    builtInCMapCache: catalog.builtInCMapCache,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  });
                });
              }
              checkFirstPage() {
                return this.getPage(0).catch(async (reason) => {
                  if (reason instanceof _core_utils.XRefEntryException) {
                    this._pagePromises.length = 0;
                    await this.cleanup();
                    throw new _core_utils.XRefParseException();
                  }
                });
              }
              fontFallback(id, handler) {
                return this.catalog.fontFallback(id, handler);
              }
              async cleanup() {
                return this.catalog ? this.catalog.cleanup() : (0, _primitives.clearPrimitiveCaches)();
              }
            }
            exports3.PDFDocument = PDFDocument;
          },
          /* 9 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.FileSpec = exports3.XRef = exports3.ObjectLoader = exports3.Catalog = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _parser = __w_pdfjs_require__2(10);
            var _core_utils = __w_pdfjs_require__2(7);
            var _crypto = __w_pdfjs_require__2(21);
            var _colorspace = __w_pdfjs_require__2(22);
            function fetchDestination(dest) {
              return (0, _primitives.isDict)(dest) ? dest.get("D") : dest;
            }
            class Catalog {
              constructor(pdfManager, xref) {
                this.pdfManager = pdfManager;
                this.xref = xref;
                this.catDict = xref.getCatalogObj();
                if (!(0, _primitives.isDict)(this.catDict)) {
                  throw new _util2.FormatError("Catalog object is not a dictionary.");
                }
                this.fontCache = new _primitives.RefSetCache();
                this.builtInCMapCache = /* @__PURE__ */ new Map();
                this.pageKidsCountCache = new _primitives.RefSetCache();
              }
              get metadata() {
                const streamRef = this.catDict.getRaw("Metadata");
                if (!(0, _primitives.isRef)(streamRef)) {
                  return (0, _util2.shadow)(this, "metadata", null);
                }
                const suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
                const stream = this.xref.fetch(streamRef, suppressEncryption);
                let metadata;
                if (stream && (0, _primitives.isDict)(stream.dict)) {
                  const type = stream.dict.get("Type");
                  const subtype = stream.dict.get("Subtype");
                  if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                    try {
                      metadata = (0, _util2.stringToUTF8String)((0, _util2.bytesToString)(stream.getBytes()));
                    } catch (e2) {
                      if (e2 instanceof _core_utils.MissingDataException) {
                        throw e2;
                      }
                      (0, _util2.info)("Skipping invalid metadata.");
                    }
                  }
                }
                return (0, _util2.shadow)(this, "metadata", metadata);
              }
              get toplevelPagesDict() {
                const pagesObj = this.catDict.get("Pages");
                if (!(0, _primitives.isDict)(pagesObj)) {
                  throw new _util2.FormatError("Invalid top-level pages dictionary.");
                }
                return (0, _util2.shadow)(this, "toplevelPagesDict", pagesObj);
              }
              get documentOutline() {
                let obj = null;
                try {
                  obj = this._readDocumentOutline();
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.warn)("Unable to read document outline.");
                }
                return (0, _util2.shadow)(this, "documentOutline", obj);
              }
              _readDocumentOutline() {
                let obj = this.catDict.get("Outlines");
                if (!(0, _primitives.isDict)(obj)) {
                  return null;
                }
                obj = obj.getRaw("First");
                if (!(0, _primitives.isRef)(obj)) {
                  return null;
                }
                const root = {
                  items: []
                };
                const queue = [{
                  obj,
                  parent: root
                }];
                const processed = new _primitives.RefSet();
                processed.put(obj);
                const xref = this.xref, blackColor = new Uint8ClampedArray(3);
                while (queue.length > 0) {
                  const i2 = queue.shift();
                  const outlineDict = xref.fetchIfRef(i2.obj);
                  if (outlineDict === null) {
                    continue;
                  }
                  if (!outlineDict.has("Title")) {
                    throw new _util2.FormatError("Invalid outline item encountered.");
                  }
                  const data = {
                    url: null,
                    dest: null
                  };
                  Catalog.parseDestDictionary({
                    destDict: outlineDict,
                    resultObj: data,
                    docBaseUrl: this.pdfManager.docBaseUrl
                  });
                  const title = outlineDict.get("Title");
                  const flags = outlineDict.get("F") || 0;
                  const color = outlineDict.getArray("C");
                  const count = outlineDict.get("Count");
                  let rgbColor = blackColor;
                  if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                    rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                  }
                  const outlineItem = {
                    dest: data.dest,
                    url: data.url,
                    unsafeUrl: data.unsafeUrl,
                    newWindow: data.newWindow,
                    title: (0, _util2.stringToPDFString)(title),
                    color: rgbColor,
                    count: Number.isInteger(count) ? count : void 0,
                    bold: !!(flags & 2),
                    italic: !!(flags & 1),
                    items: []
                  };
                  i2.parent.items.push(outlineItem);
                  obj = outlineDict.getRaw("First");
                  if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                    queue.push({
                      obj,
                      parent: outlineItem
                    });
                    processed.put(obj);
                  }
                  obj = outlineDict.getRaw("Next");
                  if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                    queue.push({
                      obj,
                      parent: i2.parent
                    });
                    processed.put(obj);
                  }
                }
                return root.items.length > 0 ? root.items : null;
              }
              get permissions() {
                let permissions = null;
                try {
                  permissions = this._readPermissions();
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.warn)("Unable to read permissions.");
                }
                return (0, _util2.shadow)(this, "permissions", permissions);
              }
              _readPermissions() {
                const encrypt = this.xref.trailer.get("Encrypt");
                if (!(0, _primitives.isDict)(encrypt)) {
                  return null;
                }
                let flags = encrypt.get("P");
                if (!(0, _util2.isNum)(flags)) {
                  return null;
                }
                flags += 2 ** 32;
                const permissions = [];
                for (const key in _util2.PermissionFlag) {
                  const value = _util2.PermissionFlag[key];
                  if (flags & value) {
                    permissions.push(value);
                  }
                }
                return permissions;
              }
              get numPages() {
                const obj = this.toplevelPagesDict.get("Count");
                if (!Number.isInteger(obj)) {
                  throw new _util2.FormatError("Page count in top-level pages dictionary is not an integer.");
                }
                return (0, _util2.shadow)(this, "numPages", obj);
              }
              get destinations() {
                const obj = this._readDests(), dests = /* @__PURE__ */ Object.create(null);
                if (obj instanceof NameTree) {
                  const names = obj.getAll();
                  for (const name in names) {
                    dests[name] = fetchDestination(names[name]);
                  }
                } else if (obj instanceof _primitives.Dict) {
                  obj.forEach(function(key, value) {
                    if (value) {
                      dests[key] = fetchDestination(value);
                    }
                  });
                }
                return (0, _util2.shadow)(this, "destinations", dests);
              }
              getDestination(destinationId) {
                const obj = this._readDests();
                if (obj instanceof NameTree || obj instanceof _primitives.Dict) {
                  return fetchDestination(obj.get(destinationId) || null);
                }
                return null;
              }
              _readDests() {
                const obj = this.catDict.get("Names");
                if (obj && obj.has("Dests")) {
                  return new NameTree(obj.getRaw("Dests"), this.xref);
                } else if (this.catDict.has("Dests")) {
                  return this.catDict.get("Dests");
                }
                return void 0;
              }
              get pageLabels() {
                let obj = null;
                try {
                  obj = this._readPageLabels();
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.warn)("Unable to read page labels.");
                }
                return (0, _util2.shadow)(this, "pageLabels", obj);
              }
              _readPageLabels() {
                const obj = this.catDict.getRaw("PageLabels");
                if (!obj) {
                  return null;
                }
                const pageLabels = new Array(this.numPages);
                let style = null, prefix = "";
                const numberTree = new NumberTree(obj, this.xref);
                const nums = numberTree.getAll();
                let currentLabel = "", currentIndex = 1;
                for (let i2 = 0, ii = this.numPages; i2 < ii; i2++) {
                  if (i2 in nums) {
                    const labelDict = nums[i2];
                    if (!(0, _primitives.isDict)(labelDict)) {
                      throw new _util2.FormatError("PageLabel is not a dictionary.");
                    }
                    if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
                      throw new _util2.FormatError("Invalid type in PageLabel dictionary.");
                    }
                    if (labelDict.has("S")) {
                      const s2 = labelDict.get("S");
                      if (!(0, _primitives.isName)(s2)) {
                        throw new _util2.FormatError("Invalid style in PageLabel dictionary.");
                      }
                      style = s2.name;
                    } else {
                      style = null;
                    }
                    if (labelDict.has("P")) {
                      const p = labelDict.get("P");
                      if (!(0, _util2.isString)(p)) {
                        throw new _util2.FormatError("Invalid prefix in PageLabel dictionary.");
                      }
                      prefix = (0, _util2.stringToPDFString)(p);
                    } else {
                      prefix = "";
                    }
                    if (labelDict.has("St")) {
                      const st = labelDict.get("St");
                      if (!(Number.isInteger(st) && st >= 1)) {
                        throw new _util2.FormatError("Invalid start in PageLabel dictionary.");
                      }
                      currentIndex = st;
                    } else {
                      currentIndex = 1;
                    }
                  }
                  switch (style) {
                    case "D":
                      currentLabel = currentIndex;
                      break;
                    case "R":
                    case "r":
                      currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
                      break;
                    case "A":
                    case "a":
                      const LIMIT = 26;
                      const A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                      const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                      const letterIndex = currentIndex - 1;
                      const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                      const charBuf = [];
                      for (let j2 = 0, jj = letterIndex / LIMIT | 0; j2 <= jj; j2++) {
                        charBuf.push(character);
                      }
                      currentLabel = charBuf.join("");
                      break;
                    default:
                      if (style) {
                        throw new _util2.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
                      }
                      currentLabel = "";
                  }
                  pageLabels[i2] = prefix + currentLabel;
                  currentIndex++;
                }
                return pageLabels;
              }
              get pageLayout() {
                const obj = this.catDict.get("PageLayout");
                let pageLayout = "";
                if ((0, _primitives.isName)(obj)) {
                  switch (obj.name) {
                    case "SinglePage":
                    case "OneColumn":
                    case "TwoColumnLeft":
                    case "TwoColumnRight":
                    case "TwoPageLeft":
                    case "TwoPageRight":
                      pageLayout = obj.name;
                  }
                }
                return (0, _util2.shadow)(this, "pageLayout", pageLayout);
              }
              get pageMode() {
                const obj = this.catDict.get("PageMode");
                let pageMode = "UseNone";
                if ((0, _primitives.isName)(obj)) {
                  switch (obj.name) {
                    case "UseNone":
                    case "UseOutlines":
                    case "UseThumbs":
                    case "FullScreen":
                    case "UseOC":
                    case "UseAttachments":
                      pageMode = obj.name;
                  }
                }
                return (0, _util2.shadow)(this, "pageMode", pageMode);
              }
              get viewerPreferences() {
                const ViewerPreferencesValidators = {
                  HideToolbar: _util2.isBool,
                  HideMenubar: _util2.isBool,
                  HideWindowUI: _util2.isBool,
                  FitWindow: _util2.isBool,
                  CenterWindow: _util2.isBool,
                  DisplayDocTitle: _util2.isBool,
                  NonFullScreenPageMode: _primitives.isName,
                  Direction: _primitives.isName,
                  ViewArea: _primitives.isName,
                  ViewClip: _primitives.isName,
                  PrintArea: _primitives.isName,
                  PrintClip: _primitives.isName,
                  PrintScaling: _primitives.isName,
                  Duplex: _primitives.isName,
                  PickTrayByPDFSize: _util2.isBool,
                  PrintPageRange: Array.isArray,
                  NumCopies: Number.isInteger
                };
                const obj = this.catDict.get("ViewerPreferences");
                const prefs = /* @__PURE__ */ Object.create(null);
                if ((0, _primitives.isDict)(obj)) {
                  for (const key in ViewerPreferencesValidators) {
                    if (!obj.has(key)) {
                      continue;
                    }
                    const value = obj.get(key);
                    if (!ViewerPreferencesValidators[key](value)) {
                      (0, _util2.info)(`Bad value in ViewerPreferences for "${key}".`);
                      continue;
                    }
                    let prefValue;
                    switch (key) {
                      case "NonFullScreenPageMode":
                        switch (value.name) {
                          case "UseNone":
                          case "UseOutlines":
                          case "UseThumbs":
                          case "UseOC":
                            prefValue = value.name;
                            break;
                          default:
                            prefValue = "UseNone";
                        }
                        break;
                      case "Direction":
                        switch (value.name) {
                          case "L2R":
                          case "R2L":
                            prefValue = value.name;
                            break;
                          default:
                            prefValue = "L2R";
                        }
                        break;
                      case "ViewArea":
                      case "ViewClip":
                      case "PrintArea":
                      case "PrintClip":
                        switch (value.name) {
                          case "MediaBox":
                          case "CropBox":
                          case "BleedBox":
                          case "TrimBox":
                          case "ArtBox":
                            prefValue = value.name;
                            break;
                          default:
                            prefValue = "CropBox";
                        }
                        break;
                      case "PrintScaling":
                        switch (value.name) {
                          case "None":
                          case "AppDefault":
                            prefValue = value.name;
                            break;
                          default:
                            prefValue = "AppDefault";
                        }
                        break;
                      case "Duplex":
                        switch (value.name) {
                          case "Simplex":
                          case "DuplexFlipShortEdge":
                          case "DuplexFlipLongEdge":
                            prefValue = value.name;
                            break;
                          default:
                            prefValue = "None";
                        }
                        break;
                      case "PrintPageRange":
                        const length = value.length;
                        if (length % 2 !== 0) {
                          break;
                        }
                        const isValid = value.every((page, i2, arr) => {
                          return Number.isInteger(page) && page > 0 && (i2 === 0 || page >= arr[i2 - 1]) && page <= this.numPages;
                        });
                        if (isValid) {
                          prefValue = value;
                        }
                        break;
                      case "NumCopies":
                        if (value > 0) {
                          prefValue = value;
                        }
                        break;
                      default:
                        (0, _util2.assert)(typeof value === "boolean");
                        prefValue = value;
                    }
                    if (prefValue !== void 0) {
                      prefs[key] = prefValue;
                    } else {
                      (0, _util2.info)(`Bad value in ViewerPreferences for "${key}".`);
                    }
                  }
                }
                return (0, _util2.shadow)(this, "viewerPreferences", prefs);
              }
              get openAction() {
                const obj = this.catDict.get("OpenAction");
                let openAction = null;
                if ((0, _primitives.isDict)(obj)) {
                  const destDict = new _primitives.Dict(this.xref);
                  destDict.set("A", obj);
                  const resultObj = {
                    url: null,
                    dest: null,
                    action: null
                  };
                  Catalog.parseDestDictionary({
                    destDict,
                    resultObj
                  });
                  if (Array.isArray(resultObj.dest)) {
                    if (!openAction) {
                      openAction = /* @__PURE__ */ Object.create(null);
                    }
                    openAction.dest = resultObj.dest;
                  } else if (resultObj.action) {
                    if (!openAction) {
                      openAction = /* @__PURE__ */ Object.create(null);
                    }
                    openAction.action = resultObj.action;
                  }
                } else if (Array.isArray(obj)) {
                  if (!openAction) {
                    openAction = /* @__PURE__ */ Object.create(null);
                  }
                  openAction.dest = obj;
                }
                return (0, _util2.shadow)(this, "openAction", openAction);
              }
              get attachments() {
                const obj = this.catDict.get("Names");
                let attachments = null;
                if (obj && obj.has("EmbeddedFiles")) {
                  const nameTree = new NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
                  const names = nameTree.getAll();
                  for (const name in names) {
                    const fs = new FileSpec(names[name], this.xref);
                    if (!attachments) {
                      attachments = /* @__PURE__ */ Object.create(null);
                    }
                    attachments[(0, _util2.stringToPDFString)(name)] = fs.serializable;
                  }
                }
                return (0, _util2.shadow)(this, "attachments", attachments);
              }
              get javaScript() {
                const obj = this.catDict.get("Names");
                let javaScript = null;
                function appendIfJavaScriptDict(jsDict) {
                  const type = jsDict.get("S");
                  if (!(0, _primitives.isName)(type, "JavaScript")) {
                    return;
                  }
                  let js = jsDict.get("JS");
                  if ((0, _primitives.isStream)(js)) {
                    js = (0, _util2.bytesToString)(js.getBytes());
                  } else if (!(0, _util2.isString)(js)) {
                    return;
                  }
                  if (!javaScript) {
                    javaScript = [];
                  }
                  javaScript.push((0, _util2.stringToPDFString)(js));
                }
                if (obj && obj.has("JavaScript")) {
                  const nameTree = new NameTree(obj.getRaw("JavaScript"), this.xref);
                  const names = nameTree.getAll();
                  for (const name in names) {
                    const jsDict = names[name];
                    if ((0, _primitives.isDict)(jsDict)) {
                      appendIfJavaScriptDict(jsDict);
                    }
                  }
                }
                const openAction = this.catDict.get("OpenAction");
                if ((0, _primitives.isDict)(openAction) && (0, _primitives.isName)(openAction.get("S"), "JavaScript")) {
                  appendIfJavaScriptDict(openAction);
                }
                return (0, _util2.shadow)(this, "javaScript", javaScript);
              }
              fontFallback(id, handler) {
                const promises = [];
                this.fontCache.forEach(function(promise) {
                  promises.push(promise);
                });
                return Promise.all(promises).then((translatedFonts) => {
                  for (const translatedFont of translatedFonts) {
                    if (translatedFont.loadedName === id) {
                      translatedFont.fallback(handler);
                      return;
                    }
                  }
                });
              }
              cleanup() {
                (0, _primitives.clearPrimitiveCaches)();
                this.pageKidsCountCache.clear();
                const promises = [];
                this.fontCache.forEach(function(promise) {
                  promises.push(promise);
                });
                return Promise.all(promises).then((translatedFonts) => {
                  for (const {
                    dict
                  } of translatedFonts) {
                    delete dict.translated;
                  }
                  this.fontCache.clear();
                  this.builtInCMapCache.clear();
                });
              }
              getPageDict(pageIndex) {
                const capability = (0, _util2.createPromiseCapability)();
                const nodesToVisit = [this.catDict.getRaw("Pages")];
                const visitedNodes = new _primitives.RefSet();
                const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache;
                let count, currentPageIndex = 0;
                function next() {
                  while (nodesToVisit.length) {
                    const currentNode = nodesToVisit.pop();
                    if ((0, _primitives.isRef)(currentNode)) {
                      count = pageKidsCountCache.get(currentNode);
                      if (count > 0 && currentPageIndex + count < pageIndex) {
                        currentPageIndex += count;
                        continue;
                      }
                      if (visitedNodes.has(currentNode)) {
                        capability.reject(new _util2.FormatError("Pages tree contains circular reference."));
                        return;
                      }
                      visitedNodes.put(currentNode);
                      xref.fetchAsync(currentNode).then(function(obj) {
                        if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
                          if (pageIndex === currentPageIndex) {
                            if (currentNode && !pageKidsCountCache.has(currentNode)) {
                              pageKidsCountCache.put(currentNode, 1);
                            }
                            capability.resolve([obj, currentNode]);
                          } else {
                            currentPageIndex++;
                            next();
                          }
                          return;
                        }
                        nodesToVisit.push(obj);
                        next();
                      }, capability.reject);
                      return;
                    }
                    if (!(0, _primitives.isDict)(currentNode)) {
                      capability.reject(new _util2.FormatError("Page dictionary kid reference points to wrong type of object."));
                      return;
                    }
                    count = currentNode.get("Count");
                    if (Number.isInteger(count) && count >= 0) {
                      const objId = currentNode.objId;
                      if (objId && !pageKidsCountCache.has(objId)) {
                        pageKidsCountCache.put(objId, count);
                      }
                      if (currentPageIndex + count <= pageIndex) {
                        currentPageIndex += count;
                        continue;
                      }
                    }
                    const kids = currentNode.get("Kids");
                    if (!Array.isArray(kids)) {
                      if ((0, _primitives.isName)(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
                        if (currentPageIndex === pageIndex) {
                          capability.resolve([currentNode, null]);
                          return;
                        }
                        currentPageIndex++;
                        continue;
                      }
                      capability.reject(new _util2.FormatError("Page dictionary kids object is not an array."));
                      return;
                    }
                    for (let last = kids.length - 1; last >= 0; last--) {
                      nodesToVisit.push(kids[last]);
                    }
                  }
                  capability.reject(new Error(`Page index ${pageIndex} not found.`));
                }
                next();
                return capability.promise;
              }
              getPageIndex(pageRef) {
                const xref = this.xref;
                function pagesBeforeRef(kidRef) {
                  let total2 = 0, parentRef;
                  return xref.fetchAsync(kidRef).then(function(node) {
                    if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
                      throw new _util2.FormatError("The reference does not point to a /Page dictionary.");
                    }
                    if (!node) {
                      return null;
                    }
                    if (!(0, _primitives.isDict)(node)) {
                      throw new _util2.FormatError("Node must be a dictionary.");
                    }
                    parentRef = node.getRaw("Parent");
                    return node.getAsync("Parent");
                  }).then(function(parent) {
                    if (!parent) {
                      return null;
                    }
                    if (!(0, _primitives.isDict)(parent)) {
                      throw new _util2.FormatError("Parent must be a dictionary.");
                    }
                    return parent.getAsync("Kids");
                  }).then(function(kids) {
                    if (!kids) {
                      return null;
                    }
                    const kidPromises = [];
                    let found = false;
                    for (let i2 = 0, ii = kids.length; i2 < ii; i2++) {
                      const kid = kids[i2];
                      if (!(0, _primitives.isRef)(kid)) {
                        throw new _util2.FormatError("Kid must be a reference.");
                      }
                      if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
                        found = true;
                        break;
                      }
                      kidPromises.push(xref.fetchAsync(kid).then(function(kid2) {
                        if (!(0, _primitives.isDict)(kid2)) {
                          throw new _util2.FormatError("Kid node must be a dictionary.");
                        }
                        if (kid2.has("Count")) {
                          total2 += kid2.get("Count");
                        } else {
                          total2++;
                        }
                      }));
                    }
                    if (!found) {
                      throw new _util2.FormatError("Kid reference not found in parent's kids.");
                    }
                    return Promise.all(kidPromises).then(function() {
                      return [total2, parentRef];
                    });
                  });
                }
                let total = 0;
                function next(ref) {
                  return pagesBeforeRef(ref).then(function(args) {
                    if (!args) {
                      return total;
                    }
                    const [count, parentRef] = args;
                    total += count;
                    return next(parentRef);
                  });
                }
                return next(pageRef);
              }
              static parseDestDictionary(params) {
                function addDefaultProtocolToUrl(url2) {
                  return url2.startsWith("www.") ? `http://${url2}` : url2;
                }
                function tryConvertUrlEncoding(url2) {
                  try {
                    return (0, _util2.stringToUTF8String)(url2);
                  } catch (e2) {
                    return url2;
                  }
                }
                const destDict = params.destDict;
                if (!(0, _primitives.isDict)(destDict)) {
                  (0, _util2.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                  return;
                }
                const resultObj = params.resultObj;
                if (typeof resultObj !== "object") {
                  (0, _util2.warn)("parseDestDictionary: `resultObj` must be an object.");
                  return;
                }
                const docBaseUrl = params.docBaseUrl || null;
                let action = destDict.get("A"), url, dest;
                if (!(0, _primitives.isDict)(action) && destDict.has("Dest")) {
                  action = destDict.get("Dest");
                }
                if ((0, _primitives.isDict)(action)) {
                  const actionType = action.get("S");
                  if (!(0, _primitives.isName)(actionType)) {
                    (0, _util2.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                    return;
                  }
                  const actionName = actionType.name;
                  switch (actionName) {
                    case "URI":
                      url = action.get("URI");
                      if ((0, _primitives.isName)(url)) {
                        url = "/" + url.name;
                      } else if ((0, _util2.isString)(url)) {
                        url = addDefaultProtocolToUrl(url);
                      }
                      break;
                    case "GoTo":
                      dest = action.get("D");
                      break;
                    case "Launch":
                    case "GoToR":
                      const urlDict = action.get("F");
                      if ((0, _primitives.isDict)(urlDict)) {
                        url = urlDict.get("F") || null;
                      } else if ((0, _util2.isString)(urlDict)) {
                        url = urlDict;
                      }
                      let remoteDest = action.get("D");
                      if (remoteDest) {
                        if ((0, _primitives.isName)(remoteDest)) {
                          remoteDest = remoteDest.name;
                        }
                        if ((0, _util2.isString)(url)) {
                          const baseUrl = url.split("#")[0];
                          if ((0, _util2.isString)(remoteDest)) {
                            url = baseUrl + "#" + remoteDest;
                          } else if (Array.isArray(remoteDest)) {
                            url = baseUrl + "#" + JSON.stringify(remoteDest);
                          }
                        }
                      }
                      const newWindow = action.get("NewWindow");
                      if ((0, _util2.isBool)(newWindow)) {
                        resultObj.newWindow = newWindow;
                      }
                      break;
                    case "Named":
                      const namedAction = action.get("N");
                      if ((0, _primitives.isName)(namedAction)) {
                        resultObj.action = namedAction.name;
                      }
                      break;
                    case "JavaScript":
                      const jsAction = action.get("JS");
                      let js;
                      if ((0, _primitives.isStream)(jsAction)) {
                        js = (0, _util2.bytesToString)(jsAction.getBytes());
                      } else if ((0, _util2.isString)(jsAction)) {
                        js = jsAction;
                      }
                      if (js) {
                        const URL_OPEN_METHODS = ["app.launchURL", "window.open"];
                        const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                        const jsUrl = regex.exec((0, _util2.stringToPDFString)(js));
                        if (jsUrl && jsUrl[2]) {
                          url = jsUrl[2];
                          if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                            resultObj.newWindow = true;
                          }
                          break;
                        }
                      }
                    default:
                      (0, _util2.warn)(`parseDestDictionary: unsupported action type "${actionName}".`);
                      break;
                  }
                } else if (destDict.has("Dest")) {
                  dest = destDict.get("Dest");
                }
                if ((0, _util2.isString)(url)) {
                  url = tryConvertUrlEncoding(url);
                  const absoluteUrl = (0, _util2.createValidAbsoluteUrl)(url, docBaseUrl);
                  if (absoluteUrl) {
                    resultObj.url = absoluteUrl.href;
                  }
                  resultObj.unsafeUrl = url;
                }
                if (dest) {
                  if ((0, _primitives.isName)(dest)) {
                    dest = dest.name;
                  }
                  if ((0, _util2.isString)(dest) || Array.isArray(dest)) {
                    resultObj.dest = dest;
                  }
                }
              }
            }
            exports3.Catalog = Catalog;
            var XRef = function XRefClosure() {
              function XRef2(stream, pdfManager) {
                this.stream = stream;
                this.pdfManager = pdfManager;
                this.entries = [];
                this.xrefstms = /* @__PURE__ */ Object.create(null);
                this._cacheMap = /* @__PURE__ */ new Map();
                this.stats = {
                  streamTypes: /* @__PURE__ */ Object.create(null),
                  fontTypes: /* @__PURE__ */ Object.create(null)
                };
              }
              XRef2.prototype = {
                setStartXRef: function XRef_setStartXRef(startXRef) {
                  this.startXRefQueue = [startXRef];
                },
                parse: function XRef_parse(recoveryMode) {
                  var trailerDict;
                  if (!recoveryMode) {
                    trailerDict = this.readXRef();
                  } else {
                    (0, _util2.warn)("Indexing all PDF objects");
                    trailerDict = this.indexObjects();
                  }
                  trailerDict.assignXref(this);
                  this.trailer = trailerDict;
                  let encrypt;
                  try {
                    encrypt = trailerDict.get("Encrypt");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util2.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
                  }
                  if ((0, _primitives.isDict)(encrypt)) {
                    var ids = trailerDict.get("ID");
                    var fileId = ids && ids.length ? ids[0] : "";
                    encrypt.suppressEncryption = true;
                    this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                  }
                  let root;
                  try {
                    root = trailerDict.get("Root");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util2.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
                  }
                  if ((0, _primitives.isDict)(root) && root.has("Pages")) {
                    this.root = root;
                  } else {
                    if (!recoveryMode) {
                      throw new _core_utils.XRefParseException();
                    }
                    throw new _util2.FormatError("Invalid root reference");
                  }
                },
                processXRefTable: function XRef_processXRefTable(parser) {
                  if (!("tableState" in this)) {
                    this.tableState = {
                      entryNum: 0,
                      streamPos: parser.lexer.stream.pos,
                      parserBuf1: parser.buf1,
                      parserBuf2: parser.buf2
                    };
                  }
                  var obj = this.readXRefTable(parser);
                  if (!(0, _primitives.isCmd)(obj, "trailer")) {
                    throw new _util2.FormatError("Invalid XRef table: could not find trailer dictionary");
                  }
                  var dict = parser.getObj();
                  if (!(0, _primitives.isDict)(dict) && dict.dict) {
                    dict = dict.dict;
                  }
                  if (!(0, _primitives.isDict)(dict)) {
                    throw new _util2.FormatError("Invalid XRef table: could not parse trailer dictionary");
                  }
                  delete this.tableState;
                  return dict;
                },
                readXRefTable: function XRef_readXRefTable(parser) {
                  var stream = parser.lexer.stream;
                  var tableState = this.tableState;
                  stream.pos = tableState.streamPos;
                  parser.buf1 = tableState.parserBuf1;
                  parser.buf2 = tableState.parserBuf2;
                  var obj;
                  while (true) {
                    if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                      if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                        break;
                      }
                      tableState.firstEntryNum = obj;
                      tableState.entryCount = parser.getObj();
                    }
                    var first = tableState.firstEntryNum;
                    var count = tableState.entryCount;
                    if (!Number.isInteger(first) || !Number.isInteger(count)) {
                      throw new _util2.FormatError("Invalid XRef table: wrong types in subsection header");
                    }
                    for (var i2 = tableState.entryNum; i2 < count; i2++) {
                      tableState.streamPos = stream.pos;
                      tableState.entryNum = i2;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      var entry = {};
                      entry.offset = parser.getObj();
                      entry.gen = parser.getObj();
                      var type = parser.getObj();
                      if (type instanceof _primitives.Cmd) {
                        switch (type.cmd) {
                          case "f":
                            entry.free = true;
                            break;
                          case "n":
                            entry.uncompressed = true;
                            break;
                        }
                      }
                      if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                        throw new _util2.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
                      }
                      if (i2 === 0 && entry.free && first === 1) {
                        first = 0;
                      }
                      if (!this.entries[i2 + first]) {
                        this.entries[i2 + first] = entry;
                      }
                    }
                    tableState.entryNum = 0;
                    tableState.streamPos = stream.pos;
                    tableState.parserBuf1 = parser.buf1;
                    tableState.parserBuf2 = parser.buf2;
                    delete tableState.firstEntryNum;
                    delete tableState.entryCount;
                  }
                  if (this.entries[0] && !this.entries[0].free) {
                    throw new _util2.FormatError("Invalid XRef table: unexpected first object");
                  }
                  return obj;
                },
                processXRefStream: function XRef_processXRefStream(stream) {
                  if (!("streamState" in this)) {
                    var streamParameters = stream.dict;
                    var byteWidths = streamParameters.get("W");
                    var range = streamParameters.get("Index");
                    if (!range) {
                      range = [0, streamParameters.get("Size")];
                    }
                    this.streamState = {
                      entryRanges: range,
                      byteWidths,
                      entryNum: 0,
                      streamPos: stream.pos
                    };
                  }
                  this.readXRefStream(stream);
                  delete this.streamState;
                  return stream.dict;
                },
                readXRefStream: function XRef_readXRefStream(stream) {
                  var i2, j2;
                  var streamState = this.streamState;
                  stream.pos = streamState.streamPos;
                  var byteWidths = streamState.byteWidths;
                  var typeFieldWidth = byteWidths[0];
                  var offsetFieldWidth = byteWidths[1];
                  var generationFieldWidth = byteWidths[2];
                  var entryRanges = streamState.entryRanges;
                  while (entryRanges.length > 0) {
                    var first = entryRanges[0];
                    var n2 = entryRanges[1];
                    if (!Number.isInteger(first) || !Number.isInteger(n2)) {
                      throw new _util2.FormatError(`Invalid XRef range fields: ${first}, ${n2}`);
                    }
                    if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                      throw new _util2.FormatError(`Invalid XRef entry fields length: ${first}, ${n2}`);
                    }
                    for (i2 = streamState.entryNum; i2 < n2; ++i2) {
                      streamState.entryNum = i2;
                      streamState.streamPos = stream.pos;
                      var type = 0, offset = 0, generation = 0;
                      for (j2 = 0; j2 < typeFieldWidth; ++j2) {
                        type = type << 8 | stream.getByte();
                      }
                      if (typeFieldWidth === 0) {
                        type = 1;
                      }
                      for (j2 = 0; j2 < offsetFieldWidth; ++j2) {
                        offset = offset << 8 | stream.getByte();
                      }
                      for (j2 = 0; j2 < generationFieldWidth; ++j2) {
                        generation = generation << 8 | stream.getByte();
                      }
                      var entry = {};
                      entry.offset = offset;
                      entry.gen = generation;
                      switch (type) {
                        case 0:
                          entry.free = true;
                          break;
                        case 1:
                          entry.uncompressed = true;
                          break;
                        case 2:
                          break;
                        default:
                          throw new _util2.FormatError(`Invalid XRef entry type: ${type}`);
                      }
                      if (!this.entries[first + i2]) {
                        this.entries[first + i2] = entry;
                      }
                    }
                    streamState.entryNum = 0;
                    streamState.streamPos = stream.pos;
                    entryRanges.splice(0, 2);
                  }
                },
                indexObjects: function XRef_indexObjects() {
                  var TAB = 9, LF = 10, CR = 13, SPACE = 32;
                  var PERCENT = 37, LT = 60;
                  function readToken(data, offset) {
                    var token2 = "", ch2 = data[offset];
                    while (ch2 !== LF && ch2 !== CR && ch2 !== LT) {
                      if (++offset >= data.length) {
                        break;
                      }
                      token2 += String.fromCharCode(ch2);
                      ch2 = data[offset];
                    }
                    return token2;
                  }
                  function skipUntil(data, offset, what) {
                    var length2 = what.length, dataLength = data.length;
                    var skipped = 0;
                    while (offset < dataLength) {
                      var i3 = 0;
                      while (i3 < length2 && data[offset + i3] === what[i3]) {
                        ++i3;
                      }
                      if (i3 >= length2) {
                        break;
                      }
                      offset++;
                      skipped++;
                    }
                    return skipped;
                  }
                  var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                  const endobjRegExp = /\bendobj[\b\s]$/;
                  const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
                  const CHECK_CONTENT_LENGTH = 25;
                  var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                  var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                  const objBytes = new Uint8Array([111, 98, 106]);
                  var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                  this.entries.length = 0;
                  var stream = this.stream;
                  stream.pos = 0;
                  var buffer = stream.getBytes();
                  var position = stream.start, length = buffer.length;
                  var trailers = [], xrefStms = [];
                  while (position < length) {
                    var ch = buffer[position];
                    if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                      ++position;
                      continue;
                    }
                    if (ch === PERCENT) {
                      do {
                        ++position;
                        if (position >= length) {
                          break;
                        }
                        ch = buffer[position];
                      } while (ch !== LF && ch !== CR);
                      continue;
                    }
                    var token = readToken(buffer, position);
                    var m;
                    if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
                      position += skipUntil(buffer, position, trailerBytes);
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else if (m = objRegExp.exec(token)) {
                      const num = m[1] | 0, gen = m[2] | 0;
                      if (!this.entries[num] || this.entries[num].gen === gen) {
                        this.entries[num] = {
                          offset: position - stream.start,
                          gen,
                          uncompressed: true
                        };
                      }
                      let contentLength, startPos = position + token.length;
                      while (startPos < buffer.length) {
                        const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
                        contentLength = endPos - position;
                        const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
                        const tokenStr = (0, _util2.bytesToString)(buffer.subarray(checkPos, endPos));
                        if (endobjRegExp.test(tokenStr)) {
                          break;
                        } else {
                          const objToken = nestedObjRegExp.exec(tokenStr);
                          if (objToken && objToken[1]) {
                            (0, _util2.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
                            contentLength -= objToken[1].length;
                            break;
                          }
                        }
                        startPos = endPos;
                      }
                      const content = buffer.subarray(position, position + contentLength);
                      var xrefTagOffset = skipUntil(content, 0, xrefBytes);
                      if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        xrefStms.push(position - stream.start);
                        this.xrefstms[position - stream.start] = 1;
                      }
                      position += contentLength;
                    } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else {
                      position += token.length + 1;
                    }
                  }
                  var i2, ii;
                  for (i2 = 0, ii = xrefStms.length; i2 < ii; ++i2) {
                    this.startXRefQueue.push(xrefStms[i2]);
                    this.readXRef(true);
                  }
                  let trailerDict;
                  for (i2 = 0, ii = trailers.length; i2 < ii; ++i2) {
                    stream.pos = trailers[i2];
                    const parser = new _parser.Parser({
                      lexer: new _parser.Lexer(stream),
                      xref: this,
                      allowStreams: true,
                      recoveryMode: true
                    });
                    var obj = parser.getObj();
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      continue;
                    }
                    const dict = parser.getObj();
                    if (!(0, _primitives.isDict)(dict)) {
                      continue;
                    }
                    let rootDict;
                    try {
                      rootDict = dict.get("Root");
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      continue;
                    }
                    if (!(0, _primitives.isDict)(rootDict) || !rootDict.has("Pages")) {
                      continue;
                    }
                    if (dict.has("ID")) {
                      return dict;
                    }
                    trailerDict = dict;
                  }
                  if (trailerDict) {
                    return trailerDict;
                  }
                  throw new _util2.InvalidPDFException("Invalid PDF structure.");
                },
                readXRef: function XRef_readXRef(recoveryMode) {
                  var stream = this.stream;
                  const startXRefParsedCache = /* @__PURE__ */ Object.create(null);
                  try {
                    while (this.startXRefQueue.length) {
                      var startXRef = this.startXRefQueue[0];
                      if (startXRefParsedCache[startXRef]) {
                        (0, _util2.warn)("readXRef - skipping XRef table since it was already parsed.");
                        this.startXRefQueue.shift();
                        continue;
                      }
                      startXRefParsedCache[startXRef] = true;
                      stream.pos = startXRef + stream.start;
                      const parser = new _parser.Parser({
                        lexer: new _parser.Lexer(stream),
                        xref: this,
                        allowStreams: true
                      });
                      var obj = parser.getObj();
                      var dict;
                      if ((0, _primitives.isCmd)(obj, "xref")) {
                        dict = this.processXRefTable(parser);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        obj = dict.get("XRefStm");
                        if (Number.isInteger(obj)) {
                          var pos = obj;
                          if (!(pos in this.xrefstms)) {
                            this.xrefstms[pos] = 1;
                            this.startXRefQueue.push(pos);
                          }
                        }
                      } else if (Number.isInteger(obj)) {
                        if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
                          throw new _util2.FormatError("Invalid XRef stream");
                        }
                        dict = this.processXRefStream(obj);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        if (!dict) {
                          throw new _util2.FormatError("Failed to read XRef stream");
                        }
                      } else {
                        throw new _util2.FormatError("Invalid XRef stream header");
                      }
                      obj = dict.get("Prev");
                      if (Number.isInteger(obj)) {
                        this.startXRefQueue.push(obj);
                      } else if ((0, _primitives.isRef)(obj)) {
                        this.startXRefQueue.push(obj.num);
                      }
                      this.startXRefQueue.shift();
                    }
                    return this.topDict;
                  } catch (e2) {
                    if (e2 instanceof _core_utils.MissingDataException) {
                      throw e2;
                    }
                    (0, _util2.info)("(while reading XRef): " + e2);
                  }
                  if (recoveryMode) {
                    return void 0;
                  }
                  throw new _core_utils.XRefParseException();
                },
                getEntry: function XRef_getEntry(i2) {
                  var xrefEntry = this.entries[i2];
                  if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                    return xrefEntry;
                  }
                  return null;
                },
                fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
                  if (obj instanceof _primitives.Ref) {
                    return this.fetch(obj, suppressEncryption);
                  }
                  return obj;
                },
                fetch: function XRef_fetch(ref, suppressEncryption) {
                  if (!(ref instanceof _primitives.Ref)) {
                    throw new Error("ref object is not a reference");
                  }
                  const num = ref.num;
                  const cacheEntry = this._cacheMap.get(num);
                  if (cacheEntry !== void 0) {
                    if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                      cacheEntry.objId = ref.toString();
                    }
                    return cacheEntry;
                  }
                  let xrefEntry = this.getEntry(num);
                  if (xrefEntry === null) {
                    this._cacheMap.set(num, xrefEntry);
                    return xrefEntry;
                  }
                  if (xrefEntry.uncompressed) {
                    xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                  } else {
                    xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
                  }
                  if ((0, _primitives.isDict)(xrefEntry)) {
                    xrefEntry.objId = ref.toString();
                  } else if ((0, _primitives.isStream)(xrefEntry)) {
                    xrefEntry.dict.objId = ref.toString();
                  }
                  return xrefEntry;
                },
                fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
                  var gen = ref.gen;
                  var num = ref.num;
                  if (xrefEntry.gen !== gen) {
                    throw new _core_utils.XRefEntryException(`Inconsistent generation in XRef: ${ref}`);
                  }
                  var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                  const parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  var obj1 = parser.getObj();
                  var obj2 = parser.getObj();
                  var obj3 = parser.getObj();
                  if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  if (obj3.cmd !== "obj") {
                    if (obj3.cmd.startsWith("obj")) {
                      num = parseInt(obj3.cmd.substring(3), 10);
                      if (!Number.isNaN(num)) {
                        return num;
                      }
                    }
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  if (this.encrypt && !suppressEncryption) {
                    xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                  } else {
                    xrefEntry = parser.getObj();
                  }
                  if (!(0, _primitives.isStream)(xrefEntry)) {
                    this._cacheMap.set(num, xrefEntry);
                  }
                  return xrefEntry;
                },
                fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
                  const tableOffset = xrefEntry.offset;
                  const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
                  if (!(0, _primitives.isStream)(stream)) {
                    throw new _util2.FormatError("bad ObjStm stream");
                  }
                  const first = stream.dict.get("First");
                  const n2 = stream.dict.get("N");
                  if (!Number.isInteger(first) || !Number.isInteger(n2)) {
                    throw new _util2.FormatError("invalid first and n parameters for ObjStm stream");
                  }
                  const parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  const nums = new Array(n2);
                  for (let i2 = 0; i2 < n2; ++i2) {
                    const num = parser.getObj();
                    if (!Number.isInteger(num)) {
                      throw new _util2.FormatError(`invalid object number in the ObjStm stream: ${num}`);
                    }
                    const offset = parser.getObj();
                    if (!Number.isInteger(offset)) {
                      throw new _util2.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
                    }
                    nums[i2] = num;
                  }
                  const entries = new Array(n2);
                  for (let i2 = 0; i2 < n2; ++i2) {
                    const obj = parser.getObj();
                    entries[i2] = obj;
                    if (parser.buf1 instanceof _primitives.Cmd && parser.buf1.cmd === "endobj") {
                      parser.shift();
                    }
                    if ((0, _primitives.isStream)(obj)) {
                      continue;
                    }
                    const num = nums[i2], entry = this.entries[num];
                    if (entry && entry.offset === tableOffset && entry.gen === i2) {
                      this._cacheMap.set(num, obj);
                    }
                  }
                  xrefEntry = entries[xrefEntry.gen];
                  if (xrefEntry === void 0) {
                    throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
                  }
                  return xrefEntry;
                },
                async fetchIfRefAsync(obj, suppressEncryption) {
                  if (obj instanceof _primitives.Ref) {
                    return this.fetchAsync(obj, suppressEncryption);
                  }
                  return obj;
                },
                async fetchAsync(ref, suppressEncryption) {
                  try {
                    return this.fetch(ref, suppressEncryption);
                  } catch (ex) {
                    if (!(ex instanceof _core_utils.MissingDataException)) {
                      throw ex;
                    }
                    await this.pdfManager.requestRange(ex.begin, ex.end);
                    return this.fetchAsync(ref, suppressEncryption);
                  }
                },
                getCatalogObj: function XRef_getCatalogObj() {
                  return this.root;
                }
              };
              return XRef2;
            }();
            exports3.XRef = XRef;
            class NameOrNumberTree {
              constructor(root, xref, type) {
                if (this.constructor === NameOrNumberTree) {
                  (0, _util2.unreachable)("Cannot initialize NameOrNumberTree.");
                }
                this.root = root;
                this.xref = xref;
                this._type = type;
              }
              getAll() {
                const dict = /* @__PURE__ */ Object.create(null);
                if (!this.root) {
                  return dict;
                }
                const xref = this.xref;
                const processed = new _primitives.RefSet();
                processed.put(this.root);
                const queue = [this.root];
                while (queue.length > 0) {
                  const obj = xref.fetchIfRef(queue.shift());
                  if (!(0, _primitives.isDict)(obj)) {
                    continue;
                  }
                  if (obj.has("Kids")) {
                    const kids = obj.get("Kids");
                    for (let i2 = 0, ii = kids.length; i2 < ii; i2++) {
                      const kid = kids[i2];
                      if (processed.has(kid)) {
                        throw new _util2.FormatError(`Duplicate entry in "${this._type}" tree.`);
                      }
                      queue.push(kid);
                      processed.put(kid);
                    }
                    continue;
                  }
                  const entries = obj.get(this._type);
                  if (Array.isArray(entries)) {
                    for (let i2 = 0, ii = entries.length; i2 < ii; i2 += 2) {
                      dict[xref.fetchIfRef(entries[i2])] = xref.fetchIfRef(entries[i2 + 1]);
                    }
                  }
                }
                return dict;
              }
              get(key) {
                if (!this.root) {
                  return null;
                }
                const xref = this.xref;
                let kidsOrEntries = xref.fetchIfRef(this.root);
                let loopCount = 0;
                const MAX_LEVELS = 10;
                while (kidsOrEntries.has("Kids")) {
                  if (++loopCount > MAX_LEVELS) {
                    (0, _util2.warn)(`Search depth limit reached for "${this._type}" tree.`);
                    return null;
                  }
                  const kids = kidsOrEntries.get("Kids");
                  if (!Array.isArray(kids)) {
                    return null;
                  }
                  let l2 = 0, r2 = kids.length - 1;
                  while (l2 <= r2) {
                    const m = l2 + r2 >> 1;
                    const kid = xref.fetchIfRef(kids[m]);
                    const limits = kid.get("Limits");
                    if (key < xref.fetchIfRef(limits[0])) {
                      r2 = m - 1;
                    } else if (key > xref.fetchIfRef(limits[1])) {
                      l2 = m + 1;
                    } else {
                      kidsOrEntries = xref.fetchIfRef(kids[m]);
                      break;
                    }
                  }
                  if (l2 > r2) {
                    return null;
                  }
                }
                const entries = kidsOrEntries.get(this._type);
                if (Array.isArray(entries)) {
                  let l2 = 0, r2 = entries.length - 2;
                  while (l2 <= r2) {
                    const tmp = l2 + r2 >> 1, m = tmp + (tmp & 1);
                    const currentKey = xref.fetchIfRef(entries[m]);
                    if (key < currentKey) {
                      r2 = m - 2;
                    } else if (key > currentKey) {
                      l2 = m + 2;
                    } else {
                      return xref.fetchIfRef(entries[m + 1]);
                    }
                  }
                  (0, _util2.info)(`Falling back to an exhaustive search, for key "${key}", in "${this._type}" tree.`);
                  for (let m = 0, mm = entries.length; m < mm; m += 2) {
                    const currentKey = xref.fetchIfRef(entries[m]);
                    if (currentKey === key) {
                      (0, _util2.warn)(`The "${key}" key was found at an incorrect, i.e. out-of-order, position in "${this._type}" tree.`);
                      return xref.fetchIfRef(entries[m + 1]);
                    }
                  }
                }
                return null;
              }
            }
            class NameTree extends NameOrNumberTree {
              constructor(root, xref) {
                super(root, xref, "Names");
              }
            }
            class NumberTree extends NameOrNumberTree {
              constructor(root, xref) {
                super(root, xref, "Nums");
              }
            }
            var FileSpec = function FileSpecClosure() {
              function FileSpec2(root, xref) {
                if (!root || !(0, _primitives.isDict)(root)) {
                  return;
                }
                this.xref = xref;
                this.root = root;
                if (root.has("FS")) {
                  this.fs = root.get("FS");
                }
                this.description = root.has("Desc") ? (0, _util2.stringToPDFString)(root.get("Desc")) : "";
                if (root.has("RF")) {
                  (0, _util2.warn)("Related file specifications are not supported");
                }
                this.contentAvailable = true;
                if (!root.has("EF")) {
                  this.contentAvailable = false;
                  (0, _util2.warn)("Non-embedded file specifications are not supported");
                }
              }
              function pickPlatformItem(dict) {
                if (dict.has("UF")) {
                  return dict.get("UF");
                } else if (dict.has("F")) {
                  return dict.get("F");
                } else if (dict.has("Unix")) {
                  return dict.get("Unix");
                } else if (dict.has("Mac")) {
                  return dict.get("Mac");
                } else if (dict.has("DOS")) {
                  return dict.get("DOS");
                }
                return null;
              }
              FileSpec2.prototype = {
                get filename() {
                  if (!this._filename && this.root) {
                    var filename = pickPlatformItem(this.root) || "unnamed";
                    this._filename = (0, _util2.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
                  }
                  return this._filename;
                },
                get content() {
                  if (!this.contentAvailable) {
                    return null;
                  }
                  if (!this.contentRef && this.root) {
                    this.contentRef = pickPlatformItem(this.root.get("EF"));
                  }
                  var content = null;
                  if (this.contentRef) {
                    var xref = this.xref;
                    var fileObj = xref.fetchIfRef(this.contentRef);
                    if (fileObj && (0, _primitives.isStream)(fileObj)) {
                      content = fileObj.getBytes();
                    } else {
                      (0, _util2.warn)("Embedded file specification points to non-existing/invalid content");
                    }
                  } else {
                    (0, _util2.warn)("Embedded file specification does not have a content");
                  }
                  return content;
                },
                get serializable() {
                  return {
                    filename: this.filename,
                    content: this.content
                  };
                }
              };
              return FileSpec2;
            }();
            exports3.FileSpec = FileSpec;
            const ObjectLoader = function() {
              function mayHaveChildren(value) {
                return value instanceof _primitives.Ref || value instanceof _primitives.Dict || Array.isArray(value) || (0, _primitives.isStream)(value);
              }
              function addChildren(node, nodesToVisit) {
                if (node instanceof _primitives.Dict || (0, _primitives.isStream)(node)) {
                  const dict = node instanceof _primitives.Dict ? node : node.dict;
                  const dictKeys = dict.getKeys();
                  for (let i2 = 0, ii = dictKeys.length; i2 < ii; i2++) {
                    const rawValue = dict.getRaw(dictKeys[i2]);
                    if (mayHaveChildren(rawValue)) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                } else if (Array.isArray(node)) {
                  for (let i2 = 0, ii = node.length; i2 < ii; i2++) {
                    const value = node[i2];
                    if (mayHaveChildren(value)) {
                      nodesToVisit.push(value);
                    }
                  }
                }
              }
              function ObjectLoader2(dict, keys, xref) {
                this.dict = dict;
                this.keys = keys;
                this.xref = xref;
                this.refSet = null;
              }
              ObjectLoader2.prototype = {
                async load() {
                  if (!this.xref.stream.allChunksLoaded || this.xref.stream.allChunksLoaded()) {
                    return void 0;
                  }
                  const {
                    keys,
                    dict
                  } = this;
                  this.refSet = new _primitives.RefSet();
                  const nodesToVisit = [];
                  for (let i2 = 0, ii = keys.length; i2 < ii; i2++) {
                    const rawValue = dict.getRaw(keys[i2]);
                    if (rawValue !== void 0) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                  return this._walk(nodesToVisit);
                },
                async _walk(nodesToVisit) {
                  const nodesToRevisit = [];
                  const pendingRequests = [];
                  while (nodesToVisit.length) {
                    let currentNode = nodesToVisit.pop();
                    if (currentNode instanceof _primitives.Ref) {
                      if (this.refSet.has(currentNode)) {
                        continue;
                      }
                      try {
                        this.refSet.put(currentNode);
                        currentNode = this.xref.fetch(currentNode);
                      } catch (ex) {
                        if (!(ex instanceof _core_utils.MissingDataException)) {
                          throw ex;
                        }
                        nodesToRevisit.push(currentNode);
                        pendingRequests.push({
                          begin: ex.begin,
                          end: ex.end
                        });
                      }
                    }
                    if (currentNode && currentNode.getBaseStreams) {
                      const baseStreams = currentNode.getBaseStreams();
                      let foundMissingData = false;
                      for (let i2 = 0, ii = baseStreams.length; i2 < ii; i2++) {
                        const stream = baseStreams[i2];
                        if (stream.allChunksLoaded && !stream.allChunksLoaded()) {
                          foundMissingData = true;
                          pendingRequests.push({
                            begin: stream.start,
                            end: stream.end
                          });
                        }
                      }
                      if (foundMissingData) {
                        nodesToRevisit.push(currentNode);
                      }
                    }
                    addChildren(currentNode, nodesToVisit);
                  }
                  if (pendingRequests.length) {
                    await this.xref.stream.manager.requestRanges(pendingRequests);
                    for (let i2 = 0, ii = nodesToRevisit.length; i2 < ii; i2++) {
                      const node = nodesToRevisit[i2];
                      if (node instanceof _primitives.Ref) {
                        this.refSet.remove(node);
                      }
                    }
                    return this._walk(nodesToRevisit);
                  }
                  this.refSet = null;
                  return void 0;
                }
              };
              return ObjectLoader2;
            }();
            exports3.ObjectLoader = ObjectLoader;
          },
          /* 10 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Parser = exports3.Linearization = exports3.Lexer = void 0;
            var _stream = __w_pdfjs_require__2(11);
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _core_utils = __w_pdfjs_require__2(7);
            var _ccitt_stream = __w_pdfjs_require__2(12);
            var _jbig2_stream = __w_pdfjs_require__2(14);
            var _jpeg_stream = __w_pdfjs_require__2(17);
            var _jpx_stream = __w_pdfjs_require__2(19);
            const MAX_LENGTH_TO_CACHE = 1e3;
            const MAX_ADLER32_LENGTH = 5552;
            function computeAdler32(bytes) {
              const bytesLength = bytes.length;
              let a2 = 1, b2 = 0;
              for (let i2 = 0; i2 < bytesLength; ++i2) {
                a2 += bytes[i2] & 255;
                b2 += a2;
              }
              return b2 % 65521 << 16 | a2 % 65521;
            }
            class Parser {
              constructor({
                lexer,
                xref,
                allowStreams = false,
                recoveryMode = false
              }) {
                this.lexer = lexer;
                this.xref = xref;
                this.allowStreams = allowStreams;
                this.recoveryMode = recoveryMode;
                this.imageCache = /* @__PURE__ */ Object.create(null);
                this.refill();
              }
              refill() {
                this.buf1 = this.lexer.getObj();
                this.buf2 = this.lexer.getObj();
              }
              shift() {
                if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
                  this.buf1 = this.buf2;
                  this.buf2 = null;
                } else {
                  this.buf1 = this.buf2;
                  this.buf2 = this.lexer.getObj();
                }
              }
              tryShift() {
                try {
                  this.shift();
                  return true;
                } catch (e2) {
                  if (e2 instanceof _core_utils.MissingDataException) {
                    throw e2;
                  }
                  return false;
                }
              }
              getObj(cipherTransform = null) {
                const buf1 = this.buf1;
                this.shift();
                if (buf1 instanceof _primitives.Cmd) {
                  switch (buf1.cmd) {
                    case "BI":
                      return this.makeInlineImage(cipherTransform);
                    case "[":
                      const array = [];
                      while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
                        array.push(this.getObj(cipherTransform));
                      }
                      if ((0, _primitives.isEOF)(this.buf1)) {
                        if (!this.recoveryMode) {
                          throw new _util2.FormatError("End of file inside array");
                        }
                        return array;
                      }
                      this.shift();
                      return array;
                    case "<<":
                      const dict = new _primitives.Dict(this.xref);
                      while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
                        if (!(0, _primitives.isName)(this.buf1)) {
                          (0, _util2.info)("Malformed dictionary: key must be a name object");
                          this.shift();
                          continue;
                        }
                        const key = this.buf1.name;
                        this.shift();
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          break;
                        }
                        dict.set(key, this.getObj(cipherTransform));
                      }
                      if ((0, _primitives.isEOF)(this.buf1)) {
                        if (!this.recoveryMode) {
                          throw new _util2.FormatError("End of file inside dictionary");
                        }
                        return dict;
                      }
                      if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                        return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                      }
                      this.shift();
                      return dict;
                    default:
                      return buf1;
                  }
                }
                if (Number.isInteger(buf1)) {
                  if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                    const ref = _primitives.Ref.get(buf1, this.buf1);
                    this.shift();
                    this.shift();
                    return ref;
                  }
                  return buf1;
                }
                if (typeof buf1 === "string") {
                  if (cipherTransform) {
                    return cipherTransform.decryptString(buf1);
                  }
                  return buf1;
                }
                return buf1;
              }
              findDefaultInlineStreamEnd(stream) {
                const E2 = 69, I2 = 73, SPACE = 32, LF = 10, CR = 13;
                const n2 = 10, NUL = 0;
                const startPos = stream.pos;
                let state = 0, ch, maybeEIPos;
                while ((ch = stream.getByte()) !== -1) {
                  if (state === 0) {
                    state = ch === E2 ? 1 : 0;
                  } else if (state === 1) {
                    state = ch === I2 ? 2 : 0;
                  } else {
                    (0, _util2.assert)(state === 2);
                    if (ch === SPACE || ch === LF || ch === CR) {
                      maybeEIPos = stream.pos;
                      const followingBytes = stream.peekBytes(n2);
                      for (let i2 = 0, ii = followingBytes.length; i2 < ii; i2++) {
                        ch = followingBytes[i2];
                        if (ch === NUL && followingBytes[i2 + 1] !== NUL) {
                          continue;
                        }
                        if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                          state = 0;
                          break;
                        }
                      }
                      if (state === 2) {
                        break;
                      }
                    } else {
                      state = 0;
                    }
                  }
                }
                if (ch === -1) {
                  (0, _util2.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                  if (maybeEIPos) {
                    (0, _util2.warn)('... trying to recover by using the last "EI" occurrence.');
                    stream.skip(-(stream.pos - maybeEIPos));
                  }
                }
                let endOffset = 4;
                stream.skip(-endOffset);
                ch = stream.peekByte();
                stream.skip(endOffset);
                if (!(0, _core_utils.isWhiteSpace)(ch)) {
                  endOffset--;
                }
                return stream.pos - endOffset - startPos;
              }
              findDCTDecodeInlineStreamEnd(stream) {
                const startPos = stream.pos;
                let foundEOI = false, b2, markerLength;
                while ((b2 = stream.getByte()) !== -1) {
                  if (b2 !== 255) {
                    continue;
                  }
                  switch (stream.getByte()) {
                    case 0:
                      break;
                    case 255:
                      stream.skip(-1);
                      break;
                    case 217:
                      foundEOI = true;
                      break;
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 197:
                    case 198:
                    case 199:
                    case 201:
                    case 202:
                    case 203:
                    case 205:
                    case 206:
                    case 207:
                    case 196:
                    case 204:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 254:
                      markerLength = stream.getUint16();
                      if (markerLength > 2) {
                        stream.skip(markerLength - 2);
                      } else {
                        stream.skip(-2);
                      }
                      break;
                  }
                  if (foundEOI) {
                    break;
                  }
                }
                const length = stream.pos - startPos;
                if (b2 === -1) {
                  (0, _util2.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                  stream.skip(-length);
                  return this.findDefaultInlineStreamEnd(stream);
                }
                this.inlineStreamSkipEI(stream);
                return length;
              }
              findASCII85DecodeInlineStreamEnd(stream) {
                const TILDE = 126, GT = 62;
                const startPos = stream.pos;
                let ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (ch === TILDE) {
                    const tildePos = stream.pos;
                    ch = stream.peekByte();
                    while ((0, _core_utils.isWhiteSpace)(ch)) {
                      stream.skip();
                      ch = stream.peekByte();
                    }
                    if (ch === GT) {
                      stream.skip();
                      break;
                    }
                    if (stream.pos > tildePos) {
                      const maybeEI = stream.peekBytes(2);
                      if (maybeEI[0] === 69 && maybeEI[1] === 73) {
                        break;
                      }
                    }
                  }
                }
                const length = stream.pos - startPos;
                if (ch === -1) {
                  (0, _util2.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                  stream.skip(-length);
                  return this.findDefaultInlineStreamEnd(stream);
                }
                this.inlineStreamSkipEI(stream);
                return length;
              }
              findASCIIHexDecodeInlineStreamEnd(stream) {
                const GT = 62;
                const startPos = stream.pos;
                let ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (ch === GT) {
                    break;
                  }
                }
                const length = stream.pos - startPos;
                if (ch === -1) {
                  (0, _util2.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                  stream.skip(-length);
                  return this.findDefaultInlineStreamEnd(stream);
                }
                this.inlineStreamSkipEI(stream);
                return length;
              }
              inlineStreamSkipEI(stream) {
                const E2 = 69, I2 = 73;
                let state = 0, ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (state === 0) {
                    state = ch === E2 ? 1 : 0;
                  } else if (state === 1) {
                    state = ch === I2 ? 2 : 0;
                  } else if (state === 2) {
                    break;
                  }
                }
              }
              makeInlineImage(cipherTransform) {
                const lexer = this.lexer;
                const stream = lexer.stream;
                const dict = new _primitives.Dict(this.xref);
                let dictLength;
                while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
                  if (!(0, _primitives.isName)(this.buf1)) {
                    throw new _util2.FormatError("Dictionary key must be a name object");
                  }
                  const key = this.buf1.name;
                  this.shift();
                  if ((0, _primitives.isEOF)(this.buf1)) {
                    break;
                  }
                  dict.set(key, this.getObj(cipherTransform));
                }
                if (lexer.beginInlineImagePos !== -1) {
                  dictLength = stream.pos - lexer.beginInlineImagePos;
                }
                const filter = dict.get("Filter", "F");
                let filterName;
                if ((0, _primitives.isName)(filter)) {
                  filterName = filter.name;
                } else if (Array.isArray(filter)) {
                  const filterZero = this.xref.fetchIfRef(filter[0]);
                  if ((0, _primitives.isName)(filterZero)) {
                    filterName = filterZero.name;
                  }
                }
                const startPos = stream.pos;
                let length;
                if (filterName === "DCTDecode" || filterName === "DCT") {
                  length = this.findDCTDecodeInlineStreamEnd(stream);
                } else if (filterName === "ASCII85Decode" || filterName === "A85") {
                  length = this.findASCII85DecodeInlineStreamEnd(stream);
                } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
                  length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                } else {
                  length = this.findDefaultInlineStreamEnd(stream);
                }
                let imageStream = stream.makeSubStream(startPos, length, dict);
                let cacheKey;
                if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
                  const imageBytes = imageStream.getBytes();
                  imageStream.reset();
                  const initialStreamPos = stream.pos;
                  stream.pos = lexer.beginInlineImagePos;
                  const dictBytes = stream.getBytes(dictLength);
                  stream.pos = initialStreamPos;
                  cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
                  const cacheEntry = this.imageCache[cacheKey];
                  if (cacheEntry !== void 0) {
                    this.buf2 = _primitives.Cmd.get("EI");
                    this.shift();
                    cacheEntry.reset();
                    return cacheEntry;
                  }
                }
                if (cipherTransform) {
                  imageStream = cipherTransform.createStream(imageStream, length);
                }
                imageStream = this.filter(imageStream, dict, length);
                imageStream.dict = dict;
                if (cacheKey !== void 0) {
                  imageStream.cacheKey = `inline_${length}_${cacheKey}`;
                  this.imageCache[cacheKey] = imageStream;
                }
                this.buf2 = _primitives.Cmd.get("EI");
                this.shift();
                return imageStream;
              }
              _findStreamLength(startPos, signature) {
                const {
                  stream
                } = this.lexer;
                stream.pos = startPos;
                const SCAN_BLOCK_LENGTH = 2048;
                const signatureLength = signature.length;
                while (stream.pos < stream.end) {
                  const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                  const scanLength = scanBytes.length - signatureLength;
                  if (scanLength <= 0) {
                    break;
                  }
                  let pos = 0;
                  while (pos < scanLength) {
                    let j2 = 0;
                    while (j2 < signatureLength && scanBytes[pos + j2] === signature[j2]) {
                      j2++;
                    }
                    if (j2 >= signatureLength) {
                      stream.pos += pos;
                      return stream.pos - startPos;
                    }
                    pos++;
                  }
                  stream.pos += scanLength;
                }
                return -1;
              }
              makeStream(dict, cipherTransform) {
                const lexer = this.lexer;
                let stream = lexer.stream;
                lexer.skipToNextLine();
                const startPos = stream.pos - 1;
                let length = dict.get("Length");
                if (!Number.isInteger(length)) {
                  (0, _util2.info)(`Bad length "${length}" in stream`);
                  length = 0;
                }
                stream.pos = startPos + length;
                lexer.nextChar();
                if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                  this.shift();
                } else {
                  const ENDSTREAM_SIGNATURE = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                  let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
                  if (actualLength < 0) {
                    const MAX_TRUNCATION = 1;
                    for (let i2 = 1; i2 <= MAX_TRUNCATION; i2++) {
                      const end = ENDSTREAM_SIGNATURE.length - i2;
                      const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
                      const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
                      if (maybeLength >= 0) {
                        const lastByte = stream.peekBytes(end + 1)[end];
                        if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
                          break;
                        }
                        (0, _util2.info)(`Found "${(0, _util2.bytesToString)(TRUNCATED_SIGNATURE)}" when searching for endstream command.`);
                        actualLength = maybeLength;
                        break;
                      }
                    }
                    if (actualLength < 0) {
                      throw new _util2.FormatError("Missing endstream command.");
                    }
                  }
                  length = actualLength;
                  lexer.nextChar();
                  this.shift();
                  this.shift();
                }
                this.shift();
                stream = stream.makeSubStream(startPos, length, dict);
                if (cipherTransform) {
                  stream = cipherTransform.createStream(stream, length);
                }
                stream = this.filter(stream, dict, length);
                stream.dict = dict;
                return stream;
              }
              filter(stream, dict, length) {
                let filter = dict.get("Filter", "F");
                let params = dict.get("DecodeParms", "DP");
                if ((0, _primitives.isName)(filter)) {
                  if (Array.isArray(params)) {
                    (0, _util2.warn)("/DecodeParms should not contain an Array, when /Filter contains a Name.");
                  }
                  return this.makeFilter(stream, filter.name, length, params);
                }
                let maybeLength = length;
                if (Array.isArray(filter)) {
                  const filterArray = filter;
                  const paramsArray = params;
                  for (let i2 = 0, ii = filterArray.length; i2 < ii; ++i2) {
                    filter = this.xref.fetchIfRef(filterArray[i2]);
                    if (!(0, _primitives.isName)(filter)) {
                      throw new _util2.FormatError(`Bad filter name "${filter}"`);
                    }
                    params = null;
                    if (Array.isArray(paramsArray) && i2 in paramsArray) {
                      params = this.xref.fetchIfRef(paramsArray[i2]);
                    }
                    stream = this.makeFilter(stream, filter.name, maybeLength, params);
                    maybeLength = null;
                  }
                }
                return stream;
              }
              makeFilter(stream, name, maybeLength, params) {
                if (maybeLength === 0) {
                  (0, _util2.warn)(`Empty "${name}" stream.`);
                  return new _stream.NullStream();
                }
                try {
                  const xrefStreamStats = this.xref.stats.streamTypes;
                  if (name === "FlateDecode" || name === "Fl") {
                    xrefStreamStats[_util2.StreamType.FLATE] = true;
                    if (params) {
                      return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
                    }
                    return new _stream.FlateStream(stream, maybeLength);
                  }
                  if (name === "LZWDecode" || name === "LZW") {
                    xrefStreamStats[_util2.StreamType.LZW] = true;
                    let earlyChange = 1;
                    if (params) {
                      if (params.has("EarlyChange")) {
                        earlyChange = params.get("EarlyChange");
                      }
                      return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                    }
                    return new _stream.LZWStream(stream, maybeLength, earlyChange);
                  }
                  if (name === "DCTDecode" || name === "DCT") {
                    xrefStreamStats[_util2.StreamType.DCT] = true;
                    return new _jpeg_stream.JpegStream(stream, maybeLength, stream.dict, params);
                  }
                  if (name === "JPXDecode" || name === "JPX") {
                    xrefStreamStats[_util2.StreamType.JPX] = true;
                    return new _jpx_stream.JpxStream(stream, maybeLength, stream.dict, params);
                  }
                  if (name === "ASCII85Decode" || name === "A85") {
                    xrefStreamStats[_util2.StreamType.A85] = true;
                    return new _stream.Ascii85Stream(stream, maybeLength);
                  }
                  if (name === "ASCIIHexDecode" || name === "AHx") {
                    xrefStreamStats[_util2.StreamType.AHX] = true;
                    return new _stream.AsciiHexStream(stream, maybeLength);
                  }
                  if (name === "CCITTFaxDecode" || name === "CCF") {
                    xrefStreamStats[_util2.StreamType.CCF] = true;
                    return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                  }
                  if (name === "RunLengthDecode" || name === "RL") {
                    xrefStreamStats[_util2.StreamType.RLX] = true;
                    return new _stream.RunLengthStream(stream, maybeLength);
                  }
                  if (name === "JBIG2Decode") {
                    xrefStreamStats[_util2.StreamType.JBIG] = true;
                    return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
                  }
                  (0, _util2.warn)(`Filter "${name}" is not supported.`);
                  return stream;
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  (0, _util2.warn)(`Invalid stream: "${ex}"`);
                  return new _stream.NullStream();
                }
              }
            }
            exports3.Parser = Parser;
            const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            function toHexDigit(ch) {
              if (ch >= 48 && ch <= 57) {
                return ch & 15;
              }
              if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                return (ch & 15) + 9;
              }
              return -1;
            }
            class Lexer {
              constructor(stream, knownCommands = null) {
                this.stream = stream;
                this.nextChar();
                this.strBuf = [];
                this.knownCommands = knownCommands;
                this._hexStringNumWarn = 0;
                this.beginInlineImagePos = -1;
              }
              nextChar() {
                return this.currentChar = this.stream.getByte();
              }
              peekChar() {
                return this.stream.peekByte();
              }
              getNumber() {
                let ch = this.currentChar;
                let eNotation = false;
                let divideBy = 0;
                let sign = 0;
                if (ch === 45) {
                  sign = -1;
                  ch = this.nextChar();
                  if (ch === 45) {
                    ch = this.nextChar();
                  }
                } else if (ch === 43) {
                  sign = 1;
                  ch = this.nextChar();
                }
                if (ch === 10 || ch === 13) {
                  do {
                    ch = this.nextChar();
                  } while (ch === 10 || ch === 13);
                }
                if (ch === 46) {
                  divideBy = 10;
                  ch = this.nextChar();
                }
                if (ch < 48 || ch > 57) {
                  if (divideBy === 10 && sign === 0 && ((0, _core_utils.isWhiteSpace)(ch) || ch === -1)) {
                    (0, _util2.warn)("Lexer.getNumber - treating a single decimal point as zero.");
                    return 0;
                  }
                  throw new _util2.FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
                }
                sign = sign || 1;
                let baseValue = ch - 48;
                let powerValue = 0;
                let powerValueSign = 1;
                while ((ch = this.nextChar()) >= 0) {
                  if (ch >= 48 && ch <= 57) {
                    const currentDigit = ch - 48;
                    if (eNotation) {
                      powerValue = powerValue * 10 + currentDigit;
                    } else {
                      if (divideBy !== 0) {
                        divideBy *= 10;
                      }
                      baseValue = baseValue * 10 + currentDigit;
                    }
                  } else if (ch === 46) {
                    if (divideBy === 0) {
                      divideBy = 1;
                    } else {
                      break;
                    }
                  } else if (ch === 45) {
                    (0, _util2.warn)("Badly formatted number: minus sign in the middle");
                  } else if (ch === 69 || ch === 101) {
                    ch = this.peekChar();
                    if (ch === 43 || ch === 45) {
                      powerValueSign = ch === 45 ? -1 : 1;
                      this.nextChar();
                    } else if (ch < 48 || ch > 57) {
                      break;
                    }
                    eNotation = true;
                  } else {
                    break;
                  }
                }
                if (divideBy !== 0) {
                  baseValue /= divideBy;
                }
                if (eNotation) {
                  baseValue *= 10 ** (powerValueSign * powerValue);
                }
                return sign * baseValue;
              }
              getString() {
                let numParen = 1;
                let done = false;
                const strBuf = this.strBuf;
                strBuf.length = 0;
                let ch = this.nextChar();
                while (true) {
                  let charBuffered = false;
                  switch (ch | 0) {
                    case -1:
                      (0, _util2.warn)("Unterminated string");
                      done = true;
                      break;
                    case 40:
                      ++numParen;
                      strBuf.push("(");
                      break;
                    case 41:
                      if (--numParen === 0) {
                        this.nextChar();
                        done = true;
                      } else {
                        strBuf.push(")");
                      }
                      break;
                    case 92:
                      ch = this.nextChar();
                      switch (ch) {
                        case -1:
                          (0, _util2.warn)("Unterminated string");
                          done = true;
                          break;
                        case 110:
                          strBuf.push("\n");
                          break;
                        case 114:
                          strBuf.push("\r");
                          break;
                        case 116:
                          strBuf.push("	");
                          break;
                        case 98:
                          strBuf.push("\b");
                          break;
                        case 102:
                          strBuf.push("\f");
                          break;
                        case 92:
                        case 40:
                        case 41:
                          strBuf.push(String.fromCharCode(ch));
                          break;
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                          let x2 = ch & 15;
                          ch = this.nextChar();
                          charBuffered = true;
                          if (ch >= 48 && ch <= 55) {
                            x2 = (x2 << 3) + (ch & 15);
                            ch = this.nextChar();
                            if (ch >= 48 && ch <= 55) {
                              charBuffered = false;
                              x2 = (x2 << 3) + (ch & 15);
                            }
                          }
                          strBuf.push(String.fromCharCode(x2));
                          break;
                        case 13:
                          if (this.peekChar() === 10) {
                            this.nextChar();
                          }
                          break;
                        case 10:
                          break;
                        default:
                          strBuf.push(String.fromCharCode(ch));
                          break;
                      }
                      break;
                    default:
                      strBuf.push(String.fromCharCode(ch));
                      break;
                  }
                  if (done) {
                    break;
                  }
                  if (!charBuffered) {
                    ch = this.nextChar();
                  }
                }
                return strBuf.join("");
              }
              getName() {
                let ch, previousCh;
                const strBuf = this.strBuf;
                strBuf.length = 0;
                while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                  if (ch === 35) {
                    ch = this.nextChar();
                    if (specialChars[ch]) {
                      (0, _util2.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                      strBuf.push("#");
                      break;
                    }
                    const x2 = toHexDigit(ch);
                    if (x2 !== -1) {
                      previousCh = ch;
                      ch = this.nextChar();
                      const x22 = toHexDigit(ch);
                      if (x22 === -1) {
                        (0, _util2.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) in hexadecimal number.`);
                        strBuf.push("#", String.fromCharCode(previousCh));
                        if (specialChars[ch]) {
                          break;
                        }
                        strBuf.push(String.fromCharCode(ch));
                        continue;
                      }
                      strBuf.push(String.fromCharCode(x2 << 4 | x22));
                    } else {
                      strBuf.push("#", String.fromCharCode(ch));
                    }
                  } else {
                    strBuf.push(String.fromCharCode(ch));
                  }
                }
                if (strBuf.length > 127) {
                  (0, _util2.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
                }
                return _primitives.Name.get(strBuf.join(""));
              }
              _hexStringWarn(ch) {
                const MAX_HEX_STRING_NUM_WARN = 5;
                if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
                  (0, _util2.warn)("getHexString - ignoring additional invalid characters.");
                  return;
                }
                if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
                  return;
                }
                (0, _util2.warn)(`getHexString - ignoring invalid character: ${ch}`);
              }
              getHexString() {
                const strBuf = this.strBuf;
                strBuf.length = 0;
                let ch = this.currentChar;
                let isFirstHex = true;
                let firstDigit, secondDigit;
                this._hexStringNumWarn = 0;
                while (true) {
                  if (ch < 0) {
                    (0, _util2.warn)("Unterminated hex string");
                    break;
                  } else if (ch === 62) {
                    this.nextChar();
                    break;
                  } else if (specialChars[ch] === 1) {
                    ch = this.nextChar();
                    continue;
                  } else {
                    if (isFirstHex) {
                      firstDigit = toHexDigit(ch);
                      if (firstDigit === -1) {
                        this._hexStringWarn(ch);
                        ch = this.nextChar();
                        continue;
                      }
                    } else {
                      secondDigit = toHexDigit(ch);
                      if (secondDigit === -1) {
                        this._hexStringWarn(ch);
                        ch = this.nextChar();
                        continue;
                      }
                      strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                    }
                    isFirstHex = !isFirstHex;
                    ch = this.nextChar();
                  }
                }
                return strBuf.join("");
              }
              getObj() {
                let comment = false;
                let ch = this.currentChar;
                while (true) {
                  if (ch < 0) {
                    return _primitives.EOF;
                  }
                  if (comment) {
                    if (ch === 10 || ch === 13) {
                      comment = false;
                    }
                  } else if (ch === 37) {
                    comment = true;
                  } else if (specialChars[ch] !== 1) {
                    break;
                  }
                  ch = this.nextChar();
                }
                switch (ch | 0) {
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                  case 43:
                  case 45:
                  case 46:
                    return this.getNumber();
                  case 40:
                    return this.getString();
                  case 47:
                    return this.getName();
                  case 91:
                    this.nextChar();
                    return _primitives.Cmd.get("[");
                  case 93:
                    this.nextChar();
                    return _primitives.Cmd.get("]");
                  case 60:
                    ch = this.nextChar();
                    if (ch === 60) {
                      this.nextChar();
                      return _primitives.Cmd.get("<<");
                    }
                    return this.getHexString();
                  case 62:
                    ch = this.nextChar();
                    if (ch === 62) {
                      this.nextChar();
                      return _primitives.Cmd.get(">>");
                    }
                    return _primitives.Cmd.get(">");
                  case 123:
                    this.nextChar();
                    return _primitives.Cmd.get("{");
                  case 125:
                    this.nextChar();
                    return _primitives.Cmd.get("}");
                  case 41:
                    this.nextChar();
                    throw new _util2.FormatError(`Illegal character: ${ch}`);
                }
                let str = String.fromCharCode(ch);
                const knownCommands = this.knownCommands;
                let knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                  const possibleCommand = str + String.fromCharCode(ch);
                  if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                    break;
                  }
                  if (str.length === 128) {
                    throw new _util2.FormatError(`Command token too long: ${str.length}`);
                  }
                  str = possibleCommand;
                  knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                }
                if (str === "true") {
                  return true;
                }
                if (str === "false") {
                  return false;
                }
                if (str === "null") {
                  return null;
                }
                if (str === "BI") {
                  this.beginInlineImagePos = this.stream.pos;
                }
                return _primitives.Cmd.get(str);
              }
              skipToNextLine() {
                let ch = this.currentChar;
                while (ch >= 0) {
                  if (ch === 13) {
                    ch = this.nextChar();
                    if (ch === 10) {
                      this.nextChar();
                    }
                    break;
                  } else if (ch === 10) {
                    this.nextChar();
                    break;
                  }
                  ch = this.nextChar();
                }
              }
            }
            exports3.Lexer = Lexer;
            class Linearization {
              static create(stream) {
                function getInt(linDict2, name, allowZeroValue = false) {
                  const obj4 = linDict2.get(name);
                  if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                    return obj4;
                  }
                  throw new Error(`The "${name}" parameter in the linearization dictionary is invalid.`);
                }
                function getHints(linDict2) {
                  const hints = linDict2.get("H");
                  let hintsLength;
                  if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                    for (let index = 0; index < hintsLength; index++) {
                      const hint = hints[index];
                      if (!(Number.isInteger(hint) && hint > 0)) {
                        throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
                      }
                    }
                    return hints;
                  }
                  throw new Error("Hint array in the linearization dictionary is invalid.");
                }
                const parser = new Parser({
                  lexer: new Lexer(stream),
                  xref: null
                });
                const obj1 = parser.getObj();
                const obj2 = parser.getObj();
                const obj3 = parser.getObj();
                const linDict = parser.getObj();
                let obj, length;
                if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util2.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
                  return null;
                } else if ((length = getInt(linDict, "L")) !== stream.length) {
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                }
                return {
                  length,
                  hints: getHints(linDict),
                  objectNumberFirst: getInt(linDict, "O"),
                  endFirst: getInt(linDict, "E"),
                  numPages: getInt(linDict, "N"),
                  mainXRefEntriesOffset: getInt(linDict, "T"),
                  pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
                };
              }
            }
            exports3.Linearization = Linearization;
          },
          /* 11 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.LZWStream = exports3.StringStream = exports3.StreamsSequenceStream = exports3.Stream = exports3.RunLengthStream = exports3.PredictorStream = exports3.NullStream = exports3.FlateStream = exports3.DecodeStream = exports3.DecryptStream = exports3.AsciiHexStream = exports3.Ascii85Stream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _core_utils = __w_pdfjs_require__2(7);
            var Stream = function StreamClosure() {
              function Stream2(arrayBuffer, start, length, dict) {
                this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                this.start = start || 0;
                this.pos = this.start;
                this.end = start + length || this.bytes.length;
                this.dict = dict;
              }
              Stream2.prototype = {
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function Stream_getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                },
                getUint16: function Stream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function Stream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes(length, forceClamped = false) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    const subarray2 = bytes.subarray(pos, strEnd);
                    return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  const subarray = bytes.subarray(pos, end);
                  return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
                },
                peekByte: function Stream_peekByte() {
                  var peekedByte = this.getByte();
                  if (peekedByte !== -1) {
                    this.pos--;
                  }
                  return peekedByte;
                },
                peekBytes(length, forceClamped = false) {
                  var bytes = this.getBytes(length, forceClamped);
                  this.pos -= bytes.length;
                  return bytes;
                },
                getByteRange(begin, end) {
                  if (begin < 0) {
                    begin = 0;
                  }
                  if (end > this.end) {
                    end = this.end;
                  }
                  return this.bytes.subarray(begin, end);
                },
                skip: function Stream_skip(n2) {
                  if (!n2) {
                    n2 = 1;
                  }
                  this.pos += n2;
                },
                reset: function Stream_reset() {
                  this.pos = this.start;
                },
                moveStart: function Stream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function Stream_makeSubStream(start, length, dict) {
                  return new Stream2(this.bytes.buffer, start, length, dict);
                }
              };
              return Stream2;
            }();
            exports3.Stream = Stream;
            var StringStream = function StringStreamClosure() {
              function StringStream2(str) {
                const bytes = (0, _util2.stringToBytes)(str);
                Stream.call(this, bytes);
              }
              StringStream2.prototype = Stream.prototype;
              return StringStream2;
            }();
            exports3.StringStream = StringStream;
            var DecodeStream = function DecodeStreamClosure() {
              var emptyBuffer = new Uint8Array(0);
              function DecodeStream2(maybeMinBufferLength) {
                this._rawMinBufferLength = maybeMinBufferLength || 0;
                this.pos = 0;
                this.bufferLength = 0;
                this.eof = false;
                this.buffer = emptyBuffer;
                this.minBufferLength = 512;
                if (maybeMinBufferLength) {
                  while (this.minBufferLength < maybeMinBufferLength) {
                    this.minBufferLength *= 2;
                  }
                }
              }
              DecodeStream2.prototype = {
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                },
                ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                  var buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  var size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  var buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                },
                getByte: function DecodeStream_getByte() {
                  var pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                },
                getUint16: function DecodeStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function DecodeStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes(length, forceClamped = false) {
                  var end, pos = this.pos;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    var bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  const subarray = this.buffer.subarray(pos, end);
                  return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
                },
                peekByte: function DecodeStream_peekByte() {
                  var peekedByte = this.getByte();
                  if (peekedByte !== -1) {
                    this.pos--;
                  }
                  return peekedByte;
                },
                peekBytes(length, forceClamped = false) {
                  var bytes = this.getBytes(length, forceClamped);
                  this.pos -= bytes.length;
                  return bytes;
                },
                makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                  var end = start + length;
                  while (this.bufferLength <= end && !this.eof) {
                    this.readBlock();
                  }
                  return new Stream(this.buffer, start, length, dict);
                },
                getByteRange(begin, end) {
                  (0, _util2.unreachable)("Should not call DecodeStream.getByteRange");
                },
                skip: function DecodeStream_skip(n2) {
                  if (!n2) {
                    n2 = 1;
                  }
                  this.pos += n2;
                },
                reset: function DecodeStream_reset() {
                  this.pos = 0;
                },
                getBaseStreams: function DecodeStream_getBaseStreams() {
                  if (this.str && this.str.getBaseStreams) {
                    return this.str.getBaseStreams();
                  }
                  return [];
                }
              };
              return DecodeStream2;
            }();
            exports3.DecodeStream = DecodeStream;
            var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
              function StreamsSequenceStream2(streams) {
                this.streams = streams;
                let maybeLength = 0;
                for (let i2 = 0, ii = streams.length; i2 < ii; i2++) {
                  const stream = streams[i2];
                  if (stream instanceof DecodeStream) {
                    maybeLength += stream._rawMinBufferLength;
                  } else {
                    maybeLength += stream.length;
                  }
                }
                DecodeStream.call(this, maybeLength);
              }
              StreamsSequenceStream2.prototype = Object.create(DecodeStream.prototype);
              StreamsSequenceStream2.prototype.readBlock = function streamSequenceStreamReadBlock() {
                var streams = this.streams;
                if (streams.length === 0) {
                  this.eof = true;
                  return;
                }
                var stream = streams.shift();
                var chunk = stream.getBytes();
                var bufferLength = this.bufferLength;
                var newLength = bufferLength + chunk.length;
                var buffer = this.ensureBuffer(newLength);
                buffer.set(chunk, bufferLength);
                this.bufferLength = newLength;
              };
              StreamsSequenceStream2.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                var baseStreams = [];
                for (var i2 = 0, ii = this.streams.length; i2 < ii; i2++) {
                  var stream = this.streams[i2];
                  if (stream.getBaseStreams) {
                    baseStreams.push(...stream.getBaseStreams());
                  }
                }
                return baseStreams;
              };
              return StreamsSequenceStream2;
            }();
            exports3.StreamsSequenceStream = StreamsSequenceStream;
            var FlateStream = function FlateStreamClosure() {
              var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              function FlateStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                var cmf = str.getByte();
                var flg = str.getByte();
                if (cmf === -1 || flg === -1) {
                  throw new _util2.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
                }
                if ((cmf & 15) !== 8) {
                  throw new _util2.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
                }
                if (((cmf << 8) + flg) % 31 !== 0) {
                  throw new _util2.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
                }
                if (flg & 32) {
                  throw new _util2.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
                }
                this.codeSize = 0;
                this.codeBuf = 0;
                DecodeStream.call(this, maybeLength);
              }
              FlateStream2.prototype = Object.create(DecodeStream.prototype);
              FlateStream2.prototype.getBits = function FlateStream_getBits(bits) {
                var str = this.str;
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b2;
                while (codeSize < bits) {
                  if ((b2 = str.getByte()) === -1) {
                    throw new _util2.FormatError("Bad encoding in flate stream");
                  }
                  codeBuf |= b2 << codeSize;
                  codeSize += 8;
                }
                b2 = codeBuf & (1 << bits) - 1;
                this.codeBuf = codeBuf >> bits;
                this.codeSize = codeSize -= bits;
                return b2;
              };
              FlateStream2.prototype.getCode = function FlateStream_getCode(table) {
                var str = this.str;
                var codes = table[0];
                var maxLen = table[1];
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b2;
                while (codeSize < maxLen) {
                  if ((b2 = str.getByte()) === -1) {
                    break;
                  }
                  codeBuf |= b2 << codeSize;
                  codeSize += 8;
                }
                var code = codes[codeBuf & (1 << maxLen) - 1];
                var codeLen = code >> 16;
                var codeVal = code & 65535;
                if (codeLen < 1 || codeSize < codeLen) {
                  throw new _util2.FormatError("Bad encoding in flate stream");
                }
                this.codeBuf = codeBuf >> codeLen;
                this.codeSize = codeSize - codeLen;
                return codeVal;
              };
              FlateStream2.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                var n2 = lengths.length;
                var maxLen = 0;
                var i2;
                for (i2 = 0; i2 < n2; ++i2) {
                  if (lengths[i2] > maxLen) {
                    maxLen = lengths[i2];
                  }
                }
                var size = 1 << maxLen;
                var codes = new Int32Array(size);
                for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                  for (var val = 0; val < n2; ++val) {
                    if (lengths[val] === len) {
                      var code2 = 0;
                      var t2 = code;
                      for (i2 = 0; i2 < len; ++i2) {
                        code2 = code2 << 1 | t2 & 1;
                        t2 >>= 1;
                      }
                      for (i2 = code2; i2 < size; i2 += skip) {
                        codes[i2] = len << 16 | val;
                      }
                      ++code;
                    }
                  }
                }
                return [codes, maxLen];
              };
              FlateStream2.prototype.readBlock = function FlateStream_readBlock() {
                var buffer, len;
                var str = this.str;
                var hdr = this.getBits(3);
                if (hdr & 1) {
                  this.eof = true;
                }
                hdr >>= 1;
                if (hdr === 0) {
                  var b2;
                  if ((b2 = str.getByte()) === -1) {
                    throw new _util2.FormatError("Bad block header in flate stream");
                  }
                  var blockLen = b2;
                  if ((b2 = str.getByte()) === -1) {
                    throw new _util2.FormatError("Bad block header in flate stream");
                  }
                  blockLen |= b2 << 8;
                  if ((b2 = str.getByte()) === -1) {
                    throw new _util2.FormatError("Bad block header in flate stream");
                  }
                  var check = b2;
                  if ((b2 = str.getByte()) === -1) {
                    throw new _util2.FormatError("Bad block header in flate stream");
                  }
                  check |= b2 << 8;
                  if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                    throw new _util2.FormatError("Bad uncompressed block length in flate stream");
                  }
                  this.codeBuf = 0;
                  this.codeSize = 0;
                  const bufferLength = this.bufferLength, end = bufferLength + blockLen;
                  buffer = this.ensureBuffer(end);
                  this.bufferLength = end;
                  if (blockLen === 0) {
                    if (str.peekByte() === -1) {
                      this.eof = true;
                    }
                  } else {
                    const block = str.getBytes(blockLen);
                    buffer.set(block, bufferLength);
                    if (block.length < blockLen) {
                      this.eof = true;
                    }
                  }
                  return;
                }
                var litCodeTable;
                var distCodeTable;
                if (hdr === 1) {
                  litCodeTable = fixedLitCodeTab;
                  distCodeTable = fixedDistCodeTab;
                } else if (hdr === 2) {
                  var numLitCodes = this.getBits(5) + 257;
                  var numDistCodes = this.getBits(5) + 1;
                  var numCodeLenCodes = this.getBits(4) + 4;
                  var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                  var i2;
                  for (i2 = 0; i2 < numCodeLenCodes; ++i2) {
                    codeLenCodeLengths[codeLenCodeMap[i2]] = this.getBits(3);
                  }
                  var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                  len = 0;
                  i2 = 0;
                  var codes = numLitCodes + numDistCodes;
                  var codeLengths = new Uint8Array(codes);
                  var bitsLength, bitsOffset, what;
                  while (i2 < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code === 16) {
                      bitsLength = 2;
                      bitsOffset = 3;
                      what = len;
                    } else if (code === 17) {
                      bitsLength = 3;
                      bitsOffset = 3;
                      what = len = 0;
                    } else if (code === 18) {
                      bitsLength = 7;
                      bitsOffset = 11;
                      what = len = 0;
                    } else {
                      codeLengths[i2++] = len = code;
                      continue;
                    }
                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0) {
                      codeLengths[i2++] = what;
                    }
                  }
                  litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                  distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                } else {
                  throw new _util2.FormatError("Unknown block type in flate stream");
                }
                buffer = this.buffer;
                var limit = buffer ? buffer.length : 0;
                var pos = this.bufferLength;
                while (true) {
                  var code1 = this.getCode(litCodeTable);
                  if (code1 < 256) {
                    if (pos + 1 >= limit) {
                      buffer = this.ensureBuffer(pos + 1);
                      limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                  }
                  if (code1 === 256) {
                    this.bufferLength = pos;
                    return;
                  }
                  code1 -= 257;
                  code1 = lengthDecode[code1];
                  var code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  len = (code1 & 65535) + code2;
                  code1 = this.getCode(distCodeTable);
                  code1 = distDecode[code1];
                  code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  var dist = (code1 & 65535) + code2;
                  if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                  }
                  for (var k2 = 0; k2 < len; ++k2, ++pos) {
                    buffer[pos] = buffer[pos - dist];
                  }
                }
              };
              return FlateStream2;
            }();
            exports3.FlateStream = FlateStream;
            var PredictorStream = function PredictorStreamClosure() {
              function PredictorStream2(str, maybeLength, params) {
                if (!(0, _primitives.isDict)(params)) {
                  return str;
                }
                var predictor = this.predictor = params.get("Predictor") || 1;
                if (predictor <= 1) {
                  return str;
                }
                if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                  throw new _util2.FormatError(`Unsupported predictor: ${predictor}`);
                }
                if (predictor === 2) {
                  this.readBlock = this.readBlockTiff;
                } else {
                  this.readBlock = this.readBlockPng;
                }
                this.str = str;
                this.dict = str.dict;
                var colors = this.colors = params.get("Colors") || 1;
                var bits = this.bits = params.get("BitsPerComponent") || 8;
                var columns = this.columns = params.get("Columns") || 1;
                this.pixBytes = colors * bits + 7 >> 3;
                this.rowBytes = columns * colors * bits + 7 >> 3;
                DecodeStream.call(this, maybeLength);
                return this;
              }
              PredictorStream2.prototype = Object.create(DecodeStream.prototype);
              PredictorStream2.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                var rowBytes = this.rowBytes;
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var bits = this.bits;
                var colors = this.colors;
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var inbuf = 0, outbuf = 0;
                var inbits = 0, outbits = 0;
                var pos = bufferLength;
                var i2;
                if (bits === 1 && colors === 1) {
                  for (i2 = 0; i2 < rowBytes; ++i2) {
                    var c2 = rawBytes[i2] ^ inbuf;
                    c2 ^= c2 >> 1;
                    c2 ^= c2 >> 2;
                    c2 ^= c2 >> 4;
                    inbuf = (c2 & 1) << 7;
                    buffer[pos++] = c2;
                  }
                } else if (bits === 8) {
                  for (i2 = 0; i2 < colors; ++i2) {
                    buffer[pos++] = rawBytes[i2];
                  }
                  for (; i2 < rowBytes; ++i2) {
                    buffer[pos] = buffer[pos - colors] + rawBytes[i2];
                    pos++;
                  }
                } else if (bits === 16) {
                  var bytesPerPixel = colors * 2;
                  for (i2 = 0; i2 < bytesPerPixel; ++i2) {
                    buffer[pos++] = rawBytes[i2];
                  }
                  for (; i2 < rowBytes; i2 += 2) {
                    var sum = ((rawBytes[i2] & 255) << 8) + (rawBytes[i2 + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                    buffer[pos++] = sum >> 8 & 255;
                    buffer[pos++] = sum & 255;
                  }
                } else {
                  var compArray = new Uint8Array(colors + 1);
                  var bitMask = (1 << bits) - 1;
                  var j2 = 0, k2 = bufferLength;
                  var columns = this.columns;
                  for (i2 = 0; i2 < columns; ++i2) {
                    for (var kk = 0; kk < colors; ++kk) {
                      if (inbits < bits) {
                        inbuf = inbuf << 8 | rawBytes[j2++] & 255;
                        inbits += 8;
                      }
                      compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                      inbits -= bits;
                      outbuf = outbuf << bits | compArray[kk];
                      outbits += bits;
                      if (outbits >= 8) {
                        buffer[k2++] = outbuf >> outbits - 8 & 255;
                        outbits -= 8;
                      }
                    }
                  }
                  if (outbits > 0) {
                    buffer[k2++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                  }
                }
                this.bufferLength += rowBytes;
              };
              PredictorStream2.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                var rowBytes = this.rowBytes;
                var pixBytes = this.pixBytes;
                var predictor = this.str.getByte();
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                if (prevRow.length === 0) {
                  prevRow = new Uint8Array(rowBytes);
                }
                var i2, j2 = bufferLength, up, c2;
                switch (predictor) {
                  case 0:
                    for (i2 = 0; i2 < rowBytes; ++i2) {
                      buffer[j2++] = rawBytes[i2];
                    }
                    break;
                  case 1:
                    for (i2 = 0; i2 < pixBytes; ++i2) {
                      buffer[j2++] = rawBytes[i2];
                    }
                    for (; i2 < rowBytes; ++i2) {
                      buffer[j2] = buffer[j2 - pixBytes] + rawBytes[i2] & 255;
                      j2++;
                    }
                    break;
                  case 2:
                    for (i2 = 0; i2 < rowBytes; ++i2) {
                      buffer[j2++] = prevRow[i2] + rawBytes[i2] & 255;
                    }
                    break;
                  case 3:
                    for (i2 = 0; i2 < pixBytes; ++i2) {
                      buffer[j2++] = (prevRow[i2] >> 1) + rawBytes[i2];
                    }
                    for (; i2 < rowBytes; ++i2) {
                      buffer[j2] = (prevRow[i2] + buffer[j2 - pixBytes] >> 1) + rawBytes[i2] & 255;
                      j2++;
                    }
                    break;
                  case 4:
                    for (i2 = 0; i2 < pixBytes; ++i2) {
                      up = prevRow[i2];
                      c2 = rawBytes[i2];
                      buffer[j2++] = up + c2;
                    }
                    for (; i2 < rowBytes; ++i2) {
                      up = prevRow[i2];
                      var upLeft = prevRow[i2 - pixBytes];
                      var left = buffer[j2 - pixBytes];
                      var p = left + up - upLeft;
                      var pa = p - left;
                      if (pa < 0) {
                        pa = -pa;
                      }
                      var pb = p - up;
                      if (pb < 0) {
                        pb = -pb;
                      }
                      var pc = p - upLeft;
                      if (pc < 0) {
                        pc = -pc;
                      }
                      c2 = rawBytes[i2];
                      if (pa <= pb && pa <= pc) {
                        buffer[j2++] = left + c2;
                      } else if (pb <= pc) {
                        buffer[j2++] = up + c2;
                      } else {
                        buffer[j2++] = upLeft + c2;
                      }
                    }
                    break;
                  default:
                    throw new _util2.FormatError(`Unsupported predictor: ${predictor}`);
                }
                this.bufferLength += rowBytes;
              };
              return PredictorStream2;
            }();
            exports3.PredictorStream = PredictorStream;
            var DecryptStream = function DecryptStreamClosure() {
              function DecryptStream2(str, maybeLength, decrypt) {
                this.str = str;
                this.dict = str.dict;
                this.decrypt = decrypt;
                this.nextChunk = null;
                this.initialized = false;
                DecodeStream.call(this, maybeLength);
              }
              var chunkSize = 512;
              DecryptStream2.prototype = Object.create(DecodeStream.prototype);
              DecryptStream2.prototype.readBlock = function DecryptStream_readBlock() {
                var chunk;
                if (this.initialized) {
                  chunk = this.nextChunk;
                } else {
                  chunk = this.str.getBytes(chunkSize);
                  this.initialized = true;
                }
                if (!chunk || chunk.length === 0) {
                  this.eof = true;
                  return;
                }
                this.nextChunk = this.str.getBytes(chunkSize);
                var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                var decrypt = this.decrypt;
                chunk = decrypt(chunk, !hasMoreData);
                var bufferLength = this.bufferLength;
                var i2, n2 = chunk.length;
                var buffer = this.ensureBuffer(bufferLength + n2);
                for (i2 = 0; i2 < n2; i2++) {
                  buffer[bufferLength++] = chunk[i2];
                }
                this.bufferLength = bufferLength;
              };
              return DecryptStream2;
            }();
            exports3.DecryptStream = DecryptStream;
            var Ascii85Stream = function Ascii85StreamClosure() {
              function Ascii85Stream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.input = new Uint8Array(5);
                if (maybeLength) {
                  maybeLength = 0.8 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              Ascii85Stream2.prototype = Object.create(DecodeStream.prototype);
              Ascii85Stream2.prototype.readBlock = function Ascii85Stream_readBlock() {
                var TILDA_CHAR = 126;
                var Z_LOWER_CHAR = 122;
                var EOF = -1;
                var str = this.str;
                var c2 = str.getByte();
                while ((0, _core_utils.isWhiteSpace)(c2)) {
                  c2 = str.getByte();
                }
                if (c2 === EOF || c2 === TILDA_CHAR) {
                  this.eof = true;
                  return;
                }
                var bufferLength = this.bufferLength, buffer;
                var i2;
                if (c2 === Z_LOWER_CHAR) {
                  buffer = this.ensureBuffer(bufferLength + 4);
                  for (i2 = 0; i2 < 4; ++i2) {
                    buffer[bufferLength + i2] = 0;
                  }
                  this.bufferLength += 4;
                } else {
                  var input = this.input;
                  input[0] = c2;
                  for (i2 = 1; i2 < 5; ++i2) {
                    c2 = str.getByte();
                    while ((0, _core_utils.isWhiteSpace)(c2)) {
                      c2 = str.getByte();
                    }
                    input[i2] = c2;
                    if (c2 === EOF || c2 === TILDA_CHAR) {
                      break;
                    }
                  }
                  buffer = this.ensureBuffer(bufferLength + i2 - 1);
                  this.bufferLength += i2 - 1;
                  if (i2 < 5) {
                    for (; i2 < 5; ++i2) {
                      input[i2] = 33 + 84;
                    }
                    this.eof = true;
                  }
                  var t2 = 0;
                  for (i2 = 0; i2 < 5; ++i2) {
                    t2 = t2 * 85 + (input[i2] - 33);
                  }
                  for (i2 = 3; i2 >= 0; --i2) {
                    buffer[bufferLength + i2] = t2 & 255;
                    t2 >>= 8;
                  }
                }
              };
              return Ascii85Stream2;
            }();
            exports3.Ascii85Stream = Ascii85Stream;
            var AsciiHexStream = function AsciiHexStreamClosure() {
              function AsciiHexStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.firstDigit = -1;
                if (maybeLength) {
                  maybeLength = 0.5 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              AsciiHexStream2.prototype = Object.create(DecodeStream.prototype);
              AsciiHexStream2.prototype.readBlock = function AsciiHexStream_readBlock() {
                var UPSTREAM_BLOCK_SIZE = 8e3;
                var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                if (!bytes.length) {
                  this.eof = true;
                  return;
                }
                var maxDecodeLength = bytes.length + 1 >> 1;
                var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                var bufferLength = this.bufferLength;
                var firstDigit = this.firstDigit;
                for (var i2 = 0, ii = bytes.length; i2 < ii; i2++) {
                  var ch = bytes[i2], digit;
                  if (ch >= 48 && ch <= 57) {
                    digit = ch & 15;
                  } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    digit = (ch & 15) + 9;
                  } else if (ch === 62) {
                    this.eof = true;
                    break;
                  } else {
                    continue;
                  }
                  if (firstDigit < 0) {
                    firstDigit = digit;
                  } else {
                    buffer[bufferLength++] = firstDigit << 4 | digit;
                    firstDigit = -1;
                  }
                }
                if (firstDigit >= 0 && this.eof) {
                  buffer[bufferLength++] = firstDigit << 4;
                  firstDigit = -1;
                }
                this.firstDigit = firstDigit;
                this.bufferLength = bufferLength;
              };
              return AsciiHexStream2;
            }();
            exports3.AsciiHexStream = AsciiHexStream;
            var RunLengthStream = function RunLengthStreamClosure() {
              function RunLengthStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                DecodeStream.call(this, maybeLength);
              }
              RunLengthStream2.prototype = Object.create(DecodeStream.prototype);
              RunLengthStream2.prototype.readBlock = function RunLengthStream_readBlock() {
                var repeatHeader = this.str.getBytes(2);
                if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                  this.eof = true;
                  return;
                }
                var buffer;
                var bufferLength = this.bufferLength;
                var n2 = repeatHeader[0];
                if (n2 < 128) {
                  buffer = this.ensureBuffer(bufferLength + n2 + 1);
                  buffer[bufferLength++] = repeatHeader[1];
                  if (n2 > 0) {
                    var source = this.str.getBytes(n2);
                    buffer.set(source, bufferLength);
                    bufferLength += n2;
                  }
                } else {
                  n2 = 257 - n2;
                  var b2 = repeatHeader[1];
                  buffer = this.ensureBuffer(bufferLength + n2 + 1);
                  for (var i2 = 0; i2 < n2; i2++) {
                    buffer[bufferLength++] = b2;
                  }
                }
                this.bufferLength = bufferLength;
              };
              return RunLengthStream2;
            }();
            exports3.RunLengthStream = RunLengthStream;
            var LZWStream = function LZWStreamClosure() {
              function LZWStream2(str, maybeLength, earlyChange) {
                this.str = str;
                this.dict = str.dict;
                this.cachedData = 0;
                this.bitsCached = 0;
                var maxLzwDictionarySize = 4096;
                var lzwState = {
                  earlyChange,
                  codeLength: 9,
                  nextCode: 258,
                  dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                  dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                  dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                  currentSequence: new Uint8Array(maxLzwDictionarySize),
                  currentSequenceLength: 0
                };
                for (var i2 = 0; i2 < 256; ++i2) {
                  lzwState.dictionaryValues[i2] = i2;
                  lzwState.dictionaryLengths[i2] = 1;
                }
                this.lzwState = lzwState;
                DecodeStream.call(this, maybeLength);
              }
              LZWStream2.prototype = Object.create(DecodeStream.prototype);
              LZWStream2.prototype.readBits = function LZWStream_readBits(n2) {
                var bitsCached = this.bitsCached;
                var cachedData = this.cachedData;
                while (bitsCached < n2) {
                  var c2 = this.str.getByte();
                  if (c2 === -1) {
                    this.eof = true;
                    return null;
                  }
                  cachedData = cachedData << 8 | c2;
                  bitsCached += 8;
                }
                this.bitsCached = bitsCached -= n2;
                this.cachedData = cachedData;
                this.lastCode = null;
                return cachedData >>> bitsCached & (1 << n2) - 1;
              };
              LZWStream2.prototype.readBlock = function LZWStream_readBlock() {
                var blockSize = 512;
                var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
                var i2, j2, q2;
                var lzwState = this.lzwState;
                if (!lzwState) {
                  return;
                }
                var earlyChange = lzwState.earlyChange;
                var nextCode = lzwState.nextCode;
                var dictionaryValues = lzwState.dictionaryValues;
                var dictionaryLengths = lzwState.dictionaryLengths;
                var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                var codeLength = lzwState.codeLength;
                var prevCode = lzwState.prevCode;
                var currentSequence = lzwState.currentSequence;
                var currentSequenceLength = lzwState.currentSequenceLength;
                var decodedLength = 0;
                var currentBufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                for (i2 = 0; i2 < blockSize; i2++) {
                  var code = this.readBits(codeLength);
                  var hasPrev = currentSequenceLength > 0;
                  if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                  } else if (code >= 258) {
                    if (code < nextCode) {
                      currentSequenceLength = dictionaryLengths[code];
                      for (j2 = currentSequenceLength - 1, q2 = code; j2 >= 0; j2--) {
                        currentSequence[j2] = dictionaryValues[q2];
                        q2 = dictionaryPrevCodes[q2];
                      }
                    } else {
                      currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                  } else if (code === 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                  } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                  }
                  if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                  }
                  prevCode = code;
                  decodedLength += currentSequenceLength;
                  if (estimatedDecodedSize < decodedLength) {
                    do {
                      estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  }
                  for (j2 = 0; j2 < currentSequenceLength; j2++) {
                    buffer[currentBufferLength++] = currentSequence[j2];
                  }
                }
                lzwState.nextCode = nextCode;
                lzwState.codeLength = codeLength;
                lzwState.prevCode = prevCode;
                lzwState.currentSequenceLength = currentSequenceLength;
                this.bufferLength = currentBufferLength;
              };
              return LZWStream2;
            }();
            exports3.LZWStream = LZWStream;
            var NullStream = function NullStreamClosure() {
              function NullStream2() {
                Stream.call(this, new Uint8Array(0));
              }
              NullStream2.prototype = Stream.prototype;
              return NullStream2;
            }();
            exports3.NullStream = NullStream;
          },
          /* 12 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CCITTFaxStream = void 0;
            var _primitives = __w_pdfjs_require__2(4);
            var _ccitt = __w_pdfjs_require__2(13);
            var _stream = __w_pdfjs_require__2(11);
            var CCITTFaxStream = function CCITTFaxStreamClosure() {
              function CCITTFaxStream2(str, maybeLength, params) {
                this.str = str;
                this.dict = str.dict;
                if (!(0, _primitives.isDict)(params)) {
                  params = _primitives.Dict.empty;
                }
                const source = {
                  next() {
                    return str.getByte();
                  }
                };
                this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
                  K: params.get("K"),
                  EndOfLine: params.get("EndOfLine"),
                  EncodedByteAlign: params.get("EncodedByteAlign"),
                  Columns: params.get("Columns"),
                  Rows: params.get("Rows"),
                  EndOfBlock: params.get("EndOfBlock"),
                  BlackIs1: params.get("BlackIs1")
                });
                _stream.DecodeStream.call(this, maybeLength);
              }
              CCITTFaxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              CCITTFaxStream2.prototype.readBlock = function() {
                while (!this.eof) {
                  const c2 = this.ccittFaxDecoder.readNextChar();
                  if (c2 === -1) {
                    this.eof = true;
                    return;
                  }
                  this.ensureBuffer(this.bufferLength + 1);
                  this.buffer[this.bufferLength++] = c2;
                }
              };
              return CCITTFaxStream2;
            }();
            exports3.CCITTFaxStream = CCITTFaxStream;
          },
          /* 13 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CCITTFaxDecoder = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const CCITTFaxDecoder = function CCITTFaxDecoder2() {
              const ccittEOL = -2;
              const ccittEOF = -1;
              const twoDimPass = 0;
              const twoDimHoriz = 1;
              const twoDimVert0 = 2;
              const twoDimVertR1 = 3;
              const twoDimVertL1 = 4;
              const twoDimVertR2 = 5;
              const twoDimVertL2 = 6;
              const twoDimVertR3 = 7;
              const twoDimVertL3 = 8;
              const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
              const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
              const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
              const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
              const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
              const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
              function CCITTFaxDecoder3(source, options = {}) {
                if (!source || typeof source.next !== "function") {
                  throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
                }
                this.source = source;
                this.eof = false;
                this.encoding = options["K"] || 0;
                this.eoline = options["EndOfLine"] || false;
                this.byteAlign = options["EncodedByteAlign"] || false;
                this.columns = options["Columns"] || 1728;
                this.rows = options["Rows"] || 0;
                let eoblock = options["EndOfBlock"];
                if (eoblock === null || eoblock === void 0) {
                  eoblock = true;
                }
                this.eoblock = eoblock;
                this.black = options["BlackIs1"] || false;
                this.codingLine = new Uint32Array(this.columns + 1);
                this.refLine = new Uint32Array(this.columns + 2);
                this.codingLine[0] = this.columns;
                this.codingPos = 0;
                this.row = 0;
                this.nextLine2D = this.encoding < 0;
                this.inputBits = 0;
                this.inputBuf = 0;
                this.outputBits = 0;
                this.rowsDone = false;
                let code1;
                while ((code1 = this._lookBits(12)) === 0) {
                  this._eatBits(1);
                }
                if (code1 === 1) {
                  this._eatBits(12);
                }
                if (this.encoding > 0) {
                  this.nextLine2D = !this._lookBits(1);
                  this._eatBits(1);
                }
              }
              CCITTFaxDecoder3.prototype = {
                readNextChar() {
                  if (this.eof) {
                    return -1;
                  }
                  const refLine = this.refLine;
                  const codingLine = this.codingLine;
                  const columns = this.columns;
                  let refPos, blackPixels, bits, i2;
                  if (this.outputBits === 0) {
                    if (this.rowsDone) {
                      this.eof = true;
                    }
                    if (this.eof) {
                      return -1;
                    }
                    this.err = false;
                    let code1, code2, code3;
                    if (this.nextLine2D) {
                      for (i2 = 0; codingLine[i2] < columns; ++i2) {
                        refLine[i2] = codingLine[i2];
                      }
                      refLine[i2++] = columns;
                      refLine[i2] = columns;
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      refPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = this._getTwoDimCode();
                        switch (code1) {
                          case twoDimPass:
                            this._addPixels(refLine[refPos + 1], blackPixels);
                            if (refLine[refPos + 1] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimHoriz:
                            code1 = code2 = 0;
                            if (blackPixels) {
                              do {
                                code1 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                            } else {
                              do {
                                code1 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                            }
                            this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                            if (codingLine[this.codingPos] < columns) {
                              this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                            }
                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimVertR3:
                            this._addPixels(refLine[refPos] + 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR2:
                            this._addPixels(refLine[refPos] + 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR1:
                            this._addPixels(refLine[refPos] + 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVert0:
                            this._addPixels(refLine[refPos], blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL3:
                            this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL2:
                            this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL1:
                            this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case ccittEOF:
                            this._addPixels(columns, 0);
                            this.eof = true;
                            break;
                          default:
                            (0, _util2.info)("bad 2d code");
                            this._addPixels(columns, 0);
                            this.err = true;
                        }
                      }
                    } else {
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = 0;
                        if (blackPixels) {
                          do {
                            code1 += code3 = this._getBlackCode();
                          } while (code3 >= 64);
                        } else {
                          do {
                            code1 += code3 = this._getWhiteCode();
                          } while (code3 >= 64);
                        }
                        this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                        blackPixels ^= 1;
                      }
                    }
                    let gotEOL = false;
                    if (this.byteAlign) {
                      this.inputBits &= ~7;
                    }
                    if (!this.eoblock && this.row === this.rows - 1) {
                      this.rowsDone = true;
                    } else {
                      code1 = this._lookBits(12);
                      if (this.eoline) {
                        while (code1 !== ccittEOF && code1 !== 1) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      } else {
                        while (code1 === 0) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      }
                      if (code1 === 1) {
                        this._eatBits(12);
                        gotEOL = true;
                      } else if (code1 === ccittEOF) {
                        this.eof = true;
                      }
                    }
                    if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                      this.nextLine2D = !this._lookBits(1);
                      this._eatBits(1);
                    }
                    if (this.eoblock && gotEOL && this.byteAlign) {
                      code1 = this._lookBits(12);
                      if (code1 === 1) {
                        this._eatBits(12);
                        if (this.encoding > 0) {
                          this._lookBits(1);
                          this._eatBits(1);
                        }
                        if (this.encoding >= 0) {
                          for (i2 = 0; i2 < 4; ++i2) {
                            code1 = this._lookBits(12);
                            if (code1 !== 1) {
                              (0, _util2.info)("bad rtc code: " + code1);
                            }
                            this._eatBits(12);
                            if (this.encoding > 0) {
                              this._lookBits(1);
                              this._eatBits(1);
                            }
                          }
                        }
                        this.eof = true;
                      }
                    } else if (this.err && this.eoline) {
                      while (true) {
                        code1 = this._lookBits(13);
                        if (code1 === ccittEOF) {
                          this.eof = true;
                          return -1;
                        }
                        if (code1 >> 1 === 1) {
                          break;
                        }
                        this._eatBits(1);
                      }
                      this._eatBits(12);
                      if (this.encoding > 0) {
                        this._eatBits(1);
                        this.nextLine2D = !(code1 & 1);
                      }
                    }
                    if (codingLine[0] > 0) {
                      this.outputBits = codingLine[this.codingPos = 0];
                    } else {
                      this.outputBits = codingLine[this.codingPos = 1];
                    }
                    this.row++;
                  }
                  let c2;
                  if (this.outputBits >= 8) {
                    c2 = this.codingPos & 1 ? 0 : 255;
                    this.outputBits -= 8;
                    if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                      this.codingPos++;
                      this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                    }
                  } else {
                    bits = 8;
                    c2 = 0;
                    do {
                      if (this.outputBits > bits) {
                        c2 <<= bits;
                        if (!(this.codingPos & 1)) {
                          c2 |= 255 >> 8 - bits;
                        }
                        this.outputBits -= bits;
                        bits = 0;
                      } else {
                        c2 <<= this.outputBits;
                        if (!(this.codingPos & 1)) {
                          c2 |= 255 >> 8 - this.outputBits;
                        }
                        bits -= this.outputBits;
                        this.outputBits = 0;
                        if (codingLine[this.codingPos] < columns) {
                          this.codingPos++;
                          this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                        } else if (bits > 0) {
                          c2 <<= bits;
                          bits = 0;
                        }
                      }
                    } while (bits);
                  }
                  if (this.black) {
                    c2 ^= 255;
                  }
                  return c2;
                },
                _addPixels(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util2.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                },
                _addPixelsNeg(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util2.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  } else if (a1 < codingLine[codingPos]) {
                    if (a1 < 0) {
                      (0, _util2.info)("invalid code");
                      this.err = true;
                      a1 = 0;
                    }
                    while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                      --codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                },
                _findTableCode(start, end, table, limit) {
                  const limitValue = limit || 0;
                  for (let i2 = start; i2 <= end; ++i2) {
                    let code = this._lookBits(i2);
                    if (code === ccittEOF) {
                      return [true, 1, false];
                    }
                    if (i2 < end) {
                      code <<= end - i2;
                    }
                    if (!limitValue || code >= limitValue) {
                      const p = table[code - limitValue];
                      if (p[0] === i2) {
                        this._eatBits(i2);
                        return [true, p[1], true];
                      }
                    }
                  }
                  return [false, 0, false];
                },
                _getTwoDimCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(7);
                    p = twoDimTable[code];
                    if (p && p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    const result = this._findTableCode(1, 7, twoDimTable);
                    if (result[0] && result[2]) {
                      return result[1];
                    }
                  }
                  (0, _util2.info)("Bad two dim code");
                  return ccittEOF;
                },
                _getWhiteCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(12);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 5 === 0) {
                      p = whiteTable1[code];
                    } else {
                      p = whiteTable2[code >> 3];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(1, 9, whiteTable2);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(11, 12, whiteTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util2.info)("bad white code");
                  this._eatBits(1);
                  return 1;
                },
                _getBlackCode() {
                  let code, p;
                  if (this.eoblock) {
                    code = this._lookBits(13);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 7 === 0) {
                      p = blackTable1[code];
                    } else if (code >> 9 === 0 && code >> 7 !== 0) {
                      p = blackTable2[(code >> 1) - 64];
                    } else {
                      p = blackTable3[code >> 7];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(2, 6, blackTable3);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(7, 12, blackTable2, 64);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(10, 13, blackTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util2.info)("bad black code");
                  this._eatBits(1);
                  return 1;
                },
                _lookBits(n2) {
                  let c2;
                  while (this.inputBits < n2) {
                    if ((c2 = this.source.next()) === -1) {
                      if (this.inputBits === 0) {
                        return ccittEOF;
                      }
                      return this.inputBuf << n2 - this.inputBits & 65535 >> 16 - n2;
                    }
                    this.inputBuf = this.inputBuf << 8 | c2;
                    this.inputBits += 8;
                  }
                  return this.inputBuf >> this.inputBits - n2 & 65535 >> 16 - n2;
                },
                _eatBits(n2) {
                  if ((this.inputBits -= n2) < 0) {
                    this.inputBits = 0;
                  }
                }
              };
              return CCITTFaxDecoder3;
            }();
            exports3.CCITTFaxDecoder = CCITTFaxDecoder;
          },
          /* 14 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Jbig2Stream = void 0;
            var _primitives = __w_pdfjs_require__2(4);
            var _stream = __w_pdfjs_require__2(11);
            var _jbig = __w_pdfjs_require__2(15);
            var _util2 = __w_pdfjs_require__2(2);
            const Jbig2Stream = function Jbig2StreamClosure() {
              function Jbig2Stream2(stream, maybeLength, dict, params) {
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              Jbig2Stream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(Jbig2Stream2.prototype, "bytes", {
                get() {
                  return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              Jbig2Stream2.prototype.ensureBuffer = function(requested) {
              };
              Jbig2Stream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                const jbig2Image = new _jbig.Jbig2Image();
                const chunks = [];
                if ((0, _primitives.isDict)(this.params)) {
                  const globalsStream = this.params.get("JBIG2Globals");
                  if ((0, _primitives.isStream)(globalsStream)) {
                    const globals = globalsStream.getBytes();
                    chunks.push({
                      data: globals,
                      start: 0,
                      end: globals.length
                    });
                  }
                }
                chunks.push({
                  data: this.bytes,
                  start: 0,
                  end: this.bytes.length
                });
                const data = jbig2Image.parseChunks(chunks);
                const dataLength = data.length;
                for (let i2 = 0; i2 < dataLength; i2++) {
                  data[i2] ^= 255;
                }
                this.buffer = data;
                this.bufferLength = dataLength;
                this.eof = true;
              };
              return Jbig2Stream2;
            }();
            exports3.Jbig2Stream = Jbig2Stream;
          },
          /* 15 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Jbig2Image = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _core_utils = __w_pdfjs_require__2(7);
            var _arithmetic_decoder = __w_pdfjs_require__2(16);
            var _ccitt = __w_pdfjs_require__2(13);
            class Jbig2Error extends _util2.BaseException {
              constructor(msg) {
                super(`JBIG2 error: ${msg}`);
              }
            }
            var Jbig2Image = function Jbig2ImageClosure() {
              function ContextCache() {
              }
              ContextCache.prototype = {
                getContexts(id) {
                  if (id in this) {
                    return this[id];
                  }
                  return this[id] = new Int8Array(1 << 16);
                }
              };
              function DecodingContext(data, start, end) {
                this.data = data;
                this.start = start;
                this.end = end;
              }
              DecodingContext.prototype = {
                get decoder() {
                  var decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
                  return (0, _util2.shadow)(this, "decoder", decoder);
                },
                get contextCache() {
                  var cache = new ContextCache();
                  return (0, _util2.shadow)(this, "contextCache", cache);
                }
              };
              function decodeInteger(contextCache, procedure, decoder) {
                var contexts = contextCache.getContexts(procedure);
                var prev = 1;
                function readBits(length) {
                  var v2 = 0;
                  for (var i2 = 0; i2 < length; i2++) {
                    var bit = decoder.readBit(contexts, prev);
                    prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
                    v2 = v2 << 1 | bit;
                  }
                  return v2 >>> 0;
                }
                var sign = readBits(1);
                var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
                if (sign === 0) {
                  return value;
                } else if (value > 0) {
                  return -value;
                }
                return null;
              }
              function decodeIAID(contextCache, decoder, codeLength) {
                var contexts = contextCache.getContexts("IAID");
                var prev = 1;
                for (var i2 = 0; i2 < codeLength; i2++) {
                  var bit = decoder.readBit(contexts, prev);
                  prev = prev << 1 | bit;
                }
                if (codeLength < 31) {
                  return prev & (1 << codeLength) - 1;
                }
                return prev & 2147483647;
              }
              var SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
              var CodingTemplates = [[{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: 2,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -3,
                y: -1
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }]];
              var RefinementTemplates = [{
                coding: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: -1,
                  y: 1
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }, {
                coding: [{
                  x: -1,
                  y: -1
                }, {
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }];
              var ReusedContexts = [39717, 1941, 229, 405];
              var RefinementReusedContexts = [32, 8];
              function decodeBitmapTemplate0(width, height, decodingContext) {
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GB");
                var contextLabel, i2, j2, pixel, row, row1, row2, bitmap = [];
                var OLD_PIXEL_MASK = 31735;
                for (i2 = 0; i2 < height; i2++) {
                  row = bitmap[i2] = new Uint8Array(width);
                  row1 = i2 < 1 ? row : bitmap[i2 - 1];
                  row2 = i2 < 2 ? row : bitmap[i2 - 2];
                  contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
                  for (j2 = 0; j2 < width; j2++) {
                    row[j2] = pixel = decoder.readBit(contexts, contextLabel);
                    contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j2 + 3 < width ? row2[j2 + 3] << 11 : 0) | (j2 + 4 < width ? row1[j2 + 4] << 4 : 0) | pixel;
                  }
                }
                return bitmap;
              }
              function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                if (mmr) {
                  const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                  return decodeMMRBitmap(input, width, height, false);
                }
                if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                  return decodeBitmapTemplate0(width, height, decodingContext);
                }
                var useskip = !!skip;
                var template = CodingTemplates[templateIndex].concat(at);
                template.sort(function(a2, b2) {
                  return a2.y - b2.y || a2.x - b2.x;
                });
                var templateLength = template.length;
                var templateX = new Int8Array(templateLength);
                var templateY = new Int8Array(templateLength);
                var changingTemplateEntries = [];
                var reuseMask = 0, minX = 0, maxX = 0, minY = 0;
                var c2, k2;
                for (k2 = 0; k2 < templateLength; k2++) {
                  templateX[k2] = template[k2].x;
                  templateY[k2] = template[k2].y;
                  minX = Math.min(minX, template[k2].x);
                  maxX = Math.max(maxX, template[k2].x);
                  minY = Math.min(minY, template[k2].y);
                  if (k2 < templateLength - 1 && template[k2].y === template[k2 + 1].y && template[k2].x === template[k2 + 1].x - 1) {
                    reuseMask |= 1 << templateLength - 1 - k2;
                  } else {
                    changingTemplateEntries.push(k2);
                  }
                }
                var changingEntriesLength = changingTemplateEntries.length;
                var changingTemplateX = new Int8Array(changingEntriesLength);
                var changingTemplateY = new Int8Array(changingEntriesLength);
                var changingTemplateBit = new Uint16Array(changingEntriesLength);
                for (c2 = 0; c2 < changingEntriesLength; c2++) {
                  k2 = changingTemplateEntries[c2];
                  changingTemplateX[c2] = template[k2].x;
                  changingTemplateY[c2] = template[k2].y;
                  changingTemplateBit[c2] = 1 << templateLength - 1 - k2;
                }
                var sbb_left = -minX;
                var sbb_top = -minY;
                var sbb_right = width - maxX;
                var pseudoPixelContext = ReusedContexts[templateIndex];
                var row = new Uint8Array(width);
                var bitmap = [];
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GB");
                var ltp = 0, j2, i0, j0, contextLabel = 0, bit, shift;
                for (var i2 = 0; i2 < height; i2++) {
                  if (prediction) {
                    var sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      bitmap.push(row);
                      continue;
                    }
                  }
                  row = new Uint8Array(row);
                  bitmap.push(row);
                  for (j2 = 0; j2 < width; j2++) {
                    if (useskip && skip[i2][j2]) {
                      row[j2] = 0;
                      continue;
                    }
                    if (j2 >= sbb_left && j2 < sbb_right && i2 >= sbb_top) {
                      contextLabel = contextLabel << 1 & reuseMask;
                      for (k2 = 0; k2 < changingEntriesLength; k2++) {
                        i0 = i2 + changingTemplateY[k2];
                        j0 = j2 + changingTemplateX[k2];
                        bit = bitmap[i0][j0];
                        if (bit) {
                          bit = changingTemplateBit[k2];
                          contextLabel |= bit;
                        }
                      }
                    } else {
                      contextLabel = 0;
                      shift = templateLength - 1;
                      for (k2 = 0; k2 < templateLength; k2++, shift--) {
                        j0 = j2 + templateX[k2];
                        if (j0 >= 0 && j0 < width) {
                          i0 = i2 + templateY[k2];
                          if (i0 >= 0) {
                            bit = bitmap[i0][j0];
                            if (bit) {
                              contextLabel |= bit << shift;
                            }
                          }
                        }
                      }
                    }
                    var pixel = decoder.readBit(contexts, contextLabel);
                    row[j2] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                var codingTemplate = RefinementTemplates[templateIndex].coding;
                if (templateIndex === 0) {
                  codingTemplate = codingTemplate.concat([at[0]]);
                }
                var codingTemplateLength = codingTemplate.length;
                var codingTemplateX = new Int32Array(codingTemplateLength);
                var codingTemplateY = new Int32Array(codingTemplateLength);
                var k2;
                for (k2 = 0; k2 < codingTemplateLength; k2++) {
                  codingTemplateX[k2] = codingTemplate[k2].x;
                  codingTemplateY[k2] = codingTemplate[k2].y;
                }
                var referenceTemplate = RefinementTemplates[templateIndex].reference;
                if (templateIndex === 0) {
                  referenceTemplate = referenceTemplate.concat([at[1]]);
                }
                var referenceTemplateLength = referenceTemplate.length;
                var referenceTemplateX = new Int32Array(referenceTemplateLength);
                var referenceTemplateY = new Int32Array(referenceTemplateLength);
                for (k2 = 0; k2 < referenceTemplateLength; k2++) {
                  referenceTemplateX[k2] = referenceTemplate[k2].x;
                  referenceTemplateY[k2] = referenceTemplate[k2].y;
                }
                var referenceWidth = referenceBitmap[0].length;
                var referenceHeight = referenceBitmap.length;
                var pseudoPixelContext = RefinementReusedContexts[templateIndex];
                var bitmap = [];
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GR");
                var ltp = 0;
                for (var i2 = 0; i2 < height; i2++) {
                  if (prediction) {
                    var sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      throw new Jbig2Error("prediction is not supported");
                    }
                  }
                  var row = new Uint8Array(width);
                  bitmap.push(row);
                  for (var j2 = 0; j2 < width; j2++) {
                    var i0, j0;
                    var contextLabel = 0;
                    for (k2 = 0; k2 < codingTemplateLength; k2++) {
                      i0 = i2 + codingTemplateY[k2];
                      j0 = j2 + codingTemplateX[k2];
                      if (i0 < 0 || j0 < 0 || j0 >= width) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | bitmap[i0][j0];
                      }
                    }
                    for (k2 = 0; k2 < referenceTemplateLength; k2++) {
                      i0 = i2 + referenceTemplateY[k2] - offsetY;
                      j0 = j2 + referenceTemplateX[k2] - offsetX;
                      if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
                      }
                    }
                    var pixel = decoder.readBit(contexts, contextLabel);
                    row[j2] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("symbol refinement with Huffman is not supported");
                }
                var newSymbols = [];
                var currentHeight = 0;
                var symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
                var decoder = decodingContext.decoder;
                var contextCache = decodingContext.contextCache;
                let tableB1, symbolWidths;
                if (huffman) {
                  tableB1 = getStandardTable(1);
                  symbolWidths = [];
                  symbolCodeLength = Math.max(symbolCodeLength, 1);
                }
                while (newSymbols.length < numberOfNewSymbols) {
                  var deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
                  currentHeight += deltaHeight;
                  let currentWidth = 0, totalWidth = 0;
                  const firstSymbol = huffman ? symbolWidths.length : 0;
                  while (true) {
                    var deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
                    if (deltaWidth === null) {
                      break;
                    }
                    currentWidth += deltaWidth;
                    totalWidth += currentWidth;
                    var bitmap;
                    if (refinement) {
                      var numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
                      if (numberOfInstances > 1) {
                        bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
                      } else {
                        var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                        var rdx = decodeInteger(contextCache, "IARDX", decoder);
                        var rdy = decodeInteger(contextCache, "IARDY", decoder);
                        var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
                        bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                      }
                      newSymbols.push(bitmap);
                    } else if (huffman) {
                      symbolWidths.push(currentWidth);
                    } else {
                      bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                      newSymbols.push(bitmap);
                    }
                  }
                  if (huffman && !refinement) {
                    const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
                    huffmanInput.byteAlign();
                    let collectiveBitmap;
                    if (bitmapSize === 0) {
                      collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
                    } else {
                      const originalEnd = huffmanInput.end;
                      const bitmapEnd = huffmanInput.position + bitmapSize;
                      huffmanInput.end = bitmapEnd;
                      collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
                      huffmanInput.end = originalEnd;
                      huffmanInput.position = bitmapEnd;
                    }
                    const numberOfSymbolsDecoded = symbolWidths.length;
                    if (firstSymbol === numberOfSymbolsDecoded - 1) {
                      newSymbols.push(collectiveBitmap);
                    } else {
                      let i3, y2, xMin = 0, xMax, bitmapWidth, symbolBitmap;
                      for (i3 = firstSymbol; i3 < numberOfSymbolsDecoded; i3++) {
                        bitmapWidth = symbolWidths[i3];
                        xMax = xMin + bitmapWidth;
                        symbolBitmap = [];
                        for (y2 = 0; y2 < currentHeight; y2++) {
                          symbolBitmap.push(collectiveBitmap[y2].subarray(xMin, xMax));
                        }
                        newSymbols.push(symbolBitmap);
                        xMin = xMax;
                      }
                    }
                  }
                }
                var exportedSymbols = [];
                var flags = [], currentFlag = false;
                var totalSymbolsLength = symbols.length + numberOfNewSymbols;
                while (flags.length < totalSymbolsLength) {
                  var runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
                  while (runLength--) {
                    flags.push(currentFlag);
                  }
                  currentFlag = !currentFlag;
                }
                for (var i2 = 0, ii = symbols.length; i2 < ii; i2++) {
                  if (flags[i2]) {
                    exportedSymbols.push(symbols[i2]);
                  }
                }
                for (var j2 = 0; j2 < numberOfNewSymbols; i2++, j2++) {
                  if (flags[i2]) {
                    exportedSymbols.push(newSymbols[j2]);
                  }
                }
                return exportedSymbols;
              }
              function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                var bitmap = [];
                var i2, row;
                for (i2 = 0; i2 < height; i2++) {
                  row = new Uint8Array(width);
                  if (defaultPixelValue) {
                    for (var j2 = 0; j2 < width; j2++) {
                      row[j2] = defaultPixelValue;
                    }
                  }
                  bitmap.push(row);
                }
                var decoder = decodingContext.decoder;
                var contextCache = decodingContext.contextCache;
                var stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
                var firstS = 0;
                i2 = 0;
                while (i2 < numberOfSymbolInstances) {
                  var deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
                  stripT += deltaT;
                  var deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
                  firstS += deltaFirstS;
                  var currentS = firstS;
                  do {
                    let currentT = 0;
                    if (stripSize > 1) {
                      currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
                    }
                    var t2 = stripSize * stripT + currentT;
                    var symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
                    var applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
                    var symbolBitmap = inputSymbols[symbolId];
                    var symbolWidth = symbolBitmap[0].length;
                    var symbolHeight = symbolBitmap.length;
                    if (applyRefinement) {
                      var rdw = decodeInteger(contextCache, "IARDW", decoder);
                      var rdh = decodeInteger(contextCache, "IARDH", decoder);
                      var rdx = decodeInteger(contextCache, "IARDX", decoder);
                      var rdy = decodeInteger(contextCache, "IARDY", decoder);
                      symbolWidth += rdw;
                      symbolHeight += rdh;
                      symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                    }
                    var offsetT = t2 - (referenceCorner & 1 ? 0 : symbolHeight - 1);
                    var offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
                    var s2, t22, symbolRow;
                    if (transposed) {
                      for (s2 = 0; s2 < symbolHeight; s2++) {
                        row = bitmap[offsetS + s2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[s2];
                        var maxWidth = Math.min(width - offsetT, symbolWidth);
                        switch (combinationOperator) {
                          case 0:
                            for (t22 = 0; t22 < maxWidth; t22++) {
                              row[offsetT + t22] |= symbolRow[t22];
                            }
                            break;
                          case 2:
                            for (t22 = 0; t22 < maxWidth; t22++) {
                              row[offsetT + t22] ^= symbolRow[t22];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolHeight - 1;
                    } else {
                      for (t22 = 0; t22 < symbolHeight; t22++) {
                        row = bitmap[offsetT + t22];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[t22];
                        switch (combinationOperator) {
                          case 0:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] |= symbolRow[s2];
                            }
                            break;
                          case 2:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] ^= symbolRow[s2];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolWidth - 1;
                    }
                    i2++;
                    var deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
                    if (deltaS === null) {
                      break;
                    }
                    currentS += deltaS + dsOffset;
                  } while (true);
                }
                return bitmap;
              }
              function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
                const at = [];
                if (!mmr) {
                  at.push({
                    x: -patternWidth,
                    y: 0
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    });
                    at.push({
                      x: 2,
                      y: -2
                    });
                    at.push({
                      x: -2,
                      y: -2
                    });
                  }
                }
                const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
                const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
                const patterns = [];
                for (let i2 = 0; i2 <= maxPatternIndex; i2++) {
                  const patternBitmap = [];
                  const xMin = patternWidth * i2;
                  const xMax = xMin + patternWidth;
                  for (let y2 = 0; y2 < patternHeight; y2++) {
                    patternBitmap.push(collectiveBitmap[y2].subarray(xMin, xMax));
                  }
                  patterns.push(patternBitmap);
                }
                return patterns;
              }
              function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
                const skip = null;
                if (enableSkip) {
                  throw new Jbig2Error("skip is not supported");
                }
                if (combinationOperator !== 0) {
                  throw new Jbig2Error("operator " + combinationOperator + " is not supported in halftone region");
                }
                const regionBitmap = [];
                let i2, j2, row;
                for (i2 = 0; i2 < regionHeight; i2++) {
                  row = new Uint8Array(regionWidth);
                  if (defaultPixelValue) {
                    for (j2 = 0; j2 < regionWidth; j2++) {
                      row[j2] = defaultPixelValue;
                    }
                  }
                  regionBitmap.push(row);
                }
                const numberOfPatterns = patterns.length;
                const pattern0 = patterns[0];
                const patternWidth = pattern0[0].length, patternHeight = pattern0.length;
                const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
                const at = [];
                if (!mmr) {
                  at.push({
                    x: template <= 1 ? 3 : 2,
                    y: -1
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    });
                    at.push({
                      x: 2,
                      y: -2
                    });
                    at.push({
                      x: -2,
                      y: -2
                    });
                  }
                }
                const grayScaleBitPlanes = [];
                let mmrInput, bitmap;
                if (mmr) {
                  mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                }
                for (i2 = bitsPerValue - 1; i2 >= 0; i2--) {
                  if (mmr) {
                    bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
                  } else {
                    bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
                  }
                  grayScaleBitPlanes[i2] = bitmap;
                }
                let mg, ng, bit, patternIndex, patternBitmap, x2, y2, patternRow, regionRow;
                for (mg = 0; mg < gridHeight; mg++) {
                  for (ng = 0; ng < gridWidth; ng++) {
                    bit = 0;
                    patternIndex = 0;
                    for (j2 = bitsPerValue - 1; j2 >= 0; j2--) {
                      bit = grayScaleBitPlanes[j2][mg][ng] ^ bit;
                      patternIndex |= bit << j2;
                    }
                    patternBitmap = patterns[patternIndex];
                    x2 = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
                    y2 = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
                    if (x2 >= 0 && x2 + patternWidth <= regionWidth && y2 >= 0 && y2 + patternHeight <= regionHeight) {
                      for (i2 = 0; i2 < patternHeight; i2++) {
                        regionRow = regionBitmap[y2 + i2];
                        patternRow = patternBitmap[i2];
                        for (j2 = 0; j2 < patternWidth; j2++) {
                          regionRow[x2 + j2] |= patternRow[j2];
                        }
                      }
                    } else {
                      let regionX, regionY;
                      for (i2 = 0; i2 < patternHeight; i2++) {
                        regionY = y2 + i2;
                        if (regionY < 0 || regionY >= regionHeight) {
                          continue;
                        }
                        regionRow = regionBitmap[regionY];
                        patternRow = patternBitmap[i2];
                        for (j2 = 0; j2 < patternWidth; j2++) {
                          regionX = x2 + j2;
                          if (regionX >= 0 && regionX < regionWidth) {
                            regionRow[regionX] |= patternRow[j2];
                          }
                        }
                      }
                    }
                  }
                }
                return regionBitmap;
              }
              function readSegmentHeader(data, start) {
                var segmentHeader = {};
                segmentHeader.number = (0, _core_utils.readUint32)(data, start);
                var flags = data[start + 4];
                var segmentType = flags & 63;
                if (!SegmentTypes[segmentType]) {
                  throw new Jbig2Error("invalid segment type: " + segmentType);
                }
                segmentHeader.type = segmentType;
                segmentHeader.typeName = SegmentTypes[segmentType];
                segmentHeader.deferredNonRetain = !!(flags & 128);
                var pageAssociationFieldSize = !!(flags & 64);
                var referredFlags = data[start + 5];
                var referredToCount = referredFlags >> 5 & 7;
                var retainBits = [referredFlags & 31];
                var position = start + 6;
                if (referredFlags === 7) {
                  referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 536870911;
                  position += 3;
                  var bytes = referredToCount + 7 >> 3;
                  retainBits[0] = data[position++];
                  while (--bytes > 0) {
                    retainBits.push(data[position++]);
                  }
                } else if (referredFlags === 5 || referredFlags === 6) {
                  throw new Jbig2Error("invalid referred-to flags");
                }
                segmentHeader.retainBits = retainBits;
                let referredToSegmentNumberSize = 4;
                if (segmentHeader.number <= 256) {
                  referredToSegmentNumberSize = 1;
                } else if (segmentHeader.number <= 65536) {
                  referredToSegmentNumberSize = 2;
                }
                var referredTo = [];
                var i2, ii;
                for (i2 = 0; i2 < referredToCount; i2++) {
                  let number;
                  if (referredToSegmentNumberSize === 1) {
                    number = data[position];
                  } else if (referredToSegmentNumberSize === 2) {
                    number = (0, _core_utils.readUint16)(data, position);
                  } else {
                    number = (0, _core_utils.readUint32)(data, position);
                  }
                  referredTo.push(number);
                  position += referredToSegmentNumberSize;
                }
                segmentHeader.referredTo = referredTo;
                if (!pageAssociationFieldSize) {
                  segmentHeader.pageAssociation = data[position++];
                } else {
                  segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
                  position += 4;
                }
                segmentHeader.length = (0, _core_utils.readUint32)(data, position);
                position += 4;
                if (segmentHeader.length === 4294967295) {
                  if (segmentType === 38) {
                    var genericRegionInfo = readRegionSegmentInformation(data, position);
                    var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
                    var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                    var searchPatternLength = 6;
                    var searchPattern = new Uint8Array(searchPatternLength);
                    if (!genericRegionMmr) {
                      searchPattern[0] = 255;
                      searchPattern[1] = 172;
                    }
                    searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
                    searchPattern[3] = genericRegionInfo.height >> 16 & 255;
                    searchPattern[4] = genericRegionInfo.height >> 8 & 255;
                    searchPattern[5] = genericRegionInfo.height & 255;
                    for (i2 = position, ii = data.length; i2 < ii; i2++) {
                      var j2 = 0;
                      while (j2 < searchPatternLength && searchPattern[j2] === data[i2 + j2]) {
                        j2++;
                      }
                      if (j2 === searchPatternLength) {
                        segmentHeader.length = i2 + searchPatternLength;
                        break;
                      }
                    }
                    if (segmentHeader.length === 4294967295) {
                      throw new Jbig2Error("segment end was not found");
                    }
                  } else {
                    throw new Jbig2Error("invalid unknown segment length");
                  }
                }
                segmentHeader.headerEnd = position;
                return segmentHeader;
              }
              function readSegments(header, data, start, end) {
                var segments = [];
                var position = start;
                while (position < end) {
                  var segmentHeader = readSegmentHeader(data, position);
                  position = segmentHeader.headerEnd;
                  var segment = {
                    header: segmentHeader,
                    data
                  };
                  if (!header.randomAccess) {
                    segment.start = position;
                    position += segmentHeader.length;
                    segment.end = position;
                  }
                  segments.push(segment);
                  if (segmentHeader.type === 51) {
                    break;
                  }
                }
                if (header.randomAccess) {
                  for (var i2 = 0, ii = segments.length; i2 < ii; i2++) {
                    segments[i2].start = position;
                    position += segments[i2].header.length;
                    segments[i2].end = position;
                  }
                }
                return segments;
              }
              function readRegionSegmentInformation(data, start) {
                return {
                  width: (0, _core_utils.readUint32)(data, start),
                  height: (0, _core_utils.readUint32)(data, start + 4),
                  x: (0, _core_utils.readUint32)(data, start + 8),
                  y: (0, _core_utils.readUint32)(data, start + 12),
                  combinationOperator: data[start + 16] & 7
                };
              }
              var RegionSegmentInformationFieldLength = 17;
              function processSegment(segment, visitor) {
                var header = segment.header;
                var data = segment.data, position = segment.start, end = segment.end;
                var args, at, i2, atLength;
                switch (header.type) {
                  case 0:
                    var dictionary = {};
                    var dictionaryFlags = (0, _core_utils.readUint16)(data, position);
                    dictionary.huffman = !!(dictionaryFlags & 1);
                    dictionary.refinement = !!(dictionaryFlags & 2);
                    dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
                    dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
                    dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
                    dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
                    dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                    dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                    dictionary.template = dictionaryFlags >> 10 & 3;
                    dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
                    position += 2;
                    if (!dictionary.huffman) {
                      atLength = dictionary.template === 0 ? 4 : 1;
                      at = [];
                      for (i2 = 0; i2 < atLength; i2++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.at = at;
                    }
                    if (dictionary.refinement && !dictionary.refinementTemplate) {
                      at = [];
                      for (i2 = 0; i2 < 2; i2++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.refinementAt = at;
                    }
                    dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [dictionary, header.number, header.referredTo, data, position, end];
                    break;
                  case 6:
                  case 7:
                    var textRegion = {};
                    textRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    var textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    textRegion.huffman = !!(textRegionSegmentFlags & 1);
                    textRegion.refinement = !!(textRegionSegmentFlags & 2);
                    textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
                    textRegion.stripSize = 1 << textRegion.logStripSize;
                    textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
                    textRegion.transposed = !!(textRegionSegmentFlags & 64);
                    textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
                    textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
                    textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
                    textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
                    if (textRegion.huffman) {
                      var textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      textRegion.huffmanFS = textRegionHuffmanFlags & 3;
                      textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
                      textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
                      textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
                      textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
                      textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
                      textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
                      textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
                    }
                    if (textRegion.refinement && !textRegion.refinementTemplate) {
                      at = [];
                      for (i2 = 0; i2 < 2; i2++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      textRegion.refinementAt = at;
                    }
                    textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [textRegion, header.referredTo, data, position, end];
                    break;
                  case 16:
                    const patternDictionary = {};
                    const patternDictionaryFlags = data[position++];
                    patternDictionary.mmr = !!(patternDictionaryFlags & 1);
                    patternDictionary.template = patternDictionaryFlags >> 1 & 3;
                    patternDictionary.patternWidth = data[position++];
                    patternDictionary.patternHeight = data[position++];
                    patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [patternDictionary, header.number, data, position, end];
                    break;
                  case 22:
                  case 23:
                    const halftoneRegion = {};
                    halftoneRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const halftoneRegionFlags = data[position++];
                    halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
                    halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
                    halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
                    halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
                    halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
                    halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    args = [halftoneRegion, header.referredTo, data, position, end];
                    break;
                  case 38:
                  case 39:
                    var genericRegion = {};
                    genericRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    var genericRegionSegmentFlags = data[position++];
                    genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                    genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
                    genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                    if (!genericRegion.mmr) {
                      atLength = genericRegion.template === 0 ? 4 : 1;
                      at = [];
                      for (i2 = 0; i2 < atLength; i2++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      genericRegion.at = at;
                    }
                    args = [genericRegion, data, position, end];
                    break;
                  case 48:
                    var pageInfo = {
                      width: (0, _core_utils.readUint32)(data, position),
                      height: (0, _core_utils.readUint32)(data, position + 4),
                      resolutionX: (0, _core_utils.readUint32)(data, position + 8),
                      resolutionY: (0, _core_utils.readUint32)(data, position + 12)
                    };
                    if (pageInfo.height === 4294967295) {
                      delete pageInfo.height;
                    }
                    var pageSegmentFlags = data[position + 16];
                    (0, _core_utils.readUint16)(data, position + 17);
                    pageInfo.lossless = !!(pageSegmentFlags & 1);
                    pageInfo.refinement = !!(pageSegmentFlags & 2);
                    pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
                    pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
                    pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                    pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                    args = [pageInfo];
                    break;
                  case 49:
                    break;
                  case 50:
                    break;
                  case 51:
                    break;
                  case 53:
                    args = [header.number, data, position, end];
                    break;
                  case 62:
                    break;
                  default:
                    throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
                }
                var callbackName = "on" + header.typeName;
                if (callbackName in visitor) {
                  visitor[callbackName].apply(visitor, args);
                }
              }
              function processSegments(segments, visitor) {
                for (var i2 = 0, ii = segments.length; i2 < ii; i2++) {
                  processSegment(segments[i2], visitor);
                }
              }
              function parseJbig2Chunks(chunks) {
                var visitor = new SimpleSegmentVisitor();
                for (var i2 = 0, ii = chunks.length; i2 < ii; i2++) {
                  var chunk = chunks[i2];
                  var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                  processSegments(segments, visitor);
                }
                return visitor.buffer;
              }
              function parseJbig2(data) {
                const end = data.length;
                let position = 0;
                if (data[position] !== 151 || data[position + 1] !== 74 || data[position + 2] !== 66 || data[position + 3] !== 50 || data[position + 4] !== 13 || data[position + 5] !== 10 || data[position + 6] !== 26 || data[position + 7] !== 10) {
                  throw new Jbig2Error("parseJbig2 - invalid header.");
                }
                const header = /* @__PURE__ */ Object.create(null);
                position += 8;
                const flags = data[position++];
                header.randomAccess = !(flags & 1);
                if (!(flags & 2)) {
                  header.numberOfPages = (0, _core_utils.readUint32)(data, position);
                  position += 4;
                }
                const segments = readSegments(header, data, position, end);
                const visitor = new SimpleSegmentVisitor();
                processSegments(segments, visitor);
                const {
                  width,
                  height
                } = visitor.currentPageInfo;
                const bitPacked = visitor.buffer;
                const imgData = new Uint8ClampedArray(width * height);
                let q2 = 0, k2 = 0;
                for (let i2 = 0; i2 < height; i2++) {
                  let mask = 0, buffer;
                  for (let j2 = 0; j2 < width; j2++) {
                    if (!mask) {
                      mask = 128;
                      buffer = bitPacked[k2++];
                    }
                    imgData[q2++] = buffer & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                return {
                  imgData,
                  width,
                  height
                };
              }
              function SimpleSegmentVisitor() {
              }
              SimpleSegmentVisitor.prototype = {
                onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
                  this.currentPageInfo = info;
                  var rowSize = info.width + 7 >> 3;
                  var buffer = new Uint8ClampedArray(rowSize * info.height);
                  if (info.defaultPixelValue) {
                    for (var i2 = 0, ii = buffer.length; i2 < ii; i2++) {
                      buffer[i2] = 255;
                    }
                  }
                  this.buffer = buffer;
                },
                drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
                  var pageInfo = this.currentPageInfo;
                  var width = regionInfo.width, height = regionInfo.height;
                  var rowSize = pageInfo.width + 7 >> 3;
                  var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                  var buffer = this.buffer;
                  var mask0 = 128 >> (regionInfo.x & 7);
                  var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                  var i2, j2, mask, offset;
                  switch (combinationOperator) {
                    case 0:
                      for (i2 = 0; i2 < height; i2++) {
                        mask = mask0;
                        offset = offset0;
                        for (j2 = 0; j2 < width; j2++) {
                          if (bitmap[i2][j2]) {
                            buffer[offset] |= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    case 2:
                      for (i2 = 0; i2 < height; i2++) {
                        mask = mask0;
                        offset = offset0;
                        for (j2 = 0; j2 < width; j2++) {
                          if (bitmap[i2][j2]) {
                            buffer[offset] ^= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    default:
                      throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                  }
                },
                onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
                  var regionInfo = region.info;
                  var decodingContext = new DecodingContext(data, start, end);
                  var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
                  this.onImmediateGenericRegion.apply(this, arguments);
                },
                onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                  let huffmanTables, huffmanInput;
                  if (dictionary.huffman) {
                    huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
                    huffmanInput = new Reader(data, start, end);
                  }
                  var symbols = this.symbols;
                  if (!symbols) {
                    this.symbols = symbols = {};
                  }
                  var inputSymbols = [];
                  for (var i2 = 0, ii = referredSegments.length; i2 < ii; i2++) {
                    const referredSymbols = symbols[referredSegments[i2]];
                    if (referredSymbols) {
                      inputSymbols = inputSymbols.concat(referredSymbols);
                    }
                  }
                  var decodingContext = new DecodingContext(data, start, end);
                  symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
                },
                onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
                  var regionInfo = region.info;
                  let huffmanTables, huffmanInput;
                  var symbols = this.symbols;
                  var inputSymbols = [];
                  for (var i2 = 0, ii = referredSegments.length; i2 < ii; i2++) {
                    const referredSymbols = symbols[referredSegments[i2]];
                    if (referredSymbols) {
                      inputSymbols = inputSymbols.concat(referredSymbols);
                    }
                  }
                  var symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
                  if (region.huffman) {
                    huffmanInput = new Reader(data, start, end);
                    huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
                  }
                  var decodingContext = new DecodingContext(data, start, end);
                  var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
                  this.onImmediateTextRegion.apply(this, arguments);
                },
                onPatternDictionary(dictionary, currentSegment, data, start, end) {
                  let patterns = this.patterns;
                  if (!patterns) {
                    this.patterns = patterns = {};
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
                },
                onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
                  const patterns = this.patterns[referredSegments[0]];
                  const regionInfo = region.info;
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessHalftoneRegion() {
                  this.onImmediateHalftoneRegion.apply(this, arguments);
                },
                onTables(currentSegment, data, start, end) {
                  let customTables = this.customTables;
                  if (!customTables) {
                    this.customTables = customTables = {};
                  }
                  customTables[currentSegment] = decodeTablesSegment(data, start, end);
                }
              };
              function HuffmanLine(lineData) {
                if (lineData.length === 2) {
                  this.isOOB = true;
                  this.rangeLow = 0;
                  this.prefixLength = lineData[0];
                  this.rangeLength = 0;
                  this.prefixCode = lineData[1];
                  this.isLowerRange = false;
                } else {
                  this.isOOB = false;
                  this.rangeLow = lineData[0];
                  this.prefixLength = lineData[1];
                  this.rangeLength = lineData[2];
                  this.prefixCode = lineData[3];
                  this.isLowerRange = lineData[4] === "lower";
                }
              }
              function HuffmanTreeNode(line) {
                this.children = [];
                if (line) {
                  this.isLeaf = true;
                  this.rangeLength = line.rangeLength;
                  this.rangeLow = line.rangeLow;
                  this.isLowerRange = line.isLowerRange;
                  this.isOOB = line.isOOB;
                } else {
                  this.isLeaf = false;
                }
              }
              HuffmanTreeNode.prototype = {
                buildTree(line, shift) {
                  const bit = line.prefixCode >> shift & 1;
                  if (shift <= 0) {
                    this.children[bit] = new HuffmanTreeNode(line);
                  } else {
                    let node = this.children[bit];
                    if (!node) {
                      this.children[bit] = node = new HuffmanTreeNode(null);
                    }
                    node.buildTree(line, shift - 1);
                  }
                },
                decodeNode(reader) {
                  if (this.isLeaf) {
                    if (this.isOOB) {
                      return null;
                    }
                    const htOffset = reader.readBits(this.rangeLength);
                    return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
                  }
                  const node = this.children[reader.readBit()];
                  if (!node) {
                    throw new Jbig2Error("invalid Huffman data");
                  }
                  return node.decodeNode(reader);
                }
              };
              function HuffmanTable(lines, prefixCodesDone) {
                if (!prefixCodesDone) {
                  this.assignPrefixCodes(lines);
                }
                this.rootNode = new HuffmanTreeNode(null);
                for (let i2 = 0, ii = lines.length; i2 < ii; i2++) {
                  const line = lines[i2];
                  if (line.prefixLength > 0) {
                    this.rootNode.buildTree(line, line.prefixLength - 1);
                  }
                }
              }
              HuffmanTable.prototype = {
                decode(reader) {
                  return this.rootNode.decodeNode(reader);
                },
                assignPrefixCodes(lines) {
                  const linesLength = lines.length;
                  let prefixLengthMax = 0;
                  for (let i2 = 0; i2 < linesLength; i2++) {
                    prefixLengthMax = Math.max(prefixLengthMax, lines[i2].prefixLength);
                  }
                  const histogram = new Uint32Array(prefixLengthMax + 1);
                  for (let i2 = 0; i2 < linesLength; i2++) {
                    histogram[lines[i2].prefixLength]++;
                  }
                  let currentLength = 1, firstCode = 0, currentCode, currentTemp, line;
                  histogram[0] = 0;
                  while (currentLength <= prefixLengthMax) {
                    firstCode = firstCode + histogram[currentLength - 1] << 1;
                    currentCode = firstCode;
                    currentTemp = 0;
                    while (currentTemp < linesLength) {
                      line = lines[currentTemp];
                      if (line.prefixLength === currentLength) {
                        line.prefixCode = currentCode;
                        currentCode++;
                      }
                      currentTemp++;
                    }
                    currentLength++;
                  }
                }
              };
              function decodeTablesSegment(data, start, end) {
                const flags = data[start];
                const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 4294967295;
                const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 4294967295;
                const reader = new Reader(data, start + 9, end);
                const prefixSizeBits = (flags >> 1 & 7) + 1;
                const rangeSizeBits = (flags >> 4 & 7) + 1;
                const lines = [];
                let prefixLength, rangeLength, currentRangeLow = lowestValue;
                do {
                  prefixLength = reader.readBits(prefixSizeBits);
                  rangeLength = reader.readBits(rangeSizeBits);
                  lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
                  currentRangeLow += 1 << rangeLength;
                } while (currentRangeLow < highestValue);
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
                if (flags & 1) {
                  prefixLength = reader.readBits(prefixSizeBits);
                  lines.push(new HuffmanLine([prefixLength, 0]));
                }
                return new HuffmanTable(lines, false);
              }
              const standardTablesCache = {};
              function getStandardTable(number) {
                let table = standardTablesCache[number];
                if (table) {
                  return table;
                }
                let lines;
                switch (number) {
                  case 1:
                    lines = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                    break;
                  case 2:
                    lines = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                    break;
                  case 3:
                    lines = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                    break;
                  case 4:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                    break;
                  case 5:
                    lines = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                    break;
                  case 6:
                    lines = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                    break;
                  case 7:
                    lines = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                    break;
                  case 8:
                    lines = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                    break;
                  case 9:
                    lines = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                    break;
                  case 10:
                    lines = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                    break;
                  case 11:
                    lines = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 12:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                    break;
                  case 13:
                    lines = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 14:
                    lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                    break;
                  case 15:
                    lines = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                    break;
                  default:
                    throw new Jbig2Error(`standard table B.${number} does not exist`);
                }
                for (let i2 = 0, ii = lines.length; i2 < ii; i2++) {
                  lines[i2] = new HuffmanLine(lines[i2]);
                }
                table = new HuffmanTable(lines, true);
                standardTablesCache[number] = table;
                return table;
              }
              function Reader(data, start, end) {
                this.data = data;
                this.start = start;
                this.end = end;
                this.position = start;
                this.shift = -1;
                this.currentByte = 0;
              }
              Reader.prototype = {
                readBit() {
                  if (this.shift < 0) {
                    if (this.position >= this.end) {
                      throw new Jbig2Error("end of data while reading bit");
                    }
                    this.currentByte = this.data[this.position++];
                    this.shift = 7;
                  }
                  const bit = this.currentByte >> this.shift & 1;
                  this.shift--;
                  return bit;
                },
                readBits(numBits) {
                  let result = 0, i2;
                  for (i2 = numBits - 1; i2 >= 0; i2--) {
                    result |= this.readBit() << i2;
                  }
                  return result;
                },
                byteAlign() {
                  this.shift = -1;
                },
                next() {
                  if (this.position >= this.end) {
                    return -1;
                  }
                  return this.data[this.position++];
                }
              };
              function getCustomHuffmanTable(index, referredTo, customTables) {
                let currentIndex = 0;
                for (let i2 = 0, ii = referredTo.length; i2 < ii; i2++) {
                  const table = customTables[referredTo[i2]];
                  if (table) {
                    if (index === currentIndex) {
                      return table;
                    }
                    currentIndex++;
                  }
                }
                throw new Jbig2Error("can't find custom Huffman table");
              }
              function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
                const codes = [];
                for (let i2 = 0; i2 <= 34; i2++) {
                  const codeLength = reader.readBits(4);
                  codes.push(new HuffmanLine([i2, codeLength, 0, 0]));
                }
                const runCodesTable = new HuffmanTable(codes, false);
                codes.length = 0;
                for (let i2 = 0; i2 < numberOfSymbols; ) {
                  const codeLength = runCodesTable.decode(reader);
                  if (codeLength >= 32) {
                    let repeatedLength, numberOfRepeats, j2;
                    switch (codeLength) {
                      case 32:
                        if (i2 === 0) {
                          throw new Jbig2Error("no previous value in symbol ID table");
                        }
                        numberOfRepeats = reader.readBits(2) + 3;
                        repeatedLength = codes[i2 - 1].prefixLength;
                        break;
                      case 33:
                        numberOfRepeats = reader.readBits(3) + 3;
                        repeatedLength = 0;
                        break;
                      case 34:
                        numberOfRepeats = reader.readBits(7) + 11;
                        repeatedLength = 0;
                        break;
                      default:
                        throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for (j2 = 0; j2 < numberOfRepeats; j2++) {
                      codes.push(new HuffmanLine([i2, repeatedLength, 0, 0]));
                      i2++;
                    }
                  } else {
                    codes.push(new HuffmanLine([i2, codeLength, 0, 0]));
                    i2++;
                  }
                }
                reader.byteAlign();
                const symbolIDTable = new HuffmanTable(codes, false);
                let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT;
                switch (textRegion.huffmanFS) {
                  case 0:
                  case 1:
                    tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
                    break;
                  case 3:
                    tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch (textRegion.huffmanDS) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
                    break;
                  case 3:
                    tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch (textRegion.huffmanDT) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
                    break;
                  case 3:
                    tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (textRegion.refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                return {
                  symbolIDTable,
                  tableFirstS,
                  tableDeltaS,
                  tableDeltaT
                };
              }
              function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
                let customIndex = 0, tableDeltaHeight, tableDeltaWidth;
                switch (dictionary.huffmanDHSelector) {
                  case 0:
                  case 1:
                    tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
                    break;
                  case 3:
                    tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch (dictionary.huffmanDWSelector) {
                  case 0:
                  case 1:
                    tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
                    break;
                  case 3:
                    tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DW selector");
                }
                let tableBitmapSize, tableAggregateInstances;
                if (dictionary.bitmapSizeSelector) {
                  tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
                  customIndex++;
                } else {
                  tableBitmapSize = getStandardTable(1);
                }
                if (dictionary.aggregationInstancesSelector) {
                  tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
                } else {
                  tableAggregateInstances = getStandardTable(1);
                }
                return {
                  tableDeltaHeight,
                  tableDeltaWidth,
                  tableBitmapSize,
                  tableAggregateInstances
                };
              }
              function readUncompressedBitmap(reader, width, height) {
                const bitmap = [];
                for (let y2 = 0; y2 < height; y2++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  for (let x2 = 0; x2 < width; x2++) {
                    row[x2] = reader.readBit();
                  }
                  reader.byteAlign();
                }
                return bitmap;
              }
              function decodeMMRBitmap(input, width, height, endOfBlock) {
                const params = {
                  K: -1,
                  Columns: width,
                  Rows: height,
                  BlackIs1: true,
                  EndOfBlock: endOfBlock
                };
                const decoder = new _ccitt.CCITTFaxDecoder(input, params);
                const bitmap = [];
                let currentByte, eof = false;
                for (let y2 = 0; y2 < height; y2++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  let shift = -1;
                  for (let x2 = 0; x2 < width; x2++) {
                    if (shift < 0) {
                      currentByte = decoder.readNextChar();
                      if (currentByte === -1) {
                        currentByte = 0;
                        eof = true;
                      }
                      shift = 7;
                    }
                    row[x2] = currentByte >> shift & 1;
                    shift--;
                  }
                }
                if (endOfBlock && !eof) {
                  const lookForEOFLimit = 5;
                  for (let i2 = 0; i2 < lookForEOFLimit; i2++) {
                    if (decoder.readNextChar() === -1) {
                      break;
                    }
                  }
                }
                return bitmap;
              }
              function Jbig2Image2() {
              }
              Jbig2Image2.prototype = {
                parseChunks(chunks) {
                  return parseJbig2Chunks(chunks);
                },
                parse(data) {
                  const {
                    imgData,
                    width,
                    height
                  } = parseJbig2(data);
                  this.width = width;
                  this.height = height;
                  return imgData;
                }
              };
              return Jbig2Image2;
            }();
            exports3.Jbig2Image = Jbig2Image;
          },
          /* 16 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ArithmeticDecoder = void 0;
            const QeTable = [{
              qe: 22017,
              nmps: 1,
              nlps: 1,
              switchFlag: 1
            }, {
              qe: 13313,
              nmps: 2,
              nlps: 6,
              switchFlag: 0
            }, {
              qe: 6145,
              nmps: 3,
              nlps: 9,
              switchFlag: 0
            }, {
              qe: 2753,
              nmps: 4,
              nlps: 12,
              switchFlag: 0
            }, {
              qe: 1313,
              nmps: 5,
              nlps: 29,
              switchFlag: 0
            }, {
              qe: 545,
              nmps: 38,
              nlps: 33,
              switchFlag: 0
            }, {
              qe: 22017,
              nmps: 7,
              nlps: 6,
              switchFlag: 1
            }, {
              qe: 21505,
              nmps: 8,
              nlps: 14,
              switchFlag: 0
            }, {
              qe: 18433,
              nmps: 9,
              nlps: 14,
              switchFlag: 0
            }, {
              qe: 14337,
              nmps: 10,
              nlps: 14,
              switchFlag: 0
            }, {
              qe: 12289,
              nmps: 11,
              nlps: 17,
              switchFlag: 0
            }, {
              qe: 9217,
              nmps: 12,
              nlps: 18,
              switchFlag: 0
            }, {
              qe: 7169,
              nmps: 13,
              nlps: 20,
              switchFlag: 0
            }, {
              qe: 5633,
              nmps: 29,
              nlps: 21,
              switchFlag: 0
            }, {
              qe: 22017,
              nmps: 15,
              nlps: 14,
              switchFlag: 1
            }, {
              qe: 21505,
              nmps: 16,
              nlps: 14,
              switchFlag: 0
            }, {
              qe: 20737,
              nmps: 17,
              nlps: 15,
              switchFlag: 0
            }, {
              qe: 18433,
              nmps: 18,
              nlps: 16,
              switchFlag: 0
            }, {
              qe: 14337,
              nmps: 19,
              nlps: 17,
              switchFlag: 0
            }, {
              qe: 13313,
              nmps: 20,
              nlps: 18,
              switchFlag: 0
            }, {
              qe: 12289,
              nmps: 21,
              nlps: 19,
              switchFlag: 0
            }, {
              qe: 10241,
              nmps: 22,
              nlps: 19,
              switchFlag: 0
            }, {
              qe: 9217,
              nmps: 23,
              nlps: 20,
              switchFlag: 0
            }, {
              qe: 8705,
              nmps: 24,
              nlps: 21,
              switchFlag: 0
            }, {
              qe: 7169,
              nmps: 25,
              nlps: 22,
              switchFlag: 0
            }, {
              qe: 6145,
              nmps: 26,
              nlps: 23,
              switchFlag: 0
            }, {
              qe: 5633,
              nmps: 27,
              nlps: 24,
              switchFlag: 0
            }, {
              qe: 5121,
              nmps: 28,
              nlps: 25,
              switchFlag: 0
            }, {
              qe: 4609,
              nmps: 29,
              nlps: 26,
              switchFlag: 0
            }, {
              qe: 4353,
              nmps: 30,
              nlps: 27,
              switchFlag: 0
            }, {
              qe: 2753,
              nmps: 31,
              nlps: 28,
              switchFlag: 0
            }, {
              qe: 2497,
              nmps: 32,
              nlps: 29,
              switchFlag: 0
            }, {
              qe: 2209,
              nmps: 33,
              nlps: 30,
              switchFlag: 0
            }, {
              qe: 1313,
              nmps: 34,
              nlps: 31,
              switchFlag: 0
            }, {
              qe: 1089,
              nmps: 35,
              nlps: 32,
              switchFlag: 0
            }, {
              qe: 673,
              nmps: 36,
              nlps: 33,
              switchFlag: 0
            }, {
              qe: 545,
              nmps: 37,
              nlps: 34,
              switchFlag: 0
            }, {
              qe: 321,
              nmps: 38,
              nlps: 35,
              switchFlag: 0
            }, {
              qe: 273,
              nmps: 39,
              nlps: 36,
              switchFlag: 0
            }, {
              qe: 133,
              nmps: 40,
              nlps: 37,
              switchFlag: 0
            }, {
              qe: 73,
              nmps: 41,
              nlps: 38,
              switchFlag: 0
            }, {
              qe: 37,
              nmps: 42,
              nlps: 39,
              switchFlag: 0
            }, {
              qe: 21,
              nmps: 43,
              nlps: 40,
              switchFlag: 0
            }, {
              qe: 9,
              nmps: 44,
              nlps: 41,
              switchFlag: 0
            }, {
              qe: 5,
              nmps: 45,
              nlps: 42,
              switchFlag: 0
            }, {
              qe: 1,
              nmps: 45,
              nlps: 43,
              switchFlag: 0
            }, {
              qe: 22017,
              nmps: 46,
              nlps: 46,
              switchFlag: 0
            }];
            class ArithmeticDecoder {
              constructor(data, start, end) {
                this.data = data;
                this.bp = start;
                this.dataEnd = end;
                this.chigh = data[start];
                this.clow = 0;
                this.byteIn();
                this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                this.clow = this.clow << 7 & 65535;
                this.ct -= 7;
                this.a = 32768;
              }
              byteIn() {
                const data = this.data;
                let bp = this.bp;
                if (data[bp] === 255) {
                  if (data[bp + 1] > 143) {
                    this.clow += 65280;
                    this.ct = 8;
                  } else {
                    bp++;
                    this.clow += data[bp] << 9;
                    this.ct = 7;
                    this.bp = bp;
                  }
                } else {
                  bp++;
                  this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                  this.ct = 8;
                  this.bp = bp;
                }
                if (this.clow > 65535) {
                  this.chigh += this.clow >> 16;
                  this.clow &= 65535;
                }
              }
              readBit(contexts, pos) {
                let cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                const qeTableIcx = QeTable[cx_index];
                const qeIcx = qeTableIcx.qe;
                let d2;
                let a2 = this.a - qeIcx;
                if (this.chigh < qeIcx) {
                  if (a2 < qeIcx) {
                    a2 = qeIcx;
                    d2 = cx_mps;
                    cx_index = qeTableIcx.nmps;
                  } else {
                    a2 = qeIcx;
                    d2 = 1 ^ cx_mps;
                    if (qeTableIcx.switchFlag === 1) {
                      cx_mps = d2;
                    }
                    cx_index = qeTableIcx.nlps;
                  }
                } else {
                  this.chigh -= qeIcx;
                  if ((a2 & 32768) !== 0) {
                    this.a = a2;
                    return cx_mps;
                  }
                  if (a2 < qeIcx) {
                    d2 = 1 ^ cx_mps;
                    if (qeTableIcx.switchFlag === 1) {
                      cx_mps = d2;
                    }
                    cx_index = qeTableIcx.nlps;
                  } else {
                    d2 = cx_mps;
                    cx_index = qeTableIcx.nmps;
                  }
                }
                do {
                  if (this.ct === 0) {
                    this.byteIn();
                  }
                  a2 <<= 1;
                  this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                  this.clow = this.clow << 1 & 65535;
                  this.ct--;
                } while ((a2 & 32768) === 0);
                this.a = a2;
                contexts[pos] = cx_index << 1 | cx_mps;
                return d2;
              }
            }
            exports3.ArithmeticDecoder = ArithmeticDecoder;
          },
          /* 17 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpegStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _stream = __w_pdfjs_require__2(11);
            var _primitives = __w_pdfjs_require__2(4);
            var _jpg = __w_pdfjs_require__2(18);
            const JpegStream = function JpegStreamClosure() {
              function JpegStream2(stream, maybeLength, dict, params) {
                let ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (ch === 255) {
                    stream.skip(-1);
                    break;
                  }
                }
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              JpegStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(JpegStream2.prototype, "bytes", {
                get: function JpegStream_bytes() {
                  return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpegStream2.prototype.ensureBuffer = function(requested) {
              };
              JpegStream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                const jpegOptions = {
                  decodeTransform: void 0,
                  colorTransform: void 0
                };
                const decodeArr = this.dict.getArray("Decode", "D");
                if (this.forceRGB && Array.isArray(decodeArr)) {
                  const bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
                  const decodeArrLength = decodeArr.length;
                  const transform = new Int32Array(decodeArrLength);
                  let transformNeeded = false;
                  const maxValue = (1 << bitsPerComponent) - 1;
                  for (let i2 = 0; i2 < decodeArrLength; i2 += 2) {
                    transform[i2] = (decodeArr[i2 + 1] - decodeArr[i2]) * 256 | 0;
                    transform[i2 + 1] = decodeArr[i2] * maxValue | 0;
                    if (transform[i2] !== 256 || transform[i2 + 1] !== 0) {
                      transformNeeded = true;
                    }
                  }
                  if (transformNeeded) {
                    jpegOptions.decodeTransform = transform;
                  }
                }
                if ((0, _primitives.isDict)(this.params)) {
                  const colorTransform = this.params.get("ColorTransform");
                  if (Number.isInteger(colorTransform)) {
                    jpegOptions.colorTransform = colorTransform;
                  }
                }
                const jpegImage = new _jpg.JpegImage(jpegOptions);
                jpegImage.parse(this.bytes);
                const data = jpegImage.getData({
                  width: this.drawWidth,
                  height: this.drawHeight,
                  forceRGB: this.forceRGB,
                  isSourcePDF: true
                });
                this.buffer = data;
                this.bufferLength = data.length;
                this.eof = true;
              };
              Object.defineProperty(JpegStream2.prototype, "maybeValidDimensions", {
                get: function JpegStream_maybeValidDimensions() {
                  const {
                    dict,
                    stream
                  } = this;
                  const dictHeight = dict.get("Height", "H");
                  const startPos = stream.pos;
                  let validDimensions = true, foundSOF = false, b2;
                  while ((b2 = stream.getByte()) !== -1) {
                    if (b2 !== 255) {
                      continue;
                    }
                    switch (stream.getByte()) {
                      case 192:
                      case 193:
                      case 194:
                        foundSOF = true;
                        stream.pos += 2;
                        stream.pos += 1;
                        const scanLines = stream.getUint16();
                        if (scanLines === dictHeight) {
                          break;
                        }
                        if (scanLines === 0) {
                          validDimensions = false;
                          break;
                        }
                        if (scanLines > dictHeight * 10) {
                          validDimensions = false;
                          break;
                        }
                        break;
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                        foundSOF = true;
                        break;
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        const markerLength = stream.getUint16();
                        if (markerLength > 2) {
                          stream.skip(markerLength - 2);
                        } else {
                          stream.skip(-2);
                        }
                        break;
                      case 255:
                        stream.skip(-1);
                        break;
                      case 217:
                        foundSOF = true;
                        break;
                    }
                    if (foundSOF) {
                      break;
                    }
                  }
                  stream.pos = startPos;
                  return (0, _util2.shadow)(this, "maybeValidDimensions", validDimensions);
                },
                configurable: true
              });
              JpegStream2.prototype.getIR = function(forceDataSchema = false) {
                return (0, _util2.createObjectURL)(this.bytes, "image/jpeg", forceDataSchema);
              };
              return JpegStream2;
            }();
            exports3.JpegStream = JpegStream;
          },
          /* 18 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpegImage = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _core_utils = __w_pdfjs_require__2(7);
            class JpegError extends _util2.BaseException {
              constructor(msg) {
                super(`JPEG error: ${msg}`);
              }
            }
            class DNLMarkerError extends _util2.BaseException {
              constructor(message, scanLines) {
                super(message);
                this.scanLines = scanLines;
              }
            }
            class EOIMarkerError extends _util2.BaseException {
            }
            var JpegImage = function JpegImageClosure() {
              var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
              var dctCos1 = 4017;
              var dctSin1 = 799;
              var dctCos3 = 3406;
              var dctSin3 = 2276;
              var dctCos6 = 1567;
              var dctSin6 = 3784;
              var dctSqrt2 = 5793;
              var dctSqrt1d2 = 2896;
              function JpegImage2({
                decodeTransform = null,
                colorTransform = -1
              } = {}) {
                this._decodeTransform = decodeTransform;
                this._colorTransform = colorTransform;
              }
              function buildHuffmanTable(codeLengths, values) {
                var k2 = 0, code = [], i2, j2, length = 16;
                while (length > 0 && !codeLengths[length - 1]) {
                  length--;
                }
                code.push({
                  children: [],
                  index: 0
                });
                var p = code[0], q2;
                for (i2 = 0; i2 < length; i2++) {
                  for (j2 = 0; j2 < codeLengths[i2]; j2++) {
                    p = code.pop();
                    p.children[p.index] = values[k2];
                    while (p.index > 0) {
                      p = code.pop();
                    }
                    p.index++;
                    code.push(p);
                    while (code.length <= i2) {
                      code.push(q2 = {
                        children: [],
                        index: 0
                      });
                      p.children[p.index] = q2.children;
                      p = q2;
                    }
                    k2++;
                  }
                  if (i2 + 1 < length) {
                    code.push(q2 = {
                      children: [],
                      index: 0
                    });
                    p.children[p.index] = q2.children;
                    p = q2;
                  }
                }
                return code[0].children;
              }
              function getBlockBufferOffset(component, row, col) {
                return 64 * ((component.blocksPerLine + 1) * row + col);
              }
              function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
                var mcusPerLine = frame.mcusPerLine;
                var progressive = frame.progressive;
                var startOffset = offset, bitsData = 0, bitsCount = 0;
                function readBit() {
                  if (bitsCount > 0) {
                    bitsCount--;
                    return bitsData >> bitsCount & 1;
                  }
                  bitsData = data[offset++];
                  if (bitsData === 255) {
                    var nextByte = data[offset++];
                    if (nextByte) {
                      if (nextByte === 220 && parseDNLMarker) {
                        offset += 2;
                        const scanLines = (0, _core_utils.readUint16)(data, offset);
                        offset += 2;
                        if (scanLines > 0 && scanLines !== frame.scanLines) {
                          throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
                        }
                      } else if (nextByte === 217) {
                        if (parseDNLMarker) {
                          const maybeScanLines = blockRow * 8;
                          if (maybeScanLines > 0 && maybeScanLines < frame.scanLines / 10) {
                            throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", maybeScanLines);
                          }
                        }
                        throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                      }
                      throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
                    }
                  }
                  bitsCount = 7;
                  return bitsData >>> 7;
                }
                function decodeHuffman(tree) {
                  var node = tree;
                  while (true) {
                    node = node[readBit()];
                    switch (typeof node) {
                      case "number":
                        return node;
                      case "object":
                        continue;
                    }
                    throw new JpegError("invalid huffman sequence");
                  }
                }
                function receive(length) {
                  var n3 = 0;
                  while (length > 0) {
                    n3 = n3 << 1 | readBit();
                    length--;
                  }
                  return n3;
                }
                function receiveAndExtend(length) {
                  if (length === 1) {
                    return readBit() === 1 ? 1 : -1;
                  }
                  var n3 = receive(length);
                  if (n3 >= 1 << length - 1) {
                    return n3;
                  }
                  return n3 + (-1 << length) + 1;
                }
                function decodeBaseline(component2, offset2) {
                  var t2 = decodeHuffman(component2.huffmanTableDC);
                  var diff = t2 === 0 ? 0 : receiveAndExtend(t2);
                  component2.blockData[offset2] = component2.pred += diff;
                  var k3 = 1;
                  while (k3 < 64) {
                    var rs = decodeHuffman(component2.huffmanTableAC);
                    var s2 = rs & 15, r2 = rs >> 4;
                    if (s2 === 0) {
                      if (r2 < 15) {
                        break;
                      }
                      k3 += 16;
                      continue;
                    }
                    k3 += r2;
                    var z2 = dctZigZag[k3];
                    component2.blockData[offset2 + z2] = receiveAndExtend(s2);
                    k3++;
                  }
                }
                function decodeDCFirst(component2, offset2) {
                  var t2 = decodeHuffman(component2.huffmanTableDC);
                  var diff = t2 === 0 ? 0 : receiveAndExtend(t2) << successive;
                  component2.blockData[offset2] = component2.pred += diff;
                }
                function decodeDCSuccessive(component2, offset2) {
                  component2.blockData[offset2] |= readBit() << successive;
                }
                var eobrun = 0;
                function decodeACFirst(component2, offset2) {
                  if (eobrun > 0) {
                    eobrun--;
                    return;
                  }
                  var k3 = spectralStart, e2 = spectralEnd;
                  while (k3 <= e2) {
                    var rs = decodeHuffman(component2.huffmanTableAC);
                    var s2 = rs & 15, r2 = rs >> 4;
                    if (s2 === 0) {
                      if (r2 < 15) {
                        eobrun = receive(r2) + (1 << r2) - 1;
                        break;
                      }
                      k3 += 16;
                      continue;
                    }
                    k3 += r2;
                    var z2 = dctZigZag[k3];
                    component2.blockData[offset2 + z2] = receiveAndExtend(s2) * (1 << successive);
                    k3++;
                  }
                }
                var successiveACState = 0, successiveACNextValue;
                function decodeACSuccessive(component2, offset2) {
                  var k3 = spectralStart;
                  var e2 = spectralEnd;
                  var r2 = 0;
                  var s2;
                  var rs;
                  while (k3 <= e2) {
                    const offsetZ = offset2 + dctZigZag[k3];
                    const sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
                    switch (successiveACState) {
                      case 0:
                        rs = decodeHuffman(component2.huffmanTableAC);
                        s2 = rs & 15;
                        r2 = rs >> 4;
                        if (s2 === 0) {
                          if (r2 < 15) {
                            eobrun = receive(r2) + (1 << r2);
                            successiveACState = 4;
                          } else {
                            r2 = 16;
                            successiveACState = 1;
                          }
                        } else {
                          if (s2 !== 1) {
                            throw new JpegError("invalid ACn encoding");
                          }
                          successiveACNextValue = receiveAndExtend(s2);
                          successiveACState = r2 ? 2 : 3;
                        }
                        continue;
                      case 1:
                      case 2:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          r2--;
                          if (r2 === 0) {
                            successiveACState = successiveACState === 2 ? 3 : 0;
                          }
                        }
                        break;
                      case 3:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          component2.blockData[offsetZ] = successiveACNextValue << successive;
                          successiveACState = 0;
                        }
                        break;
                      case 4:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        }
                        break;
                    }
                    k3++;
                  }
                  if (successiveACState === 4) {
                    eobrun--;
                    if (eobrun === 0) {
                      successiveACState = 0;
                    }
                  }
                }
                let blockRow = 0;
                function decodeMcu(component2, decode, mcu2, row, col) {
                  var mcuRow = mcu2 / mcusPerLine | 0;
                  var mcuCol = mcu2 % mcusPerLine;
                  blockRow = mcuRow * component2.v + row;
                  var blockCol = mcuCol * component2.h + col;
                  var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, offset2);
                }
                function decodeBlock(component2, decode, mcu2) {
                  blockRow = mcu2 / component2.blocksPerLine | 0;
                  var blockCol = mcu2 % component2.blocksPerLine;
                  var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, offset2);
                }
                var componentsLength = components.length;
                var component, i2, j2, k2, n2;
                var decodeFn;
                if (progressive) {
                  if (spectralStart === 0) {
                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                  } else {
                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                  }
                } else {
                  decodeFn = decodeBaseline;
                }
                var mcu = 0, fileMarker;
                var mcuExpected;
                if (componentsLength === 1) {
                  mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
                } else {
                  mcuExpected = mcusPerLine * frame.mcusPerColumn;
                }
                var h2, v2;
                while (mcu < mcuExpected) {
                  var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
                  for (i2 = 0; i2 < componentsLength; i2++) {
                    components[i2].pred = 0;
                  }
                  eobrun = 0;
                  if (componentsLength === 1) {
                    component = components[0];
                    for (n2 = 0; n2 < mcuToRead; n2++) {
                      decodeBlock(component, decodeFn, mcu);
                      mcu++;
                    }
                  } else {
                    for (n2 = 0; n2 < mcuToRead; n2++) {
                      for (i2 = 0; i2 < componentsLength; i2++) {
                        component = components[i2];
                        h2 = component.h;
                        v2 = component.v;
                        for (j2 = 0; j2 < v2; j2++) {
                          for (k2 = 0; k2 < h2; k2++) {
                            decodeMcu(component, decodeFn, mcu, j2, k2);
                          }
                        }
                      }
                      mcu++;
                    }
                  }
                  bitsCount = 0;
                  fileMarker = findNextFileMarker(data, offset);
                  if (!fileMarker) {
                    break;
                  } else if (fileMarker.invalid) {
                    (0, _util2.warn)("decodeScan - unexpected MCU data, current marker is: " + fileMarker.invalid);
                    offset = fileMarker.offset;
                  }
                  var marker = fileMarker && fileMarker.marker;
                  if (!marker || marker <= 65280) {
                    throw new JpegError("decodeScan - a valid marker was not found.");
                  }
                  if (marker >= 65488 && marker <= 65495) {
                    offset += 2;
                  } else {
                    break;
                  }
                }
                fileMarker = findNextFileMarker(data, offset);
                if (fileMarker && fileMarker.invalid) {
                  (0, _util2.warn)("decodeScan - unexpected Scan data, current marker is: " + fileMarker.invalid);
                  offset = fileMarker.offset;
                }
                return offset - startOffset;
              }
              function quantizeAndInverse(component, blockBufferOffset, p) {
                var qt = component.quantizationTable, blockData = component.blockData;
                var v0, v1, v2, v3, v4, v5, v6, v7;
                var p0, p1, p2, p3, p4, p5, p6, p7;
                var t2;
                if (!qt) {
                  throw new JpegError("missing required Quantization Table.");
                }
                for (var row = 0; row < 64; row += 8) {
                  p0 = blockData[blockBufferOffset + row];
                  p1 = blockData[blockBufferOffset + row + 1];
                  p2 = blockData[blockBufferOffset + row + 2];
                  p3 = blockData[blockBufferOffset + row + 3];
                  p4 = blockData[blockBufferOffset + row + 4];
                  p5 = blockData[blockBufferOffset + row + 5];
                  p6 = blockData[blockBufferOffset + row + 6];
                  p7 = blockData[blockBufferOffset + row + 7];
                  p0 *= qt[row];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t2 = dctSqrt2 * p0 + 512 >> 10;
                    p[row] = t2;
                    p[row + 1] = t2;
                    p[row + 2] = t2;
                    p[row + 3] = t2;
                    p[row + 4] = t2;
                    p[row + 5] = t2;
                    p[row + 6] = t2;
                    p[row + 7] = t2;
                    continue;
                  }
                  p1 *= qt[row + 1];
                  p2 *= qt[row + 2];
                  p3 *= qt[row + 3];
                  p4 *= qt[row + 4];
                  p5 *= qt[row + 5];
                  p6 *= qt[row + 6];
                  p7 *= qt[row + 7];
                  v0 = dctSqrt2 * p0 + 128 >> 8;
                  v1 = dctSqrt2 * p4 + 128 >> 8;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
                  v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
                  v5 = p3 << 4;
                  v6 = p5 << 4;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = v0 - v1;
                  t2 = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                  v3 = t2;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t2;
                  t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t2;
                  p[row] = v0 + v7;
                  p[row + 7] = v0 - v7;
                  p[row + 1] = v1 + v6;
                  p[row + 6] = v1 - v6;
                  p[row + 2] = v2 + v5;
                  p[row + 5] = v2 - v5;
                  p[row + 3] = v3 + v4;
                  p[row + 4] = v3 - v4;
                }
                for (var col = 0; col < 8; ++col) {
                  p0 = p[col];
                  p1 = p[col + 8];
                  p2 = p[col + 16];
                  p3 = p[col + 24];
                  p4 = p[col + 32];
                  p5 = p[col + 40];
                  p6 = p[col + 48];
                  p7 = p[col + 56];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t2 = dctSqrt2 * p0 + 8192 >> 14;
                    if (t2 < -2040) {
                      t2 = 0;
                    } else if (t2 >= 2024) {
                      t2 = 255;
                    } else {
                      t2 = t2 + 2056 >> 4;
                    }
                    blockData[blockBufferOffset + col] = t2;
                    blockData[blockBufferOffset + col + 8] = t2;
                    blockData[blockBufferOffset + col + 16] = t2;
                    blockData[blockBufferOffset + col + 24] = t2;
                    blockData[blockBufferOffset + col + 32] = t2;
                    blockData[blockBufferOffset + col + 40] = t2;
                    blockData[blockBufferOffset + col + 48] = t2;
                    blockData[blockBufferOffset + col + 56] = t2;
                    continue;
                  }
                  v0 = dctSqrt2 * p0 + 2048 >> 12;
                  v1 = dctSqrt2 * p4 + 2048 >> 12;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
                  v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
                  v5 = p3;
                  v6 = p5;
                  v0 = (v0 + v1 + 1 >> 1) + 4112;
                  v1 = v0 - v1;
                  t2 = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                  v3 = t2;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t2;
                  t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t2;
                  p0 = v0 + v7;
                  p7 = v0 - v7;
                  p1 = v1 + v6;
                  p6 = v1 - v6;
                  p2 = v2 + v5;
                  p5 = v2 - v5;
                  p3 = v3 + v4;
                  p4 = v3 - v4;
                  if (p0 < 16) {
                    p0 = 0;
                  } else if (p0 >= 4080) {
                    p0 = 255;
                  } else {
                    p0 >>= 4;
                  }
                  if (p1 < 16) {
                    p1 = 0;
                  } else if (p1 >= 4080) {
                    p1 = 255;
                  } else {
                    p1 >>= 4;
                  }
                  if (p2 < 16) {
                    p2 = 0;
                  } else if (p2 >= 4080) {
                    p2 = 255;
                  } else {
                    p2 >>= 4;
                  }
                  if (p3 < 16) {
                    p3 = 0;
                  } else if (p3 >= 4080) {
                    p3 = 255;
                  } else {
                    p3 >>= 4;
                  }
                  if (p4 < 16) {
                    p4 = 0;
                  } else if (p4 >= 4080) {
                    p4 = 255;
                  } else {
                    p4 >>= 4;
                  }
                  if (p5 < 16) {
                    p5 = 0;
                  } else if (p5 >= 4080) {
                    p5 = 255;
                  } else {
                    p5 >>= 4;
                  }
                  if (p6 < 16) {
                    p6 = 0;
                  } else if (p6 >= 4080) {
                    p6 = 255;
                  } else {
                    p6 >>= 4;
                  }
                  if (p7 < 16) {
                    p7 = 0;
                  } else if (p7 >= 4080) {
                    p7 = 255;
                  } else {
                    p7 >>= 4;
                  }
                  blockData[blockBufferOffset + col] = p0;
                  blockData[blockBufferOffset + col + 8] = p1;
                  blockData[blockBufferOffset + col + 16] = p2;
                  blockData[blockBufferOffset + col + 24] = p3;
                  blockData[blockBufferOffset + col + 32] = p4;
                  blockData[blockBufferOffset + col + 40] = p5;
                  blockData[blockBufferOffset + col + 48] = p6;
                  blockData[blockBufferOffset + col + 56] = p7;
                }
              }
              function buildComponentData(frame, component) {
                var blocksPerLine = component.blocksPerLine;
                var blocksPerColumn = component.blocksPerColumn;
                var computationBuffer = new Int16Array(64);
                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                  for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    var offset = getBlockBufferOffset(component, blockRow, blockCol);
                    quantizeAndInverse(component, offset, computationBuffer);
                  }
                }
                return component.blockData;
              }
              function findNextFileMarker(data, currentPos, startPos = currentPos) {
                const maxPos = data.length - 1;
                var newPos = startPos < currentPos ? startPos : currentPos;
                if (currentPos >= maxPos) {
                  return null;
                }
                var currentMarker = (0, _core_utils.readUint16)(data, currentPos);
                if (currentMarker >= 65472 && currentMarker <= 65534) {
                  return {
                    invalid: null,
                    marker: currentMarker,
                    offset: currentPos
                  };
                }
                var newMarker = (0, _core_utils.readUint16)(data, newPos);
                while (!(newMarker >= 65472 && newMarker <= 65534)) {
                  if (++newPos >= maxPos) {
                    return null;
                  }
                  newMarker = (0, _core_utils.readUint16)(data, newPos);
                }
                return {
                  invalid: currentMarker.toString(16),
                  marker: newMarker,
                  offset: newPos
                };
              }
              JpegImage2.prototype = {
                parse(data, {
                  dnlScanLines = null
                } = {}) {
                  function readDataBlock() {
                    const length = (0, _core_utils.readUint16)(data, offset);
                    offset += 2;
                    let endOffset = offset + length - 2;
                    var fileMarker2 = findNextFileMarker(data, endOffset, offset);
                    if (fileMarker2 && fileMarker2.invalid) {
                      (0, _util2.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
                      endOffset = fileMarker2.offset;
                    }
                    var array = data.subarray(offset, endOffset);
                    offset += array.length;
                    return array;
                  }
                  function prepareComponents(frame2) {
                    var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
                    var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
                    for (var i3 = 0; i3 < frame2.components.length; i3++) {
                      component = frame2.components[i3];
                      var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
                      var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
                      var blocksPerLineForMcu = mcusPerLine * component.h;
                      var blocksPerColumnForMcu = mcusPerColumn * component.v;
                      var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                      component.blockData = new Int16Array(blocksBufferSize);
                      component.blocksPerLine = blocksPerLine;
                      component.blocksPerColumn = blocksPerColumn;
                    }
                    frame2.mcusPerLine = mcusPerLine;
                    frame2.mcusPerColumn = mcusPerColumn;
                  }
                  var offset = 0;
                  var jfif = null;
                  var adobe = null;
                  var frame, resetInterval;
                  let numSOSMarkers = 0;
                  var quantizationTables = [];
                  var huffmanTablesAC = [], huffmanTablesDC = [];
                  let fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  if (fileMarker !== 65496) {
                    throw new JpegError("SOI not found");
                  }
                  fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  markerLoop:
                    while (fileMarker !== 65497) {
                      var i2, j2, l2;
                      switch (fileMarker) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          var appData = readDataBlock();
                          if (fileMarker === 65504) {
                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                              jfif = {
                                version: {
                                  major: appData[5],
                                  minor: appData[6]
                                },
                                densityUnits: appData[7],
                                xDensity: appData[8] << 8 | appData[9],
                                yDensity: appData[10] << 8 | appData[11],
                                thumbWidth: appData[12],
                                thumbHeight: appData[13],
                                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                              };
                            }
                          }
                          if (fileMarker === 65518) {
                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                              adobe = {
                                version: appData[5] << 8 | appData[6],
                                flags0: appData[7] << 8 | appData[8],
                                flags1: appData[9] << 8 | appData[10],
                                transformCode: appData[11]
                              };
                            }
                          }
                          break;
                        case 65499:
                          const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                          var z2;
                          while (offset < quantizationTablesEnd) {
                            var quantizationTableSpec = data[offset++];
                            var tableData = new Uint16Array(64);
                            if (quantizationTableSpec >> 4 === 0) {
                              for (j2 = 0; j2 < 64; j2++) {
                                z2 = dctZigZag[j2];
                                tableData[z2] = data[offset++];
                              }
                            } else if (quantizationTableSpec >> 4 === 1) {
                              for (j2 = 0; j2 < 64; j2++) {
                                z2 = dctZigZag[j2];
                                tableData[z2] = (0, _core_utils.readUint16)(data, offset);
                                offset += 2;
                              }
                            } else {
                              throw new JpegError("DQT - invalid table spec");
                            }
                            quantizationTables[quantizationTableSpec & 15] = tableData;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (frame) {
                            throw new JpegError("Only single frame JPEGs supported");
                          }
                          offset += 2;
                          frame = {};
                          frame.extended = fileMarker === 65473;
                          frame.progressive = fileMarker === 65474;
                          frame.precision = data[offset++];
                          const sofScanLines = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.scanLines = dnlScanLines || sofScanLines;
                          frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.components = [];
                          frame.componentIds = {};
                          var componentsCount = data[offset++], componentId;
                          var maxH = 0, maxV = 0;
                          for (i2 = 0; i2 < componentsCount; i2++) {
                            componentId = data[offset];
                            var h2 = data[offset + 1] >> 4;
                            var v2 = data[offset + 1] & 15;
                            if (maxH < h2) {
                              maxH = h2;
                            }
                            if (maxV < v2) {
                              maxV = v2;
                            }
                            var qId = data[offset + 2];
                            l2 = frame.components.push({
                              h: h2,
                              v: v2,
                              quantizationId: qId,
                              quantizationTable: null
                            });
                            frame.componentIds[componentId] = l2 - 1;
                            offset += 3;
                          }
                          frame.maxH = maxH;
                          frame.maxV = maxV;
                          prepareComponents(frame);
                          break;
                        case 65476:
                          const huffmanLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          for (i2 = 2; i2 < huffmanLength; ) {
                            var huffmanTableSpec = data[offset++];
                            var codeLengths = new Uint8Array(16);
                            var codeLengthSum = 0;
                            for (j2 = 0; j2 < 16; j2++, offset++) {
                              codeLengthSum += codeLengths[j2] = data[offset];
                            }
                            var huffmanValues = new Uint8Array(codeLengthSum);
                            for (j2 = 0; j2 < codeLengthSum; j2++, offset++) {
                              huffmanValues[j2] = data[offset];
                            }
                            i2 += 17 + codeLengthSum;
                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                          }
                          break;
                        case 65501:
                          offset += 2;
                          resetInterval = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          break;
                        case 65498:
                          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
                          offset += 2;
                          var selectorsCount = data[offset++];
                          var components = [], component;
                          for (i2 = 0; i2 < selectorsCount; i2++) {
                            var componentIndex = frame.componentIds[data[offset++]];
                            component = frame.components[componentIndex];
                            var tableSpec = data[offset++];
                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                            components.push(component);
                          }
                          var spectralStart = data[offset++];
                          var spectralEnd = data[offset++];
                          var successiveApproximation = data[offset++];
                          try {
                            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
                            offset += processed;
                          } catch (ex) {
                            if (ex instanceof DNLMarkerError) {
                              (0, _util2.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
                              return this.parse(data, {
                                dnlScanLines: ex.scanLines
                              });
                            } else if (ex instanceof EOIMarkerError) {
                              (0, _util2.warn)(`${ex.message} -- ignoring the rest of the image data.`);
                              break markerLoop;
                            }
                            throw ex;
                          }
                          break;
                        case 65500:
                          offset += 4;
                          break;
                        case 65535:
                          if (data[offset] !== 255) {
                            offset--;
                          }
                          break;
                        default:
                          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);
                          if (nextFileMarker && nextFileMarker.invalid) {
                            (0, _util2.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
                            offset = nextFileMarker.offset;
                            break;
                          }
                          if (offset >= data.length - 1) {
                            (0, _util2.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                            break markerLoop;
                          }
                          throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
                      }
                      fileMarker = (0, _core_utils.readUint16)(data, offset);
                      offset += 2;
                    }
                  this.width = frame.samplesPerLine;
                  this.height = frame.scanLines;
                  this.jfif = jfif;
                  this.adobe = adobe;
                  this.components = [];
                  for (i2 = 0; i2 < frame.components.length; i2++) {
                    component = frame.components[i2];
                    var quantizationTable = quantizationTables[component.quantizationId];
                    if (quantizationTable) {
                      component.quantizationTable = quantizationTable;
                    }
                    this.components.push({
                      output: buildComponentData(frame, component),
                      scaleX: component.h / frame.maxH,
                      scaleY: component.v / frame.maxV,
                      blocksPerLine: component.blocksPerLine,
                      blocksPerColumn: component.blocksPerColumn
                    });
                  }
                  this.numComponents = this.components.length;
                  return void 0;
                },
                _getLinearizedBlockData(width, height, isSourcePDF = false) {
                  var scaleX = this.width / width, scaleY = this.height / height;
                  var component, componentScaleX, componentScaleY, blocksPerScanline;
                  var x2, y2, i2, j2, k2;
                  var index;
                  var offset = 0;
                  var output;
                  var numComponents = this.components.length;
                  var dataLength = width * height * numComponents;
                  var data = new Uint8ClampedArray(dataLength);
                  var xScaleBlockOffset = new Uint32Array(width);
                  var mask3LSB = 4294967288;
                  let lastComponentScaleX;
                  for (i2 = 0; i2 < numComponents; i2++) {
                    component = this.components[i2];
                    componentScaleX = component.scaleX * scaleX;
                    componentScaleY = component.scaleY * scaleY;
                    offset = i2;
                    output = component.output;
                    blocksPerScanline = component.blocksPerLine + 1 << 3;
                    if (componentScaleX !== lastComponentScaleX) {
                      for (x2 = 0; x2 < width; x2++) {
                        j2 = 0 | x2 * componentScaleX;
                        xScaleBlockOffset[x2] = (j2 & mask3LSB) << 3 | j2 & 7;
                      }
                      lastComponentScaleX = componentScaleX;
                    }
                    for (y2 = 0; y2 < height; y2++) {
                      j2 = 0 | y2 * componentScaleY;
                      index = blocksPerScanline * (j2 & mask3LSB) | (j2 & 7) << 3;
                      for (x2 = 0; x2 < width; x2++) {
                        data[offset] = output[index + xScaleBlockOffset[x2]];
                        offset += numComponents;
                      }
                    }
                  }
                  let transform = this._decodeTransform;
                  if (!isSourcePDF && numComponents === 4 && !transform) {
                    transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
                  }
                  if (transform) {
                    for (i2 = 0; i2 < dataLength; ) {
                      for (j2 = 0, k2 = 0; j2 < numComponents; j2++, i2++, k2 += 2) {
                        data[i2] = (data[i2] * transform[k2] >> 8) + transform[k2 + 1];
                      }
                    }
                  }
                  return data;
                },
                get _isColorConversionNeeded() {
                  if (this.adobe) {
                    return !!this.adobe.transformCode;
                  }
                  if (this.numComponents === 3) {
                    if (this._colorTransform === 0) {
                      return false;
                    }
                    return true;
                  }
                  if (this._colorTransform === 1) {
                    return true;
                  }
                  return false;
                },
                _convertYccToRgb: function convertYccToRgb(data) {
                  var Y2, Cb, Cr;
                  for (var i2 = 0, length = data.length; i2 < length; i2 += 3) {
                    Y2 = data[i2];
                    Cb = data[i2 + 1];
                    Cr = data[i2 + 2];
                    data[i2] = Y2 - 179.456 + 1.402 * Cr;
                    data[i2 + 1] = Y2 + 135.459 - 0.344 * Cb - 0.714 * Cr;
                    data[i2 + 2] = Y2 - 226.816 + 1.772 * Cb;
                  }
                  return data;
                },
                _convertYcckToRgb: function convertYcckToRgb(data) {
                  var Y2, Cb, Cr, k2;
                  var offset = 0;
                  for (var i2 = 0, length = data.length; i2 < length; i2 += 4) {
                    Y2 = data[i2];
                    Cb = data[i2 + 1];
                    Cr = data[i2 + 2];
                    k2 = data[i2 + 3];
                    data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y2 + 48449797120281e-17 * k2 - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y2 - 0.00477271405408747 * k2 + 1.53380253221734) + Y2 * (961250184130688e-18 * Y2 - 0.00266257332283933 * k2 + 0.48357088451265) + k2 * (-336197177618394e-18 * k2 + 0.484791561490776);
                    data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y2 + 426105652938837e-18 * k2 - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y2 + 770482631801132e-18 * k2 - 0.151051492775562) + Y2 * (0.00126935368114843 * Y2 - 0.00265090189010898 * k2 + 0.25802910206845) + k2 * (-318913117588328e-18 * k2 - 0.213742400323665);
                    data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y2 - 0.00288260236853442 * k2 + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y2 + 560833691242812e-18 * k2 - 0.195152027534049) + Y2 * (0.00174418132927582 * Y2 - 0.00255243321439347 * k2 + 0.116935020465145) + k2 * (-343531996510555e-18 * k2 + 0.24165260232407);
                  }
                  return data.subarray(0, offset);
                },
                _convertYcckToCmyk: function convertYcckToCmyk(data) {
                  var Y2, Cb, Cr;
                  for (var i2 = 0, length = data.length; i2 < length; i2 += 4) {
                    Y2 = data[i2];
                    Cb = data[i2 + 1];
                    Cr = data[i2 + 2];
                    data[i2] = 434.456 - Y2 - 1.402 * Cr;
                    data[i2 + 1] = 119.541 - Y2 + 0.344 * Cb + 0.714 * Cr;
                    data[i2 + 2] = 481.816 - Y2 - 1.772 * Cb;
                  }
                  return data;
                },
                _convertCmykToRgb: function convertCmykToRgb(data) {
                  var c2, m, y2, k2;
                  var offset = 0;
                  for (var i2 = 0, length = data.length; i2 < length; i2 += 4) {
                    c2 = data[i2];
                    m = data[i2 + 1];
                    y2 = data[i2 + 2];
                    k2 = data[i2 + 3];
                    data[offset++] = 255 + c2 * (-6747147073602441e-20 * c2 + 8379262121013727e-19 * m + 2894718188643294e-19 * y2 + 0.003264231057537806 * k2 - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y2 - 2748769067499491e-19 * k2 - 0.02155688794978967) + y2 * (-3878099212869363e-20 * y2 - 3267808279485286e-19 * k2 + 0.0686742238595345) - k2 * (3361971776183937e-19 * k2 + 0.7430659151342254);
                    data[offset++] = 255 + c2 * (13596372813588848e-20 * c2 + 924537132573585e-18 * m + 10567359618683593e-20 * y2 + 4791864687436512e-19 * k2 - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y2 + 0.0020200308977307156 * k2 - 0.7488052167015494) + y2 * (6834815998235662e-20 * y2 + 15168452363460973e-20 * k2 - 0.09751927774728933) - k2 * (3189131175883281e-19 * k2 + 0.7364883807733168);
                    data[offset++] = 255 + c2 * (13598650411385307e-21 * c2 + 12423956175490851e-20 * m + 4751985097583589e-19 * y2 - 36729317476630422e-22 * k2 - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y2 + 7782692450036253e-19 * k2 - 0.44015232367526463) + y2 * (5068882914068769e-22 * y2 + 0.0017778369011375071 * k2 - 0.7591454649749609) - k2 * (3435319965105553e-19 * k2 + 0.7063770186160144);
                  }
                  return data.subarray(0, offset);
                },
                getData({
                  width,
                  height,
                  forceRGB = false,
                  isSourcePDF = false
                }) {
                  if (this.numComponents > 4) {
                    throw new JpegError("Unsupported color mode");
                  }
                  var data = this._getLinearizedBlockData(width, height, isSourcePDF);
                  if (this.numComponents === 1 && forceRGB) {
                    var dataLength = data.length;
                    var rgbData = new Uint8ClampedArray(dataLength * 3);
                    var offset = 0;
                    for (var i2 = 0; i2 < dataLength; i2++) {
                      var grayColor = data[i2];
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                    }
                    return rgbData;
                  } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
                    return this._convertYccToRgb(data);
                  } else if (this.numComponents === 4) {
                    if (this._isColorConversionNeeded) {
                      if (forceRGB) {
                        return this._convertYcckToRgb(data);
                      }
                      return this._convertYcckToCmyk(data);
                    } else if (forceRGB) {
                      return this._convertCmykToRgb(data);
                    }
                  }
                  return data;
                }
              };
              return JpegImage2;
            }();
            exports3.JpegImage = JpegImage;
          },
          /* 19 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpxStream = void 0;
            var _stream = __w_pdfjs_require__2(11);
            var _jpx = __w_pdfjs_require__2(20);
            var _util2 = __w_pdfjs_require__2(2);
            const JpxStream = function JpxStreamClosure() {
              function JpxStream2(stream, maybeLength, dict, params) {
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              JpxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(JpxStream2.prototype, "bytes", {
                get: function JpxStream_bytes() {
                  return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpxStream2.prototype.ensureBuffer = function(requested) {
              };
              JpxStream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                const jpxImage = new _jpx.JpxImage();
                jpxImage.parse(this.bytes);
                const width = jpxImage.width;
                const height = jpxImage.height;
                const componentsCount = jpxImage.componentsCount;
                const tileCount = jpxImage.tiles.length;
                if (tileCount === 1) {
                  this.buffer = jpxImage.tiles[0].items;
                } else {
                  const data = new Uint8ClampedArray(width * height * componentsCount);
                  for (let k2 = 0; k2 < tileCount; k2++) {
                    const tileComponents = jpxImage.tiles[k2];
                    const tileWidth = tileComponents.width;
                    const tileHeight = tileComponents.height;
                    const tileLeft = tileComponents.left;
                    const tileTop = tileComponents.top;
                    const src = tileComponents.items;
                    let srcPosition = 0;
                    let dataPosition = (width * tileTop + tileLeft) * componentsCount;
                    const imgRowSize = width * componentsCount;
                    const tileRowSize = tileWidth * componentsCount;
                    for (let j2 = 0; j2 < tileHeight; j2++) {
                      const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                      data.set(rowBytes, dataPosition);
                      srcPosition += tileRowSize;
                      dataPosition += imgRowSize;
                    }
                  }
                  this.buffer = data;
                }
                this.bufferLength = this.buffer.length;
                this.eof = true;
              };
              return JpxStream2;
            }();
            exports3.JpxStream = JpxStream;
          },
          /* 20 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpxImage = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _core_utils = __w_pdfjs_require__2(7);
            var _arithmetic_decoder = __w_pdfjs_require__2(16);
            class JpxError extends _util2.BaseException {
              constructor(msg) {
                super(`JPX error: ${msg}`);
              }
            }
            var JpxImage = function JpxImageClosure() {
              var SubbandsGainLog2 = {
                LL: 0,
                LH: 1,
                HL: 1,
                HH: 2
              };
              function JpxImage2() {
                this.failOnCorruptedImage = false;
              }
              JpxImage2.prototype = {
                parse: function JpxImage_parse(data) {
                  var head = (0, _core_utils.readUint16)(data, 0);
                  if (head === 65359) {
                    this.parseCodestream(data, 0, data.length);
                    return;
                  }
                  var position = 0, length = data.length;
                  while (position < length) {
                    var headerSize = 8;
                    var lbox = (0, _core_utils.readUint32)(data, position);
                    var tbox = (0, _core_utils.readUint32)(data, position + 4);
                    position += headerSize;
                    if (lbox === 1) {
                      lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
                      position += 8;
                      headerSize += 8;
                    }
                    if (lbox === 0) {
                      lbox = length - position + headerSize;
                    }
                    if (lbox < headerSize) {
                      throw new JpxError("Invalid box field size");
                    }
                    var dataLength = lbox - headerSize;
                    var jumpDataLength = true;
                    switch (tbox) {
                      case 1785737832:
                        jumpDataLength = false;
                        break;
                      case 1668246642:
                        var method = data[position];
                        if (method === 1) {
                          var colorspace = (0, _core_utils.readUint32)(data, position + 3);
                          switch (colorspace) {
                            case 16:
                            case 17:
                            case 18:
                              break;
                            default:
                              (0, _util2.warn)("Unknown colorspace " + colorspace);
                              break;
                          }
                        } else if (method === 2) {
                          (0, _util2.info)("ICC profile not supported");
                        }
                        break;
                      case 1785737827:
                        this.parseCodestream(data, position, position + dataLength);
                        break;
                      case 1783636e3:
                        if ((0, _core_utils.readUint32)(data, position) !== 218793738) {
                          (0, _util2.warn)("Invalid JP2 signature");
                        }
                        break;
                      case 1783634458:
                      case 1718909296:
                      case 1920099697:
                      case 1919251232:
                      case 1768449138:
                        break;
                      default:
                        var headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                        (0, _util2.warn)("Unsupported header type " + tbox + " (" + headerType + ")");
                        break;
                    }
                    if (jumpDataLength) {
                      position += dataLength;
                    }
                  }
                },
                parseImageProperties: function JpxImage_parseImageProperties(stream) {
                  var newByte = stream.getByte();
                  while (newByte >= 0) {
                    var oldByte = newByte;
                    newByte = stream.getByte();
                    var code = oldByte << 8 | newByte;
                    if (code === 65361) {
                      stream.skip(4);
                      var Xsiz = stream.getInt32() >>> 0;
                      var Ysiz = stream.getInt32() >>> 0;
                      var XOsiz = stream.getInt32() >>> 0;
                      var YOsiz = stream.getInt32() >>> 0;
                      stream.skip(16);
                      var Csiz = stream.getUint16();
                      this.width = Xsiz - XOsiz;
                      this.height = Ysiz - YOsiz;
                      this.componentsCount = Csiz;
                      this.bitsPerComponent = 8;
                      return;
                    }
                  }
                  throw new JpxError("No size marker found in JPX stream");
                },
                parseCodestream: function JpxImage_parseCodestream(data, start, end) {
                  var context = {};
                  var doNotRecover = false;
                  try {
                    var position = start;
                    while (position + 1 < end) {
                      var code = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      var length = 0, j2, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                      switch (code) {
                        case 65359:
                          context.mainHeader = true;
                          break;
                        case 65497:
                          break;
                        case 65361:
                          length = (0, _core_utils.readUint16)(data, position);
                          var siz = {};
                          siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
                          siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
                          siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
                          siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
                          siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
                          siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
                          siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
                          siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
                          var componentsCount = (0, _core_utils.readUint16)(data, position + 36);
                          siz.Csiz = componentsCount;
                          var components = [];
                          j2 = position + 38;
                          for (var i2 = 0; i2 < componentsCount; i2++) {
                            var component = {
                              precision: (data[j2] & 127) + 1,
                              isSigned: !!(data[j2] & 128),
                              XRsiz: data[j2 + 1],
                              YRsiz: data[j2 + 2]
                            };
                            j2 += 3;
                            calculateComponentDimensions(component, siz);
                            components.push(component);
                          }
                          context.SIZ = siz;
                          context.components = components;
                          calculateTileGrids(context, components);
                          context.QCC = [];
                          context.COC = [];
                          break;
                        case 65372:
                          length = (0, _core_utils.readUint16)(data, position);
                          var qcd = {};
                          j2 = position + 2;
                          sqcd = data[j2++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcd.noQuantization = spqcdSize === 8;
                          qcd.scalarExpounded = scalarExpounded;
                          qcd.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j2 < length + position) {
                            var spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j2++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j2] >> 3;
                              spqcd.mu = (data[j2] & 7) << 8 | data[j2 + 1];
                              j2 += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcd.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCD = qcd;
                          } else {
                            context.currentTile.QCD = qcd;
                            context.currentTile.QCC = [];
                          }
                          break;
                        case 65373:
                          length = (0, _core_utils.readUint16)(data, position);
                          var qcc = {};
                          j2 = position + 2;
                          var cqcc;
                          if (context.SIZ.Csiz < 257) {
                            cqcc = data[j2++];
                          } else {
                            cqcc = (0, _core_utils.readUint16)(data, j2);
                            j2 += 2;
                          }
                          sqcd = data[j2++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcc.noQuantization = spqcdSize === 8;
                          qcc.scalarExpounded = scalarExpounded;
                          qcc.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j2 < length + position) {
                            spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j2++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j2] >> 3;
                              spqcd.mu = (data[j2] & 7) << 8 | data[j2 + 1];
                              j2 += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcc.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCC[cqcc] = qcc;
                          } else {
                            context.currentTile.QCC[cqcc] = qcc;
                          }
                          break;
                        case 65362:
                          length = (0, _core_utils.readUint16)(data, position);
                          var cod = {};
                          j2 = position + 2;
                          var scod = data[j2++];
                          cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                          cod.sopMarkerUsed = !!(scod & 2);
                          cod.ephMarkerUsed = !!(scod & 4);
                          cod.progressionOrder = data[j2++];
                          cod.layersCount = (0, _core_utils.readUint16)(data, j2);
                          j2 += 2;
                          cod.multipleComponentTransform = data[j2++];
                          cod.decompositionLevelsCount = data[j2++];
                          cod.xcb = (data[j2++] & 15) + 2;
                          cod.ycb = (data[j2++] & 15) + 2;
                          var blockStyle = data[j2++];
                          cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                          cod.resetContextProbabilities = !!(blockStyle & 2);
                          cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                          cod.verticallyStripe = !!(blockStyle & 8);
                          cod.predictableTermination = !!(blockStyle & 16);
                          cod.segmentationSymbolUsed = !!(blockStyle & 32);
                          cod.reversibleTransformation = data[j2++];
                          if (cod.entropyCoderWithCustomPrecincts) {
                            var precinctsSizes = [];
                            while (j2 < length + position) {
                              var precinctsSize = data[j2++];
                              precinctsSizes.push({
                                PPx: precinctsSize & 15,
                                PPy: precinctsSize >> 4
                              });
                            }
                            cod.precinctsSizes = precinctsSizes;
                          }
                          var unsupported = [];
                          if (cod.selectiveArithmeticCodingBypass) {
                            unsupported.push("selectiveArithmeticCodingBypass");
                          }
                          if (cod.resetContextProbabilities) {
                            unsupported.push("resetContextProbabilities");
                          }
                          if (cod.terminationOnEachCodingPass) {
                            unsupported.push("terminationOnEachCodingPass");
                          }
                          if (cod.verticallyStripe) {
                            unsupported.push("verticallyStripe");
                          }
                          if (cod.predictableTermination) {
                            unsupported.push("predictableTermination");
                          }
                          if (unsupported.length > 0) {
                            doNotRecover = true;
                            throw new Error("Unsupported COD options (" + unsupported.join(", ") + ")");
                          }
                          if (context.mainHeader) {
                            context.COD = cod;
                          } else {
                            context.currentTile.COD = cod;
                            context.currentTile.COC = [];
                          }
                          break;
                        case 65424:
                          length = (0, _core_utils.readUint16)(data, position);
                          tile = {};
                          tile.index = (0, _core_utils.readUint16)(data, position + 2);
                          tile.length = (0, _core_utils.readUint32)(data, position + 4);
                          tile.dataEnd = tile.length + position - 2;
                          tile.partIndex = data[position + 8];
                          tile.partsCount = data[position + 9];
                          context.mainHeader = false;
                          if (tile.partIndex === 0) {
                            tile.COD = context.COD;
                            tile.COC = context.COC.slice(0);
                            tile.QCD = context.QCD;
                            tile.QCC = context.QCC.slice(0);
                          }
                          context.currentTile = tile;
                          break;
                        case 65427:
                          tile = context.currentTile;
                          if (tile.partIndex === 0) {
                            initializeTile(context, tile.index);
                            buildPackets(context);
                          }
                          length = tile.dataEnd - position;
                          parseTilePackets(context, data, position, length);
                          break;
                        case 65365:
                        case 65367:
                        case 65368:
                        case 65380:
                          length = (0, _core_utils.readUint16)(data, position);
                          break;
                        case 65363:
                          throw new Error("Codestream code 0xFF53 (COC) is not implemented");
                        default:
                          throw new Error("Unknown codestream code: " + code.toString(16));
                      }
                      position += length;
                    }
                  } catch (e2) {
                    if (doNotRecover || this.failOnCorruptedImage) {
                      throw new JpxError(e2.message);
                    } else {
                      (0, _util2.warn)("JPX: Trying to recover from: " + e2.message);
                    }
                  }
                  this.tiles = transformComponents(context);
                  this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                  this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                  this.componentsCount = context.SIZ.Csiz;
                }
              };
              function calculateComponentDimensions(component, siz) {
                component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                component.width = component.x1 - component.x0;
                component.height = component.y1 - component.y0;
              }
              function calculateTileGrids(context, components) {
                var siz = context.SIZ;
                var tile, tiles = [];
                var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                for (var q2 = 0; q2 < numYtiles; q2++) {
                  for (var p = 0; p < numXtiles; p++) {
                    tile = {};
                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                    tile.ty0 = Math.max(siz.YTOsiz + q2 * siz.YTsiz, siz.YOsiz);
                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                    tile.ty1 = Math.min(siz.YTOsiz + (q2 + 1) * siz.YTsiz, siz.Ysiz);
                    tile.width = tile.tx1 - tile.tx0;
                    tile.height = tile.ty1 - tile.ty0;
                    tile.components = [];
                    tiles.push(tile);
                  }
                }
                context.tiles = tiles;
                var componentsCount = siz.Csiz;
                for (var i2 = 0, ii = componentsCount; i2 < ii; i2++) {
                  var component = components[i2];
                  for (var j2 = 0, jj = tiles.length; j2 < jj; j2++) {
                    var tileComponent = {};
                    tile = tiles[j2];
                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                    tile.components[i2] = tileComponent;
                  }
                }
              }
              function getBlocksDimensions(context, component, r2) {
                var codOrCoc = component.codingStyleParameters;
                var result = {};
                if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                  result.PPx = 15;
                  result.PPy = 15;
                } else {
                  result.PPx = codOrCoc.precinctsSizes[r2].PPx;
                  result.PPy = codOrCoc.precinctsSizes[r2].PPy;
                }
                result.xcb_ = r2 > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                result.ycb_ = r2 > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                return result;
              }
              function buildPrecincts(context, resolution, dimensions) {
                var precinctWidth = 1 << dimensions.PPx;
                var precinctHeight = 1 << dimensions.PPy;
                var isZeroRes = resolution.resLevel === 0;
                var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                var numprecincts = numprecinctswide * numprecinctshigh;
                resolution.precinctParameters = {
                  precinctWidth,
                  precinctHeight,
                  numprecinctswide,
                  numprecinctshigh,
                  numprecincts,
                  precinctWidthInSubband,
                  precinctHeightInSubband
                };
              }
              function buildCodeblocks(context, subband, dimensions) {
                var xcb_ = dimensions.xcb_;
                var ycb_ = dimensions.ycb_;
                var codeblockWidth = 1 << xcb_;
                var codeblockHeight = 1 << ycb_;
                var cbx0 = subband.tbx0 >> xcb_;
                var cby0 = subband.tby0 >> ycb_;
                var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                var precinctParameters = subband.resolution.precinctParameters;
                var codeblocks = [];
                var precincts = [];
                var i2, j2, codeblock, precinctNumber;
                for (j2 = cby0; j2 < cby1; j2++) {
                  for (i2 = cbx0; i2 < cbx1; i2++) {
                    codeblock = {
                      cbx: i2,
                      cby: j2,
                      tbx0: codeblockWidth * i2,
                      tby0: codeblockHeight * j2,
                      tbx1: codeblockWidth * (i2 + 1),
                      tby1: codeblockHeight * (j2 + 1)
                    };
                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                    var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                    var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                    codeblock.precinctNumber = precinctNumber;
                    codeblock.subbandType = subband.type;
                    codeblock.Lblock = 3;
                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                      continue;
                    }
                    codeblocks.push(codeblock);
                    var precinct = precincts[precinctNumber];
                    if (precinct !== void 0) {
                      if (i2 < precinct.cbxMin) {
                        precinct.cbxMin = i2;
                      } else if (i2 > precinct.cbxMax) {
                        precinct.cbxMax = i2;
                      }
                      if (j2 < precinct.cbyMin) {
                        precinct.cbxMin = j2;
                      } else if (j2 > precinct.cbyMax) {
                        precinct.cbyMax = j2;
                      }
                    } else {
                      precincts[precinctNumber] = precinct = {
                        cbxMin: i2,
                        cbyMin: j2,
                        cbxMax: i2,
                        cbyMax: j2
                      };
                    }
                    codeblock.precinct = precinct;
                  }
                }
                subband.codeblockParameters = {
                  codeblockWidth: xcb_,
                  codeblockHeight: ycb_,
                  numcodeblockwide: cbx1 - cbx0 + 1,
                  numcodeblockhigh: cby1 - cby0 + 1
                };
                subband.codeblocks = codeblocks;
                subband.precincts = precincts;
              }
              function createPacket(resolution, precinctNumber, layerNumber) {
                var precinctCodeblocks = [];
                var subbands = resolution.subbands;
                for (var i2 = 0, ii = subbands.length; i2 < ii; i2++) {
                  var subband = subbands[i2];
                  var codeblocks = subband.codeblocks;
                  for (var j2 = 0, jj = codeblocks.length; j2 < jj; j2++) {
                    var codeblock = codeblocks[j2];
                    if (codeblock.precinctNumber !== precinctNumber) {
                      continue;
                    }
                    precinctCodeblocks.push(codeblock);
                  }
                }
                return {
                  layerNumber,
                  codeblocks: precinctCodeblocks
                };
              }
              function LayerResolutionComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q2 = 0; q2 < componentsCount; q2++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q2].codingStyleParameters.decompositionLevelsCount);
                }
                var l2 = 0, r2 = 0, i2 = 0, k2 = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; l2 < layersCount; l2++) {
                    for (; r2 <= maxDecompositionLevelsCount; r2++) {
                      for (; i2 < componentsCount; i2++) {
                        var component = tile.components[i2];
                        if (r2 > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r2];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k2 < numprecincts; ) {
                          var packet = createPacket(resolution, k2, l2);
                          k2++;
                          return packet;
                        }
                        k2 = 0;
                      }
                      i2 = 0;
                    }
                    r2 = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionLayerComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q2 = 0; q2 < componentsCount; q2++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q2].codingStyleParameters.decompositionLevelsCount);
                }
                var r2 = 0, l2 = 0, i2 = 0, k2 = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r2 <= maxDecompositionLevelsCount; r2++) {
                    for (; l2 < layersCount; l2++) {
                      for (; i2 < componentsCount; i2++) {
                        var component = tile.components[i2];
                        if (r2 > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r2];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k2 < numprecincts; ) {
                          var packet = createPacket(resolution, k2, l2);
                          k2++;
                          return packet;
                        }
                        k2 = 0;
                      }
                      i2 = 0;
                    }
                    l2 = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionPositionComponentLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var l2, r2, c2, p;
                var maxDecompositionLevelsCount = 0;
                for (c2 = 0; c2 < componentsCount; c2++) {
                  var component = tile.components[c2];
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                }
                var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                for (r2 = 0; r2 <= maxDecompositionLevelsCount; ++r2) {
                  var maxNumPrecincts = 0;
                  for (c2 = 0; c2 < componentsCount; ++c2) {
                    var resolutions = tile.components[c2].resolutions;
                    if (r2 < resolutions.length) {
                      maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r2].precinctParameters.numprecincts);
                    }
                  }
                  maxNumPrecinctsInLevel[r2] = maxNumPrecincts;
                }
                l2 = 0;
                r2 = 0;
                c2 = 0;
                p = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r2 <= maxDecompositionLevelsCount; r2++) {
                    for (; p < maxNumPrecinctsInLevel[r2]; p++) {
                      for (; c2 < componentsCount; c2++) {
                        var component2 = tile.components[c2];
                        if (r2 > component2.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component2.resolutions[r2];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        if (p >= numprecincts) {
                          continue;
                        }
                        for (; l2 < layersCount; ) {
                          var packet = createPacket(resolution, p, l2);
                          l2++;
                          return packet;
                        }
                        l2 = 0;
                      }
                      c2 = 0;
                    }
                    p = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function PositionComponentResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var precinctsIterationSizes = precinctsSizes;
                var l2 = 0, r2 = 0, c2 = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                    for (; px < precinctsIterationSizes.maxNumWide; px++) {
                      for (; c2 < componentsCount; c2++) {
                        var component = tile.components[c2];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; r2 <= decompositionLevelsCount; r2++) {
                          var resolution = component.resolutions[r2];
                          var sizeInImageScale = precinctsSizes.components[c2].resolutions[r2];
                          var k2 = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k2 === null) {
                            continue;
                          }
                          for (; l2 < layersCount; ) {
                            var packet = createPacket(resolution, k2, l2);
                            l2++;
                            return packet;
                          }
                          l2 = 0;
                        }
                        r2 = 0;
                      }
                      c2 = 0;
                    }
                    px = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ComponentPositionResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var l2 = 0, r2 = 0, c2 = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; c2 < componentsCount; ++c2) {
                    var component = tile.components[c2];
                    var precinctsIterationSizes = precinctsSizes.components[c2];
                    var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                      for (; px < precinctsIterationSizes.maxNumWide; px++) {
                        for (; r2 <= decompositionLevelsCount; r2++) {
                          var resolution = component.resolutions[r2];
                          var sizeInImageScale = precinctsIterationSizes.resolutions[r2];
                          var k2 = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k2 === null) {
                            continue;
                          }
                          for (; l2 < layersCount; ) {
                            var packet = createPacket(resolution, k2, l2);
                            l2++;
                            return packet;
                          }
                          l2 = 0;
                        }
                        r2 = 0;
                      }
                      px = 0;
                    }
                    py = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                var posX = pxIndex * precinctIterationSizes.minWidth;
                var posY = pyIndex * precinctIterationSizes.minHeight;
                if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                  return null;
                }
                var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                return posX / sizeInImageScale.height + startPrecinctRowIndex;
              }
              function getPrecinctSizesInImageScale(tile) {
                var componentsCount = tile.components.length;
                var minWidth = Number.MAX_VALUE;
                var minHeight = Number.MAX_VALUE;
                var maxNumWide = 0;
                var maxNumHigh = 0;
                var sizePerComponent = new Array(componentsCount);
                for (var c2 = 0; c2 < componentsCount; c2++) {
                  var component = tile.components[c2];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var sizePerResolution = new Array(decompositionLevelsCount + 1);
                  var minWidthCurrentComponent = Number.MAX_VALUE;
                  var minHeightCurrentComponent = Number.MAX_VALUE;
                  var maxNumWideCurrentComponent = 0;
                  var maxNumHighCurrentComponent = 0;
                  var scale = 1;
                  for (var r2 = decompositionLevelsCount; r2 >= 0; --r2) {
                    var resolution = component.resolutions[r2];
                    var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                    var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                    sizePerResolution[r2] = {
                      width: widthCurrentResolution,
                      height: heightCurrentResolution
                    };
                    scale <<= 1;
                  }
                  minWidth = Math.min(minWidth, minWidthCurrentComponent);
                  minHeight = Math.min(minHeight, minHeightCurrentComponent);
                  maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                  maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                  sizePerComponent[c2] = {
                    resolutions: sizePerResolution,
                    minWidth: minWidthCurrentComponent,
                    minHeight: minHeightCurrentComponent,
                    maxNumWide: maxNumWideCurrentComponent,
                    maxNumHigh: maxNumHighCurrentComponent
                  };
                }
                return {
                  components: sizePerComponent,
                  minWidth,
                  minHeight,
                  maxNumWide,
                  maxNumHigh
                };
              }
              function buildPackets(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var componentsCount = siz.Csiz;
                for (var c2 = 0; c2 < componentsCount; c2++) {
                  var component = tile.components[c2];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var resolutions = [];
                  var subbands = [];
                  for (var r2 = 0; r2 <= decompositionLevelsCount; r2++) {
                    var blocksDimensions = getBlocksDimensions(context, component, r2);
                    var resolution = {};
                    var scale = 1 << decompositionLevelsCount - r2;
                    resolution.trx0 = Math.ceil(component.tcx0 / scale);
                    resolution.try0 = Math.ceil(component.tcy0 / scale);
                    resolution.trx1 = Math.ceil(component.tcx1 / scale);
                    resolution.try1 = Math.ceil(component.tcy1 / scale);
                    resolution.resLevel = r2;
                    buildPrecincts(context, resolution, blocksDimensions);
                    resolutions.push(resolution);
                    var subband;
                    if (r2 === 0) {
                      subband = {};
                      subband.type = "LL";
                      subband.tbx0 = Math.ceil(component.tcx0 / scale);
                      subband.tby0 = Math.ceil(component.tcy0 / scale);
                      subband.tbx1 = Math.ceil(component.tcx1 / scale);
                      subband.tby1 = Math.ceil(component.tcy1 / scale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolution.subbands = [subband];
                    } else {
                      var bscale = 1 << decompositionLevelsCount - r2 + 1;
                      var resolutionSubbands = [];
                      subband = {};
                      subband.type = "HL";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "LH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "HH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      resolution.subbands = resolutionSubbands;
                    }
                  }
                  component.resolutions = resolutions;
                  component.subbands = subbands;
                }
                var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                switch (progressionOrder) {
                  case 0:
                    tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                    break;
                  case 1:
                    tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                    break;
                  case 2:
                    tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                    break;
                  case 3:
                    tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                    break;
                  case 4:
                    tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                    break;
                  default:
                    throw new JpxError(`Unsupported progression order ${progressionOrder}`);
                }
              }
              function parseTilePackets(context, data, offset, dataLength) {
                var position = 0;
                var buffer, bufferSize = 0, skipNextBit = false;
                function readBits(count) {
                  while (bufferSize < count) {
                    var b2 = data[offset + position];
                    position++;
                    if (skipNextBit) {
                      buffer = buffer << 7 | b2;
                      bufferSize += 7;
                      skipNextBit = false;
                    } else {
                      buffer = buffer << 8 | b2;
                      bufferSize += 8;
                    }
                    if (b2 === 255) {
                      skipNextBit = true;
                    }
                  }
                  bufferSize -= count;
                  return buffer >>> bufferSize & (1 << count) - 1;
                }
                function skipMarkerIfEqual(value) {
                  if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                    skipBytes(1);
                    return true;
                  } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                    skipBytes(2);
                    return true;
                  }
                  return false;
                }
                function skipBytes(count) {
                  position += count;
                }
                function alignToByte() {
                  bufferSize = 0;
                  if (skipNextBit) {
                    position++;
                    skipNextBit = false;
                  }
                }
                function readCodingpasses() {
                  if (readBits(1) === 0) {
                    return 1;
                  }
                  if (readBits(1) === 0) {
                    return 2;
                  }
                  var value = readBits(2);
                  if (value < 3) {
                    return value + 3;
                  }
                  value = readBits(5);
                  if (value < 31) {
                    return value + 6;
                  }
                  value = readBits(7);
                  return value + 37;
                }
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var sopMarkerUsed = context.COD.sopMarkerUsed;
                var ephMarkerUsed = context.COD.ephMarkerUsed;
                var packetsIterator = tile.packetsIterator;
                while (position < dataLength) {
                  alignToByte();
                  if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                    skipBytes(4);
                  }
                  var packet = packetsIterator.nextPacket();
                  if (!readBits(1)) {
                    continue;
                  }
                  var layerNumber = packet.layerNumber;
                  var queue = [], codeblock;
                  for (var i2 = 0, ii = packet.codeblocks.length; i2 < ii; i2++) {
                    codeblock = packet.codeblocks[i2];
                    var precinct = codeblock.precinct;
                    var codeblockColumn = codeblock.cbx - precinct.cbxMin;
                    var codeblockRow = codeblock.cby - precinct.cbyMin;
                    var codeblockIncluded = false;
                    var firstTimeInclusion = false;
                    var valueReady;
                    if (codeblock["included"] !== void 0) {
                      codeblockIncluded = !!readBits(1);
                    } else {
                      precinct = codeblock.precinct;
                      var inclusionTree, zeroBitPlanesTree;
                      if (precinct["inclusionTree"] !== void 0) {
                        inclusionTree = precinct.inclusionTree;
                      } else {
                        var width = precinct.cbxMax - precinct.cbxMin + 1;
                        var height = precinct.cbyMax - precinct.cbyMin + 1;
                        inclusionTree = new InclusionTree(width, height, layerNumber);
                        zeroBitPlanesTree = new TagTree(width, height);
                        precinct.inclusionTree = inclusionTree;
                        precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                      }
                      if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                        while (true) {
                          if (readBits(1)) {
                            valueReady = !inclusionTree.nextLevel();
                            if (valueReady) {
                              codeblock.included = true;
                              codeblockIncluded = firstTimeInclusion = true;
                              break;
                            }
                          } else {
                            inclusionTree.incrementValue(layerNumber);
                            break;
                          }
                        }
                      }
                    }
                    if (!codeblockIncluded) {
                      continue;
                    }
                    if (firstTimeInclusion) {
                      zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                      zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                      while (true) {
                        if (readBits(1)) {
                          valueReady = !zeroBitPlanesTree.nextLevel();
                          if (valueReady) {
                            break;
                          }
                        } else {
                          zeroBitPlanesTree.incrementValue();
                        }
                      }
                      codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                    }
                    var codingpasses = readCodingpasses();
                    while (readBits(1)) {
                      codeblock.Lblock++;
                    }
                    var codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
                    var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                    var codedDataLength = readBits(bits);
                    queue.push({
                      codeblock,
                      codingpasses,
                      dataLength: codedDataLength
                    });
                  }
                  alignToByte();
                  if (ephMarkerUsed) {
                    skipMarkerIfEqual(146);
                  }
                  while (queue.length > 0) {
                    var packetItem = queue.shift();
                    codeblock = packetItem.codeblock;
                    if (codeblock["data"] === void 0) {
                      codeblock.data = [];
                    }
                    codeblock.data.push({
                      data,
                      start: offset + position,
                      end: offset + position + packetItem.dataLength,
                      codingpasses: packetItem.codingpasses
                    });
                    position += packetItem.dataLength;
                  }
                }
                return position;
              }
              function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
                var x0 = subband.tbx0;
                var y0 = subband.tby0;
                var width = subband.tbx1 - subband.tbx0;
                var codeblocks = subband.codeblocks;
                var right = subband.type.charAt(0) === "H" ? 1 : 0;
                var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                for (var i2 = 0, ii = codeblocks.length; i2 < ii; ++i2) {
                  var codeblock = codeblocks[i2];
                  var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                  var blockHeight = codeblock.tby1_ - codeblock.tby0_;
                  if (blockWidth === 0 || blockHeight === 0) {
                    continue;
                  }
                  if (codeblock["data"] === void 0) {
                    continue;
                  }
                  var bitModel, currentCodingpassType;
                  bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                  currentCodingpassType = 2;
                  var data = codeblock.data, totalLength = 0, codingpasses = 0;
                  var j2, jj, dataItem;
                  for (j2 = 0, jj = data.length; j2 < jj; j2++) {
                    dataItem = data[j2];
                    totalLength += dataItem.end - dataItem.start;
                    codingpasses += dataItem.codingpasses;
                  }
                  var encodedData = new Uint8Array(totalLength);
                  var position = 0;
                  for (j2 = 0, jj = data.length; j2 < jj; j2++) {
                    dataItem = data[j2];
                    var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                    encodedData.set(chunk, position);
                    position += chunk.length;
                  }
                  var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                  bitModel.setDecoder(decoder);
                  for (j2 = 0; j2 < codingpasses; j2++) {
                    switch (currentCodingpassType) {
                      case 0:
                        bitModel.runSignificancePropagationPass();
                        break;
                      case 1:
                        bitModel.runMagnitudeRefinementPass();
                        break;
                      case 2:
                        bitModel.runCleanupPass();
                        if (segmentationSymbolUsed) {
                          bitModel.checkSegmentationSymbol();
                        }
                        break;
                    }
                    currentCodingpassType = (currentCodingpassType + 1) % 3;
                  }
                  var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                  var sign = bitModel.coefficentsSign;
                  var magnitude = bitModel.coefficentsMagnitude;
                  var bitsDecoded = bitModel.bitsDecoded;
                  var magnitudeCorrection = reversible ? 0 : 0.5;
                  var k2, n2, nb;
                  position = 0;
                  var interleave = subband.type !== "LL";
                  for (j2 = 0; j2 < blockHeight; j2++) {
                    var row = offset / width | 0;
                    var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                    for (k2 = 0; k2 < blockWidth; k2++) {
                      n2 = magnitude[position];
                      if (n2 !== 0) {
                        n2 = (n2 + magnitudeCorrection) * delta;
                        if (sign[position] !== 0) {
                          n2 = -n2;
                        }
                        nb = bitsDecoded[position];
                        var pos = interleave ? levelOffset + (offset << 1) : offset;
                        if (reversible && nb >= mb) {
                          coefficients[pos] = n2;
                        } else {
                          coefficients[pos] = n2 * (1 << mb - nb);
                        }
                      }
                      offset++;
                      position++;
                    }
                    offset += width - blockWidth;
                  }
                }
              }
              function transformTile(context, tile, c2) {
                var component = tile.components[c2];
                var codingStyleParameters = component.codingStyleParameters;
                var quantizationParameters = component.quantizationParameters;
                var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                var spqcds = quantizationParameters.SPqcds;
                var scalarExpounded = quantizationParameters.scalarExpounded;
                var guardBits = quantizationParameters.guardBits;
                var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                var precision = context.components[c2].precision;
                var reversible = codingStyleParameters.reversibleTransformation;
                var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                var subbandCoefficients = [];
                var b2 = 0;
                for (var i2 = 0; i2 <= decompositionLevelsCount; i2++) {
                  var resolution = component.resolutions[i2];
                  var width = resolution.trx1 - resolution.trx0;
                  var height = resolution.try1 - resolution.try0;
                  var coefficients = new Float32Array(width * height);
                  for (var j2 = 0, jj = resolution.subbands.length; j2 < jj; j2++) {
                    var mu, epsilon;
                    if (!scalarExpounded) {
                      mu = spqcds[0].mu;
                      epsilon = spqcds[0].epsilon + (i2 > 0 ? 1 - i2 : 0);
                    } else {
                      mu = spqcds[b2].mu;
                      epsilon = spqcds[b2].epsilon;
                      b2++;
                    }
                    var subband = resolution.subbands[j2];
                    var gainLog2 = SubbandsGainLog2[subband.type];
                    var delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
                    var mb = guardBits + epsilon - 1;
                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
                  }
                  subbandCoefficients.push({
                    width,
                    height,
                    items: coefficients
                  });
                }
                var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                return {
                  left: component.tcx0,
                  top: component.tcy0,
                  width: result.width,
                  height: result.height,
                  items: result.items
                };
              }
              function transformComponents(context) {
                var siz = context.SIZ;
                var components = context.components;
                var componentsCount = siz.Csiz;
                var resultImages = [];
                for (var i2 = 0, ii = context.tiles.length; i2 < ii; i2++) {
                  var tile = context.tiles[i2];
                  var transformedTiles = [];
                  var c2;
                  for (c2 = 0; c2 < componentsCount; c2++) {
                    transformedTiles[c2] = transformTile(context, tile, c2);
                  }
                  var tile0 = transformedTiles[0];
                  var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                  var result = {
                    left: tile0.left,
                    top: tile0.top,
                    width: tile0.width,
                    height: tile0.height,
                    items: out
                  };
                  var shift, offset;
                  var pos = 0, j2, jj, y0, y1, y2;
                  if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                    var fourComponents = componentsCount === 4;
                    var y0items = transformedTiles[0].items;
                    var y1items = transformedTiles[1].items;
                    var y2items = transformedTiles[2].items;
                    var y3items = fourComponents ? transformedTiles[3].items : null;
                    shift = components[0].precision - 8;
                    offset = (128 << shift) + 0.5;
                    var component0 = tile.components[0];
                    var alpha01 = componentsCount - 3;
                    jj = y0items.length;
                    if (!component0.codingStyleParameters.reversibleTransformation) {
                      for (j2 = 0; j2 < jj; j2++, pos += alpha01) {
                        y0 = y0items[j2] + offset;
                        y1 = y1items[j2];
                        y2 = y2items[j2];
                        out[pos++] = y0 + 1.402 * y2 >> shift;
                        out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                        out[pos++] = y0 + 1.772 * y1 >> shift;
                      }
                    } else {
                      for (j2 = 0; j2 < jj; j2++, pos += alpha01) {
                        y0 = y0items[j2] + offset;
                        y1 = y1items[j2];
                        y2 = y2items[j2];
                        const g2 = y0 - (y2 + y1 >> 2);
                        out[pos++] = g2 + y2 >> shift;
                        out[pos++] = g2 >> shift;
                        out[pos++] = g2 + y1 >> shift;
                      }
                    }
                    if (fourComponents) {
                      for (j2 = 0, pos = 3; j2 < jj; j2++, pos += 4) {
                        out[pos] = y3items[j2] + offset >> shift;
                      }
                    }
                  } else {
                    for (c2 = 0; c2 < componentsCount; c2++) {
                      var items = transformedTiles[c2].items;
                      shift = components[c2].precision - 8;
                      offset = (128 << shift) + 0.5;
                      for (pos = c2, j2 = 0, jj = items.length; j2 < jj; j2++) {
                        out[pos] = items[j2] + offset >> shift;
                        pos += componentsCount;
                      }
                    }
                  }
                  resultImages.push(result);
                }
                return resultImages;
              }
              function initializeTile(context, tileIndex) {
                var siz = context.SIZ;
                var componentsCount = siz.Csiz;
                var tile = context.tiles[tileIndex];
                for (var c2 = 0; c2 < componentsCount; c2++) {
                  var component = tile.components[c2];
                  var qcdOrQcc = context.currentTile.QCC[c2] !== void 0 ? context.currentTile.QCC[c2] : context.currentTile.QCD;
                  component.quantizationParameters = qcdOrQcc;
                  var codOrCoc = context.currentTile.COC[c2] !== void 0 ? context.currentTile.COC[c2] : context.currentTile.COD;
                  component.codingStyleParameters = codOrCoc;
                }
                tile.codingStyleDefaultParameters = context.currentTile.COD;
              }
              var TagTree = function TagTreeClosure() {
                function TagTree2(width, height) {
                  var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i2 = 0; i2 < levelsLength; i2++) {
                    var level = {
                      width,
                      height,
                      items: []
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                TagTree2.prototype = {
                  reset: function TagTree_reset(i2, j2) {
                    var currentLevel = 0, value = 0, level;
                    while (currentLevel < this.levels.length) {
                      level = this.levels[currentLevel];
                      var index = i2 + j2 * level.width;
                      if (level.items[index] !== void 0) {
                        value = level.items[index];
                        break;
                      }
                      level.index = index;
                      i2 >>= 1;
                      j2 >>= 1;
                      currentLevel++;
                    }
                    currentLevel--;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    this.currentLevel = currentLevel;
                    delete this.value;
                  },
                  incrementValue: function TagTree_incrementValue() {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index]++;
                  },
                  nextLevel: function TagTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    currentLevel--;
                    if (currentLevel < 0) {
                      this.value = value;
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return TagTree2;
              }();
              var InclusionTree = function InclusionTreeClosure() {
                function InclusionTree2(width, height, defaultValue) {
                  var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i2 = 0; i2 < levelsLength; i2++) {
                    var items = new Uint8Array(width * height);
                    for (var j2 = 0, jj = items.length; j2 < jj; j2++) {
                      items[j2] = defaultValue;
                    }
                    var level = {
                      width,
                      height,
                      items
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                InclusionTree2.prototype = {
                  reset: function InclusionTree_reset(i2, j2, stopValue) {
                    var currentLevel = 0;
                    while (currentLevel < this.levels.length) {
                      var level = this.levels[currentLevel];
                      var index = i2 + j2 * level.width;
                      level.index = index;
                      var value = level.items[index];
                      if (value === 255) {
                        break;
                      }
                      if (value > stopValue) {
                        this.currentLevel = currentLevel;
                        this.propagateValues();
                        return false;
                      }
                      i2 >>= 1;
                      j2 >>= 1;
                      currentLevel++;
                    }
                    this.currentLevel = currentLevel - 1;
                    return true;
                  },
                  incrementValue: function InclusionTree_incrementValue(stopValue) {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index] = stopValue + 1;
                    this.propagateValues();
                  },
                  propagateValues: function InclusionTree_propagateValues() {
                    var levelIndex = this.currentLevel;
                    var level = this.levels[levelIndex];
                    var currentValue = level.items[level.index];
                    while (--levelIndex >= 0) {
                      level = this.levels[levelIndex];
                      level.items[level.index] = currentValue;
                    }
                  },
                  nextLevel: function InclusionTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    level.items[level.index] = 255;
                    currentLevel--;
                    if (currentLevel < 0) {
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return InclusionTree2;
              }();
              var BitModel = function BitModelClosure() {
                var UNIFORM_CONTEXT = 17;
                var RUNLENGTH_CONTEXT = 18;
                var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
                function BitModel2(width, height, subband, zeroBitPlanes, mb) {
                  this.width = width;
                  this.height = height;
                  let contextLabelTable;
                  if (subband === "HH") {
                    contextLabelTable = HHContextLabel;
                  } else if (subband === "HL") {
                    contextLabelTable = HLContextLabel;
                  } else {
                    contextLabelTable = LLAndLHContextsLabel;
                  }
                  this.contextLabelTable = contextLabelTable;
                  var coefficientCount = width * height;
                  this.neighborsSignificance = new Uint8Array(coefficientCount);
                  this.coefficentsSign = new Uint8Array(coefficientCount);
                  let coefficentsMagnitude;
                  if (mb > 14) {
                    coefficentsMagnitude = new Uint32Array(coefficientCount);
                  } else if (mb > 6) {
                    coefficentsMagnitude = new Uint16Array(coefficientCount);
                  } else {
                    coefficentsMagnitude = new Uint8Array(coefficientCount);
                  }
                  this.coefficentsMagnitude = coefficentsMagnitude;
                  this.processingFlags = new Uint8Array(coefficientCount);
                  var bitsDecoded = new Uint8Array(coefficientCount);
                  if (zeroBitPlanes !== 0) {
                    for (var i2 = 0; i2 < coefficientCount; i2++) {
                      bitsDecoded[i2] = zeroBitPlanes;
                    }
                  }
                  this.bitsDecoded = bitsDecoded;
                  this.reset();
                }
                BitModel2.prototype = {
                  setDecoder: function BitModel_setDecoder(decoder) {
                    this.decoder = decoder;
                  },
                  reset: function BitModel_reset() {
                    this.contexts = new Int8Array(19);
                    this.contexts[0] = 4 << 1 | 0;
                    this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
                    this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                  },
                  setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
                    var neighborsSignificance = this.neighborsSignificance;
                    var width = this.width, height = this.height;
                    var left = column > 0;
                    var right = column + 1 < width;
                    var i2;
                    if (row > 0) {
                      i2 = index - width;
                      if (left) {
                        neighborsSignificance[i2 - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i2 + 1] += 16;
                      }
                      neighborsSignificance[i2] += 4;
                    }
                    if (row + 1 < height) {
                      i2 = index + width;
                      if (left) {
                        neighborsSignificance[i2 - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i2 + 1] += 16;
                      }
                      neighborsSignificance[i2] += 4;
                    }
                    if (left) {
                      neighborsSignificance[index - 1] += 1;
                    }
                    if (right) {
                      neighborsSignificance[index + 1] += 1;
                    }
                    neighborsSignificance[index] |= 128;
                  },
                  runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var neighborsSignificance = this.neighborsSignificance;
                    var processingFlags = this.processingFlags;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processedInverseMask = ~1;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    for (var i0 = 0; i0 < height; i0 += 4) {
                      for (var j2 = 0; j2 < width; j2++) {
                        var index = i0 * width + j2;
                        for (var i1 = 0; i1 < 4; i1++, index += width) {
                          var i2 = i0 + i1;
                          if (i2 >= height) {
                            break;
                          }
                          processingFlags[index] &= processedInverseMask;
                          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision) {
                            var sign = this.decodeSignBit(i2, j2, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i2, j2, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contribution, sign0, sign1, significance1;
                    var contextLabel, decoded;
                    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                      sign1 = coefficentsSign[index + 1];
                      if (significance1) {
                        sign0 = coefficentsSign[index - 1];
                        contribution = 1 - sign1 - sign0;
                      } else {
                        contribution = 1 - sign1 - sign1;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - 1];
                      contribution = 1 - sign0 - sign0;
                    } else {
                      contribution = 0;
                    }
                    var horizontalContribution = 3 * contribution;
                    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                      sign1 = coefficentsSign[index + width];
                      if (significance1) {
                        sign0 = coefficentsSign[index - width];
                        contribution = 1 - sign1 - sign0 + horizontalContribution;
                      } else {
                        contribution = 1 - sign1 - sign1 + horizontalContribution;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - width];
                      contribution = 1 - sign0 - sign0 + horizontalContribution;
                    } else {
                      contribution = horizontalContribution;
                    }
                    if (contribution >= 0) {
                      contextLabel = 9 + contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel);
                    } else {
                      contextLabel = 9 - contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                    }
                    return decoded;
                  },
                  runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var neighborsSignificance = this.neighborsSignificance;
                    var contexts = this.contexts;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var length = width * height;
                    var width4 = width * 4;
                    for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                      indexNext = Math.min(length, index0 + width4);
                      for (var j2 = 0; j2 < width; j2++) {
                        for (var index = index0 + j2; index < indexNext; index += width) {
                          if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = 16;
                          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                            processingFlags[index] ^= firstMagnitudeBitMask;
                            var significance = neighborsSignificance[index] & 127;
                            contextLabel = significance === 0 ? 15 : 14;
                          }
                          var bit = decoder.readBit(contexts, contextLabel);
                          coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  runCleanupPass: function BitModel_runCleanupPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var neighborsSignificance = this.neighborsSignificance;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var oneRowDown = width;
                    var twoRowsDown = width * 2;
                    var threeRowsDown = width * 3;
                    var iNext;
                    for (var i0 = 0; i0 < height; i0 = iNext) {
                      iNext = Math.min(i0 + 4, height);
                      var indexBase = i0 * width;
                      var checkAllEmpty = i0 + 3 < height;
                      for (var j2 = 0; j2 < width; j2++) {
                        var index0 = indexBase + j2;
                        var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                        var i1 = 0, index = index0;
                        var i2 = i0, sign;
                        if (allEmpty) {
                          var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                          if (!hasSignificantCoefficent) {
                            bitsDecoded[index0]++;
                            bitsDecoded[index0 + oneRowDown]++;
                            bitsDecoded[index0 + twoRowsDown]++;
                            bitsDecoded[index0 + threeRowsDown]++;
                            continue;
                          }
                          i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                          if (i1 !== 0) {
                            i2 = i0 + i1;
                            index += i1 * width;
                          }
                          sign = this.decodeSignBit(i2, j2, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i2, j2, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                          index = index0;
                          for (var i22 = i0; i22 <= i2; i22++, index += width) {
                            bitsDecoded[index]++;
                          }
                          i1++;
                        }
                        for (i2 = i0 + i1; i2 < iNext; i2++, index += width) {
                          if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision === 1) {
                            sign = this.decodeSignBit(i2, j2, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i2, j2, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                        }
                      }
                    }
                  },
                  checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
                    var decoder = this.decoder;
                    var contexts = this.contexts;
                    var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                    if (symbol !== 10) {
                      throw new JpxError("Invalid segmentation symbol");
                    }
                  }
                };
                return BitModel2;
              }();
              var Transform = function TransformClosure() {
                function Transform2() {
                }
                Transform2.prototype.calculate = function transformCalculate(subbands, u0, v0) {
                  var ll = subbands[0];
                  for (var i2 = 1, ii = subbands.length; i2 < ii; i2++) {
                    ll = this.iterate(ll, subbands[i2], u0, v0);
                  }
                  return ll;
                };
                Transform2.prototype.extend = function extend(buffer, offset, size) {
                  var i1 = offset - 1, j1 = offset + 1;
                  var i2 = offset + size - 2, j2 = offset + size;
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1] = buffer[j1];
                  buffer[j2] = buffer[i2];
                };
                Transform2.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
                  var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
                  var width = hl_lh_hh.width;
                  var height = hl_lh_hh.height;
                  var items = hl_lh_hh.items;
                  var i2, j2, k2, l2, u2, v2;
                  for (k2 = 0, i2 = 0; i2 < llHeight; i2++) {
                    l2 = i2 * 2 * width;
                    for (j2 = 0; j2 < llWidth; j2++, k2++, l2 += 2) {
                      items[l2] = llItems[k2];
                    }
                  }
                  llItems = ll.items = null;
                  var bufferPadding = 4;
                  var rowBuffer = new Float32Array(width + 2 * bufferPadding);
                  if (width === 1) {
                    if ((u0 & 1) !== 0) {
                      for (v2 = 0, k2 = 0; v2 < height; v2++, k2 += width) {
                        items[k2] *= 0.5;
                      }
                    }
                  } else {
                    for (v2 = 0, k2 = 0; v2 < height; v2++, k2 += width) {
                      rowBuffer.set(items.subarray(k2, k2 + width), bufferPadding);
                      this.extend(rowBuffer, bufferPadding, width);
                      this.filter(rowBuffer, bufferPadding, width);
                      items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k2);
                    }
                  }
                  var numBuffers = 16;
                  var colBuffers = [];
                  for (i2 = 0; i2 < numBuffers; i2++) {
                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                  }
                  var b2, currentBuffer = 0;
                  ll = bufferPadding + height;
                  if (height === 1) {
                    if ((v0 & 1) !== 0) {
                      for (u2 = 0; u2 < width; u2++) {
                        items[u2] *= 0.5;
                      }
                    }
                  } else {
                    for (u2 = 0; u2 < width; u2++) {
                      if (currentBuffer === 0) {
                        numBuffers = Math.min(width - u2, numBuffers);
                        for (k2 = u2, l2 = bufferPadding; l2 < ll; k2 += width, l2++) {
                          for (b2 = 0; b2 < numBuffers; b2++) {
                            colBuffers[b2][l2] = items[k2 + b2];
                          }
                        }
                        currentBuffer = numBuffers;
                      }
                      currentBuffer--;
                      var buffer = colBuffers[currentBuffer];
                      this.extend(buffer, bufferPadding, height);
                      this.filter(buffer, bufferPadding, height);
                      if (currentBuffer === 0) {
                        k2 = u2 - numBuffers + 1;
                        for (l2 = bufferPadding; l2 < ll; k2 += width, l2++) {
                          for (b2 = 0; b2 < numBuffers; b2++) {
                            items[k2 + b2] = colBuffers[b2][l2];
                          }
                        }
                      }
                    }
                  }
                  return {
                    width,
                    height,
                    items
                  };
                };
                return Transform2;
              }();
              var IrreversibleTransform = function IrreversibleTransformClosure() {
                function IrreversibleTransform2() {
                  Transform.call(this);
                }
                IrreversibleTransform2.prototype = Object.create(Transform.prototype);
                IrreversibleTransform2.prototype.filter = function irreversibleTransformFilter(x2, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j2, n2, current, next;
                  var alpha = -1.586134342059924;
                  var beta = -0.052980118572961;
                  var gamma = 0.882911075530934;
                  var delta = 0.443506852043971;
                  var K2 = 1.230174104914001;
                  var K_ = 1 / K2;
                  j2 = offset - 3;
                  for (n2 = len + 4; n2--; j2 += 2) {
                    x2[j2] *= K_;
                  }
                  j2 = offset - 2;
                  current = delta * x2[j2 - 1];
                  for (n2 = len + 3; n2--; j2 += 2) {
                    next = delta * x2[j2 + 1];
                    x2[j2] = K2 * x2[j2] - current - next;
                    if (n2--) {
                      j2 += 2;
                      current = delta * x2[j2 + 1];
                      x2[j2] = K2 * x2[j2] - current - next;
                    } else {
                      break;
                    }
                  }
                  j2 = offset - 1;
                  current = gamma * x2[j2 - 1];
                  for (n2 = len + 2; n2--; j2 += 2) {
                    next = gamma * x2[j2 + 1];
                    x2[j2] -= current + next;
                    if (n2--) {
                      j2 += 2;
                      current = gamma * x2[j2 + 1];
                      x2[j2] -= current + next;
                    } else {
                      break;
                    }
                  }
                  j2 = offset;
                  current = beta * x2[j2 - 1];
                  for (n2 = len + 1; n2--; j2 += 2) {
                    next = beta * x2[j2 + 1];
                    x2[j2] -= current + next;
                    if (n2--) {
                      j2 += 2;
                      current = beta * x2[j2 + 1];
                      x2[j2] -= current + next;
                    } else {
                      break;
                    }
                  }
                  if (len !== 0) {
                    j2 = offset + 1;
                    current = alpha * x2[j2 - 1];
                    for (n2 = len; n2--; j2 += 2) {
                      next = alpha * x2[j2 + 1];
                      x2[j2] -= current + next;
                      if (n2--) {
                        j2 += 2;
                        current = alpha * x2[j2 + 1];
                        x2[j2] -= current + next;
                      } else {
                        break;
                      }
                    }
                  }
                };
                return IrreversibleTransform2;
              }();
              var ReversibleTransform = function ReversibleTransformClosure() {
                function ReversibleTransform2() {
                  Transform.call(this);
                }
                ReversibleTransform2.prototype = Object.create(Transform.prototype);
                ReversibleTransform2.prototype.filter = function reversibleTransformFilter(x2, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j2, n2;
                  for (j2 = offset, n2 = len + 1; n2--; j2 += 2) {
                    x2[j2] -= x2[j2 - 1] + x2[j2 + 1] + 2 >> 2;
                  }
                  for (j2 = offset + 1, n2 = len; n2--; j2 += 2) {
                    x2[j2] += x2[j2 - 1] + x2[j2 + 1] >> 1;
                  }
                };
                return ReversibleTransform2;
              }();
              return JpxImage2;
            }();
            exports3.JpxImage = JpxImage;
          },
          /* 21 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.calculateSHA512 = exports3.calculateSHA384 = exports3.calculateSHA256 = exports3.calculateMD5 = exports3.PDF20 = exports3.PDF17 = exports3.CipherTransformFactory = exports3.ARCFourCipher = exports3.AES256Cipher = exports3.AES128Cipher = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _stream = __w_pdfjs_require__2(11);
            var ARCFourCipher = function ARCFourCipherClosure() {
              function ARCFourCipher2(key) {
                this.a = 0;
                this.b = 0;
                var s2 = new Uint8Array(256);
                var i2, j2 = 0, tmp, keyLength = key.length;
                for (i2 = 0; i2 < 256; ++i2) {
                  s2[i2] = i2;
                }
                for (i2 = 0; i2 < 256; ++i2) {
                  tmp = s2[i2];
                  j2 = j2 + tmp + key[i2 % keyLength] & 255;
                  s2[i2] = s2[j2];
                  s2[j2] = tmp;
                }
                this.s = s2;
              }
              ARCFourCipher2.prototype = {
                encryptBlock: function ARCFourCipher_encryptBlock(data) {
                  var i2, n2 = data.length, tmp, tmp2;
                  var a2 = this.a, b2 = this.b, s2 = this.s;
                  var output = new Uint8Array(n2);
                  for (i2 = 0; i2 < n2; ++i2) {
                    a2 = a2 + 1 & 255;
                    tmp = s2[a2];
                    b2 = b2 + tmp & 255;
                    tmp2 = s2[b2];
                    s2[a2] = tmp2;
                    s2[b2] = tmp;
                    output[i2] = data[i2] ^ s2[tmp + tmp2 & 255];
                  }
                  this.a = a2;
                  this.b = b2;
                  return output;
                }
              };
              ARCFourCipher2.prototype.decryptBlock = ARCFourCipher2.prototype.encryptBlock;
              return ARCFourCipher2;
            }();
            exports3.ARCFourCipher = ARCFourCipher;
            var calculateMD5 = function calculateMD5Closure() {
              var r2 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
              var k2 = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
              function hash(data, offset, length) {
                var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                var paddedLength = length + 72 & ~63;
                var padded = new Uint8Array(paddedLength);
                var i2, j2, n2;
                for (i2 = 0; i2 < length; ++i2) {
                  padded[i2] = data[offset++];
                }
                padded[i2++] = 128;
                n2 = paddedLength - 8;
                while (i2 < n2) {
                  padded[i2++] = 0;
                }
                padded[i2++] = length << 3 & 255;
                padded[i2++] = length >> 5 & 255;
                padded[i2++] = length >> 13 & 255;
                padded[i2++] = length >> 21 & 255;
                padded[i2++] = length >>> 29 & 255;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                var w2 = new Int32Array(16);
                for (i2 = 0; i2 < paddedLength; ) {
                  for (j2 = 0; j2 < 16; ++j2, i2 += 4) {
                    w2[j2] = padded[i2] | padded[i2 + 1] << 8 | padded[i2 + 2] << 16 | padded[i2 + 3] << 24;
                  }
                  var a2 = h0, b2 = h1, c2 = h2, d2 = h3, f, g2;
                  for (j2 = 0; j2 < 64; ++j2) {
                    if (j2 < 16) {
                      f = b2 & c2 | ~b2 & d2;
                      g2 = j2;
                    } else if (j2 < 32) {
                      f = d2 & b2 | ~d2 & c2;
                      g2 = 5 * j2 + 1 & 15;
                    } else if (j2 < 48) {
                      f = b2 ^ c2 ^ d2;
                      g2 = 3 * j2 + 5 & 15;
                    } else {
                      f = c2 ^ (b2 | ~d2);
                      g2 = 7 * j2 & 15;
                    }
                    var tmp = d2, rotateArg = a2 + f + k2[j2] + w2[g2] | 0, rotate = r2[j2];
                    d2 = c2;
                    c2 = b2;
                    b2 = b2 + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                    a2 = tmp;
                  }
                  h0 = h0 + a2 | 0;
                  h1 = h1 + b2 | 0;
                  h2 = h2 + c2 | 0;
                  h3 = h3 + d2 | 0;
                }
                return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
              }
              return hash;
            }();
            exports3.calculateMD5 = calculateMD5;
            var Word64 = function Word64Closure() {
              function Word642(highInteger, lowInteger) {
                this.high = highInteger | 0;
                this.low = lowInteger | 0;
              }
              Word642.prototype = {
                and: function Word64_and(word) {
                  this.high &= word.high;
                  this.low &= word.low;
                },
                xor: function Word64_xor(word) {
                  this.high ^= word.high;
                  this.low ^= word.low;
                },
                or: function Word64_or(word) {
                  this.high |= word.high;
                  this.low |= word.low;
                },
                shiftRight: function Word64_shiftRight(places) {
                  if (places >= 32) {
                    this.low = this.high >>> places - 32 | 0;
                    this.high = 0;
                  } else {
                    this.low = this.low >>> places | this.high << 32 - places;
                    this.high = this.high >>> places | 0;
                  }
                },
                shiftLeft: function Word64_shiftLeft(places) {
                  if (places >= 32) {
                    this.high = this.low << places - 32;
                    this.low = 0;
                  } else {
                    this.high = this.high << places | this.low >>> 32 - places;
                    this.low = this.low << places;
                  }
                },
                rotateRight: function Word64_rotateRight(places) {
                  var low, high;
                  if (places & 32) {
                    high = this.low;
                    low = this.high;
                  } else {
                    low = this.low;
                    high = this.high;
                  }
                  places &= 31;
                  this.low = low >>> places | high << 32 - places;
                  this.high = high >>> places | low << 32 - places;
                },
                not: function Word64_not() {
                  this.high = ~this.high;
                  this.low = ~this.low;
                },
                add: function Word64_add(word) {
                  var lowAdd = (this.low >>> 0) + (word.low >>> 0);
                  var highAdd = (this.high >>> 0) + (word.high >>> 0);
                  if (lowAdd > 4294967295) {
                    highAdd += 1;
                  }
                  this.low = lowAdd | 0;
                  this.high = highAdd | 0;
                },
                copyTo: function Word64_copyTo(bytes, offset) {
                  bytes[offset] = this.high >>> 24 & 255;
                  bytes[offset + 1] = this.high >> 16 & 255;
                  bytes[offset + 2] = this.high >> 8 & 255;
                  bytes[offset + 3] = this.high & 255;
                  bytes[offset + 4] = this.low >>> 24 & 255;
                  bytes[offset + 5] = this.low >> 16 & 255;
                  bytes[offset + 6] = this.low >> 8 & 255;
                  bytes[offset + 7] = this.low & 255;
                },
                assign: function Word64_assign(word) {
                  this.high = word.high;
                  this.low = word.low;
                }
              };
              return Word642;
            }();
            var calculateSHA256 = function calculateSHA256Closure() {
              function rotr(x2, n2) {
                return x2 >>> n2 | x2 << 32 - n2;
              }
              function ch(x2, y2, z2) {
                return x2 & y2 ^ ~x2 & z2;
              }
              function maj(x2, y2, z2) {
                return x2 & y2 ^ x2 & z2 ^ y2 & z2;
              }
              function sigma(x2) {
                return rotr(x2, 2) ^ rotr(x2, 13) ^ rotr(x2, 22);
              }
              function sigmaPrime(x2) {
                return rotr(x2, 6) ^ rotr(x2, 11) ^ rotr(x2, 25);
              }
              function littleSigma(x2) {
                return rotr(x2, 7) ^ rotr(x2, 18) ^ x2 >>> 3;
              }
              function littleSigmaPrime(x2) {
                return rotr(x2, 17) ^ rotr(x2, 19) ^ x2 >>> 10;
              }
              var k2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
              function hash(data, offset, length) {
                var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                var paddedLength = Math.ceil((length + 9) / 64) * 64;
                var padded = new Uint8Array(paddedLength);
                var i2, j2, n2;
                for (i2 = 0; i2 < length; ++i2) {
                  padded[i2] = data[offset++];
                }
                padded[i2++] = 128;
                n2 = paddedLength - 8;
                while (i2 < n2) {
                  padded[i2++] = 0;
                }
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = length >>> 29 & 255;
                padded[i2++] = length >> 21 & 255;
                padded[i2++] = length >> 13 & 255;
                padded[i2++] = length >> 5 & 255;
                padded[i2++] = length << 3 & 255;
                var w2 = new Uint32Array(64);
                for (i2 = 0; i2 < paddedLength; ) {
                  for (j2 = 0; j2 < 16; ++j2) {
                    w2[j2] = padded[i2] << 24 | padded[i2 + 1] << 16 | padded[i2 + 2] << 8 | padded[i2 + 3];
                    i2 += 4;
                  }
                  for (j2 = 16; j2 < 64; ++j2) {
                    w2[j2] = littleSigmaPrime(w2[j2 - 2]) + w2[j2 - 7] + littleSigma(w2[j2 - 15]) + w2[j2 - 16] | 0;
                  }
                  var a2 = h0, b2 = h1, c2 = h2, d2 = h3, e2 = h4, f = h5, g2 = h6, h8 = h7, t1, t2;
                  for (j2 = 0; j2 < 64; ++j2) {
                    t1 = h8 + sigmaPrime(e2) + ch(e2, f, g2) + k2[j2] + w2[j2];
                    t2 = sigma(a2) + maj(a2, b2, c2);
                    h8 = g2;
                    g2 = f;
                    f = e2;
                    e2 = d2 + t1 | 0;
                    d2 = c2;
                    c2 = b2;
                    b2 = a2;
                    a2 = t1 + t2 | 0;
                  }
                  h0 = h0 + a2 | 0;
                  h1 = h1 + b2 | 0;
                  h2 = h2 + c2 | 0;
                  h3 = h3 + d2 | 0;
                  h4 = h4 + e2 | 0;
                  h5 = h5 + f | 0;
                  h6 = h6 + g2 | 0;
                  h7 = h7 + h8 | 0;
                }
                return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
              }
              return hash;
            }();
            exports3.calculateSHA256 = calculateSHA256;
            var calculateSHA512 = function calculateSHA512Closure() {
              function ch(result, x2, y2, z2, tmp) {
                result.assign(x2);
                result.and(y2);
                tmp.assign(x2);
                tmp.not();
                tmp.and(z2);
                result.xor(tmp);
              }
              function maj(result, x2, y2, z2, tmp) {
                result.assign(x2);
                result.and(y2);
                tmp.assign(x2);
                tmp.and(z2);
                result.xor(tmp);
                tmp.assign(y2);
                tmp.and(z2);
                result.xor(tmp);
              }
              function sigma(result, x2, tmp) {
                result.assign(x2);
                result.rotateRight(28);
                tmp.assign(x2);
                tmp.rotateRight(34);
                result.xor(tmp);
                tmp.assign(x2);
                tmp.rotateRight(39);
                result.xor(tmp);
              }
              function sigmaPrime(result, x2, tmp) {
                result.assign(x2);
                result.rotateRight(14);
                tmp.assign(x2);
                tmp.rotateRight(18);
                result.xor(tmp);
                tmp.assign(x2);
                tmp.rotateRight(41);
                result.xor(tmp);
              }
              function littleSigma(result, x2, tmp) {
                result.assign(x2);
                result.rotateRight(1);
                tmp.assign(x2);
                tmp.rotateRight(8);
                result.xor(tmp);
                tmp.assign(x2);
                tmp.shiftRight(7);
                result.xor(tmp);
              }
              function littleSigmaPrime(result, x2, tmp) {
                result.assign(x2);
                result.rotateRight(19);
                tmp.assign(x2);
                tmp.rotateRight(61);
                result.xor(tmp);
                tmp.assign(x2);
                tmp.shiftRight(6);
                result.xor(tmp);
              }
              var k2 = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
              function hash(data, offset, length, mode384) {
                mode384 = !!mode384;
                var h0, h1, h2, h3, h4, h5, h6, h7;
                if (!mode384) {
                  h0 = new Word64(1779033703, 4089235720);
                  h1 = new Word64(3144134277, 2227873595);
                  h2 = new Word64(1013904242, 4271175723);
                  h3 = new Word64(2773480762, 1595750129);
                  h4 = new Word64(1359893119, 2917565137);
                  h5 = new Word64(2600822924, 725511199);
                  h6 = new Word64(528734635, 4215389547);
                  h7 = new Word64(1541459225, 327033209);
                } else {
                  h0 = new Word64(3418070365, 3238371032);
                  h1 = new Word64(1654270250, 914150663);
                  h2 = new Word64(2438529370, 812702999);
                  h3 = new Word64(355462360, 4144912697);
                  h4 = new Word64(1731405415, 4290775857);
                  h5 = new Word64(2394180231, 1750603025);
                  h6 = new Word64(3675008525, 1694076839);
                  h7 = new Word64(1203062813, 3204075428);
                }
                var paddedLength = Math.ceil((length + 17) / 128) * 128;
                var padded = new Uint8Array(paddedLength);
                var i2, j2, n2;
                for (i2 = 0; i2 < length; ++i2) {
                  padded[i2] = data[offset++];
                }
                padded[i2++] = 128;
                n2 = paddedLength - 16;
                while (i2 < n2) {
                  padded[i2++] = 0;
                }
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = 0;
                padded[i2++] = length >>> 29 & 255;
                padded[i2++] = length >> 21 & 255;
                padded[i2++] = length >> 13 & 255;
                padded[i2++] = length >> 5 & 255;
                padded[i2++] = length << 3 & 255;
                var w2 = new Array(80);
                for (i2 = 0; i2 < 80; i2++) {
                  w2[i2] = new Word64(0, 0);
                }
                var a2 = new Word64(0, 0), b2 = new Word64(0, 0), c2 = new Word64(0, 0);
                var d2 = new Word64(0, 0), e2 = new Word64(0, 0), f = new Word64(0, 0);
                var g2 = new Word64(0, 0), h8 = new Word64(0, 0);
                var t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                var tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0), tmp3;
                for (i2 = 0; i2 < paddedLength; ) {
                  for (j2 = 0; j2 < 16; ++j2) {
                    w2[j2].high = padded[i2] << 24 | padded[i2 + 1] << 16 | padded[i2 + 2] << 8 | padded[i2 + 3];
                    w2[j2].low = padded[i2 + 4] << 24 | padded[i2 + 5] << 16 | padded[i2 + 6] << 8 | padded[i2 + 7];
                    i2 += 8;
                  }
                  for (j2 = 16; j2 < 80; ++j2) {
                    tmp3 = w2[j2];
                    littleSigmaPrime(tmp3, w2[j2 - 2], tmp2);
                    tmp3.add(w2[j2 - 7]);
                    littleSigma(tmp1, w2[j2 - 15], tmp2);
                    tmp3.add(tmp1);
                    tmp3.add(w2[j2 - 16]);
                  }
                  a2.assign(h0);
                  b2.assign(h1);
                  c2.assign(h2);
                  d2.assign(h3);
                  e2.assign(h4);
                  f.assign(h5);
                  g2.assign(h6);
                  h8.assign(h7);
                  for (j2 = 0; j2 < 80; ++j2) {
                    t1.assign(h8);
                    sigmaPrime(tmp1, e2, tmp2);
                    t1.add(tmp1);
                    ch(tmp1, e2, f, g2, tmp2);
                    t1.add(tmp1);
                    t1.add(k2[j2]);
                    t1.add(w2[j2]);
                    sigma(t2, a2, tmp2);
                    maj(tmp1, a2, b2, c2, tmp2);
                    t2.add(tmp1);
                    tmp3 = h8;
                    h8 = g2;
                    g2 = f;
                    f = e2;
                    d2.add(t1);
                    e2 = d2;
                    d2 = c2;
                    c2 = b2;
                    b2 = a2;
                    tmp3.assign(t1);
                    tmp3.add(t2);
                    a2 = tmp3;
                  }
                  h0.add(a2);
                  h1.add(b2);
                  h2.add(c2);
                  h3.add(d2);
                  h4.add(e2);
                  h5.add(f);
                  h6.add(g2);
                  h7.add(h8);
                }
                var result;
                if (!mode384) {
                  result = new Uint8Array(64);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                  h6.copyTo(result, 48);
                  h7.copyTo(result, 56);
                } else {
                  result = new Uint8Array(48);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                }
                return result;
              }
              return hash;
            }();
            exports3.calculateSHA512 = calculateSHA512;
            var calculateSHA384 = function calculateSHA384Closure() {
              function hash(data, offset, length) {
                return calculateSHA512(data, offset, length, true);
              }
              return hash;
            }();
            exports3.calculateSHA384 = calculateSHA384;
            var NullCipher = function NullCipherClosure() {
              function NullCipher2() {
              }
              NullCipher2.prototype = {
                decryptBlock: function NullCipher_decryptBlock(data) {
                  return data;
                }
              };
              return NullCipher2;
            }();
            class AESBaseCipher {
              constructor() {
                if (this.constructor === AESBaseCipher) {
                  (0, _util2.unreachable)("Cannot initialize AESBaseCipher.");
                }
                this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
                this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
                this._mixCol = new Uint8Array(256);
                for (let i2 = 0; i2 < 256; i2++) {
                  if (i2 < 128) {
                    this._mixCol[i2] = i2 << 1;
                  } else {
                    this._mixCol[i2] = i2 << 1 ^ 27;
                  }
                }
                this.buffer = new Uint8Array(16);
                this.bufferPosition = 0;
              }
              _expandKey(cipherKey) {
                (0, _util2.unreachable)("Cannot call `_expandKey` on the base class");
              }
              _decrypt(input, key) {
                let t2, u2, v2;
                const state = new Uint8Array(16);
                state.set(input);
                for (let j2 = 0, k2 = this._keySize; j2 < 16; ++j2, ++k2) {
                  state[j2] ^= key[k2];
                }
                for (let i2 = this._cyclesOfRepetition - 1; i2 >= 1; --i2) {
                  t2 = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t2;
                  t2 = state[14];
                  u2 = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t2;
                  state[2] = u2;
                  t2 = state[15];
                  u2 = state[11];
                  v2 = state[7];
                  state[15] = state[3];
                  state[11] = t2;
                  state[7] = u2;
                  state[3] = v2;
                  for (let j2 = 0; j2 < 16; ++j2) {
                    state[j2] = this._inv_s[state[j2]];
                  }
                  for (let j2 = 0, k2 = i2 * 16; j2 < 16; ++j2, ++k2) {
                    state[j2] ^= key[k2];
                  }
                  for (let j2 = 0; j2 < 16; j2 += 4) {
                    const s0 = this._mix[state[j2]];
                    const s1 = this._mix[state[j2 + 1]];
                    const s2 = this._mix[state[j2 + 2]];
                    const s3 = this._mix[state[j2 + 3]];
                    t2 = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                    state[j2] = t2 >>> 24 & 255;
                    state[j2 + 1] = t2 >> 16 & 255;
                    state[j2 + 2] = t2 >> 8 & 255;
                    state[j2 + 3] = t2 & 255;
                  }
                }
                t2 = state[13];
                state[13] = state[9];
                state[9] = state[5];
                state[5] = state[1];
                state[1] = t2;
                t2 = state[14];
                u2 = state[10];
                state[14] = state[6];
                state[10] = state[2];
                state[6] = t2;
                state[2] = u2;
                t2 = state[15];
                u2 = state[11];
                v2 = state[7];
                state[15] = state[3];
                state[11] = t2;
                state[7] = u2;
                state[3] = v2;
                for (let j2 = 0; j2 < 16; ++j2) {
                  state[j2] = this._inv_s[state[j2]];
                  state[j2] ^= key[j2];
                }
                return state;
              }
              _encrypt(input, key) {
                const s2 = this._s;
                let t2, u2, v2;
                const state = new Uint8Array(16);
                state.set(input);
                for (let j2 = 0; j2 < 16; ++j2) {
                  state[j2] ^= key[j2];
                }
                for (let i2 = 1; i2 < this._cyclesOfRepetition; i2++) {
                  for (let j2 = 0; j2 < 16; ++j2) {
                    state[j2] = s2[state[j2]];
                  }
                  v2 = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v2;
                  v2 = state[2];
                  u2 = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v2;
                  state[14] = u2;
                  v2 = state[3];
                  u2 = state[7];
                  t2 = state[11];
                  state[3] = state[15];
                  state[7] = v2;
                  state[11] = u2;
                  state[15] = t2;
                  for (let j2 = 0; j2 < 16; j2 += 4) {
                    const s0 = state[j2 + 0];
                    const s1 = state[j2 + 1];
                    const s22 = state[j2 + 2];
                    const s3 = state[j2 + 3];
                    t2 = s0 ^ s1 ^ s22 ^ s3;
                    state[j2 + 0] ^= t2 ^ this._mixCol[s0 ^ s1];
                    state[j2 + 1] ^= t2 ^ this._mixCol[s1 ^ s22];
                    state[j2 + 2] ^= t2 ^ this._mixCol[s22 ^ s3];
                    state[j2 + 3] ^= t2 ^ this._mixCol[s3 ^ s0];
                  }
                  for (let j2 = 0, k2 = i2 * 16; j2 < 16; ++j2, ++k2) {
                    state[j2] ^= key[k2];
                  }
                }
                for (let j2 = 0; j2 < 16; ++j2) {
                  state[j2] = s2[state[j2]];
                }
                v2 = state[1];
                state[1] = state[5];
                state[5] = state[9];
                state[9] = state[13];
                state[13] = v2;
                v2 = state[2];
                u2 = state[6];
                state[2] = state[10];
                state[6] = state[14];
                state[10] = v2;
                state[14] = u2;
                v2 = state[3];
                u2 = state[7];
                t2 = state[11];
                state[3] = state[15];
                state[7] = v2;
                state[11] = u2;
                state[15] = t2;
                for (let j2 = 0, k2 = this._keySize; j2 < 16; ++j2, ++k2) {
                  state[j2] ^= key[k2];
                }
                return state;
              }
              _decryptBlock2(data, finalize) {
                const sourceLength = data.length;
                let buffer = this.buffer, bufferLength = this.bufferPosition;
                const result = [];
                let iv = this.iv;
                for (let i2 = 0; i2 < sourceLength; ++i2) {
                  buffer[bufferLength] = data[i2];
                  ++bufferLength;
                  if (bufferLength < 16) {
                    continue;
                  }
                  const plain = this._decrypt(buffer, this._key);
                  for (let j2 = 0; j2 < 16; ++j2) {
                    plain[j2] ^= iv[j2];
                  }
                  iv = buffer;
                  result.push(plain);
                  buffer = new Uint8Array(16);
                  bufferLength = 0;
                }
                this.buffer = buffer;
                this.bufferLength = bufferLength;
                this.iv = iv;
                if (result.length === 0) {
                  return new Uint8Array(0);
                }
                let outputLength = 16 * result.length;
                if (finalize) {
                  const lastBlock = result[result.length - 1];
                  let psLen = lastBlock[15];
                  if (psLen <= 16) {
                    for (let i2 = 15, ii = 16 - psLen; i2 >= ii; --i2) {
                      if (lastBlock[i2] !== psLen) {
                        psLen = 0;
                        break;
                      }
                    }
                    outputLength -= psLen;
                    result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                  }
                }
                const output = new Uint8Array(outputLength);
                for (let i2 = 0, j2 = 0, ii = result.length; i2 < ii; ++i2, j2 += 16) {
                  output.set(result[i2], j2);
                }
                return output;
              }
              decryptBlock(data, finalize, iv = null) {
                const sourceLength = data.length;
                const buffer = this.buffer;
                let bufferLength = this.bufferPosition;
                if (iv) {
                  this.iv = iv;
                } else {
                  for (let i2 = 0; bufferLength < 16 && i2 < sourceLength; ++i2, ++bufferLength) {
                    buffer[bufferLength] = data[i2];
                  }
                  if (bufferLength < 16) {
                    this.bufferLength = bufferLength;
                    return new Uint8Array(0);
                  }
                  this.iv = buffer;
                  data = data.subarray(16);
                }
                this.buffer = new Uint8Array(16);
                this.bufferLength = 0;
                this.decryptBlock = this._decryptBlock2;
                return this.decryptBlock(data, finalize);
              }
              encrypt(data, iv) {
                const sourceLength = data.length;
                let buffer = this.buffer, bufferLength = this.bufferPosition;
                const result = [];
                if (!iv) {
                  iv = new Uint8Array(16);
                }
                for (let i2 = 0; i2 < sourceLength; ++i2) {
                  buffer[bufferLength] = data[i2];
                  ++bufferLength;
                  if (bufferLength < 16) {
                    continue;
                  }
                  for (let j2 = 0; j2 < 16; ++j2) {
                    buffer[j2] ^= iv[j2];
                  }
                  const cipher = this._encrypt(buffer, this._key);
                  iv = cipher;
                  result.push(cipher);
                  buffer = new Uint8Array(16);
                  bufferLength = 0;
                }
                this.buffer = buffer;
                this.bufferLength = bufferLength;
                this.iv = iv;
                if (result.length === 0) {
                  return new Uint8Array(0);
                }
                const outputLength = 16 * result.length;
                const output = new Uint8Array(outputLength);
                for (let i2 = 0, j2 = 0, ii = result.length; i2 < ii; ++i2, j2 += 16) {
                  output.set(result[i2], j2);
                }
                return output;
              }
            }
            class AES128Cipher extends AESBaseCipher {
              constructor(key) {
                super();
                this._cyclesOfRepetition = 10;
                this._keySize = 160;
                this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
                this._key = this._expandKey(key);
              }
              _expandKey(cipherKey) {
                const b2 = 176;
                const s2 = this._s;
                const rcon = this._rcon;
                const result = new Uint8Array(b2);
                result.set(cipherKey);
                for (let j2 = 16, i2 = 1; j2 < b2; ++i2) {
                  let t1 = result[j2 - 3];
                  let t2 = result[j2 - 2];
                  let t3 = result[j2 - 1];
                  let t4 = result[j2 - 4];
                  t1 = s2[t1];
                  t2 = s2[t2];
                  t3 = s2[t3];
                  t4 = s2[t4];
                  t1 = t1 ^ rcon[i2];
                  for (let n2 = 0; n2 < 4; ++n2) {
                    result[j2] = t1 ^= result[j2 - 16];
                    j2++;
                    result[j2] = t2 ^= result[j2 - 16];
                    j2++;
                    result[j2] = t3 ^= result[j2 - 16];
                    j2++;
                    result[j2] = t4 ^= result[j2 - 16];
                    j2++;
                  }
                }
                return result;
              }
            }
            exports3.AES128Cipher = AES128Cipher;
            class AES256Cipher extends AESBaseCipher {
              constructor(key) {
                super();
                this._cyclesOfRepetition = 14;
                this._keySize = 224;
                this._key = this._expandKey(key);
              }
              _expandKey(cipherKey) {
                const b2 = 240;
                const s2 = this._s;
                const result = new Uint8Array(b2);
                result.set(cipherKey);
                let r2 = 1;
                let t1, t2, t3, t4;
                for (let j2 = 32, i2 = 1; j2 < b2; ++i2) {
                  if (j2 % 32 === 16) {
                    t1 = s2[t1];
                    t2 = s2[t2];
                    t3 = s2[t3];
                    t4 = s2[t4];
                  } else if (j2 % 32 === 0) {
                    t1 = result[j2 - 3];
                    t2 = result[j2 - 2];
                    t3 = result[j2 - 1];
                    t4 = result[j2 - 4];
                    t1 = s2[t1];
                    t2 = s2[t2];
                    t3 = s2[t3];
                    t4 = s2[t4];
                    t1 = t1 ^ r2;
                    if ((r2 <<= 1) >= 256) {
                      r2 = (r2 ^ 27) & 255;
                    }
                  }
                  for (let n2 = 0; n2 < 4; ++n2) {
                    result[j2] = t1 ^= result[j2 - 32];
                    j2++;
                    result[j2] = t2 ^= result[j2 - 32];
                    j2++;
                    result[j2] = t3 ^= result[j2 - 32];
                    j2++;
                    result[j2] = t4 ^= result[j2 - 32];
                    j2++;
                  }
                }
                return result;
              }
            }
            exports3.AES256Cipher = AES256Cipher;
            var PDF17 = function PDF17Closure() {
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i2 = 0; i2 < array1.length; i2++) {
                  if (array1[i2] !== array2[i2]) {
                    return false;
                  }
                }
                return true;
              }
              function PDF172() {
              }
              PDF172.prototype = {
                checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF172;
            }();
            exports3.PDF17 = PDF17;
            var PDF20 = function PDF20Closure() {
              function concatArrays(array1, array2) {
                var t2 = new Uint8Array(array1.length + array2.length);
                t2.set(array1, 0);
                t2.set(array2, array1.length);
                return t2;
              }
              function calculatePDF20Hash(password, input, userBytes) {
                var k2 = calculateSHA256(input, 0, input.length).subarray(0, 32);
                var e2 = [0];
                var i2 = 0;
                while (i2 < 64 || e2[e2.length - 1] > i2 - 32) {
                  var arrayLength = password.length + k2.length + userBytes.length;
                  var k1 = new Uint8Array(arrayLength * 64);
                  var array = concatArrays(password, k2);
                  array = concatArrays(array, userBytes);
                  for (var j2 = 0, pos = 0; j2 < 64; j2++, pos += arrayLength) {
                    k1.set(array, pos);
                  }
                  var cipher = new AES128Cipher(k2.subarray(0, 16));
                  e2 = cipher.encrypt(k1, k2.subarray(16, 32));
                  var remainder = 0;
                  for (var z2 = 0; z2 < 16; z2++) {
                    remainder *= 256 % 3;
                    remainder %= 3;
                    remainder += (e2[z2] >>> 0) % 3;
                    remainder %= 3;
                  }
                  if (remainder === 0) {
                    k2 = calculateSHA256(e2, 0, e2.length);
                  } else if (remainder === 1) {
                    k2 = calculateSHA384(e2, 0, e2.length);
                  } else if (remainder === 2) {
                    k2 = calculateSHA512(e2, 0, e2.length);
                  }
                  i2++;
                }
                return k2.subarray(0, 32);
              }
              function PDF202() {
              }
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i2 = 0; i2 < array1.length; i2++) {
                  if (array1[i2] !== array2[i2]) {
                    return false;
                  }
                }
                return true;
              }
              PDF202.prototype = {
                hash: function PDF20_hash(password, concatBytes, userBytes) {
                  return calculatePDF20Hash(password, concatBytes, userBytes);
                },
                checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculatePDF20Hash(password, hashData, userBytes);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculatePDF20Hash(password, hashData, []);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculatePDF20Hash(password, hashData, userBytes);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculatePDF20Hash(password, hashData, []);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF202;
            }();
            exports3.PDF20 = PDF20;
            var CipherTransform = function CipherTransformClosure() {
              function CipherTransform2(stringCipherConstructor, streamCipherConstructor) {
                this.StringCipherConstructor = stringCipherConstructor;
                this.StreamCipherConstructor = streamCipherConstructor;
              }
              CipherTransform2.prototype = {
                createStream: function CipherTransform_createStream(stream, length) {
                  var cipher = new this.StreamCipherConstructor();
                  return new _stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
                    return cipher.decryptBlock(data, finalize);
                  });
                },
                decryptString: function CipherTransform_decryptString(s2) {
                  var cipher = new this.StringCipherConstructor();
                  var data = (0, _util2.stringToBytes)(s2);
                  data = cipher.decryptBlock(data, true);
                  return (0, _util2.bytesToString)(data);
                }
              };
              return CipherTransform2;
            }();
            var CipherTransformFactory = function CipherTransformFactoryClosure() {
              var defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
              function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                if (password) {
                  var passwordLength = Math.min(127, password.length);
                  password = password.subarray(0, passwordLength);
                } else {
                  password = [];
                }
                var pdfAlgorithm;
                if (revision === 6) {
                  pdfAlgorithm = new PDF20();
                } else {
                  pdfAlgorithm = new PDF17();
                }
                if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                  return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                  return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                }
                return null;
              }
              function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                var hashDataSize = 40 + ownerPassword.length + fileId.length;
                var hashData = new Uint8Array(hashDataSize), i2 = 0, j2, n2;
                if (password) {
                  n2 = Math.min(32, password.length);
                  for (; i2 < n2; ++i2) {
                    hashData[i2] = password[i2];
                  }
                }
                j2 = 0;
                while (i2 < 32) {
                  hashData[i2++] = defaultPasswordBytes[j2++];
                }
                for (j2 = 0, n2 = ownerPassword.length; j2 < n2; ++j2) {
                  hashData[i2++] = ownerPassword[j2];
                }
                hashData[i2++] = flags & 255;
                hashData[i2++] = flags >> 8 & 255;
                hashData[i2++] = flags >> 16 & 255;
                hashData[i2++] = flags >>> 24 & 255;
                for (j2 = 0, n2 = fileId.length; j2 < n2; ++j2) {
                  hashData[i2++] = fileId[j2];
                }
                if (revision >= 4 && !encryptMetadata) {
                  hashData[i2++] = 255;
                  hashData[i2++] = 255;
                  hashData[i2++] = 255;
                  hashData[i2++] = 255;
                }
                var hash = calculateMD5(hashData, 0, i2);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j2 = 0; j2 < 50; ++j2) {
                    hash = calculateMD5(hash, 0, keyLengthInBytes);
                  }
                }
                var encryptionKey = hash.subarray(0, keyLengthInBytes);
                var cipher, checkData;
                if (revision >= 3) {
                  for (i2 = 0; i2 < 32; ++i2) {
                    hashData[i2] = defaultPasswordBytes[i2];
                  }
                  for (j2 = 0, n2 = fileId.length; j2 < n2; ++j2) {
                    hashData[i2++] = fileId[j2];
                  }
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i2));
                  n2 = encryptionKey.length;
                  var derivedKey = new Uint8Array(n2), k2;
                  for (j2 = 1; j2 <= 19; ++j2) {
                    for (k2 = 0; k2 < n2; ++k2) {
                      derivedKey[k2] = encryptionKey[k2] ^ j2;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    checkData = cipher.encryptBlock(checkData);
                  }
                  for (j2 = 0, n2 = checkData.length; j2 < n2; ++j2) {
                    if (userPassword[j2] !== checkData[j2]) {
                      return null;
                    }
                  }
                } else {
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(defaultPasswordBytes);
                  for (j2 = 0, n2 = checkData.length; j2 < n2; ++j2) {
                    if (userPassword[j2] !== checkData[j2]) {
                      return null;
                    }
                  }
                }
                return encryptionKey;
              }
              function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                var hashData = new Uint8Array(32), i2 = 0, j2, n2;
                n2 = Math.min(32, password.length);
                for (; i2 < n2; ++i2) {
                  hashData[i2] = password[i2];
                }
                j2 = 0;
                while (i2 < 32) {
                  hashData[i2++] = defaultPasswordBytes[j2++];
                }
                var hash = calculateMD5(hashData, 0, i2);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j2 = 0; j2 < 50; ++j2) {
                    hash = calculateMD5(hash, 0, hash.length);
                  }
                }
                var cipher, userPassword;
                if (revision >= 3) {
                  userPassword = ownerPassword;
                  var derivedKey = new Uint8Array(keyLengthInBytes), k2;
                  for (j2 = 19; j2 >= 0; j2--) {
                    for (k2 = 0; k2 < keyLengthInBytes; ++k2) {
                      derivedKey[k2] = hash[k2] ^ j2;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    userPassword = cipher.encryptBlock(userPassword);
                  }
                } else {
                  cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                  userPassword = cipher.encryptBlock(ownerPassword);
                }
                return userPassword;
              }
              var identityName = _primitives.Name.get("Identity");
              function CipherTransformFactory2(dict, fileId, password) {
                var filter = dict.get("Filter");
                if (!(0, _primitives.isName)(filter, "Standard")) {
                  throw new _util2.FormatError("unknown encryption method");
                }
                this.dict = dict;
                var algorithm = dict.get("V");
                if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                  throw new _util2.FormatError("unsupported encryption algorithm");
                }
                this.algorithm = algorithm;
                var keyLength = dict.get("Length");
                if (!keyLength) {
                  if (algorithm <= 3) {
                    keyLength = 40;
                  } else {
                    var cfDict = dict.get("CF");
                    var streamCryptoName = dict.get("StmF");
                    if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
                      cfDict.suppressEncryption = true;
                      var handlerDict = cfDict.get(streamCryptoName.name);
                      keyLength = handlerDict && handlerDict.get("Length") || 128;
                      if (keyLength < 40) {
                        keyLength <<= 3;
                      }
                    }
                  }
                }
                if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                  throw new _util2.FormatError("invalid key length");
                }
                var ownerPassword = (0, _util2.stringToBytes)(dict.get("O")).subarray(0, 32);
                var userPassword = (0, _util2.stringToBytes)(dict.get("U")).subarray(0, 32);
                var flags = dict.get("P");
                var revision = dict.get("R");
                var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                this.encryptMetadata = encryptMetadata;
                var fileIdBytes = (0, _util2.stringToBytes)(fileId);
                var passwordBytes;
                if (password) {
                  if (revision === 6) {
                    try {
                      password = (0, _util2.utf8StringToString)(password);
                    } catch (ex) {
                      (0, _util2.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  }
                  passwordBytes = (0, _util2.stringToBytes)(password);
                }
                var encryptionKey;
                if (algorithm !== 5) {
                  encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                } else {
                  var ownerValidationSalt = (0, _util2.stringToBytes)(dict.get("O")).subarray(32, 40);
                  var ownerKeySalt = (0, _util2.stringToBytes)(dict.get("O")).subarray(40, 48);
                  var uBytes = (0, _util2.stringToBytes)(dict.get("U")).subarray(0, 48);
                  var userValidationSalt = (0, _util2.stringToBytes)(dict.get("U")).subarray(32, 40);
                  var userKeySalt = (0, _util2.stringToBytes)(dict.get("U")).subarray(40, 48);
                  var ownerEncryption = (0, _util2.stringToBytes)(dict.get("OE"));
                  var userEncryption = (0, _util2.stringToBytes)(dict.get("UE"));
                  var perms = (0, _util2.stringToBytes)(dict.get("Perms"));
                  encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                }
                if (!encryptionKey && !password) {
                  throw new _util2.PasswordException("No password given", _util2.PasswordResponses.NEED_PASSWORD);
                } else if (!encryptionKey && password) {
                  var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                  encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                }
                if (!encryptionKey) {
                  throw new _util2.PasswordException("Incorrect Password", _util2.PasswordResponses.INCORRECT_PASSWORD);
                }
                this.encryptionKey = encryptionKey;
                if (algorithm >= 4) {
                  var cf = dict.get("CF");
                  if ((0, _primitives.isDict)(cf)) {
                    cf.suppressEncryption = true;
                  }
                  this.cf = cf;
                  this.stmf = dict.get("StmF") || identityName;
                  this.strf = dict.get("StrF") || identityName;
                  this.eff = dict.get("EFF") || this.stmf;
                }
              }
              function buildObjectKey(num, gen, encryptionKey, isAes) {
                var key = new Uint8Array(encryptionKey.length + 9), i2, n2;
                for (i2 = 0, n2 = encryptionKey.length; i2 < n2; ++i2) {
                  key[i2] = encryptionKey[i2];
                }
                key[i2++] = num & 255;
                key[i2++] = num >> 8 & 255;
                key[i2++] = num >> 16 & 255;
                key[i2++] = gen & 255;
                key[i2++] = gen >> 8 & 255;
                if (isAes) {
                  key[i2++] = 115;
                  key[i2++] = 65;
                  key[i2++] = 108;
                  key[i2++] = 84;
                }
                var hash = calculateMD5(key, 0, i2);
                return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
              }
              function buildCipherConstructor(cf, name, num, gen, key) {
                if (!(0, _primitives.isName)(name)) {
                  throw new _util2.FormatError("Invalid crypt filter name.");
                }
                var cryptFilter = cf.get(name.name);
                var cfm;
                if (cryptFilter !== null && cryptFilter !== void 0) {
                  cfm = cryptFilter.get("CFM");
                }
                if (!cfm || cfm.name === "None") {
                  return function cipherTransformFactoryBuildCipherConstructorNone() {
                    return new NullCipher();
                  };
                }
                if (cfm.name === "V2") {
                  return function cipherTransformFactoryBuildCipherConstructorV2() {
                    return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                  };
                }
                if (cfm.name === "AESV2") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV2() {
                    return new AES128Cipher(buildObjectKey(num, gen, key, true));
                  };
                }
                if (cfm.name === "AESV3") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV3() {
                    return new AES256Cipher(key);
                  };
                }
                throw new _util2.FormatError("Unknown crypto method");
              }
              CipherTransformFactory2.prototype = {
                createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
                  if (this.algorithm === 4 || this.algorithm === 5) {
                    return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
                  }
                  var key = buildObjectKey(num, gen, this.encryptionKey, false);
                  var cipherConstructor = function buildCipherCipherConstructor() {
                    return new ARCFourCipher(key);
                  };
                  return new CipherTransform(cipherConstructor, cipherConstructor);
                }
              };
              return CipherTransformFactory2;
            }();
            exports3.CipherTransformFactory = CipherTransformFactory;
          },
          /* 22 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ColorSpace = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
              const COMPONENTS = 3;
              alpha01 = alpha01 !== 1 ? 0 : alpha01;
              const xRatio = w1 / w2;
              const yRatio = h1 / h2;
              let newIndex = 0, oldIndex;
              const xScaled = new Uint16Array(w2);
              const w1Scanline = w1 * COMPONENTS;
              for (let i2 = 0; i2 < w2; i2++) {
                xScaled[i2] = Math.floor(i2 * xRatio) * COMPONENTS;
              }
              for (let i2 = 0; i2 < h2; i2++) {
                const py = Math.floor(i2 * yRatio) * w1Scanline;
                for (let j2 = 0; j2 < w2; j2++) {
                  oldIndex = py + xScaled[j2];
                  dest[newIndex++] = src[oldIndex++];
                  dest[newIndex++] = src[oldIndex++];
                  dest[newIndex++] = src[oldIndex++];
                  newIndex += alpha01;
                }
              }
            }
            class ColorSpace {
              constructor(name, numComps) {
                if (this.constructor === ColorSpace) {
                  (0, _util2.unreachable)("Cannot initialize ColorSpace.");
                }
                this.name = name;
                this.numComps = numComps;
              }
              getRgb(src, srcOffset) {
                const rgb = new Uint8ClampedArray(3);
                this.getRgbItem(src, srcOffset, rgb, 0);
                return rgb;
              }
              getRgbItem(src, srcOffset, dest, destOffset) {
                (0, _util2.unreachable)("Should not call ColorSpace.getRgbItem");
              }
              getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                (0, _util2.unreachable)("Should not call ColorSpace.getRgbBuffer");
              }
              getOutputLength(inputLength, alpha01) {
                (0, _util2.unreachable)("Should not call ColorSpace.getOutputLength");
              }
              isPassthrough(bits) {
                return false;
              }
              isDefaultDecode(decodeMap, bpc) {
                return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
              }
              fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                const count = originalWidth * originalHeight;
                let rgbBuf = null;
                const numComponentColors = 1 << bpc;
                const needsResizing = originalHeight !== height || originalWidth !== width;
                if (this.isPassthrough(bpc)) {
                  rgbBuf = comps;
                } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                  const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                  for (let i2 = 0; i2 < numComponentColors; i2++) {
                    allColors[i2] = i2;
                  }
                  const colorMap = new Uint8ClampedArray(numComponentColors * 3);
                  this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                  if (!needsResizing) {
                    let destPos = 0;
                    for (let i2 = 0; i2 < count; ++i2) {
                      const key = comps[i2] * 3;
                      dest[destPos++] = colorMap[key];
                      dest[destPos++] = colorMap[key + 1];
                      dest[destPos++] = colorMap[key + 2];
                      destPos += alpha01;
                    }
                  } else {
                    rgbBuf = new Uint8Array(count * 3);
                    let rgbPos = 0;
                    for (let i2 = 0; i2 < count; ++i2) {
                      const key = comps[i2] * 3;
                      rgbBuf[rgbPos++] = colorMap[key];
                      rgbBuf[rgbPos++] = colorMap[key + 1];
                      rgbBuf[rgbPos++] = colorMap[key + 2];
                    }
                  }
                } else {
                  if (!needsResizing) {
                    this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                  } else {
                    rgbBuf = new Uint8ClampedArray(count * 3);
                    this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                  }
                }
                if (rgbBuf) {
                  if (needsResizing) {
                    resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
                  } else {
                    let destPos = 0, rgbPos = 0;
                    for (let i2 = 0, ii = width * actualHeight; i2 < ii; i2++) {
                      dest[destPos++] = rgbBuf[rgbPos++];
                      dest[destPos++] = rgbBuf[rgbPos++];
                      dest[destPos++] = rgbBuf[rgbPos++];
                      destPos += alpha01;
                    }
                  }
                }
              }
              get usesZeroToOneRange() {
                return (0, _util2.shadow)(this, "usesZeroToOneRange", true);
              }
              static parse(cs, xref, res, pdfFunctionFactory) {
                const IR = this.parseToIR(cs, xref, res, pdfFunctionFactory);
                return this.fromIR(IR);
              }
              static fromIR(IR) {
                const name = Array.isArray(IR) ? IR[0] : IR;
                let whitePoint, blackPoint, gamma;
                switch (name) {
                  case "DeviceGrayCS":
                    return this.singletons.gray;
                  case "DeviceRgbCS":
                    return this.singletons.rgb;
                  case "DeviceCmykCS":
                    return this.singletons.cmyk;
                  case "CalGrayCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    return new CalGrayCS(whitePoint, blackPoint, gamma);
                  case "CalRGBCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    const matrix = IR[4];
                    return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                  case "PatternCS":
                    let basePatternCS = IR[1];
                    if (basePatternCS) {
                      basePatternCS = this.fromIR(basePatternCS);
                    }
                    return new PatternCS(basePatternCS);
                  case "IndexedCS":
                    const baseIndexedCS = IR[1];
                    const hiVal = IR[2];
                    const lookup = IR[3];
                    return new IndexedCS(this.fromIR(baseIndexedCS), hiVal, lookup);
                  case "AlternateCS":
                    const numComps = IR[1];
                    const alt = IR[2];
                    const tintFn = IR[3];
                    return new AlternateCS(numComps, this.fromIR(alt), tintFn);
                  case "LabCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    const range = IR[3];
                    return new LabCS(whitePoint, blackPoint, range);
                  default:
                    throw new _util2.FormatError(`Unknown colorspace name: ${name}`);
                }
              }
              static parseToIR(cs, xref, res = null, pdfFunctionFactory) {
                cs = xref.fetchIfRef(cs);
                if ((0, _primitives.isName)(cs)) {
                  switch (cs.name) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "Pattern":
                      return ["PatternCS", null];
                    default:
                      if ((0, _primitives.isDict)(res)) {
                        const colorSpaces = res.get("ColorSpace");
                        if ((0, _primitives.isDict)(colorSpaces)) {
                          const resCS = colorSpaces.get(cs.name);
                          if (resCS) {
                            if ((0, _primitives.isName)(resCS)) {
                              return this.parseToIR(resCS, xref, res, pdfFunctionFactory);
                            }
                            cs = resCS;
                            break;
                          }
                        }
                      }
                      throw new _util2.FormatError(`unrecognized colorspace ${cs.name}`);
                  }
                }
                if (Array.isArray(cs)) {
                  const mode = xref.fetchIfRef(cs[0]).name;
                  let numComps, params, alt, whitePoint, blackPoint, gamma;
                  switch (mode) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "CalGray":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.get("Gamma");
                      return ["CalGrayCS", whitePoint, blackPoint, gamma];
                    case "CalRGB":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.getArray("Gamma");
                      const matrix = params.getArray("Matrix");
                      return ["CalRGBCS", whitePoint, blackPoint, gamma, matrix];
                    case "ICCBased":
                      const stream = xref.fetchIfRef(cs[1]);
                      const dict = stream.dict;
                      numComps = dict.get("N");
                      alt = dict.get("Alternate");
                      if (alt) {
                        const altIR = this.parseToIR(alt, xref, res, pdfFunctionFactory);
                        const altCS = this.fromIR(altIR, pdfFunctionFactory);
                        if (altCS.numComps === numComps) {
                          return altIR;
                        }
                        (0, _util2.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                      }
                      if (numComps === 1) {
                        return "DeviceGrayCS";
                      } else if (numComps === 3) {
                        return "DeviceRgbCS";
                      } else if (numComps === 4) {
                        return "DeviceCmykCS";
                      }
                      break;
                    case "Pattern":
                      let basePatternCS = cs[1] || null;
                      if (basePatternCS) {
                        basePatternCS = this.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
                      }
                      return ["PatternCS", basePatternCS];
                    case "Indexed":
                    case "I":
                      const baseIndexedCS = this.parseToIR(cs[1], xref, res, pdfFunctionFactory);
                      const hiVal = xref.fetchIfRef(cs[2]) + 1;
                      let lookup = xref.fetchIfRef(cs[3]);
                      if ((0, _primitives.isStream)(lookup)) {
                        lookup = lookup.getBytes();
                      }
                      return ["IndexedCS", baseIndexedCS, hiVal, lookup];
                    case "Separation":
                    case "DeviceN":
                      const name = xref.fetchIfRef(cs[1]);
                      numComps = Array.isArray(name) ? name.length : 1;
                      alt = this.parseToIR(cs[2], xref, res, pdfFunctionFactory);
                      const tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
                      return ["AlternateCS", numComps, alt, tintFn];
                    case "Lab":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      const range = params.getArray("Range");
                      return ["LabCS", whitePoint, blackPoint, range];
                    default:
                      throw new _util2.FormatError(`unimplemented color space object "${mode}"`);
                  }
                }
                throw new _util2.FormatError(`unrecognized color space object: "${cs}"`);
              }
              static isDefaultDecode(decode, numComps) {
                if (!Array.isArray(decode)) {
                  return true;
                }
                if (numComps * 2 !== decode.length) {
                  (0, _util2.warn)("The decode map is not the correct length");
                  return true;
                }
                for (let i2 = 0, ii = decode.length; i2 < ii; i2 += 2) {
                  if (decode[i2] !== 0 || decode[i2 + 1] !== 1) {
                    return false;
                  }
                }
                return true;
              }
              static get singletons() {
                return (0, _util2.shadow)(this, "singletons", {
                  get gray() {
                    return (0, _util2.shadow)(this, "gray", new DeviceGrayCS());
                  },
                  get rgb() {
                    return (0, _util2.shadow)(this, "rgb", new DeviceRgbCS());
                  },
                  get cmyk() {
                    return (0, _util2.shadow)(this, "cmyk", new DeviceCmykCS());
                  }
                });
              }
            }
            exports3.ColorSpace = ColorSpace;
            class AlternateCS extends ColorSpace {
              constructor(numComps, base, tintFn) {
                super("Alternate", numComps);
                this.base = base;
                this.tintFn = tintFn;
                this.tmpBuf = new Float32Array(base.numComps);
              }
              getRgbItem(src, srcOffset, dest, destOffset) {
                const tmpBuf = this.tmpBuf;
                this.tintFn(src, srcOffset, tmpBuf, 0);
                this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
              }
              getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                const tintFn = this.tintFn;
                const base = this.base;
                const scale = 1 / ((1 << bits) - 1);
                const baseNumComps = base.numComps;
                const usesZeroToOneRange = base.usesZeroToOneRange;
                const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                let pos = isPassthrough ? destOffset : 0;
                const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
                const numComps = this.numComps;
                const scaled = new Float32Array(numComps);
                const tinted = new Float32Array(baseNumComps);
                let i2, j2;
                for (i2 = 0; i2 < count; i2++) {
                  for (j2 = 0; j2 < numComps; j2++) {
                    scaled[j2] = src[srcOffset++] * scale;
                  }
                  tintFn(scaled, 0, tinted, 0);
                  if (usesZeroToOneRange) {
                    for (j2 = 0; j2 < baseNumComps; j2++) {
                      baseBuf[pos++] = tinted[j2] * 255;
                    }
                  } else {
                    base.getRgbItem(tinted, 0, baseBuf, pos);
                    pos += baseNumComps;
                  }
                }
                if (!isPassthrough) {
                  base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                }
              }
              getOutputLength(inputLength, alpha01) {
                return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
              }
            }
            class PatternCS extends ColorSpace {
              constructor(baseCS) {
                super("Pattern", null);
                this.base = baseCS;
              }
              isDefaultDecode(decodeMap, bpc) {
                (0, _util2.unreachable)("Should not call PatternCS.isDefaultDecode");
              }
            }
            class IndexedCS extends ColorSpace {
              constructor(base, highVal, lookup) {
                super("Indexed", 1);
                this.base = base;
                this.highVal = highVal;
                const baseNumComps = base.numComps;
                const length = baseNumComps * highVal;
                if ((0, _primitives.isStream)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  const bytes = lookup.getBytes(length);
                  this.lookup.set(bytes);
                } else if ((0, _util2.isString)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  for (let i2 = 0; i2 < length; ++i2) {
                    this.lookup[i2] = lookup.charCodeAt(i2);
                  }
                } else if (lookup instanceof Uint8Array) {
                  this.lookup = lookup;
                } else {
                  throw new _util2.FormatError(`Unrecognized lookup table: ${lookup}`);
                }
              }
              getRgbItem(src, srcOffset, dest, destOffset) {
                const numComps = this.base.numComps;
                const start = src[srcOffset] * numComps;
                this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
              }
              getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                const base = this.base;
                const numComps = base.numComps;
                const outputDelta = base.getOutputLength(numComps, alpha01);
                const lookup = this.lookup;
                for (let i2 = 0; i2 < count; ++i2) {
                  const lookupPos = src[srcOffset++] * numComps;
                  base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                  destOffset += outputDelta;
                }
              }
              getOutputLength(inputLength, alpha01) {
                return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
              }
              isDefaultDecode(decodeMap, bpc) {
                if (!Array.isArray(decodeMap)) {
                  return true;
                }
                if (decodeMap.length !== 2) {
                  (0, _util2.warn)("Decode map length is not correct");
                  return true;
                }
                if (!Number.isInteger(bpc) || bpc < 1) {
                  (0, _util2.warn)("Bits per component is not correct");
                  return true;
                }
                return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
              }
            }
            class DeviceGrayCS extends ColorSpace {
              constructor() {
                super("DeviceGray", 1);
              }
              getRgbItem(src, srcOffset, dest, destOffset) {
                const c2 = src[srcOffset] * 255;
                dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c2;
              }
              getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                const scale = 255 / ((1 << bits) - 1);
                let j2 = srcOffset, q2 = destOffset;
                for (let i2 = 0; i2 < count; ++i2) {
                  const c2 = scale * src[j2++];
                  dest[q2++] = c2;
                  dest[q2++] = c2;
                  dest[q2++] = c2;
                  q2 += alpha01;
                }
              }
              getOutputLength(inputLength, alpha01) {
                return inputLength * (3 + alpha01);
              }
            }
            class DeviceRgbCS extends ColorSpace {
              constructor() {
                super("DeviceRGB", 3);
              }
              getRgbItem(src, srcOffset, dest, destOffset) {
                dest[destOffset] = src[srcOffset] * 255;
                dest[destOffset + 1] = src[srcOffset + 1] * 255;
                dest[destOffset + 2] = src[srcOffset + 2] * 255;
              }
              getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                if (bits === 8 && alpha01 === 0) {
                  dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                  return;
                }
                const scale = 255 / ((1 << bits) - 1);
                let j2 = srcOffset, q2 = destOffset;
                for (let i2 = 0; i2 < count; ++i2) {
                  dest[q2++] = scale * src[j2++];
                  dest[q2++] = scale * src[j2++];
                  dest[q2++] = scale * src[j2++];
                  q2 += alpha01;
                }
              }
              getOutputLength(inputLength, alpha01) {
                return inputLength * (3 + alpha01) / 3 | 0;
              }
              isPassthrough(bits) {
                return bits === 8;
              }
            }
            const DeviceCmykCS = function DeviceCmykCSClosure() {
              function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                const c2 = src[srcOffset] * srcScale;
                const m = src[srcOffset + 1] * srcScale;
                const y2 = src[srcOffset + 2] * srcScale;
                const k2 = src[srcOffset + 3] * srcScale;
                dest[destOffset] = 255 + c2 * (-4.387332384609988 * c2 + 54.48615194189176 * m + 18.82290502165302 * y2 + 212.25662451639585 * k2 + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y2 + -17.873870861415444 * k2 - 5.497006427196366) + y2 * (-2.5217340131683033 * y2 - 21.248923337353073 * k2 + 17.5119270841813) + k2 * (-21.86122147463605 * k2 - 189.48180835922747);
                dest[destOffset + 1] = 255 + c2 * (8.841041422036149 * c2 + 60.118027045597366 * m + 6.871425592049007 * y2 + 31.159100130055922 * k2 + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y2 + 131.35250912493976 * k2 - 190.9453302588951) + y2 * (4.444339102852739 * y2 + 9.8632861493405 * k2 - 24.86741582555878) + k2 * (-20.737325471181034 * k2 - 187.80453709719578);
                dest[destOffset + 2] = 255 + c2 * (0.8842522430003296 * c2 + 8.078677503112928 * m + 30.89978309703729 * y2 - 0.23883238689178934 * k2 + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y2 + 50.606957656360734 * k2 - 112.23884253719248) + y2 * (0.03296041114873217 * y2 + 115.60384449646641 * k2 + -193.58209356861505) + k2 * (-22.33816807309886 * k2 - 180.12613974708367);
              }
              class DeviceCmykCS2 extends ColorSpace {
                constructor() {
                  super("DeviceCMYK", 4);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(src, srcOffset, 1, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i2 = 0; i2 < count; i2++) {
                    convertToRgb(src, srcOffset, scale, dest, destOffset);
                    srcOffset += 4;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength / 4 * (3 + alpha01) | 0;
                }
              }
              return DeviceCmykCS2;
            }();
            const CalGrayCS = function CalGrayCSClosure() {
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                const A2 = src[srcOffset] * scale;
                const AG = A2 ** cs.G;
                const L2 = cs.YW * AG;
                const val = Math.max(295.8 * L2 ** 0.3333333333333333 - 40.8, 0);
                dest[destOffset] = val;
                dest[destOffset + 1] = val;
                dest[destOffset + 2] = val;
              }
              class CalGrayCS2 extends ColorSpace {
                constructor(whitePoint, blackPoint, gamma) {
                  super("CalGray", 1);
                  if (!whitePoint) {
                    throw new _util2.FormatError("WhitePoint missing - required for color space CalGray");
                  }
                  blackPoint = blackPoint || [0, 0, 0];
                  gamma = gamma || 1;
                  this.XW = whitePoint[0];
                  this.YW = whitePoint[1];
                  this.ZW = whitePoint[2];
                  this.XB = blackPoint[0];
                  this.YB = blackPoint[1];
                  this.ZB = blackPoint[2];
                  this.G = gamma;
                  if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                    throw new _util2.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                  }
                  if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                    (0, _util2.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
                    this.XB = this.YB = this.ZB = 0;
                  }
                  if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                    (0, _util2.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
                  }
                  if (this.G < 1) {
                    (0, _util2.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
                    this.G = 1;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i2 = 0; i2 < count; ++i2) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 1;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                }
              }
              return CalGrayCS2;
            }();
            const CalRGBCS = function CalRGBCSClosure() {
              const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
              const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
              const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
              const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
              const tempNormalizeMatrix = new Float32Array(3);
              const tempConvertMatrix1 = new Float32Array(3);
              const tempConvertMatrix2 = new Float32Array(3);
              const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8;
              function matrixProduct(a2, b2, result) {
                result[0] = a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
                result[1] = a2[3] * b2[0] + a2[4] * b2[1] + a2[5] * b2[2];
                result[2] = a2[6] * b2[0] + a2[7] * b2[1] + a2[8] * b2[2];
              }
              function convertToFlat(sourceWhitePoint, LMS, result) {
                result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                result[2] = LMS[2] * 1 / sourceWhitePoint[2];
              }
              function convertToD65(sourceWhitePoint, LMS, result) {
                const D65X = 0.95047;
                const D65Y = 1;
                const D65Z = 1.08883;
                result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
              }
              function sRGBTransferFunction(color) {
                if (color <= 31308e-7) {
                  return adjustToRange(0, 1, 12.92 * color);
                }
                return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
              }
              function adjustToRange(min, max, value) {
                return Math.max(min, Math.min(max, value));
              }
              function decodeL(L2) {
                if (L2 < 0) {
                  return -decodeL(-L2);
                }
                if (L2 > 8) {
                  return ((L2 + 16) / 116) ** 3;
                }
                return L2 * DECODE_L_CONSTANT;
              }
              function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                  result[0] = XYZ_Flat[0];
                  result[1] = XYZ_Flat[1];
                  result[2] = XYZ_Flat[2];
                  return;
                }
                const zeroDecodeL = decodeL(0);
                const X_DST = zeroDecodeL;
                const X_SRC = decodeL(sourceBlackPoint[0]);
                const Y_DST = zeroDecodeL;
                const Y_SRC = decodeL(sourceBlackPoint[1]);
                const Z_DST = zeroDecodeL;
                const Z_SRC = decodeL(sourceBlackPoint[2]);
                const X_Scale = (1 - X_DST) / (1 - X_SRC);
                const X_Offset = 1 - X_Scale;
                const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                const Y_Offset = 1 - Y_Scale;
                const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                const Z_Offset = 1 - Z_Scale;
                result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
              }
              function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                  result[0] = XYZ_In[0];
                  result[1] = XYZ_In[1];
                  result[2] = XYZ_In[2];
                  return;
                }
                const LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                const LMS_Flat = tempNormalizeMatrix;
                convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
              }
              function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                const LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                const LMS_D65 = tempNormalizeMatrix;
                convertToD65(sourceWhitePoint, LMS, LMS_D65);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                const A2 = adjustToRange(0, 1, src[srcOffset] * scale);
                const B2 = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                const C2 = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                const AGR = A2 ** cs.GR;
                const BGG = B2 ** cs.GG;
                const CGB = C2 ** cs.GB;
                const X2 = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                const Y2 = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                const Z2 = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                const XYZ = tempConvertMatrix1;
                XYZ[0] = X2;
                XYZ[1] = Y2;
                XYZ[2] = Z2;
                const XYZ_Flat = tempConvertMatrix2;
                normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                const XYZ_Black = tempConvertMatrix1;
                compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                const XYZ_D65 = tempConvertMatrix2;
                normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                const SRGB = tempConvertMatrix1;
                matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
                dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
                dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
              }
              class CalRGBCS2 extends ColorSpace {
                constructor(whitePoint, blackPoint, gamma, matrix) {
                  super("CalRGB", 3);
                  if (!whitePoint) {
                    throw new _util2.FormatError("WhitePoint missing - required for color space CalRGB");
                  }
                  blackPoint = blackPoint || new Float32Array(3);
                  gamma = gamma || new Float32Array([1, 1, 1]);
                  matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                  const XW = whitePoint[0];
                  const YW = whitePoint[1];
                  const ZW = whitePoint[2];
                  this.whitePoint = whitePoint;
                  const XB = blackPoint[0];
                  const YB = blackPoint[1];
                  const ZB = blackPoint[2];
                  this.blackPoint = blackPoint;
                  this.GR = gamma[0];
                  this.GG = gamma[1];
                  this.GB = gamma[2];
                  this.MXA = matrix[0];
                  this.MYA = matrix[1];
                  this.MZA = matrix[2];
                  this.MXB = matrix[3];
                  this.MYB = matrix[4];
                  this.MZB = matrix[5];
                  this.MXC = matrix[6];
                  this.MYC = matrix[7];
                  this.MZC = matrix[8];
                  if (XW < 0 || ZW < 0 || YW !== 1) {
                    throw new _util2.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                  }
                  if (XB < 0 || YB < 0 || ZB < 0) {
                    (0, _util2.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], falling back to default.`);
                    this.blackPoint = new Float32Array(3);
                  }
                  if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                    (0, _util2.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
                    this.GR = this.GG = this.GB = 1;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 1 / ((1 << bits) - 1);
                  for (let i2 = 0; i2 < count; ++i2) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
              }
              return CalRGBCS2;
            }();
            const LabCS = function LabCSClosure() {
              function fn_g(x2) {
                let result;
                if (x2 >= 6 / 29) {
                  result = x2 * x2 * x2;
                } else {
                  result = 108 / 841 * (x2 - 4 / 29);
                }
                return result;
              }
              function decode(value, high1, low2, high2) {
                return low2 + value * (high2 - low2) / high1;
              }
              function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                let Ls = src[srcOffset];
                let as = src[srcOffset + 1];
                let bs = src[srcOffset + 2];
                if (maxVal !== false) {
                  Ls = decode(Ls, maxVal, 0, 100);
                  as = decode(as, maxVal, cs.amin, cs.amax);
                  bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                }
                if (as > cs.amax) {
                  as = cs.amax;
                } else if (as < cs.amin) {
                  as = cs.amin;
                }
                if (bs > cs.bmax) {
                  bs = cs.bmax;
                } else if (bs < cs.bmin) {
                  bs = cs.bmin;
                }
                const M2 = (Ls + 16) / 116;
                const L2 = M2 + as / 500;
                const N2 = M2 - bs / 200;
                const X2 = cs.XW * fn_g(L2);
                const Y2 = cs.YW * fn_g(M2);
                const Z2 = cs.ZW * fn_g(N2);
                let r2, g2, b2;
                if (cs.ZW < 1) {
                  r2 = X2 * 3.1339 + Y2 * -1.617 + Z2 * -0.4906;
                  g2 = X2 * -0.9785 + Y2 * 1.916 + Z2 * 0.0333;
                  b2 = X2 * 0.072 + Y2 * -0.229 + Z2 * 1.4057;
                } else {
                  r2 = X2 * 3.2406 + Y2 * -1.5372 + Z2 * -0.4986;
                  g2 = X2 * -0.9689 + Y2 * 1.8758 + Z2 * 0.0415;
                  b2 = X2 * 0.0557 + Y2 * -0.204 + Z2 * 1.057;
                }
                dest[destOffset] = Math.sqrt(r2) * 255;
                dest[destOffset + 1] = Math.sqrt(g2) * 255;
                dest[destOffset + 2] = Math.sqrt(b2) * 255;
              }
              class LabCS2 extends ColorSpace {
                constructor(whitePoint, blackPoint, range) {
                  super("Lab", 3);
                  if (!whitePoint) {
                    throw new _util2.FormatError("WhitePoint missing - required for color space Lab");
                  }
                  blackPoint = blackPoint || [0, 0, 0];
                  range = range || [-100, 100, -100, 100];
                  this.XW = whitePoint[0];
                  this.YW = whitePoint[1];
                  this.ZW = whitePoint[2];
                  this.amin = range[0];
                  this.amax = range[1];
                  this.bmin = range[2];
                  this.bmax = range[3];
                  this.XB = blackPoint[0];
                  this.YB = blackPoint[1];
                  this.ZB = blackPoint[2];
                  if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                    throw new _util2.FormatError("Invalid WhitePoint components, no fallback available");
                  }
                  if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                    (0, _util2.info)("Invalid BlackPoint, falling back to default");
                    this.XB = this.YB = this.ZB = 0;
                  }
                  if (this.amin > this.amax || this.bmin > this.bmax) {
                    (0, _util2.info)("Invalid Range, falling back to defaults");
                    this.amin = -100;
                    this.amax = 100;
                    this.bmin = -100;
                    this.bmax = 100;
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, false, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const maxVal = (1 << bits) - 1;
                  for (let i2 = 0; i2 < count; i2++) {
                    convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
                isDefaultDecode(decodeMap, bpc) {
                  return true;
                }
                get usesZeroToOneRange() {
                  return (0, _util2.shadow)(this, "usesZeroToOneRange", false);
                }
              }
              return LabCS2;
            }();
          },
          /* 23 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getQuadPoints = getQuadPoints;
            exports3.MarkupAnnotation = exports3.AnnotationFactory = exports3.AnnotationBorderStyle = exports3.Annotation = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _obj = __w_pdfjs_require__2(9);
            var _primitives = __w_pdfjs_require__2(4);
            var _colorspace = __w_pdfjs_require__2(22);
            var _core_utils = __w_pdfjs_require__2(7);
            var _operator_list = __w_pdfjs_require__2(24);
            var _stream = __w_pdfjs_require__2(11);
            class AnnotationFactory {
              static create(xref, ref, pdfManager, idFactory) {
                return pdfManager.ensure(this, "_create", [xref, ref, pdfManager, idFactory]);
              }
              static _create(xref, ref, pdfManager, idFactory) {
                const dict = xref.fetchIfRef(ref);
                if (!(0, _primitives.isDict)(dict)) {
                  return void 0;
                }
                const id = (0, _primitives.isRef)(ref) ? ref.toString() : `annot_${idFactory.createObjId()}`;
                let subtype = dict.get("Subtype");
                subtype = (0, _primitives.isName)(subtype) ? subtype.name : null;
                const parameters = {
                  xref,
                  dict,
                  subtype,
                  id,
                  pdfManager
                };
                switch (subtype) {
                  case "Link":
                    return new LinkAnnotation(parameters);
                  case "Text":
                    return new TextAnnotation(parameters);
                  case "Widget":
                    let fieldType = (0, _core_utils.getInheritableProperty)({
                      dict,
                      key: "FT"
                    });
                    fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotation(parameters);
                      case "Btn":
                        return new ButtonWidgetAnnotation(parameters);
                      case "Ch":
                        return new ChoiceWidgetAnnotation(parameters);
                    }
                    (0, _util2.warn)('Unimplemented widget field type "' + fieldType + '", falling back to base field type.');
                    return new WidgetAnnotation(parameters);
                  case "Popup":
                    return new PopupAnnotation(parameters);
                  case "FreeText":
                    return new FreeTextAnnotation(parameters);
                  case "Line":
                    return new LineAnnotation(parameters);
                  case "Square":
                    return new SquareAnnotation(parameters);
                  case "Circle":
                    return new CircleAnnotation(parameters);
                  case "PolyLine":
                    return new PolylineAnnotation(parameters);
                  case "Polygon":
                    return new PolygonAnnotation(parameters);
                  case "Caret":
                    return new CaretAnnotation(parameters);
                  case "Ink":
                    return new InkAnnotation(parameters);
                  case "Highlight":
                    return new HighlightAnnotation(parameters);
                  case "Underline":
                    return new UnderlineAnnotation(parameters);
                  case "Squiggly":
                    return new SquigglyAnnotation(parameters);
                  case "StrikeOut":
                    return new StrikeOutAnnotation(parameters);
                  case "Stamp":
                    return new StampAnnotation(parameters);
                  case "FileAttachment":
                    return new FileAttachmentAnnotation(parameters);
                  default:
                    if (!subtype) {
                      (0, _util2.warn)("Annotation is missing the required /Subtype.");
                    } else {
                      (0, _util2.warn)('Unimplemented annotation type "' + subtype + '", falling back to base annotation.');
                    }
                    return new Annotation(parameters);
                }
              }
            }
            exports3.AnnotationFactory = AnnotationFactory;
            function getQuadPoints(dict, rect) {
              if (!dict.has("QuadPoints")) {
                return null;
              }
              const quadPoints = dict.getArray("QuadPoints");
              if (!Array.isArray(quadPoints) || quadPoints.length % 8 > 0) {
                return null;
              }
              const quadPointsLists = [];
              for (let i2 = 0, ii = quadPoints.length / 8; i2 < ii; i2++) {
                quadPointsLists.push([]);
                for (let j2 = i2 * 8, jj = i2 * 8 + 8; j2 < jj; j2 += 2) {
                  const x2 = quadPoints[j2];
                  const y2 = quadPoints[j2 + 1];
                  if (x2 < rect[0] || x2 > rect[2] || y2 < rect[1] || y2 > rect[3]) {
                    return null;
                  }
                  quadPointsLists[i2].push({
                    x: x2,
                    y: y2
                  });
                }
              }
              return quadPointsLists;
            }
            function getTransformMatrix(rect, bbox, matrix) {
              const [minX, minY, maxX, maxY] = _util2.Util.getAxialAlignedBoundingBox(bbox, matrix);
              if (minX === maxX || minY === maxY) {
                return [1, 0, 0, 1, rect[0], rect[1]];
              }
              const xRatio = (rect[2] - rect[0]) / (maxX - minX);
              const yRatio = (rect[3] - rect[1]) / (maxY - minY);
              return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
            }
            class Annotation {
              constructor(params) {
                const dict = params.dict;
                this.setContents(dict.get("Contents"));
                this.setModificationDate(dict.get("M"));
                this.setFlags(dict.get("F"));
                this.setRectangle(dict.getArray("Rect"));
                this.setColor(dict.getArray("C"));
                this.setBorderStyle(dict);
                this.setAppearance(dict);
                this.data = {
                  annotationFlags: this.flags,
                  borderStyle: this.borderStyle,
                  color: this.color,
                  contents: this.contents,
                  hasAppearance: !!this.appearance,
                  id: params.id,
                  modificationDate: this.modificationDate,
                  rect: this.rectangle,
                  subtype: params.subtype
                };
              }
              _hasFlag(flags, flag) {
                return !!(flags & flag);
              }
              _isViewable(flags) {
                return !this._hasFlag(flags, _util2.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util2.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util2.AnnotationFlag.NOVIEW);
              }
              _isPrintable(flags) {
                return this._hasFlag(flags, _util2.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util2.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util2.AnnotationFlag.HIDDEN);
              }
              get viewable() {
                if (this.flags === 0) {
                  return true;
                }
                return this._isViewable(this.flags);
              }
              get printable() {
                if (this.flags === 0) {
                  return false;
                }
                return this._isPrintable(this.flags);
              }
              setContents(contents) {
                this.contents = (0, _util2.stringToPDFString)(contents || "");
              }
              setModificationDate(modificationDate) {
                this.modificationDate = (0, _util2.isString)(modificationDate) ? modificationDate : null;
              }
              setFlags(flags) {
                this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
              }
              hasFlag(flag) {
                return this._hasFlag(this.flags, flag);
              }
              setRectangle(rectangle) {
                if (Array.isArray(rectangle) && rectangle.length === 4) {
                  this.rectangle = _util2.Util.normalizeRect(rectangle);
                } else {
                  this.rectangle = [0, 0, 0, 0];
                }
              }
              setColor(color) {
                const rgbColor = new Uint8ClampedArray(3);
                if (!Array.isArray(color)) {
                  this.color = rgbColor;
                  return;
                }
                switch (color.length) {
                  case 0:
                    this.color = null;
                    break;
                  case 1:
                    _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                    this.color = rgbColor;
                    break;
                  case 3:
                    _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                    this.color = rgbColor;
                    break;
                  case 4:
                    _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                    this.color = rgbColor;
                    break;
                  default:
                    this.color = rgbColor;
                    break;
                }
              }
              setBorderStyle(borderStyle) {
                this.borderStyle = new AnnotationBorderStyle();
                if (!(0, _primitives.isDict)(borderStyle)) {
                  return;
                }
                if (borderStyle.has("BS")) {
                  const dict = borderStyle.get("BS");
                  const dictType = dict.get("Type");
                  if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
                    this.borderStyle.setWidth(dict.get("W"), this.rectangle);
                    this.borderStyle.setStyle(dict.get("S"));
                    this.borderStyle.setDashArray(dict.getArray("D"));
                  }
                } else if (borderStyle.has("Border")) {
                  const array = borderStyle.getArray("Border");
                  if (Array.isArray(array) && array.length >= 3) {
                    this.borderStyle.setHorizontalCornerRadius(array[0]);
                    this.borderStyle.setVerticalCornerRadius(array[1]);
                    this.borderStyle.setWidth(array[2], this.rectangle);
                    if (array.length === 4) {
                      this.borderStyle.setDashArray(array[3]);
                    }
                  }
                } else {
                  this.borderStyle.setWidth(0);
                }
              }
              setAppearance(dict) {
                this.appearance = null;
                const appearanceStates = dict.get("AP");
                if (!(0, _primitives.isDict)(appearanceStates)) {
                  return;
                }
                const normalAppearanceState = appearanceStates.get("N");
                if ((0, _primitives.isStream)(normalAppearanceState)) {
                  this.appearance = normalAppearanceState;
                  return;
                }
                if (!(0, _primitives.isDict)(normalAppearanceState)) {
                  return;
                }
                const as = dict.get("AS");
                if (!(0, _primitives.isName)(as) || !normalAppearanceState.has(as.name)) {
                  return;
                }
                this.appearance = normalAppearanceState.get(as.name);
              }
              loadResources(keys) {
                return this.appearance.dict.getAsync("Resources").then((resources) => {
                  if (!resources) {
                    return void 0;
                  }
                  const objectLoader = new _obj.ObjectLoader(resources, keys, resources.xref);
                  return objectLoader.load().then(function() {
                    return resources;
                  });
                });
              }
              getOperatorList(evaluator, task, renderForms) {
                if (!this.appearance) {
                  return Promise.resolve(new _operator_list.OperatorList());
                }
                const data = this.data;
                const appearanceDict = this.appearance.dict;
                const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                const transform = getTransformMatrix(data.rect, bbox, matrix);
                return resourcesPromise.then((resources) => {
                  const opList = new _operator_list.OperatorList();
                  opList.addOp(_util2.OPS.beginAnnotation, [data.rect, transform, matrix]);
                  return evaluator.getOperatorList({
                    stream: this.appearance,
                    task,
                    resources,
                    operatorList: opList
                  }).then(() => {
                    opList.addOp(_util2.OPS.endAnnotation, []);
                    this.appearance.reset();
                    return opList;
                  });
                });
              }
            }
            exports3.Annotation = Annotation;
            class AnnotationBorderStyle {
              constructor() {
                this.width = 1;
                this.style = _util2.AnnotationBorderStyleType.SOLID;
                this.dashArray = [3];
                this.horizontalCornerRadius = 0;
                this.verticalCornerRadius = 0;
              }
              setWidth(width, rect = [0, 0, 0, 0]) {
                if ((0, _primitives.isName)(width)) {
                  this.width = 0;
                  return;
                }
                if (Number.isInteger(width)) {
                  if (width > 0) {
                    const maxWidth = (rect[2] - rect[0]) / 2;
                    const maxHeight = (rect[3] - rect[1]) / 2;
                    if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
                      (0, _util2.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
                      width = 1;
                    }
                  }
                  this.width = width;
                }
              }
              setStyle(style) {
                if (!(0, _primitives.isName)(style)) {
                  return;
                }
                switch (style.name) {
                  case "S":
                    this.style = _util2.AnnotationBorderStyleType.SOLID;
                    break;
                  case "D":
                    this.style = _util2.AnnotationBorderStyleType.DASHED;
                    break;
                  case "B":
                    this.style = _util2.AnnotationBorderStyleType.BEVELED;
                    break;
                  case "I":
                    this.style = _util2.AnnotationBorderStyleType.INSET;
                    break;
                  case "U":
                    this.style = _util2.AnnotationBorderStyleType.UNDERLINE;
                    break;
                  default:
                    break;
                }
              }
              setDashArray(dashArray) {
                if (Array.isArray(dashArray) && dashArray.length > 0) {
                  let isValid = true;
                  let allZeros = true;
                  for (const element of dashArray) {
                    const validNumber = +element >= 0;
                    if (!validNumber) {
                      isValid = false;
                      break;
                    } else if (element > 0) {
                      allZeros = false;
                    }
                  }
                  if (isValid && !allZeros) {
                    this.dashArray = dashArray;
                  } else {
                    this.width = 0;
                  }
                } else if (dashArray) {
                  this.width = 0;
                }
              }
              setHorizontalCornerRadius(radius) {
                if (Number.isInteger(radius)) {
                  this.horizontalCornerRadius = radius;
                }
              }
              setVerticalCornerRadius(radius) {
                if (Number.isInteger(radius)) {
                  this.verticalCornerRadius = radius;
                }
              }
            }
            exports3.AnnotationBorderStyle = AnnotationBorderStyle;
            class MarkupAnnotation extends Annotation {
              constructor(parameters) {
                super(parameters);
                const dict = parameters.dict;
                if (dict.has("IRT")) {
                  const rawIRT = dict.getRaw("IRT");
                  this.data.inReplyTo = (0, _primitives.isRef)(rawIRT) ? rawIRT.toString() : null;
                  const rt = dict.get("RT");
                  this.data.replyType = (0, _primitives.isName)(rt) ? rt.name : _util2.AnnotationReplyType.REPLY;
                }
                if (this.data.replyType === _util2.AnnotationReplyType.GROUP) {
                  const parent = dict.get("IRT");
                  this.data.title = (0, _util2.stringToPDFString)(parent.get("T") || "");
                  this.setContents(parent.get("Contents"));
                  this.data.contents = this.contents;
                  if (!parent.has("CreationDate")) {
                    this.data.creationDate = null;
                  } else {
                    this.setCreationDate(parent.get("CreationDate"));
                    this.data.creationDate = this.creationDate;
                  }
                  if (!parent.has("M")) {
                    this.data.modificationDate = null;
                  } else {
                    this.setModificationDate(parent.get("M"));
                    this.data.modificationDate = this.modificationDate;
                  }
                  this.data.hasPopup = parent.has("Popup");
                  if (!parent.has("C")) {
                    this.data.color = null;
                  } else {
                    this.setColor(parent.getArray("C"));
                    this.data.color = this.color;
                  }
                } else {
                  this.data.title = (0, _util2.stringToPDFString)(dict.get("T") || "");
                  this.setCreationDate(dict.get("CreationDate"));
                  this.data.creationDate = this.creationDate;
                  this.data.hasPopup = dict.has("Popup");
                  if (!dict.has("C")) {
                    this.data.color = null;
                  }
                }
              }
              setCreationDate(creationDate) {
                this.creationDate = (0, _util2.isString)(creationDate) ? creationDate : null;
              }
            }
            exports3.MarkupAnnotation = MarkupAnnotation;
            class WidgetAnnotation extends Annotation {
              constructor(params) {
                super(params);
                const dict = params.dict;
                const data = this.data;
                data.annotationType = _util2.AnnotationType.WIDGET;
                data.fieldName = this._constructFieldName(dict);
                data.fieldValue = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "V",
                  getArray: true
                });
                data.alternativeText = (0, _util2.stringToPDFString)(dict.get("TU") || "");
                data.defaultAppearance = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "DA"
                }) || "";
                const fieldType = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "FT"
                });
                data.fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                this.fieldResources = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "DR"
                }) || _primitives.Dict.empty;
                data.fieldFlags = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "Ff"
                });
                if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
                  data.fieldFlags = 0;
                }
                data.readOnly = this.hasFieldFlag(_util2.AnnotationFieldFlag.READONLY);
                if (data.fieldType === "Sig") {
                  data.fieldValue = null;
                  this.setFlags(_util2.AnnotationFlag.HIDDEN);
                }
              }
              _constructFieldName(dict) {
                if (!dict.has("T") && !dict.has("Parent")) {
                  (0, _util2.warn)("Unknown field name, falling back to empty field name.");
                  return "";
                }
                if (!dict.has("Parent")) {
                  return (0, _util2.stringToPDFString)(dict.get("T"));
                }
                const fieldName = [];
                if (dict.has("T")) {
                  fieldName.unshift((0, _util2.stringToPDFString)(dict.get("T")));
                }
                let loopDict = dict;
                while (loopDict.has("Parent")) {
                  loopDict = loopDict.get("Parent");
                  if (!(0, _primitives.isDict)(loopDict)) {
                    break;
                  }
                  if (loopDict.has("T")) {
                    fieldName.unshift((0, _util2.stringToPDFString)(loopDict.get("T")));
                  }
                }
                return fieldName.join(".");
              }
              hasFieldFlag(flag) {
                return !!(this.data.fieldFlags & flag);
              }
              getOperatorList(evaluator, task, renderForms) {
                if (renderForms) {
                  return Promise.resolve(new _operator_list.OperatorList());
                }
                return super.getOperatorList(evaluator, task, renderForms);
              }
            }
            class TextWidgetAnnotation extends WidgetAnnotation {
              constructor(params) {
                super(params);
                const dict = params.dict;
                this.data.fieldValue = (0, _util2.stringToPDFString)(this.data.fieldValue || "");
                let alignment = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "Q"
                });
                if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
                  alignment = null;
                }
                this.data.textAlignment = alignment;
                let maximumLength = (0, _core_utils.getInheritableProperty)({
                  dict,
                  key: "MaxLen"
                });
                if (!Number.isInteger(maximumLength) || maximumLength < 0) {
                  maximumLength = null;
                }
                this.data.maxLen = maximumLength;
                this.data.multiLine = this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTILINE);
                this.data.comb = this.hasFieldFlag(_util2.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== null;
              }
              getOperatorList(evaluator, task, renderForms) {
                if (renderForms || this.appearance) {
                  return super.getOperatorList(evaluator, task, renderForms);
                }
                const operatorList = new _operator_list.OperatorList();
                if (!this.data.defaultAppearance) {
                  return Promise.resolve(operatorList);
                }
                const stream = new _stream.Stream((0, _util2.stringToBytes)(this.data.defaultAppearance));
                return evaluator.getOperatorList({
                  stream,
                  task,
                  resources: this.fieldResources,
                  operatorList
                }).then(function() {
                  return operatorList;
                });
              }
            }
            class ButtonWidgetAnnotation extends WidgetAnnotation {
              constructor(params) {
                super(params);
                this.data.checkBox = !this.hasFieldFlag(_util2.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                this.data.radioButton = this.hasFieldFlag(_util2.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                this.data.pushButton = this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                if (this.data.checkBox) {
                  this._processCheckBox(params);
                } else if (this.data.radioButton) {
                  this._processRadioButton(params);
                } else if (this.data.pushButton) {
                  this._processPushButton(params);
                } else {
                  (0, _util2.warn)("Invalid field flags for button widget annotation");
                }
              }
              _processCheckBox(params) {
                if ((0, _primitives.isName)(this.data.fieldValue)) {
                  this.data.fieldValue = this.data.fieldValue.name;
                }
                const customAppearance = params.dict.get("AP");
                if (!(0, _primitives.isDict)(customAppearance)) {
                  return;
                }
                const exportValueOptionsDict = customAppearance.get("D");
                if (!(0, _primitives.isDict)(exportValueOptionsDict)) {
                  return;
                }
                const exportValues = exportValueOptionsDict.getKeys();
                const hasCorrectOptionCount = exportValues.length === 2;
                if (!hasCorrectOptionCount) {
                  return;
                }
                this.data.exportValue = exportValues[0] === "Off" ? exportValues[1] : exportValues[0];
              }
              _processRadioButton(params) {
                this.data.fieldValue = this.data.buttonValue = null;
                const fieldParent = params.dict.get("Parent");
                if ((0, _primitives.isDict)(fieldParent) && fieldParent.has("V")) {
                  const fieldParentValue = fieldParent.get("V");
                  if ((0, _primitives.isName)(fieldParentValue)) {
                    this.data.fieldValue = fieldParentValue.name;
                  }
                }
                const appearanceStates = params.dict.get("AP");
                if (!(0, _primitives.isDict)(appearanceStates)) {
                  return;
                }
                const normalAppearanceState = appearanceStates.get("N");
                if (!(0, _primitives.isDict)(normalAppearanceState)) {
                  return;
                }
                for (const key of normalAppearanceState.getKeys()) {
                  if (key !== "Off") {
                    this.data.buttonValue = key;
                    break;
                  }
                }
              }
              _processPushButton(params) {
                if (!params.dict.has("A")) {
                  (0, _util2.warn)("Push buttons without action dictionaries are not supported");
                  return;
                }
                _obj.Catalog.parseDestDictionary({
                  destDict: params.dict,
                  resultObj: this.data,
                  docBaseUrl: params.pdfManager.docBaseUrl
                });
              }
            }
            class ChoiceWidgetAnnotation extends WidgetAnnotation {
              constructor(params) {
                super(params);
                this.data.options = [];
                const options = (0, _core_utils.getInheritableProperty)({
                  dict: params.dict,
                  key: "Opt"
                });
                if (Array.isArray(options)) {
                  const xref = params.xref;
                  for (let i2 = 0, ii = options.length; i2 < ii; i2++) {
                    const option = xref.fetchIfRef(options[i2]);
                    const isOptionArray = Array.isArray(option);
                    this.data.options[i2] = {
                      exportValue: isOptionArray ? xref.fetchIfRef(option[0]) : option,
                      displayValue: (0, _util2.stringToPDFString)(isOptionArray ? xref.fetchIfRef(option[1]) : option)
                    };
                  }
                }
                if (!Array.isArray(this.data.fieldValue)) {
                  this.data.fieldValue = [this.data.fieldValue];
                }
                this.data.combo = this.hasFieldFlag(_util2.AnnotationFieldFlag.COMBO);
                this.data.multiSelect = this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTISELECT);
              }
            }
            class TextAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                const DEFAULT_ICON_SIZE = 22;
                super(parameters);
                const dict = parameters.dict;
                this.data.annotationType = _util2.AnnotationType.TEXT;
                if (this.data.hasAppearance) {
                  this.data.name = "NoIcon";
                } else {
                  this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
                  this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
                  this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
                }
                if (dict.has("State")) {
                  this.data.state = dict.get("State") || null;
                  this.data.stateModel = dict.get("StateModel") || null;
                } else {
                  this.data.state = null;
                  this.data.stateModel = null;
                }
              }
            }
            class LinkAnnotation extends Annotation {
              constructor(params) {
                super(params);
                this.data.annotationType = _util2.AnnotationType.LINK;
                const quadPoints = getQuadPoints(params.dict, this.rectangle);
                if (quadPoints) {
                  this.data.quadPoints = quadPoints;
                }
                _obj.Catalog.parseDestDictionary({
                  destDict: params.dict,
                  resultObj: this.data,
                  docBaseUrl: params.pdfManager.docBaseUrl
                });
              }
            }
            class PopupAnnotation extends Annotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.POPUP;
                let parentItem = parameters.dict.get("Parent");
                if (!parentItem) {
                  (0, _util2.warn)("Popup annotation has a missing or invalid parent annotation.");
                  return;
                }
                const parentSubtype = parentItem.get("Subtype");
                this.data.parentType = (0, _primitives.isName)(parentSubtype) ? parentSubtype.name : null;
                const rawParent = parameters.dict.getRaw("Parent");
                this.data.parentId = (0, _primitives.isRef)(rawParent) ? rawParent.toString() : null;
                const rt = parentItem.get("RT");
                if ((0, _primitives.isName)(rt, _util2.AnnotationReplyType.GROUP)) {
                  parentItem = parentItem.get("IRT");
                }
                if (!parentItem.has("M")) {
                  this.data.modificationDate = null;
                } else {
                  this.setModificationDate(parentItem.get("M"));
                  this.data.modificationDate = this.modificationDate;
                }
                if (!parentItem.has("C")) {
                  this.data.color = null;
                } else {
                  this.setColor(parentItem.getArray("C"));
                  this.data.color = this.color;
                }
                if (!this.viewable) {
                  const parentFlags = parentItem.get("F");
                  if (this._isViewable(parentFlags)) {
                    this.setFlags(parentFlags);
                  }
                }
                this.data.title = (0, _util2.stringToPDFString)(parentItem.get("T") || "");
                this.data.contents = (0, _util2.stringToPDFString)(parentItem.get("Contents") || "");
              }
            }
            class FreeTextAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.FREETEXT;
              }
            }
            class LineAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.LINE;
                this.data.lineCoordinates = _util2.Util.normalizeRect(parameters.dict.getArray("L"));
              }
            }
            class SquareAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.SQUARE;
              }
            }
            class CircleAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.CIRCLE;
              }
            }
            class PolylineAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.POLYLINE;
                const rawVertices = parameters.dict.getArray("Vertices");
                this.data.vertices = [];
                for (let i2 = 0, ii = rawVertices.length; i2 < ii; i2 += 2) {
                  this.data.vertices.push({
                    x: rawVertices[i2],
                    y: rawVertices[i2 + 1]
                  });
                }
              }
            }
            class PolygonAnnotation extends PolylineAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.POLYGON;
              }
            }
            class CaretAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.CARET;
              }
            }
            class InkAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.INK;
                const xref = parameters.xref;
                const originalInkLists = parameters.dict.getArray("InkList");
                this.data.inkLists = [];
                for (let i2 = 0, ii = originalInkLists.length; i2 < ii; ++i2) {
                  this.data.inkLists.push([]);
                  for (let j2 = 0, jj = originalInkLists[i2].length; j2 < jj; j2 += 2) {
                    this.data.inkLists[i2].push({
                      x: xref.fetchIfRef(originalInkLists[i2][j2]),
                      y: xref.fetchIfRef(originalInkLists[i2][j2 + 1])
                    });
                  }
                }
              }
            }
            class HighlightAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.HIGHLIGHT;
                const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                if (quadPoints) {
                  this.data.quadPoints = quadPoints;
                }
              }
            }
            class UnderlineAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.UNDERLINE;
                const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                if (quadPoints) {
                  this.data.quadPoints = quadPoints;
                }
              }
            }
            class SquigglyAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.SQUIGGLY;
                const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                if (quadPoints) {
                  this.data.quadPoints = quadPoints;
                }
              }
            }
            class StrikeOutAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.STRIKEOUT;
                const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                if (quadPoints) {
                  this.data.quadPoints = quadPoints;
                }
              }
            }
            class StampAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                this.data.annotationType = _util2.AnnotationType.STAMP;
              }
            }
            class FileAttachmentAnnotation extends MarkupAnnotation {
              constructor(parameters) {
                super(parameters);
                const file = new _obj.FileSpec(parameters.dict.get("FS"), parameters.xref);
                this.data.annotationType = _util2.AnnotationType.FILEATTACHMENT;
                this.data.file = file.serializable;
              }
            }
          },
          /* 24 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.OperatorList = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var QueueOptimizer = function QueueOptimizerClosure() {
              function addState(parentState, pattern, checkFn, iterateFn, processFn) {
                var state = parentState;
                for (var i2 = 0, ii = pattern.length - 1; i2 < ii; i2++) {
                  var item = pattern[i2];
                  state = state[item] || (state[item] = []);
                }
                state[pattern[pattern.length - 1]] = {
                  checkFn,
                  iterateFn,
                  processFn
                };
              }
              function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
                var iFirstPIMXO = iFirstSave + 2;
                for (var i2 = 0; i2 < count; i2++) {
                  var arg = argsArray[iFirstPIMXO + 4 * i2];
                  var imageMask = arg.length === 1 && arg[0];
                  if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
                    fnArray[iFirstPIMXO + 4 * i2] = _util2.OPS.paintSolidColorImageMask;
                    continue;
                  }
                  break;
                }
                return count - i2;
              }
              var InitialState = [];
              addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintInlineImageXObject, _util2.OPS.restore], null, function iterateInlineImageGroup(context, i2) {
                var fnArray = context.fnArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i2 - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i2] === _util2.OPS.save;
                  case 1:
                    return fnArray[i2] === _util2.OPS.transform;
                  case 2:
                    return fnArray[i2] === _util2.OPS.paintInlineImageXObject;
                  case 3:
                    return fnArray[i2] === _util2.OPS.restore;
                }
                throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
              }, function foundInlineImageGroup(context, i2) {
                var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                var MAX_WIDTH = 1e3;
                var IMAGE_PADDING = 1;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIIXO = curr - 1;
                var count = Math.min(Math.floor((i2 - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                  return i2 - (i2 - iFirstSave) % 4;
                }
                var maxX = 0;
                var map = [], maxLineHeight = 0;
                var currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
                var q2;
                for (q2 = 0; q2 < count; q2++) {
                  var transform = argsArray[iFirstTransform + (q2 << 2)];
                  var img = argsArray[iFirstPIIXO + (q2 << 2)][0];
                  if (currentX + img.width > MAX_WIDTH) {
                    maxX = Math.max(maxX, currentX);
                    currentY += maxLineHeight + 2 * IMAGE_PADDING;
                    currentX = 0;
                    maxLineHeight = 0;
                  }
                  map.push({
                    transform,
                    x: currentX,
                    y: currentY,
                    w: img.width,
                    h: img.height
                  });
                  currentX += img.width + 2 * IMAGE_PADDING;
                  maxLineHeight = Math.max(maxLineHeight, img.height);
                }
                var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                var imgData = new Uint8ClampedArray(imgWidth * imgHeight * 4);
                var imgRowSize = imgWidth << 2;
                for (q2 = 0; q2 < count; q2++) {
                  var data = argsArray[iFirstPIIXO + (q2 << 2)][0].data;
                  var rowSize = map[q2].w << 2;
                  var dataOffset = 0;
                  var offset = map[q2].x + map[q2].y * imgWidth << 2;
                  imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                  for (var k2 = 0, kk = map[q2].h; k2 < kk; k2++) {
                    imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                    dataOffset += rowSize;
                    offset += imgRowSize;
                  }
                  imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                  while (offset >= 0) {
                    data[offset - 4] = data[offset];
                    data[offset - 3] = data[offset + 1];
                    data[offset - 2] = data[offset + 2];
                    data[offset - 1] = data[offset + 3];
                    data[offset + rowSize] = data[offset + rowSize - 4];
                    data[offset + rowSize + 1] = data[offset + rowSize - 3];
                    data[offset + rowSize + 2] = data[offset + rowSize - 2];
                    data[offset + rowSize + 3] = data[offset + rowSize - 1];
                    offset -= imgRowSize;
                  }
                }
                fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintInlineImageXObjectGroup);
                argsArray.splice(iFirstSave, count * 4, [{
                  width: imgWidth,
                  height: imgHeight,
                  kind: _util2.ImageKind.RGBA_32BPP,
                  data: imgData
                }, map]);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintImageMaskXObject, _util2.OPS.restore], null, function iterateImageMaskGroup(context, i2) {
                var fnArray = context.fnArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i2 - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i2] === _util2.OPS.save;
                  case 1:
                    return fnArray[i2] === _util2.OPS.transform;
                  case 2:
                    return fnArray[i2] === _util2.OPS.paintImageMaskXObject;
                  case 3:
                    return fnArray[i2] === _util2.OPS.restore;
                }
                throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
              }, function foundImageMaskGroup(context, i2) {
                var MIN_IMAGES_IN_MASKS_BLOCK = 10;
                var MAX_IMAGES_IN_MASKS_BLOCK = 100;
                var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIMXO = curr - 1;
                var count = Math.floor((i2 - iFirstSave) / 4);
                count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
                if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                  return i2 - (i2 - iFirstSave) % 4;
                }
                var q2;
                var isSameImage = false;
                var iTransform, transformArgs;
                var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
                  isSameImage = true;
                  var firstTransformArg0 = argsArray[iFirstTransform][0];
                  var firstTransformArg3 = argsArray[iFirstTransform][3];
                  iTransform = iFirstTransform + 4;
                  var iPIMXO = iFirstPIMXO + 4;
                  for (q2 = 1; q2 < count; q2++, iTransform += 4, iPIMXO += 4) {
                    transformArgs = argsArray[iTransform];
                    if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
                      if (q2 < MIN_IMAGES_IN_MASKS_BLOCK) {
                        isSameImage = false;
                      } else {
                        count = q2;
                      }
                      break;
                    }
                  }
                }
                if (isSameImage) {
                  count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                  var positions = new Float32Array(count * 2);
                  iTransform = iFirstTransform;
                  for (q2 = 0; q2 < count; q2++, iTransform += 4) {
                    transformArgs = argsArray[iTransform];
                    positions[q2 << 1] = transformArgs[4];
                    positions[(q2 << 1) + 1] = transformArgs[5];
                  }
                  fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageMaskXObjectRepeat);
                  argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
                } else {
                  count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                  var images = [];
                  for (q2 = 0; q2 < count; q2++) {
                    transformArgs = argsArray[iFirstTransform + (q2 << 2)];
                    var maskParams = argsArray[iFirstPIMXO + (q2 << 2)][0];
                    images.push({
                      data: maskParams.data,
                      width: maskParams.width,
                      height: maskParams.height,
                      transform: transformArgs
                    });
                  }
                  fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageMaskXObjectGroup);
                  argsArray.splice(iFirstSave, count * 4, [images]);
                }
                return iFirstSave + 1;
              });
              addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintImageXObject, _util2.OPS.restore], function(context) {
                var argsArray = context.argsArray;
                var iFirstTransform = context.iCurr - 2;
                return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
              }, function iterateImageGroup(context, i2) {
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i2 - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i2] === _util2.OPS.save;
                  case 1:
                    if (fnArray[i2] !== _util2.OPS.transform) {
                      return false;
                    }
                    var iFirstTransform = context.iCurr - 2;
                    var firstTransformArg0 = argsArray[iFirstTransform][0];
                    var firstTransformArg3 = argsArray[iFirstTransform][3];
                    if (argsArray[i2][0] !== firstTransformArg0 || argsArray[i2][1] !== 0 || argsArray[i2][2] !== 0 || argsArray[i2][3] !== firstTransformArg3) {
                      return false;
                    }
                    return true;
                  case 2:
                    if (fnArray[i2] !== _util2.OPS.paintImageXObject) {
                      return false;
                    }
                    var iFirstPIXO = context.iCurr - 1;
                    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    if (argsArray[i2][0] !== firstPIXOArg0) {
                      return false;
                    }
                    return true;
                  case 3:
                    return fnArray[i2] === _util2.OPS.restore;
                }
                throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
              }, function(context, i2) {
                var MIN_IMAGES_IN_BLOCK = 3;
                var MAX_IMAGES_IN_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIXO = curr - 1;
                var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                var firstTransformArg0 = argsArray[iFirstTransform][0];
                var firstTransformArg3 = argsArray[iFirstTransform][3];
                var count = Math.min(Math.floor((i2 - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
                if (count < MIN_IMAGES_IN_BLOCK) {
                  return i2 - (i2 - iFirstSave) % 4;
                }
                var positions = new Float32Array(count * 2);
                var iTransform = iFirstTransform;
                for (var q2 = 0; q2 < count; q2++, iTransform += 4) {
                  var transformArgs = argsArray[iTransform];
                  positions[q2 << 1] = transformArgs[4];
                  positions[(q2 << 1) + 1] = transformArgs[5];
                }
                var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageXObjectRepeat);
                argsArray.splice(iFirstSave, count * 4, args);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util2.OPS.beginText, _util2.OPS.setFont, _util2.OPS.setTextMatrix, _util2.OPS.showText, _util2.OPS.endText], null, function iterateShowTextGroup(context, i2) {
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var iFirstSave = context.iCurr - 4;
                var pos = (i2 - iFirstSave) % 5;
                switch (pos) {
                  case 0:
                    return fnArray[i2] === _util2.OPS.beginText;
                  case 1:
                    return fnArray[i2] === _util2.OPS.setFont;
                  case 2:
                    return fnArray[i2] === _util2.OPS.setTextMatrix;
                  case 3:
                    if (fnArray[i2] !== _util2.OPS.showText) {
                      return false;
                    }
                    var iFirstSetFont = context.iCurr - 3;
                    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    if (argsArray[i2][0] !== firstSetFontArg0 || argsArray[i2][1] !== firstSetFontArg1) {
                      return false;
                    }
                    return true;
                  case 4:
                    return fnArray[i2] === _util2.OPS.endText;
                }
                throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
              }, function(context, i2) {
                var MIN_CHARS_IN_BLOCK = 3;
                var MAX_CHARS_IN_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstBeginText = curr - 4;
                var iFirstSetFont = curr - 3;
                var iFirstSetTextMatrix = curr - 2;
                var iFirstShowText = curr - 1;
                var iFirstEndText = curr;
                var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                var count = Math.min(Math.floor((i2 - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                if (count < MIN_CHARS_IN_BLOCK) {
                  return i2 - (i2 - iFirstBeginText) % 5;
                }
                var iFirst = iFirstBeginText;
                if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                  count++;
                  iFirst -= 5;
                }
                var iEndText = iFirst + 4;
                for (var q2 = 1; q2 < count; q2++) {
                  fnArray.splice(iEndText, 3);
                  argsArray.splice(iEndText, 3);
                  iEndText += 2;
                }
                return iEndText + 1;
              });
              function QueueOptimizer2(queue) {
                this.queue = queue;
                this.state = null;
                this.context = {
                  iCurr: 0,
                  fnArray: queue.fnArray,
                  argsArray: queue.argsArray
                };
                this.match = null;
                this.lastProcessed = 0;
              }
              QueueOptimizer2.prototype = {
                _optimize() {
                  const fnArray = this.queue.fnArray;
                  let i2 = this.lastProcessed, ii = fnArray.length;
                  let state = this.state;
                  let match = this.match;
                  if (!state && !match && i2 + 1 === ii && !InitialState[fnArray[i2]]) {
                    this.lastProcessed = ii;
                    return;
                  }
                  const context = this.context;
                  while (i2 < ii) {
                    if (match) {
                      const iterate = (0, match.iterateFn)(context, i2);
                      if (iterate) {
                        i2++;
                        continue;
                      }
                      i2 = (0, match.processFn)(context, i2 + 1);
                      ii = fnArray.length;
                      match = null;
                      state = null;
                      if (i2 >= ii) {
                        break;
                      }
                    }
                    state = (state || InitialState)[fnArray[i2]];
                    if (!state || Array.isArray(state)) {
                      i2++;
                      continue;
                    }
                    context.iCurr = i2;
                    i2++;
                    if (state.checkFn && !(0, state.checkFn)(context)) {
                      state = null;
                      continue;
                    }
                    match = state;
                    state = null;
                  }
                  this.state = state;
                  this.match = match;
                  this.lastProcessed = i2;
                },
                push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                  this._optimize();
                },
                flush() {
                  while (this.match) {
                    const length = this.queue.fnArray.length;
                    this.lastProcessed = (0, this.match.processFn)(this.context, length);
                    this.match = null;
                    this.state = null;
                    this._optimize();
                  }
                },
                reset() {
                  this.state = null;
                  this.match = null;
                  this.lastProcessed = 0;
                }
              };
              return QueueOptimizer2;
            }();
            var NullOptimizer = function NullOptimizerClosure() {
              function NullOptimizer2(queue) {
                this.queue = queue;
              }
              NullOptimizer2.prototype = {
                push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                },
                flush() {
                },
                reset() {
                }
              };
              return NullOptimizer2;
            }();
            var OperatorList = function OperatorListClosure() {
              var CHUNK_SIZE = 1e3;
              var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;
              function OperatorList2(intent, streamSink, pageIndex) {
                this._streamSink = streamSink;
                this.fnArray = [];
                this.argsArray = [];
                if (streamSink && intent !== "oplist") {
                  this.optimizer = new QueueOptimizer(this);
                } else {
                  this.optimizer = new NullOptimizer(this);
                }
                this.dependencies = /* @__PURE__ */ Object.create(null);
                this._totalLength = 0;
                this.pageIndex = pageIndex;
                this.intent = intent;
                this.weight = 0;
                this._resolved = streamSink ? null : Promise.resolve();
              }
              OperatorList2.prototype = {
                get length() {
                  return this.argsArray.length;
                },
                get ready() {
                  return this._resolved || this._streamSink.ready;
                },
                get totalLength() {
                  return this._totalLength + this.length;
                },
                addOp(fn, args) {
                  this.optimizer.push(fn, args);
                  this.weight++;
                  if (this._streamSink) {
                    if (this.weight >= CHUNK_SIZE) {
                      this.flush();
                    } else if (this.weight >= CHUNK_SIZE_ABOUT && (fn === _util2.OPS.restore || fn === _util2.OPS.endText)) {
                      this.flush();
                    }
                  }
                },
                addDependency(dependency) {
                  if (dependency in this.dependencies) {
                    return;
                  }
                  this.dependencies[dependency] = true;
                  this.addOp(_util2.OPS.dependency, [dependency]);
                },
                addDependencies(dependencies) {
                  for (var key in dependencies) {
                    this.addDependency(key);
                  }
                },
                addOpList(opList) {
                  Object.assign(this.dependencies, opList.dependencies);
                  for (var i2 = 0, ii = opList.length; i2 < ii; i2++) {
                    this.addOp(opList.fnArray[i2], opList.argsArray[i2]);
                  }
                },
                getIR() {
                  return {
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    length: this.length
                  };
                },
                get _transfers() {
                  const transfers = [];
                  const {
                    fnArray,
                    argsArray,
                    length
                  } = this;
                  for (let i2 = 0; i2 < length; i2++) {
                    switch (fnArray[i2]) {
                      case _util2.OPS.paintInlineImageXObject:
                      case _util2.OPS.paintInlineImageXObjectGroup:
                      case _util2.OPS.paintImageMaskXObject:
                        const arg = argsArray[i2][0];
                        ;
                        if (!arg.cached) {
                          transfers.push(arg.data.buffer);
                        }
                        break;
                    }
                  }
                  return transfers;
                },
                flush(lastChunk = false) {
                  this.optimizer.flush();
                  const length = this.length;
                  this._totalLength += length;
                  this._streamSink.enqueue({
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    lastChunk,
                    length
                  }, 1, this._transfers);
                  this.dependencies = /* @__PURE__ */ Object.create(null);
                  this.fnArray.length = 0;
                  this.argsArray.length = 0;
                  this.weight = 0;
                  this.optimizer.reset();
                }
              };
              return OperatorList2;
            }();
            exports3.OperatorList = OperatorList;
          },
          /* 25 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PartialEvaluator = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _cmap = __w_pdfjs_require__2(26);
            var _primitives = __w_pdfjs_require__2(4);
            var _fonts = __w_pdfjs_require__2(27);
            var _encodings = __w_pdfjs_require__2(30);
            var _core_utils = __w_pdfjs_require__2(7);
            var _unicode = __w_pdfjs_require__2(33);
            var _standard_fonts = __w_pdfjs_require__2(32);
            var _pattern = __w_pdfjs_require__2(36);
            var _parser = __w_pdfjs_require__2(10);
            var _bidi = __w_pdfjs_require__2(37);
            var _colorspace = __w_pdfjs_require__2(22);
            var _stream = __w_pdfjs_require__2(11);
            var _glyphlist = __w_pdfjs_require__2(31);
            var _metrics = __w_pdfjs_require__2(38);
            var _function = __w_pdfjs_require__2(39);
            var _jpeg_stream = __w_pdfjs_require__2(17);
            var _murmurhash = __w_pdfjs_require__2(41);
            var _image_utils = __w_pdfjs_require__2(42);
            var _operator_list = __w_pdfjs_require__2(24);
            var _image = __w_pdfjs_require__2(43);
            var PartialEvaluator = function PartialEvaluatorClosure() {
              const DefaultPartialEvaluatorOptions = {
                forceDataSchema: false,
                maxImageSize: -1,
                disableFontFace: false,
                nativeImageDecoderSupport: _util2.NativeImageDecoding.DECODE,
                ignoreErrors: false,
                isEvalSupported: true
              };
              function PartialEvaluator2({
                xref,
                handler,
                pageIndex,
                idFactory,
                fontCache,
                builtInCMapCache,
                options = null,
                pdfFunctionFactory
              }) {
                this.xref = xref;
                this.handler = handler;
                this.pageIndex = pageIndex;
                this.idFactory = idFactory;
                this.fontCache = fontCache;
                this.builtInCMapCache = builtInCMapCache;
                this.options = options || DefaultPartialEvaluatorOptions;
                this.pdfFunctionFactory = pdfFunctionFactory;
                this.parsingType3Font = false;
                this.fetchBuiltInCMap = async (name) => {
                  if (this.builtInCMapCache.has(name)) {
                    return this.builtInCMapCache.get(name);
                  }
                  const readableStream = this.handler.sendWithStream("FetchBuiltInCMap", {
                    name
                  });
                  const reader = readableStream.getReader();
                  const data = await new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          return;
                        }
                        resolve(value);
                        pump();
                      }, reject);
                    }
                    pump();
                  });
                  if (data.compressionType !== _util2.CMapCompressionType.NONE) {
                    this.builtInCMapCache.set(name, data);
                  }
                  return data;
                };
              }
              var TIME_SLOT_DURATION_MS = 20;
              var CHECK_TIME_EVERY = 100;
              function TimeSlotManager() {
                this.reset();
              }
              TimeSlotManager.prototype = {
                check: function TimeSlotManager_check() {
                  if (++this.checked < CHECK_TIME_EVERY) {
                    return false;
                  }
                  this.checked = 0;
                  return this.endTime <= Date.now();
                },
                reset: function TimeSlotManager_reset() {
                  this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
                  this.checked = 0;
                }
              };
              function normalizeBlendMode(value, parsingArray = false) {
                if (Array.isArray(value)) {
                  for (let i2 = 0, ii = value.length; i2 < ii; i2++) {
                    const maybeBM = normalizeBlendMode(value[i2], true);
                    if (maybeBM) {
                      return maybeBM;
                    }
                  }
                  (0, _util2.warn)(`Unsupported blend mode Array: ${value}`);
                  return "source-over";
                }
                if (!(0, _primitives.isName)(value)) {
                  if (parsingArray) {
                    return null;
                  }
                  return "source-over";
                }
                switch (value.name) {
                  case "Normal":
                  case "Compatible":
                    return "source-over";
                  case "Multiply":
                    return "multiply";
                  case "Screen":
                    return "screen";
                  case "Overlay":
                    return "overlay";
                  case "Darken":
                    return "darken";
                  case "Lighten":
                    return "lighten";
                  case "ColorDodge":
                    return "color-dodge";
                  case "ColorBurn":
                    return "color-burn";
                  case "HardLight":
                    return "hard-light";
                  case "SoftLight":
                    return "soft-light";
                  case "Difference":
                    return "difference";
                  case "Exclusion":
                    return "exclusion";
                  case "Hue":
                    return "hue";
                  case "Saturation":
                    return "saturation";
                  case "Color":
                    return "color";
                  case "Luminosity":
                    return "luminosity";
                }
                if (parsingArray) {
                  return null;
                }
                (0, _util2.warn)(`Unsupported blend mode: ${value.name}`);
                return "source-over";
              }
              var deferred = Promise.resolve();
              var TILING_PATTERN = 1, SHADING_PATTERN = 2;
              PartialEvaluator2.prototype = {
                clone(newOptions = DefaultPartialEvaluatorOptions) {
                  var newEvaluator = Object.create(this);
                  newEvaluator.options = newOptions;
                  return newEvaluator;
                },
                hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
                  if (!(resources instanceof _primitives.Dict)) {
                    return false;
                  }
                  var processed = /* @__PURE__ */ Object.create(null);
                  if (resources.objId) {
                    processed[resources.objId] = true;
                  }
                  var nodes = [resources], xref = this.xref;
                  while (nodes.length) {
                    var node = nodes.shift();
                    var graphicStates = node.get("ExtGState");
                    if (graphicStates instanceof _primitives.Dict) {
                      var graphicStatesKeys = graphicStates.getKeys();
                      for (let i2 = 0, ii = graphicStatesKeys.length; i2 < ii; i2++) {
                        const key = graphicStatesKeys[i2];
                        let graphicState = graphicStates.getRaw(key);
                        if (graphicState instanceof _primitives.Ref) {
                          if (processed[graphicState.toString()]) {
                            continue;
                          }
                          try {
                            graphicState = xref.fetch(graphicState);
                          } catch (ex) {
                            if (ex instanceof _core_utils.MissingDataException) {
                              throw ex;
                            }
                            if (this.options.ignoreErrors) {
                              if (graphicState instanceof _primitives.Ref) {
                                processed[graphicState.toString()] = true;
                              }
                              this.handler.send("UnsupportedFeature", {
                                featureId: _util2.UNSUPPORTED_FEATURES.unknown
                              });
                              (0, _util2.warn)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
                              continue;
                            }
                            throw ex;
                          }
                        }
                        if (!(graphicState instanceof _primitives.Dict)) {
                          continue;
                        }
                        if (graphicState.objId) {
                          processed[graphicState.objId] = true;
                        }
                        const bm = graphicState.get("BM");
                        if (bm instanceof _primitives.Name) {
                          if (bm.name !== "Normal") {
                            return true;
                          }
                          continue;
                        }
                        if (bm !== void 0 && Array.isArray(bm)) {
                          for (let j2 = 0, jj = bm.length; j2 < jj; j2++) {
                            if (bm[j2] instanceof _primitives.Name && bm[j2].name !== "Normal") {
                              return true;
                            }
                          }
                        }
                      }
                    }
                    var xObjects = node.get("XObject");
                    if (!(xObjects instanceof _primitives.Dict)) {
                      continue;
                    }
                    var xObjectsKeys = xObjects.getKeys();
                    for (let i2 = 0, ii = xObjectsKeys.length; i2 < ii; i2++) {
                      const key = xObjectsKeys[i2];
                      var xObject = xObjects.getRaw(key);
                      if (xObject instanceof _primitives.Ref) {
                        if (processed[xObject.toString()]) {
                          continue;
                        }
                        try {
                          xObject = xref.fetch(xObject);
                        } catch (ex) {
                          if (ex instanceof _core_utils.MissingDataException) {
                            throw ex;
                          }
                          if (this.options.ignoreErrors) {
                            if (xObject instanceof _primitives.Ref) {
                              processed[xObject.toString()] = true;
                            }
                            this.handler.send("UnsupportedFeature", {
                              featureId: _util2.UNSUPPORTED_FEATURES.unknown
                            });
                            (0, _util2.warn)(`hasBlendModes - ignoring XObject: "${ex}".`);
                            continue;
                          }
                          throw ex;
                        }
                      }
                      if (!(0, _primitives.isStream)(xObject)) {
                        continue;
                      }
                      if (xObject.dict.objId) {
                        if (processed[xObject.dict.objId]) {
                          continue;
                        }
                        processed[xObject.dict.objId] = true;
                      }
                      var xResources = xObject.dict.get("Resources");
                      if (xResources instanceof _primitives.Dict && (!xResources.objId || !processed[xResources.objId])) {
                        nodes.push(xResources);
                        if (xResources.objId) {
                          processed[xResources.objId] = true;
                        }
                      }
                    }
                  }
                  return false;
                },
                async buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
                  var dict = xobj.dict;
                  var matrix = dict.getArray("Matrix");
                  var bbox = dict.getArray("BBox");
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    bbox = _util2.Util.normalizeRect(bbox);
                  } else {
                    bbox = null;
                  }
                  var group = dict.get("Group");
                  if (group) {
                    var groupOptions = {
                      matrix,
                      bbox,
                      smask,
                      isolated: false,
                      knockout: false
                    };
                    var groupSubtype = group.get("S");
                    var colorSpace = null;
                    if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                      groupOptions.isolated = group.get("I") || false;
                      groupOptions.knockout = group.get("K") || false;
                      if (group.has("CS")) {
                        colorSpace = await this.parseColorSpace({
                          cs: group.get("CS"),
                          resources
                        });
                      }
                    }
                    if (smask && smask.backdrop) {
                      colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                      smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                    }
                    operatorList.addOp(_util2.OPS.beginGroup, [groupOptions]);
                  }
                  operatorList.addOp(_util2.OPS.paintFormXObjectBegin, [matrix, bbox]);
                  return this.getOperatorList({
                    stream: xobj,
                    task,
                    resources: dict.get("Resources") || resources,
                    operatorList,
                    initialState
                  }).then(function() {
                    operatorList.addOp(_util2.OPS.paintFormXObjectEnd, []);
                    if (group) {
                      operatorList.addOp(_util2.OPS.endGroup, [groupOptions]);
                    }
                  });
                },
                async buildPaintImageXObject({
                  resources,
                  image,
                  isInline = false,
                  operatorList,
                  cacheKey,
                  imageCache,
                  forceDisableNativeImageDecoder = false
                }) {
                  var dict = image.dict;
                  var w2 = dict.get("Width", "W");
                  var h2 = dict.get("Height", "H");
                  if (!(w2 && (0, _util2.isNum)(w2)) || !(h2 && (0, _util2.isNum)(h2))) {
                    (0, _util2.warn)("Image dimensions are missing, or not numbers.");
                    return void 0;
                  }
                  var maxImageSize = this.options.maxImageSize;
                  if (maxImageSize !== -1 && w2 * h2 > maxImageSize) {
                    (0, _util2.warn)("Image exceeded maximum allowed size and was removed.");
                    return void 0;
                  }
                  var imageMask = dict.get("ImageMask", "IM") || false;
                  var imgData, args;
                  if (imageMask) {
                    var width = dict.get("Width", "W");
                    var height = dict.get("Height", "H");
                    var bitStrideLength = width + 7 >> 3;
                    var imgArray = image.getBytes(bitStrideLength * height, true);
                    var decode = dict.getArray("Decode", "D");
                    imgData = _image.PDFImage.createMask({
                      imgArray,
                      width,
                      height,
                      imageIsFromDecodeStream: image instanceof _stream.DecodeStream,
                      inverseDecode: !!decode && decode[0] > 0
                    });
                    imgData.cached = !!cacheKey;
                    args = [imgData];
                    operatorList.addOp(_util2.OPS.paintImageMaskXObject, args);
                    if (cacheKey) {
                      imageCache[cacheKey] = {
                        fn: _util2.OPS.paintImageMaskXObject,
                        args
                      };
                    }
                    return void 0;
                  }
                  var softMask = dict.get("SMask", "SM") || false;
                  var mask = dict.get("Mask") || false;
                  var SMALL_IMAGE_DIMENSIONS = 200;
                  if (isInline && !softMask && !mask && !(image instanceof _jpeg_stream.JpegStream) && w2 + h2 < SMALL_IMAGE_DIMENSIONS) {
                    const imageObj = new _image.PDFImage({
                      xref: this.xref,
                      res: resources,
                      image,
                      isInline,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                    imgData = imageObj.createImageData(true);
                    operatorList.addOp(_util2.OPS.paintInlineImageXObject, [imgData]);
                    return void 0;
                  }
                  const nativeImageDecoderSupport = forceDisableNativeImageDecoder ? _util2.NativeImageDecoding.NONE : this.options.nativeImageDecoderSupport;
                  let objId = `img_${this.idFactory.createObjId()}`;
                  if (this.parsingType3Font) {
                    (0, _util2.assert)(nativeImageDecoderSupport === _util2.NativeImageDecoding.NONE, "Type3 image resources should be completely decoded in the worker.");
                    objId = `${this.idFactory.getDocId()}_type3res_${objId}`;
                  }
                  if (nativeImageDecoderSupport !== _util2.NativeImageDecoding.NONE && !softMask && !mask && image instanceof _jpeg_stream.JpegStream && _image_utils.NativeImageDecoder.isSupported(image, this.xref, resources, this.pdfFunctionFactory) && image.maybeValidDimensions) {
                    return this.handler.sendWithPromise("obj", [objId, this.pageIndex, "JpegStream", image.getIR(this.options.forceDataSchema)]).then(function() {
                      operatorList.addDependency(objId);
                      args = [objId, w2, h2];
                      operatorList.addOp(_util2.OPS.paintJpegXObject, args);
                      if (cacheKey) {
                        imageCache[cacheKey] = {
                          fn: _util2.OPS.paintJpegXObject,
                          args
                        };
                      }
                    }, (reason) => {
                      (0, _util2.warn)("Native JPEG decoding failed -- trying to recover: " + (reason && reason.message));
                      return this.buildPaintImageXObject({
                        resources,
                        image,
                        isInline,
                        operatorList,
                        cacheKey,
                        imageCache,
                        forceDisableNativeImageDecoder: true
                      });
                    });
                  }
                  var nativeImageDecoder = null;
                  if (nativeImageDecoderSupport === _util2.NativeImageDecoding.DECODE && (image instanceof _jpeg_stream.JpegStream || mask instanceof _jpeg_stream.JpegStream || softMask instanceof _jpeg_stream.JpegStream)) {
                    nativeImageDecoder = new _image_utils.NativeImageDecoder({
                      xref: this.xref,
                      resources,
                      handler: this.handler,
                      forceDataSchema: this.options.forceDataSchema,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                  }
                  operatorList.addDependency(objId);
                  args = [objId, w2, h2];
                  const imgPromise = _image.PDFImage.buildImage({
                    handler: this.handler,
                    xref: this.xref,
                    res: resources,
                    image,
                    isInline,
                    nativeDecoder: nativeImageDecoder,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  }).then((imageObj) => {
                    var imgData2 = imageObj.createImageData(false);
                    if (this.parsingType3Font) {
                      return this.handler.sendWithPromise("commonobj", [objId, "FontType3Res", imgData2], [imgData2.data.buffer]);
                    }
                    this.handler.send("obj", [objId, this.pageIndex, "Image", imgData2], [imgData2.data.buffer]);
                    return void 0;
                  }).catch((reason) => {
                    (0, _util2.warn)("Unable to decode image: " + reason);
                    if (this.parsingType3Font) {
                      return this.handler.sendWithPromise("commonobj", [objId, "FontType3Res", null]);
                    }
                    this.handler.send("obj", [objId, this.pageIndex, "Image", null]);
                    return void 0;
                  });
                  if (this.parsingType3Font) {
                    await imgPromise;
                  }
                  operatorList.addOp(_util2.OPS.paintImageXObject, args);
                  if (cacheKey) {
                    imageCache[cacheKey] = {
                      fn: _util2.OPS.paintImageXObject,
                      args
                    };
                  }
                  return void 0;
                },
                handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
                  var smaskContent = smask.get("G");
                  var smaskOptions = {
                    subtype: smask.get("S").name,
                    backdrop: smask.get("BC")
                  };
                  var transferObj = smask.get("TR");
                  if ((0, _function.isPDFFunction)(transferObj)) {
                    const transferFn = this.pdfFunctionFactory.create(transferObj);
                    var transferMap = new Uint8Array(256);
                    var tmp = new Float32Array(1);
                    for (var i2 = 0; i2 < 256; i2++) {
                      tmp[0] = i2 / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[i2] = tmp[0] * 255 | 0;
                    }
                    smaskOptions.transferMap = transferMap;
                  }
                  return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
                },
                handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
                  const tilingOpList = new _operator_list.OperatorList();
                  const resourcesArray = [patternDict.get("Resources"), resources];
                  const patternResources = _primitives.Dict.merge(this.xref, resourcesArray);
                  return this.getOperatorList({
                    stream: pattern,
                    task,
                    resources: patternResources,
                    operatorList: tilingOpList
                  }).then(function() {
                    return (0, _pattern.getTilingPatternIR)({
                      fnArray: tilingOpList.fnArray,
                      argsArray: tilingOpList.argsArray
                    }, patternDict, args);
                  }).then(function(tilingPatternIR) {
                    operatorList.addDependencies(tilingOpList.dependencies);
                    operatorList.addOp(fn, tilingPatternIR);
                  }, (reason) => {
                    if (reason instanceof _util2.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util2.UNSUPPORTED_FEATURES.unknown
                      });
                      (0, _util2.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
                      return;
                    }
                    throw reason;
                  });
                },
                handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                  var fontName;
                  if (fontArgs) {
                    fontArgs = fontArgs.slice();
                    fontName = fontArgs[0].name;
                  }
                  return this.loadFont(fontName, fontRef, resources).then((translated) => {
                    if (!translated.font.isType3Font) {
                      return translated;
                    }
                    return translated.loadType3Data(this, resources, operatorList, task).then(function() {
                      return translated;
                    }).catch((reason) => {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util2.UNSUPPORTED_FEATURES.font
                      });
                      return new TranslatedFont("g_font_error", new _fonts.ErrorFont("Type3 font load error: " + reason), translated.font);
                    });
                  }).then((translated) => {
                    state.font = translated.font;
                    translated.send(this.handler);
                    return translated.loadedName;
                  });
                },
                handleText(chars, state) {
                  const font = state.font;
                  const glyphs = font.charsToGlyphs(chars);
                  if (font.data) {
                    const isAddToPathSet = !!(state.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                    if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
                      PartialEvaluator2.buildFontPaths(font, glyphs, this.handler);
                    }
                  }
                  return glyphs;
                },
                ensureStateFont(state) {
                  if (state.font) {
                    return;
                  }
                  const reason = new _util2.FormatError("Missing setFont (Tf) operator before text rendering operator.");
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util2.UNSUPPORTED_FEATURES.font
                    });
                    (0, _util2.warn)(`ensureStateFont: "${reason}".`);
                    return;
                  }
                  throw reason;
                },
                setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
                  var gStateObj = [];
                  var gStateKeys = gState.getKeys();
                  var promise = Promise.resolve();
                  for (var i2 = 0, ii = gStateKeys.length; i2 < ii; i2++) {
                    const key = gStateKeys[i2];
                    const value = gState.get(key);
                    switch (key) {
                      case "Type":
                        break;
                      case "LW":
                      case "LC":
                      case "LJ":
                      case "ML":
                      case "D":
                      case "RI":
                      case "FL":
                      case "CA":
                      case "ca":
                        gStateObj.push([key, value]);
                        break;
                      case "Font":
                        promise = promise.then(() => {
                          return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            gStateObj.push([key, [loadedName, value[1]]]);
                          });
                        });
                        break;
                      case "BM":
                        gStateObj.push([key, normalizeBlendMode(value)]);
                        break;
                      case "SMask":
                        if ((0, _primitives.isName)(value, "None")) {
                          gStateObj.push([key, false]);
                          break;
                        }
                        if ((0, _primitives.isDict)(value)) {
                          promise = promise.then(() => {
                            return this.handleSMask(value, resources, operatorList, task, stateManager);
                          });
                          gStateObj.push([key, true]);
                        } else {
                          (0, _util2.warn)("Unsupported SMask type");
                        }
                        break;
                      case "OP":
                      case "op":
                      case "OPM":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                      case "TR":
                      case "TR2":
                      case "HT":
                      case "SM":
                      case "SA":
                      case "AIS":
                      case "TK":
                        (0, _util2.info)("graphic state operator " + key);
                        break;
                      default:
                        (0, _util2.info)("Unknown graphic state operator " + key);
                        break;
                    }
                  }
                  return promise.then(function() {
                    if (gStateObj.length > 0) {
                      operatorList.addOp(_util2.OPS.setGState, [gStateObj]);
                    }
                  });
                },
                loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
                  function errorFont() {
                    return Promise.resolve(new TranslatedFont("g_font_error", new _fonts.ErrorFont("Font " + fontName + " is not available"), font));
                  }
                  var fontRef, xref = this.xref;
                  if (font) {
                    if (!(0, _primitives.isRef)(font)) {
                      throw new _util2.FormatError('The "font" object should be a reference.');
                    }
                    fontRef = font;
                  } else {
                    var fontRes = resources.get("Font");
                    if (fontRes) {
                      fontRef = fontRes.getRaw(fontName);
                    }
                  }
                  if (!fontRef) {
                    const partialMsg = `Font "${fontName || font && font.toString()}" is not available`;
                    if (!this.options.ignoreErrors && !this.parsingType3Font) {
                      (0, _util2.warn)(`${partialMsg}.`);
                      return errorFont();
                    }
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util2.UNSUPPORTED_FEATURES.font
                    });
                    (0, _util2.warn)(`${partialMsg} -- attempting to fallback to a default font.`);
                    fontRef = PartialEvaluator2.getFallbackFontDict();
                  }
                  if (this.fontCache.has(fontRef)) {
                    return this.fontCache.get(fontRef);
                  }
                  font = xref.fetchIfRef(fontRef);
                  if (!(0, _primitives.isDict)(font)) {
                    return errorFont();
                  }
                  if (font.translated) {
                    return font.translated;
                  }
                  var fontCapability = (0, _util2.createPromiseCapability)();
                  var preEvaluatedFont = this.preEvaluateFont(font);
                  const {
                    descriptor,
                    hash
                  } = preEvaluatedFont;
                  var fontRefIsRef = (0, _primitives.isRef)(fontRef), fontID;
                  if (fontRefIsRef) {
                    fontID = fontRef.toString();
                  }
                  if (hash && (0, _primitives.isDict)(descriptor)) {
                    if (!descriptor.fontAliases) {
                      descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
                    }
                    var fontAliases = descriptor.fontAliases;
                    if (fontAliases[hash]) {
                      var aliasFontRef = fontAliases[hash].aliasRef;
                      if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                        this.fontCache.putAlias(fontRef, aliasFontRef);
                        return this.fontCache.get(fontRef);
                      }
                    } else {
                      fontAliases[hash] = {
                        fontID: _fonts.Font.getFontID()
                      };
                    }
                    if (fontRefIsRef) {
                      fontAliases[hash].aliasRef = fontRef;
                    }
                    fontID = fontAliases[hash].fontID;
                  }
                  if (fontRefIsRef) {
                    this.fontCache.put(fontRef, fontCapability.promise);
                  } else {
                    if (!fontID) {
                      fontID = this.idFactory.createObjId();
                    }
                    this.fontCache.put(`id_${fontID}`, fontCapability.promise);
                  }
                  (0, _util2.assert)(fontID, 'The "fontID" must be defined.');
                  font.loadedName = `${this.idFactory.getDocId()}_f${fontID}`;
                  font.translated = fontCapability.promise;
                  var translatedPromise;
                  try {
                    translatedPromise = this.translateFont(preEvaluatedFont);
                  } catch (e2) {
                    translatedPromise = Promise.reject(e2);
                  }
                  translatedPromise.then(function(translatedFont) {
                    if (translatedFont.fontType !== void 0) {
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[translatedFont.fontType] = true;
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
                  }).catch((reason) => {
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util2.UNSUPPORTED_FEATURES.font
                    });
                    try {
                      var fontFile3 = descriptor && descriptor.get("FontFile3");
                      var subtype = fontFile3 && fontFile3.get("Subtype");
                      var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[fontType] = true;
                    } catch (ex) {
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), font));
                  });
                  return fontCapability.promise;
                },
                buildPath(operatorList, fn, args, parsingText = false) {
                  var lastIndex = operatorList.length - 1;
                  if (!args) {
                    args = [];
                  }
                  if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util2.OPS.constructPath) {
                    if (parsingText) {
                      (0, _util2.warn)(`Encountered path operator "${fn}" inside of a text object.`);
                      operatorList.addOp(_util2.OPS.save, null);
                    }
                    operatorList.addOp(_util2.OPS.constructPath, [[fn], args]);
                    if (parsingText) {
                      operatorList.addOp(_util2.OPS.restore, null);
                    }
                  } else {
                    var opArgs = operatorList.argsArray[lastIndex];
                    opArgs[0].push(fn);
                    Array.prototype.push.apply(opArgs[1], args);
                  }
                },
                parseColorSpace({
                  cs,
                  resources
                }) {
                  return new Promise((resolve) => {
                    resolve(_colorspace.ColorSpace.parse(cs, this.xref, resources, this.pdfFunctionFactory));
                  }).catch((reason) => {
                    if (reason instanceof _util2.AbortException) {
                      return null;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util2.UNSUPPORTED_FEATURES.unknown
                      });
                      (0, _util2.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
                      return null;
                    }
                    throw reason;
                  });
                },
                async handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
                  var patternName = args[args.length - 1];
                  var pattern;
                  if ((0, _primitives.isName)(patternName) && (pattern = patterns.get(patternName.name))) {
                    var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
                    var typeNum = dict.get("PatternType");
                    if (typeNum === TILING_PATTERN) {
                      var color = cs.base ? cs.base.getRgb(args, 0) : null;
                      return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
                    } else if (typeNum === SHADING_PATTERN) {
                      var shading = dict.get("Shading");
                      var matrix = dict.getArray("Matrix");
                      pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this.pdfFunctionFactory);
                      operatorList.addOp(fn, pattern.getIR());
                      return void 0;
                    }
                    throw new _util2.FormatError(`Unknown PatternType: ${typeNum}`);
                  }
                  throw new _util2.FormatError(`Unknown PatternName: ${patternName}`);
                },
                getOperatorList({
                  stream,
                  task,
                  resources,
                  operatorList,
                  initialState = null
                }) {
                  resources = resources || _primitives.Dict.empty;
                  initialState = initialState || new EvalState();
                  if (!operatorList) {
                    throw new Error('getOperatorList: missing "operatorList" parameter');
                  }
                  var self2 = this;
                  var xref = this.xref;
                  let parsingText = false;
                  var imageCache = /* @__PURE__ */ Object.create(null);
                  var xobjs = resources.get("XObject") || _primitives.Dict.empty;
                  var patterns = resources.get("Pattern") || _primitives.Dict.empty;
                  var stateManager = new StateManager(initialState);
                  var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  var timeSlotManager = new TimeSlotManager();
                  function closePendingRestoreOPS(argument) {
                    for (var i2 = 0, ii = preprocessor.savedStatesDepth; i2 < ii; i2++) {
                      operatorList.addOp(_util2.OPS.restore, []);
                    }
                  }
                  return new Promise(function promiseBody(resolve, reject) {
                    const next = function(promise) {
                      Promise.all([promise, operatorList.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    var stop, operation = {}, i2, ii, cs;
                    while (!(stop = timeSlotManager.check())) {
                      operation.args = null;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      var args = operation.args;
                      var fn = operation.fn;
                      switch (fn | 0) {
                        case _util2.OPS.paintXObject:
                          var name = args[0].name;
                          if (name && imageCache[name] !== void 0) {
                            operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                            args = null;
                            continue;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!name) {
                              throw new _util2.FormatError("XObject must be referred to by name.");
                            }
                            const xobj = xobjs.get(name);
                            if (!xobj) {
                              operatorList.addOp(fn, args);
                              resolveXObject();
                              return;
                            }
                            if (!(0, _primitives.isStream)(xobj)) {
                              throw new _util2.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(0, _primitives.isName)(type)) {
                              throw new _util2.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name === "Form") {
                              stateManager.save();
                              self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function() {
                                stateManager.restore();
                                resolveXObject();
                              }, rejectXObject);
                              return;
                            } else if (type.name === "Image") {
                              self2.buildPaintImageXObject({
                                resources,
                                image: xobj,
                                operatorList,
                                cacheKey: name,
                                imageCache
                              }).then(resolveXObject, rejectXObject);
                              return;
                            } else if (type.name === "PS") {
                              (0, _util2.info)("Ignored XObject subtype PS");
                            } else {
                              throw new _util2.FormatError(`Unhandled XObject subtype ${type.name}`);
                            }
                            resolveXObject();
                          }).catch(function(reason) {
                            if (reason instanceof _util2.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              self2.handler.send("UnsupportedFeature", {
                                featureId: _util2.UNSUPPORTED_FEATURES.unknown
                              });
                              (0, _util2.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util2.OPS.setFont:
                          var fontSize = args[1];
                          next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            operatorList.addOp(_util2.OPS.setFont, [loadedName, fontSize]);
                          }));
                          return;
                        case _util2.OPS.beginText:
                          parsingText = true;
                          break;
                        case _util2.OPS.endText:
                          parsingText = false;
                          break;
                        case _util2.OPS.endInlineImage:
                          var cacheKey = args[0].cacheKey;
                          if (cacheKey) {
                            var cacheEntry = imageCache[cacheKey];
                            if (cacheEntry !== void 0) {
                              operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                              args = null;
                              continue;
                            }
                          }
                          next(self2.buildPaintImageXObject({
                            resources,
                            image: args[0],
                            isInline: true,
                            operatorList,
                            cacheKey,
                            imageCache
                          }));
                          return;
                        case _util2.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          args[0] = self2.handleText(args[0], stateManager.state);
                          break;
                        case _util2.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          var arr = args[0];
                          var combinedGlyphs = [];
                          var arrLength = arr.length;
                          var state = stateManager.state;
                          for (i2 = 0; i2 < arrLength; ++i2) {
                            var arrItem = arr[i2];
                            if ((0, _util2.isString)(arrItem)) {
                              Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
                            } else if ((0, _util2.isNum)(arrItem)) {
                              combinedGlyphs.push(arrItem);
                            }
                          }
                          args[0] = combinedGlyphs;
                          fn = _util2.OPS.showText;
                          break;
                        case _util2.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util2.OPS.nextLine);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util2.OPS.showText;
                          break;
                        case _util2.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util2.OPS.nextLine);
                          operatorList.addOp(_util2.OPS.setWordSpacing, [args.shift()]);
                          operatorList.addOp(_util2.OPS.setCharSpacing, [args.shift()]);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util2.OPS.showText;
                          break;
                        case _util2.OPS.setTextRenderingMode:
                          stateManager.state.textRenderingMode = args[0];
                          break;
                        case _util2.OPS.setFillColorSpace:
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.fillColorSpace = colorSpace;
                            }
                          }));
                          return;
                        case _util2.OPS.setStrokeColorSpace:
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.strokeColorSpace = colorSpace;
                            }
                          }));
                          return;
                        case _util2.OPS.setFillColor:
                          cs = stateManager.state.fillColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util2.OPS.setFillRGBColor;
                          break;
                        case _util2.OPS.setStrokeColor:
                          cs = stateManager.state.strokeColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util2.OPS.setStrokeRGBColor;
                          break;
                        case _util2.OPS.setFillGray:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util2.OPS.setFillRGBColor;
                          break;
                        case _util2.OPS.setStrokeGray:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util2.OPS.setStrokeRGBColor;
                          break;
                        case _util2.OPS.setFillCMYKColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util2.OPS.setFillRGBColor;
                          break;
                        case _util2.OPS.setStrokeCMYKColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util2.OPS.setStrokeRGBColor;
                          break;
                        case _util2.OPS.setFillRGBColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util2.OPS.setStrokeRGBColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util2.OPS.setFillColorN:
                          cs = stateManager.state.fillColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util2.OPS.setFillColorN, args, cs, patterns, resources, task));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util2.OPS.setFillRGBColor;
                          break;
                        case _util2.OPS.setStrokeColorN:
                          cs = stateManager.state.strokeColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util2.OPS.setStrokeColorN, args, cs, patterns, resources, task));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util2.OPS.setStrokeRGBColor;
                          break;
                        case _util2.OPS.shadingFill:
                          var shadingRes = resources.get("Shading");
                          if (!shadingRes) {
                            throw new _util2.FormatError("No shading resource found");
                          }
                          var shading = shadingRes.get(args[0].name);
                          if (!shading) {
                            throw new _util2.FormatError("No shading object found");
                          }
                          var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self2.handler, self2.pdfFunctionFactory);
                          var patternIR = shadingFill.getIR();
                          args = [patternIR];
                          fn = _util2.OPS.shadingFill;
                          break;
                        case _util2.OPS.setGState:
                          var dictName = args[0];
                          var extGState = resources.get("ExtGState");
                          if (!(0, _primitives.isDict)(extGState) || !extGState.has(dictName.name)) {
                            break;
                          }
                          var gState = extGState.get(dictName.name);
                          next(self2.setGState(resources, gState, operatorList, task, stateManager));
                          return;
                        case _util2.OPS.moveTo:
                        case _util2.OPS.lineTo:
                        case _util2.OPS.curveTo:
                        case _util2.OPS.curveTo2:
                        case _util2.OPS.curveTo3:
                        case _util2.OPS.closePath:
                        case _util2.OPS.rectangle:
                          self2.buildPath(operatorList, fn, args, parsingText);
                          continue;
                        case _util2.OPS.markPoint:
                        case _util2.OPS.markPointProps:
                        case _util2.OPS.beginMarkedContent:
                        case _util2.OPS.beginMarkedContentProps:
                        case _util2.OPS.endMarkedContent:
                        case _util2.OPS.beginCompat:
                        case _util2.OPS.endCompat:
                          continue;
                        default:
                          if (args !== null) {
                            for (i2 = 0, ii = args.length; i2 < ii; i2++) {
                              if (args[i2] instanceof _primitives.Dict) {
                                break;
                              }
                            }
                            if (i2 < ii) {
                              (0, _util2.warn)("getOperatorList - ignoring operator: " + fn);
                              continue;
                            }
                          }
                      }
                      operatorList.addOp(fn, args);
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    closePendingRestoreOPS();
                    resolve();
                  }).catch((reason) => {
                    if (reason instanceof _util2.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util2.UNSUPPORTED_FEATURES.unknown
                      });
                      (0, _util2.warn)(`getOperatorList - ignoring errors during "${task.name}" task: "${reason}".`);
                      closePendingRestoreOPS();
                      return;
                    }
                    throw reason;
                  });
                },
                getTextContent({
                  stream,
                  task,
                  resources,
                  stateManager = null,
                  normalizeWhitespace = false,
                  combineTextItems = false,
                  sink,
                  seenStyles = /* @__PURE__ */ Object.create(null)
                }) {
                  resources = resources || _primitives.Dict.empty;
                  stateManager = stateManager || new StateManager(new TextState());
                  var WhitespaceRegexp = /\s/g;
                  var textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  var textContentItem = {
                    initialized: false,
                    str: [],
                    width: 0,
                    height: 0,
                    vertical: false,
                    lastAdvanceWidth: 0,
                    lastAdvanceHeight: 0,
                    textAdvanceScale: 0,
                    spaceWidth: 0,
                    fakeSpaceMin: Infinity,
                    fakeMultiSpaceMin: Infinity,
                    fakeMultiSpaceMax: -0,
                    textRunBreakAllowed: false,
                    transform: null,
                    fontName: null
                  };
                  var SPACE_FACTOR = 0.3;
                  var MULTI_SPACE_FACTOR = 1.5;
                  var MULTI_SPACE_FACTOR_MAX = 4;
                  var self2 = this;
                  var xref = this.xref;
                  var xobjs = null;
                  var skipEmptyXObjs = /* @__PURE__ */ Object.create(null);
                  var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  var textState;
                  function ensureTextContentItem() {
                    if (textContentItem.initialized) {
                      return textContentItem;
                    }
                    var font = textState.font;
                    if (!(font.loadedName in seenStyles)) {
                      seenStyles[font.loadedName] = true;
                      textContent.styles[font.loadedName] = {
                        fontFamily: font.fallbackName,
                        ascent: font.ascent,
                        descent: font.descent,
                        vertical: !!font.vertical
                      };
                    }
                    textContentItem.fontName = font.loadedName;
                    var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                    if (font.isType3Font && textState.fontSize <= 1 && !(0, _util2.isArrayEqual)(textState.fontMatrix, _util2.FONT_IDENTITY_MATRIX)) {
                      const glyphHeight = font.bbox[3] - font.bbox[1];
                      if (glyphHeight > 0) {
                        tsm[3] *= glyphHeight * textState.fontMatrix[3];
                      }
                    }
                    var trm = _util2.Util.transform(textState.ctm, _util2.Util.transform(textState.textMatrix, tsm));
                    textContentItem.transform = trm;
                    if (!font.vertical) {
                      textContentItem.width = 0;
                      textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
                      textContentItem.vertical = false;
                    } else {
                      textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
                      textContentItem.height = 0;
                      textContentItem.vertical = true;
                    }
                    var a2 = textState.textLineMatrix[0];
                    var b2 = textState.textLineMatrix[1];
                    var scaleLineX = Math.sqrt(a2 * a2 + b2 * b2);
                    a2 = textState.ctm[0];
                    b2 = textState.ctm[1];
                    var scaleCtmX = Math.sqrt(a2 * a2 + b2 * b2);
                    textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                    textContentItem.lastAdvanceWidth = 0;
                    textContentItem.lastAdvanceHeight = 0;
                    var spaceWidth = font.spaceWidth / 1e3 * textState.fontSize;
                    if (spaceWidth) {
                      textContentItem.spaceWidth = spaceWidth;
                      textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
                      textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
                      textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
                      textContentItem.textRunBreakAllowed = !font.isMonospace;
                    } else {
                      textContentItem.spaceWidth = 0;
                      textContentItem.fakeSpaceMin = Infinity;
                      textContentItem.fakeMultiSpaceMin = Infinity;
                      textContentItem.fakeMultiSpaceMax = 0;
                      textContentItem.textRunBreakAllowed = false;
                    }
                    textContentItem.initialized = true;
                    return textContentItem;
                  }
                  function replaceWhitespace(str) {
                    var i2 = 0, ii = str.length, code;
                    while (i2 < ii && (code = str.charCodeAt(i2)) >= 32 && code <= 127) {
                      i2++;
                    }
                    return i2 < ii ? str.replace(WhitespaceRegexp, " ") : str;
                  }
                  function runBidiTransform(textChunk) {
                    var str = textChunk.str.join("");
                    var bidiResult = (0, _bidi.bidi)(str, -1, textChunk.vertical);
                    return {
                      str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str,
                      dir: bidiResult.dir,
                      width: textChunk.width,
                      height: textChunk.height,
                      transform: textChunk.transform,
                      fontName: textChunk.fontName
                    };
                  }
                  function handleSetFont(fontName, fontRef) {
                    return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
                      textState.font = translated.font;
                      textState.fontMatrix = translated.font.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    });
                  }
                  function buildTextContentItem(chars) {
                    var font = textState.font;
                    var textChunk = ensureTextContentItem();
                    var width = 0;
                    var height = 0;
                    var glyphs = font.charsToGlyphs(chars);
                    for (var i2 = 0; i2 < glyphs.length; i2++) {
                      var glyph = glyphs[i2];
                      var glyphWidth = null;
                      if (font.vertical && glyph.vmetric) {
                        glyphWidth = glyph.vmetric[0];
                      } else {
                        glyphWidth = glyph.width;
                      }
                      var glyphUnicode = glyph.unicode;
                      var NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
                      if (NormalizedUnicodes[glyphUnicode] !== void 0) {
                        glyphUnicode = NormalizedUnicodes[glyphUnicode];
                      }
                      glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
                      var charSpacing = textState.charSpacing;
                      if (glyph.isSpace) {
                        var wordSpacing = textState.wordSpacing;
                        charSpacing += wordSpacing;
                        if (wordSpacing > 0) {
                          addFakeSpaces(wordSpacing, textChunk.str);
                        }
                      }
                      var tx = 0;
                      var ty = 0;
                      if (!font.vertical) {
                        var w0 = glyphWidth * textState.fontMatrix[0];
                        tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
                        width += tx;
                      } else {
                        var w1 = glyphWidth * textState.fontMatrix[0];
                        ty = w1 * textState.fontSize + charSpacing;
                        height += ty;
                      }
                      textState.translateTextMatrix(tx, ty);
                      textChunk.str.push(glyphUnicode);
                    }
                    if (!font.vertical) {
                      textChunk.lastAdvanceWidth = width;
                      textChunk.width += width;
                    } else {
                      textChunk.lastAdvanceHeight = height;
                      textChunk.height += Math.abs(height);
                    }
                    return textChunk;
                  }
                  function addFakeSpaces(width, strBuf) {
                    if (width < textContentItem.fakeSpaceMin) {
                      return;
                    }
                    if (width < textContentItem.fakeMultiSpaceMin) {
                      strBuf.push(" ");
                      return;
                    }
                    var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
                    while (fakeSpaces-- > 0) {
                      strBuf.push(" ");
                    }
                  }
                  function flushTextContentItem() {
                    if (!textContentItem.initialized) {
                      return;
                    }
                    if (!textContentItem.vertical) {
                      textContentItem.width *= textContentItem.textAdvanceScale;
                    } else {
                      textContentItem.height *= textContentItem.textAdvanceScale;
                    }
                    textContent.items.push(runBidiTransform(textContentItem));
                    textContentItem.initialized = false;
                    textContentItem.str.length = 0;
                  }
                  function enqueueChunk() {
                    const length = textContent.items.length;
                    if (length > 0) {
                      sink.enqueue(textContent, length);
                      textContent.items = [];
                      textContent.styles = /* @__PURE__ */ Object.create(null);
                    }
                  }
                  var timeSlotManager = new TimeSlotManager();
                  return new Promise(function promiseBody(resolve, reject) {
                    const next = function(promise) {
                      enqueueChunk();
                      Promise.all([promise, sink.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    var stop, operation = {}, args = [];
                    while (!(stop = timeSlotManager.check())) {
                      args.length = 0;
                      operation.args = args;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      textState = stateManager.state;
                      var fn = operation.fn;
                      args = operation.args;
                      var advance, diff;
                      switch (fn | 0) {
                        case _util2.OPS.setFont:
                          var fontNameArg = args[0].name, fontSizeArg = args[1];
                          if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                            break;
                          }
                          flushTextContentItem();
                          textState.fontName = fontNameArg;
                          textState.fontSize = fontSizeArg;
                          next(handleSetFont(fontNameArg, null));
                          return;
                        case _util2.OPS.setTextRise:
                          flushTextContentItem();
                          textState.textRise = args[0];
                          break;
                        case _util2.OPS.setHScale:
                          flushTextContentItem();
                          textState.textHScale = args[0] / 100;
                          break;
                        case _util2.OPS.setLeading:
                          flushTextContentItem();
                          textState.leading = args[0];
                          break;
                        case _util2.OPS.moveText:
                          var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
                          advance = args[0] - args[1];
                          if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                            textState.translateTextLineMatrix(args[0], args[1]);
                            textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
                            textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
                            diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
                            addFakeSpaces(diff, textContentItem.str);
                            break;
                          }
                          flushTextContentItem();
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util2.OPS.setLeadingMoveText:
                          flushTextContentItem();
                          textState.leading = -args[1];
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util2.OPS.nextLine:
                          flushTextContentItem();
                          textState.carriageReturn();
                          break;
                        case _util2.OPS.setTextMatrix:
                          advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);
                          if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
                            textState.translateTextLineMatrix(advance.width, advance.height);
                            textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
                            textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
                            diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
                            addFakeSpaces(diff, textContentItem.str);
                            break;
                          }
                          flushTextContentItem();
                          textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.setCharSpacing:
                          textState.charSpacing = args[0];
                          break;
                        case _util2.OPS.setWordSpacing:
                          textState.wordSpacing = args[0];
                          break;
                        case _util2.OPS.beginText:
                          flushTextContentItem();
                          textState.textMatrix = _util2.IDENTITY_MATRIX.slice();
                          textState.textLineMatrix = _util2.IDENTITY_MATRIX.slice();
                          break;
                        case _util2.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          var items = args[0];
                          var offset;
                          for (var j2 = 0, jj = items.length; j2 < jj; j2++) {
                            if (typeof items[j2] === "string") {
                              buildTextContentItem(items[j2]);
                            } else if ((0, _util2.isNum)(items[j2])) {
                              ensureTextContentItem();
                              advance = items[j2] * textState.fontSize / 1e3;
                              var breakTextRun = false;
                              if (textState.font.vertical) {
                                offset = advance;
                                textState.translateTextMatrix(0, offset);
                                breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                if (!breakTextRun) {
                                  textContentItem.height += offset;
                                }
                              } else {
                                advance = -advance;
                                offset = advance * textState.textHScale;
                                textState.translateTextMatrix(offset, 0);
                                breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                if (!breakTextRun) {
                                  textContentItem.width += offset;
                                }
                              }
                              if (breakTextRun) {
                                flushTextContentItem();
                              } else if (advance > 0) {
                                addFakeSpaces(advance, textContentItem.str);
                              }
                            }
                          }
                          break;
                        case _util2.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          buildTextContentItem(args[0]);
                          break;
                        case _util2.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          flushTextContentItem();
                          textState.carriageReturn();
                          buildTextContentItem(args[0]);
                          break;
                        case _util2.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          flushTextContentItem();
                          textState.wordSpacing = args[0];
                          textState.charSpacing = args[1];
                          textState.carriageReturn();
                          buildTextContentItem(args[2]);
                          break;
                        case _util2.OPS.paintXObject:
                          flushTextContentItem();
                          if (!xobjs) {
                            xobjs = resources.get("XObject") || _primitives.Dict.empty;
                          }
                          var name = args[0].name;
                          if (name && skipEmptyXObjs[name] !== void 0) {
                            break;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!name) {
                              throw new _util2.FormatError("XObject must be referred to by name.");
                            }
                            const xobj = xobjs.get(name);
                            if (!xobj) {
                              resolveXObject();
                              return;
                            }
                            if (!(0, _primitives.isStream)(xobj)) {
                              throw new _util2.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(0, _primitives.isName)(type)) {
                              throw new _util2.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name !== "Form") {
                              skipEmptyXObjs[name] = true;
                              resolveXObject();
                              return;
                            }
                            const currentState = stateManager.state.clone();
                            const xObjStateManager = new StateManager(currentState);
                            const matrix = xobj.dict.getArray("Matrix");
                            if (Array.isArray(matrix) && matrix.length === 6) {
                              xObjStateManager.transform(matrix);
                            }
                            enqueueChunk();
                            const sinkWrapper = {
                              enqueueInvoked: false,
                              enqueue(chunk, size) {
                                this.enqueueInvoked = true;
                                sink.enqueue(chunk, size);
                              },
                              get desiredSize() {
                                return sink.desiredSize;
                              },
                              get ready() {
                                return sink.ready;
                              }
                            };
                            self2.getTextContent({
                              stream: xobj,
                              task,
                              resources: xobj.dict.get("Resources") || resources,
                              stateManager: xObjStateManager,
                              normalizeWhitespace,
                              combineTextItems,
                              sink: sinkWrapper,
                              seenStyles
                            }).then(function() {
                              if (!sinkWrapper.enqueueInvoked) {
                                skipEmptyXObjs[name] = true;
                              }
                              resolveXObject();
                            }, rejectXObject);
                          }).catch(function(reason) {
                            if (reason instanceof _util2.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util2.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util2.OPS.setGState:
                          flushTextContentItem();
                          var dictName = args[0];
                          var extGState = resources.get("ExtGState");
                          if (!(0, _primitives.isDict)(extGState) || !(0, _primitives.isName)(dictName)) {
                            break;
                          }
                          var gState = extGState.get(dictName.name);
                          if (!(0, _primitives.isDict)(gState)) {
                            break;
                          }
                          var gStateFont = gState.get("Font");
                          if (gStateFont) {
                            textState.fontName = null;
                            textState.fontSize = gStateFont[1];
                            next(handleSetFont(null, gStateFont[0]));
                            return;
                          }
                          break;
                      }
                      if (textContent.items.length >= sink.desiredSize) {
                        stop = true;
                        break;
                      }
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    flushTextContentItem();
                    enqueueChunk();
                    resolve();
                  }).catch((reason) => {
                    if (reason instanceof _util2.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util2.warn)(`getTextContent - ignoring errors during "${task.name}" task: "${reason}".`);
                      flushTextContentItem();
                      enqueueChunk();
                      return;
                    }
                    throw reason;
                  });
                },
                extractDataStructures: function PartialEvaluator_extractDataStructures(dict, baseDict, properties) {
                  const xref = this.xref;
                  let cidToGidBytes;
                  var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                  var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(void 0);
                  if (properties.composite) {
                    var cidSystemInfo = dict.get("CIDSystemInfo");
                    if ((0, _primitives.isDict)(cidSystemInfo)) {
                      properties.cidSystemInfo = {
                        registry: (0, _util2.stringToPDFString)(cidSystemInfo.get("Registry")),
                        ordering: (0, _util2.stringToPDFString)(cidSystemInfo.get("Ordering")),
                        supplement: cidSystemInfo.get("Supplement")
                      };
                    }
                    var cidToGidMap = dict.get("CIDToGIDMap");
                    if ((0, _primitives.isStream)(cidToGidMap)) {
                      cidToGidBytes = cidToGidMap.getBytes();
                    }
                  }
                  var differences = [];
                  var baseEncodingName = null;
                  var encoding;
                  if (dict.has("Encoding")) {
                    encoding = dict.get("Encoding");
                    if ((0, _primitives.isDict)(encoding)) {
                      baseEncodingName = encoding.get("BaseEncoding");
                      baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;
                      if (encoding.has("Differences")) {
                        var diffEncoding = encoding.get("Differences");
                        var index = 0;
                        for (var j2 = 0, jj = diffEncoding.length; j2 < jj; j2++) {
                          var data = xref.fetchIfRef(diffEncoding[j2]);
                          if ((0, _util2.isNum)(data)) {
                            index = data;
                          } else if ((0, _primitives.isName)(data)) {
                            differences[index++] = data.name;
                          } else {
                            throw new _util2.FormatError(`Invalid entry in 'Differences' array: ${data}`);
                          }
                        }
                      }
                    } else if ((0, _primitives.isName)(encoding)) {
                      baseEncodingName = encoding.name;
                    } else {
                      throw new _util2.FormatError("Encoding is not a Name nor a Dict");
                    }
                    if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
                      baseEncodingName = null;
                    }
                  }
                  if (baseEncodingName) {
                    properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName).slice();
                  } else {
                    var isSymbolicFont = !!(properties.flags & _fonts.FontFlags.Symbolic);
                    var isNonsymbolicFont = !!(properties.flags & _fonts.FontFlags.Nonsymbolic);
                    encoding = _encodings.StandardEncoding;
                    if (properties.type === "TrueType" && !isNonsymbolicFont) {
                      encoding = _encodings.WinAnsiEncoding;
                    }
                    if (isSymbolicFont) {
                      encoding = _encodings.MacRomanEncoding;
                      if (!properties.file) {
                        if (/Symbol/i.test(properties.name)) {
                          encoding = _encodings.SymbolSetEncoding;
                        } else if (/Dingbats|Wingdings/i.test(properties.name)) {
                          encoding = _encodings.ZapfDingbatsEncoding;
                        }
                      }
                    }
                    properties.defaultEncoding = encoding;
                  }
                  properties.differences = differences;
                  properties.baseEncodingName = baseEncodingName;
                  properties.hasEncoding = !!baseEncodingName || differences.length > 0;
                  properties.dict = dict;
                  return toUnicodePromise.then((toUnicode2) => {
                    properties.toUnicode = toUnicode2;
                    return this.buildToUnicode(properties);
                  }).then((toUnicode2) => {
                    properties.toUnicode = toUnicode2;
                    if (cidToGidBytes) {
                      properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, toUnicode2);
                    }
                    return properties;
                  });
                },
                _buildSimpleFontToUnicode(properties, forceGlyphs = false) {
                  (0, _util2.assert)(!properties.composite, "Must be a simple font.");
                  const toUnicode = [];
                  const encoding = properties.defaultEncoding.slice();
                  const baseEncodingName = properties.baseEncodingName;
                  const differences = properties.differences;
                  for (const charcode in differences) {
                    const glyphName = differences[charcode];
                    if (glyphName === ".notdef") {
                      continue;
                    }
                    encoding[charcode] = glyphName;
                  }
                  const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                  for (const charcode in encoding) {
                    let glyphName = encoding[charcode];
                    if (glyphName === "") {
                      continue;
                    } else if (glyphsUnicodeMap[glyphName] === void 0) {
                      let code = 0;
                      switch (glyphName[0]) {
                        case "G":
                          if (glyphName.length === 3) {
                            code = parseInt(glyphName.substring(1), 16);
                          }
                          break;
                        case "g":
                          if (glyphName.length === 5) {
                            code = parseInt(glyphName.substring(1), 16);
                          }
                          break;
                        case "C":
                        case "c":
                          if (glyphName.length >= 3 && glyphName.length <= 4) {
                            const codeStr = glyphName.substring(1);
                            if (forceGlyphs) {
                              code = parseInt(codeStr, 16);
                              break;
                            }
                            code = +codeStr;
                            if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                              return this._buildSimpleFontToUnicode(properties, true);
                            }
                          }
                          break;
                        default:
                          const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                          if (unicode !== -1) {
                            code = unicode;
                          }
                      }
                      if (code > 0 && Number.isInteger(code)) {
                        if (baseEncodingName && code === +charcode) {
                          const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                          if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                            continue;
                          }
                        }
                        toUnicode[charcode] = String.fromCodePoint(code);
                      }
                      continue;
                    }
                    toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                  }
                  return new _fonts.ToUnicodeMap(toUnicode);
                },
                buildToUnicode(properties) {
                  properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
                  if (properties.hasIncludedToUnicodeMap) {
                    if (!properties.composite && properties.hasEncoding) {
                      properties.fallbackToUnicode = this._buildSimpleFontToUnicode(properties);
                    }
                    return Promise.resolve(properties.toUnicode);
                  }
                  if (!properties.composite) {
                    return Promise.resolve(this._buildSimpleFontToUnicode(properties));
                  }
                  if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
                    const registry = properties.cidSystemInfo.registry;
                    const ordering = properties.cidSystemInfo.ordering;
                    const ucs2CMapName = _primitives.Name.get(registry + "-" + ordering + "-UCS2");
                    return _cmap.CMapFactory.create({
                      encoding: ucs2CMapName,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(ucs2CMap) {
                      const cMap = properties.cMap;
                      const toUnicode = [];
                      cMap.forEach(function(charcode, cid) {
                        if (cid > 65535) {
                          throw new _util2.FormatError("Max size of CID is 65,535");
                        }
                        const ucs2 = ucs2CMap.lookup(cid);
                        if (ucs2) {
                          toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
                        }
                      });
                      return new _fonts.ToUnicodeMap(toUnicode);
                    });
                  }
                  return Promise.resolve(new _fonts.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
                },
                readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
                  var cmapObj = toUnicode;
                  if ((0, _primitives.isName)(cmapObj)) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _fonts.IdentityToUnicodeMap(0, 65535);
                      }
                      return new _fonts.ToUnicodeMap(cmap.getMap());
                    });
                  } else if ((0, _primitives.isStream)(cmapObj)) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _fonts.IdentityToUnicodeMap(0, 65535);
                      }
                      var map = new Array(cmap.length);
                      cmap.forEach(function(charCode, token) {
                        var str = [];
                        for (var k2 = 0; k2 < token.length; k2 += 2) {
                          var w1 = token.charCodeAt(k2) << 8 | token.charCodeAt(k2 + 1);
                          if ((w1 & 63488) !== 55296) {
                            str.push(w1);
                            continue;
                          }
                          k2 += 2;
                          var w2 = token.charCodeAt(k2) << 8 | token.charCodeAt(k2 + 1);
                          str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
                        }
                        map[charCode] = String.fromCodePoint.apply(String, str);
                      });
                      return new _fonts.ToUnicodeMap(map);
                    }, (reason) => {
                      if (reason instanceof _util2.AbortException) {
                        return null;
                      }
                      if (this.options.ignoreErrors) {
                        this.handler.send("UnsupportedFeature", {
                          featureId: _util2.UNSUPPORTED_FEATURES.font
                        });
                        (0, _util2.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
                        return null;
                      }
                      throw reason;
                    });
                  }
                  return Promise.resolve(null);
                },
                readCidToGidMap(glyphsData, toUnicode) {
                  var result = [];
                  for (var j2 = 0, jj = glyphsData.length; j2 < jj; j2++) {
                    var glyphID = glyphsData[j2++] << 8 | glyphsData[j2];
                    const code = j2 >> 1;
                    if (glyphID === 0 && !toUnicode.has(code)) {
                      continue;
                    }
                    result[code] = glyphID;
                  }
                  return result;
                },
                extractWidths: function PartialEvaluator_extractWidths(dict, descriptor, properties) {
                  var xref = this.xref;
                  var glyphsWidths = [];
                  var defaultWidth = 0;
                  var glyphsVMetrics = [];
                  var defaultVMetrics;
                  var i2, ii, j2, jj, start, code, widths;
                  if (properties.composite) {
                    defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
                    widths = dict.get("W");
                    if (widths) {
                      for (i2 = 0, ii = widths.length; i2 < ii; i2++) {
                        start = xref.fetchIfRef(widths[i2++]);
                        code = xref.fetchIfRef(widths[i2]);
                        if (Array.isArray(code)) {
                          for (j2 = 0, jj = code.length; j2 < jj; j2++) {
                            glyphsWidths[start++] = xref.fetchIfRef(code[j2]);
                          }
                        } else {
                          var width = xref.fetchIfRef(widths[++i2]);
                          for (j2 = start; j2 <= code; j2++) {
                            glyphsWidths[j2] = width;
                          }
                        }
                      }
                    }
                    if (properties.vertical) {
                      var vmetrics = dict.getArray("DW2") || [880, -1e3];
                      defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                      vmetrics = dict.get("W2");
                      if (vmetrics) {
                        for (i2 = 0, ii = vmetrics.length; i2 < ii; i2++) {
                          start = xref.fetchIfRef(vmetrics[i2++]);
                          code = xref.fetchIfRef(vmetrics[i2]);
                          if (Array.isArray(code)) {
                            for (j2 = 0, jj = code.length; j2 < jj; j2++) {
                              glyphsVMetrics[start++] = [xref.fetchIfRef(code[j2++]), xref.fetchIfRef(code[j2++]), xref.fetchIfRef(code[j2])];
                            }
                          } else {
                            var vmetric = [xref.fetchIfRef(vmetrics[++i2]), xref.fetchIfRef(vmetrics[++i2]), xref.fetchIfRef(vmetrics[++i2])];
                            for (j2 = start; j2 <= code; j2++) {
                              glyphsVMetrics[j2] = vmetric;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    var firstChar = properties.firstChar;
                    widths = dict.get("Widths");
                    if (widths) {
                      j2 = firstChar;
                      for (i2 = 0, ii = widths.length; i2 < ii; i2++) {
                        glyphsWidths[j2++] = xref.fetchIfRef(widths[i2]);
                      }
                      defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
                    } else {
                      var baseFontName = dict.get("BaseFont");
                      if ((0, _primitives.isName)(baseFontName)) {
                        var metrics = this.getBaseFontMetrics(baseFontName.name);
                        glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                        defaultWidth = metrics.defaultWidth;
                      }
                    }
                  }
                  var isMonospace = true;
                  var firstWidth = defaultWidth;
                  for (var glyph in glyphsWidths) {
                    var glyphWidth = glyphsWidths[glyph];
                    if (!glyphWidth) {
                      continue;
                    }
                    if (!firstWidth) {
                      firstWidth = glyphWidth;
                      continue;
                    }
                    if (firstWidth !== glyphWidth) {
                      isMonospace = false;
                      break;
                    }
                  }
                  if (isMonospace) {
                    properties.flags |= _fonts.FontFlags.FixedPitch;
                  }
                  properties.defaultWidth = defaultWidth;
                  properties.widths = glyphsWidths;
                  properties.defaultVMetrics = defaultVMetrics;
                  properties.vmetrics = glyphsVMetrics;
                },
                isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
                  var fontNameWoStyle = baseFontName.split("-")[0];
                  return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
                },
                getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
                  var defaultWidth = 0;
                  var widths = [];
                  var monospace = false;
                  var stdFontMap = (0, _standard_fonts.getStdFontMap)();
                  var lookupName = stdFontMap[name] || name;
                  var Metrics = (0, _metrics.getMetrics)();
                  if (!(lookupName in Metrics)) {
                    if (this.isSerifFont(name)) {
                      lookupName = "Times-Roman";
                    } else {
                      lookupName = "Helvetica";
                    }
                  }
                  var glyphWidths = Metrics[lookupName];
                  if ((0, _util2.isNum)(glyphWidths)) {
                    defaultWidth = glyphWidths;
                    monospace = true;
                  } else {
                    widths = glyphWidths();
                  }
                  return {
                    defaultWidth,
                    monospace,
                    widths
                  };
                },
                buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
                  var widths = /* @__PURE__ */ Object.create(null);
                  var differences = properties.differences;
                  var encoding = properties.defaultEncoding;
                  for (var charCode = 0; charCode < 256; charCode++) {
                    if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                      widths[charCode] = widthsByGlyphName[differences[charCode]];
                      continue;
                    }
                    if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                      widths[charCode] = widthsByGlyphName[encoding[charCode]];
                      continue;
                    }
                  }
                  return widths;
                },
                preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict) {
                  var baseDict = dict;
                  var type = dict.get("Subtype");
                  if (!(0, _primitives.isName)(type)) {
                    throw new _util2.FormatError("invalid font Subtype");
                  }
                  var composite = false;
                  var uint8array;
                  if (type.name === "Type0") {
                    var df = dict.get("DescendantFonts");
                    if (!df) {
                      throw new _util2.FormatError("Descendant fonts are not specified");
                    }
                    dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
                    type = dict.get("Subtype");
                    if (!(0, _primitives.isName)(type)) {
                      throw new _util2.FormatError("invalid font Subtype");
                    }
                    composite = true;
                  }
                  var descriptor = dict.get("FontDescriptor");
                  if (descriptor) {
                    var hash = new _murmurhash.MurmurHash3_64();
                    var encoding = baseDict.getRaw("Encoding");
                    if ((0, _primitives.isName)(encoding)) {
                      hash.update(encoding.name);
                    } else if ((0, _primitives.isRef)(encoding)) {
                      hash.update(encoding.toString());
                    } else if ((0, _primitives.isDict)(encoding)) {
                      var keys = encoding.getKeys();
                      for (var i2 = 0, ii = keys.length; i2 < ii; i2++) {
                        var entry = encoding.getRaw(keys[i2]);
                        if ((0, _primitives.isName)(entry)) {
                          hash.update(entry.name);
                        } else if ((0, _primitives.isRef)(entry)) {
                          hash.update(entry.toString());
                        } else if (Array.isArray(entry)) {
                          var diffLength = entry.length, diffBuf = new Array(diffLength);
                          for (var j2 = 0; j2 < diffLength; j2++) {
                            var diffEntry = entry[j2];
                            if ((0, _primitives.isName)(diffEntry)) {
                              diffBuf[j2] = diffEntry.name;
                            } else if ((0, _util2.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
                              diffBuf[j2] = diffEntry.toString();
                            }
                          }
                          hash.update(diffBuf.join());
                        }
                      }
                    }
                    const firstChar = dict.get("FirstChar") || 0;
                    const lastChar = dict.get("LastChar") || (composite ? 65535 : 255);
                    hash.update(`${firstChar}-${lastChar}`);
                    var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                    if ((0, _primitives.isStream)(toUnicode)) {
                      var stream = toUnicode.str || toUnicode;
                      uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
                      hash.update(uint8array);
                    } else if ((0, _primitives.isName)(toUnicode)) {
                      hash.update(toUnicode.name);
                    }
                    var widths = dict.get("Widths") || baseDict.get("Widths");
                    if (widths) {
                      uint8array = new Uint8Array(new Uint32Array(widths).buffer);
                      hash.update(uint8array);
                    }
                  }
                  return {
                    descriptor,
                    dict,
                    baseDict,
                    composite,
                    type: type.name,
                    hash: hash ? hash.hexdigest() : ""
                  };
                },
                translateFont: function PartialEvaluator_translateFont(preEvaluatedFont) {
                  var baseDict = preEvaluatedFont.baseDict;
                  var dict = preEvaluatedFont.dict;
                  var composite = preEvaluatedFont.composite;
                  var descriptor = preEvaluatedFont.descriptor;
                  var type = preEvaluatedFont.type;
                  var maxCharIndex = composite ? 65535 : 255;
                  var properties;
                  const firstChar = dict.get("FirstChar") || 0;
                  const lastChar = dict.get("LastChar") || maxCharIndex;
                  if (!descriptor) {
                    if (type === "Type3") {
                      descriptor = new _primitives.Dict(null);
                      descriptor.set("FontName", _primitives.Name.get(type));
                      descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
                    } else {
                      var baseFontName = dict.get("BaseFont");
                      if (!(0, _primitives.isName)(baseFontName)) {
                        throw new _util2.FormatError("Base font is not specified");
                      }
                      baseFontName = baseFontName.name.replace(/[,_]/g, "-");
                      var metrics = this.getBaseFontMetrics(baseFontName);
                      var fontNameWoStyle = baseFontName.split("-")[0];
                      var flags = (this.isSerifFont(fontNameWoStyle) ? _fonts.FontFlags.Serif : 0) | (metrics.monospace ? _fonts.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts.FontFlags.Symbolic : _fonts.FontFlags.Nonsymbolic);
                      properties = {
                        type,
                        name: baseFontName,
                        widths: metrics.widths,
                        defaultWidth: metrics.defaultWidth,
                        flags,
                        firstChar,
                        lastChar
                      };
                      const widths = dict.get("Widths");
                      return this.extractDataStructures(dict, dict, properties).then((properties2) => {
                        if (widths) {
                          const glyphWidths = [];
                          let j2 = firstChar;
                          for (let i2 = 0, ii = widths.length; i2 < ii; i2++) {
                            glyphWidths[j2++] = this.xref.fetchIfRef(widths[i2]);
                          }
                          properties2.widths = glyphWidths;
                        } else {
                          properties2.widths = this.buildCharCodeToWidth(metrics.widths, properties2);
                        }
                        return new _fonts.Font(baseFontName, null, properties2);
                      });
                    }
                  }
                  var fontName = descriptor.get("FontName");
                  var baseFont = dict.get("BaseFont");
                  if ((0, _util2.isString)(fontName)) {
                    fontName = _primitives.Name.get(fontName);
                  }
                  if ((0, _util2.isString)(baseFont)) {
                    baseFont = _primitives.Name.get(baseFont);
                  }
                  if (type !== "Type3") {
                    var fontNameStr = fontName && fontName.name;
                    var baseFontStr = baseFont && baseFont.name;
                    if (fontNameStr !== baseFontStr) {
                      (0, _util2.info)(`The FontDescriptor's FontName is "${fontNameStr}" but should be the same as the Font's BaseFont "${baseFontStr}".`);
                      if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
                        fontName = baseFont;
                      }
                    }
                  }
                  fontName = fontName || baseFont;
                  if (!(0, _primitives.isName)(fontName)) {
                    throw new _util2.FormatError("invalid font name");
                  }
                  var fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                  if (fontFile) {
                    if (fontFile.dict) {
                      var subtype = fontFile.dict.get("Subtype");
                      if (subtype) {
                        subtype = subtype.name;
                      }
                      var length1 = fontFile.dict.get("Length1");
                      var length2 = fontFile.dict.get("Length2");
                      var length3 = fontFile.dict.get("Length3");
                    }
                  }
                  properties = {
                    type,
                    name: fontName.name,
                    subtype,
                    file: fontFile,
                    length1,
                    length2,
                    length3,
                    loadedName: baseDict.loadedName,
                    composite,
                    wideChars: composite,
                    fixedPitch: false,
                    fontMatrix: dict.getArray("FontMatrix") || _util2.FONT_IDENTITY_MATRIX,
                    firstChar: firstChar || 0,
                    lastChar: lastChar || maxCharIndex,
                    bbox: descriptor.getArray("FontBBox"),
                    ascent: descriptor.get("Ascent"),
                    descent: descriptor.get("Descent"),
                    xHeight: descriptor.get("XHeight"),
                    capHeight: descriptor.get("CapHeight"),
                    flags: descriptor.get("Flags"),
                    italicAngle: descriptor.get("ItalicAngle"),
                    isType3Font: false
                  };
                  var cMapPromise;
                  if (composite) {
                    var cidEncoding = baseDict.get("Encoding");
                    if ((0, _primitives.isName)(cidEncoding)) {
                      properties.cidEncoding = cidEncoding.name;
                    }
                    cMapPromise = _cmap.CMapFactory.create({
                      encoding: cidEncoding,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cMap) {
                      properties.cMap = cMap;
                      properties.vertical = properties.cMap.vertical;
                    });
                  } else {
                    cMapPromise = Promise.resolve(void 0);
                  }
                  return cMapPromise.then(() => {
                    return this.extractDataStructures(dict, baseDict, properties);
                  }).then((properties2) => {
                    this.extractWidths(dict, descriptor, properties2);
                    if (type === "Type3") {
                      properties2.isType3Font = true;
                    }
                    return new _fonts.Font(fontName.name, fontFile, properties2);
                  });
                }
              };
              PartialEvaluator2.buildFontPaths = function(font, glyphs, handler) {
                function buildPath(fontChar) {
                  if (font.renderer.hasBuiltPath(fontChar)) {
                    return;
                  }
                  handler.send("commonobj", [`${font.loadedName}_path_${fontChar}`, "FontPath", font.renderer.getPathJs(fontChar)]);
                }
                for (const glyph of glyphs) {
                  buildPath(glyph.fontChar);
                  const accent = glyph.accent;
                  if (accent && accent.fontChar) {
                    buildPath(accent.fontChar);
                  }
                }
              };
              PartialEvaluator2.getFallbackFontDict = function() {
                if (this._fallbackFontDict) {
                  return this._fallbackFontDict;
                }
                const dict = new _primitives.Dict();
                dict.set("BaseFont", _primitives.Name.get("PDFJS-FallbackFont"));
                dict.set("Type", _primitives.Name.get("FallbackType"));
                dict.set("Subtype", _primitives.Name.get("FallbackType"));
                dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                return this._fallbackFontDict = dict;
              };
              return PartialEvaluator2;
            }();
            exports3.PartialEvaluator = PartialEvaluator;
            var TranslatedFont = function TranslatedFontClosure() {
              function TranslatedFont2(loadedName, font, dict) {
                this.loadedName = loadedName;
                this.font = font;
                this.dict = dict;
                this.type3Loaded = null;
                this.sent = false;
              }
              TranslatedFont2.prototype = {
                send(handler) {
                  if (this.sent) {
                    return;
                  }
                  this.sent = true;
                  handler.send("commonobj", [this.loadedName, "Font", this.font.exportData()]);
                },
                fallback(handler) {
                  if (!this.font.data) {
                    return;
                  }
                  this.font.disableFontFace = true;
                  const glyphs = this.font.glyphCacheValues;
                  PartialEvaluator.buildFontPaths(this.font, glyphs, handler);
                },
                loadType3Data(evaluator, resources, parentOperatorList, task) {
                  if (!this.font.isType3Font) {
                    throw new Error("Must be a Type3 font.");
                  }
                  if (this.type3Loaded) {
                    return this.type3Loaded;
                  }
                  var type3Options = Object.create(evaluator.options);
                  type3Options.ignoreErrors = false;
                  type3Options.nativeImageDecoderSupport = _util2.NativeImageDecoding.NONE;
                  var type3Evaluator = evaluator.clone(type3Options);
                  type3Evaluator.parsingType3Font = true;
                  var translatedFont = this.font;
                  var loadCharProcsPromise = Promise.resolve();
                  var charProcs = this.dict.get("CharProcs");
                  var fontResources = this.dict.get("Resources") || resources;
                  var charProcKeys = charProcs.getKeys();
                  var charProcOperatorList = /* @__PURE__ */ Object.create(null);
                  for (var i2 = 0, n2 = charProcKeys.length; i2 < n2; ++i2) {
                    const key = charProcKeys[i2];
                    loadCharProcsPromise = loadCharProcsPromise.then(function() {
                      var glyphStream = charProcs.get(key);
                      var operatorList = new _operator_list.OperatorList();
                      return type3Evaluator.getOperatorList({
                        stream: glyphStream,
                        task,
                        resources: fontResources,
                        operatorList
                      }).then(function() {
                        charProcOperatorList[key] = operatorList.getIR();
                        parentOperatorList.addDependencies(operatorList.dependencies);
                      }).catch(function(reason) {
                        (0, _util2.warn)(`Type3 font resource "${key}" is not available.`);
                        var operatorList2 = new _operator_list.OperatorList();
                        charProcOperatorList[key] = operatorList2.getIR();
                      });
                    });
                  }
                  this.type3Loaded = loadCharProcsPromise.then(function() {
                    translatedFont.charProcOperatorList = charProcOperatorList;
                  });
                  return this.type3Loaded;
                }
              };
              return TranslatedFont2;
            }();
            var StateManager = function StateManagerClosure() {
              function StateManager2(initialState) {
                this.state = initialState;
                this.stateStack = [];
              }
              StateManager2.prototype = {
                save() {
                  var old = this.state;
                  this.stateStack.push(this.state);
                  this.state = old.clone();
                },
                restore() {
                  var prev = this.stateStack.pop();
                  if (prev) {
                    this.state = prev;
                  }
                },
                transform(args) {
                  this.state.ctm = _util2.Util.transform(this.state.ctm, args);
                }
              };
              return StateManager2;
            }();
            var TextState = function TextStateClosure() {
              function TextState2() {
                this.ctm = new Float32Array(_util2.IDENTITY_MATRIX);
                this.fontName = null;
                this.fontSize = 0;
                this.font = null;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.textMatrix = _util2.IDENTITY_MATRIX.slice();
                this.textLineMatrix = _util2.IDENTITY_MATRIX.slice();
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.leading = 0;
                this.textHScale = 1;
                this.textRise = 0;
              }
              TextState2.prototype = {
                setTextMatrix: function TextState_setTextMatrix(a2, b2, c2, d2, e2, f) {
                  var m = this.textMatrix;
                  m[0] = a2;
                  m[1] = b2;
                  m[2] = c2;
                  m[3] = d2;
                  m[4] = e2;
                  m[5] = f;
                },
                setTextLineMatrix: function TextState_setTextMatrix(a2, b2, c2, d2, e2, f) {
                  var m = this.textLineMatrix;
                  m[0] = a2;
                  m[1] = b2;
                  m[2] = c2;
                  m[3] = d2;
                  m[4] = e2;
                  m[5] = f;
                },
                translateTextMatrix: function TextState_translateTextMatrix(x2, y2) {
                  var m = this.textMatrix;
                  m[4] = m[0] * x2 + m[2] * y2 + m[4];
                  m[5] = m[1] * x2 + m[3] * y2 + m[5];
                },
                translateTextLineMatrix: function TextState_translateTextMatrix(x2, y2) {
                  var m = this.textLineMatrix;
                  m[4] = m[0] * x2 + m[2] * y2 + m[4];
                  m[5] = m[1] * x2 + m[3] * y2 + m[5];
                },
                calcTextLineMatrixAdvance: function TextState_calcTextLineMatrixAdvance(a2, b2, c2, d2, e2, f) {
                  var font = this.font;
                  if (!font) {
                    return null;
                  }
                  var m = this.textLineMatrix;
                  if (!(a2 === m[0] && b2 === m[1] && c2 === m[2] && d2 === m[3])) {
                    return null;
                  }
                  var txDiff = e2 - m[4], tyDiff = f - m[5];
                  if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
                    return null;
                  }
                  var tx, ty, denominator = a2 * d2 - b2 * c2;
                  if (font.vertical) {
                    tx = -tyDiff * c2 / denominator;
                    ty = tyDiff * a2 / denominator;
                  } else {
                    tx = txDiff * d2 / denominator;
                    ty = -txDiff * b2 / denominator;
                  }
                  return {
                    width: tx,
                    height: ty,
                    value: font.vertical ? ty : tx
                  };
                },
                calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
                  var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
                  return _util2.Util.transform(ctm, _util2.Util.transform(this.textMatrix, tsm));
                },
                carriageReturn: function TextState_carriageReturn() {
                  this.translateTextLineMatrix(0, -this.leading);
                  this.textMatrix = this.textLineMatrix.slice();
                },
                clone: function TextState_clone() {
                  var clone = Object.create(this);
                  clone.textMatrix = this.textMatrix.slice();
                  clone.textLineMatrix = this.textLineMatrix.slice();
                  clone.fontMatrix = this.fontMatrix.slice();
                  return clone;
                }
              };
              return TextState2;
            }();
            var EvalState = function EvalStateClosure() {
              function EvalState2() {
                this.ctm = new Float32Array(_util2.IDENTITY_MATRIX);
                this.font = null;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
              }
              EvalState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                }
              };
              return EvalState2;
            }();
            var EvaluatorPreprocessor = function EvaluatorPreprocessorClosure() {
              var getOPMap = (0, _core_utils.getLookupTableFactory)(function(t2) {
                t2["w"] = {
                  id: _util2.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["J"] = {
                  id: _util2.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["j"] = {
                  id: _util2.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["M"] = {
                  id: _util2.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["d"] = {
                  id: _util2.OPS.setDash,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["ri"] = {
                  id: _util2.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["i"] = {
                  id: _util2.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["gs"] = {
                  id: _util2.OPS.setGState,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["q"] = {
                  id: _util2.OPS.save,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["Q"] = {
                  id: _util2.OPS.restore,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["cm"] = {
                  id: _util2.OPS.transform,
                  numArgs: 6,
                  variableArgs: false
                };
                t2["m"] = {
                  id: _util2.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["l"] = {
                  id: _util2.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["c"] = {
                  id: _util2.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: false
                };
                t2["v"] = {
                  id: _util2.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: false
                };
                t2["y"] = {
                  id: _util2.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: false
                };
                t2["h"] = {
                  id: _util2.OPS.closePath,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["re"] = {
                  id: _util2.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: false
                };
                t2["S"] = {
                  id: _util2.OPS.stroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["s"] = {
                  id: _util2.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["f"] = {
                  id: _util2.OPS.fill,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["F"] = {
                  id: _util2.OPS.fill,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["f*"] = {
                  id: _util2.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["B"] = {
                  id: _util2.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["B*"] = {
                  id: _util2.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["b"] = {
                  id: _util2.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["b*"] = {
                  id: _util2.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["n"] = {
                  id: _util2.OPS.endPath,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["W"] = {
                  id: _util2.OPS.clip,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["W*"] = {
                  id: _util2.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["BT"] = {
                  id: _util2.OPS.beginText,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["ET"] = {
                  id: _util2.OPS.endText,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["Tc"] = {
                  id: _util2.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Tw"] = {
                  id: _util2.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Tz"] = {
                  id: _util2.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["TL"] = {
                  id: _util2.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Tf"] = {
                  id: _util2.OPS.setFont,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["Tr"] = {
                  id: _util2.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Ts"] = {
                  id: _util2.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Td"] = {
                  id: _util2.OPS.moveText,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["TD"] = {
                  id: _util2.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["Tm"] = {
                  id: _util2.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: false
                };
                t2["T*"] = {
                  id: _util2.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["Tj"] = {
                  id: _util2.OPS.showText,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["TJ"] = {
                  id: _util2.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["'"] = {
                  id: _util2.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: false
                };
                t2['"'] = {
                  id: _util2.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: false
                };
                t2["d0"] = {
                  id: _util2.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["d1"] = {
                  id: _util2.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: false
                };
                t2["CS"] = {
                  id: _util2.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["cs"] = {
                  id: _util2.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["SC"] = {
                  id: _util2.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: true
                };
                t2["SCN"] = {
                  id: _util2.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: true
                };
                t2["sc"] = {
                  id: _util2.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: true
                };
                t2["scn"] = {
                  id: _util2.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: true
                };
                t2["G"] = {
                  id: _util2.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["g"] = {
                  id: _util2.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["RG"] = {
                  id: _util2.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: false
                };
                t2["rg"] = {
                  id: _util2.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: false
                };
                t2["K"] = {
                  id: _util2.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: false
                };
                t2["k"] = {
                  id: _util2.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: false
                };
                t2["sh"] = {
                  id: _util2.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["BI"] = {
                  id: _util2.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["ID"] = {
                  id: _util2.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["EI"] = {
                  id: _util2.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["Do"] = {
                  id: _util2.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["MP"] = {
                  id: _util2.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["DP"] = {
                  id: _util2.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["BMC"] = {
                  id: _util2.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: false
                };
                t2["BDC"] = {
                  id: _util2.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: false
                };
                t2["EMC"] = {
                  id: _util2.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["BX"] = {
                  id: _util2.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["EX"] = {
                  id: _util2.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: false
                };
                t2["BM"] = null;
                t2["BD"] = null;
                t2["true"] = null;
                t2["fa"] = null;
                t2["fal"] = null;
                t2["fals"] = null;
                t2["false"] = null;
                t2["nu"] = null;
                t2["nul"] = null;
                t2["null"] = null;
              });
              const MAX_INVALID_PATH_OPS = 20;
              function EvaluatorPreprocessor2(stream, xref, stateManager) {
                this.opMap = getOPMap();
                this.parser = new _parser.Parser({
                  lexer: new _parser.Lexer(stream, this.opMap),
                  xref
                });
                this.stateManager = stateManager;
                this.nonProcessedArgs = [];
                this._numInvalidPathOPS = 0;
              }
              EvaluatorPreprocessor2.prototype = {
                get savedStatesDepth() {
                  return this.stateManager.stateStack.length;
                },
                read: function EvaluatorPreprocessor_read(operation) {
                  var args = operation.args;
                  while (true) {
                    var obj = this.parser.getObj();
                    if (obj instanceof _primitives.Cmd) {
                      var cmd = obj.cmd;
                      var opSpec = this.opMap[cmd];
                      if (!opSpec) {
                        (0, _util2.warn)(`Unknown command "${cmd}".`);
                        continue;
                      }
                      var fn = opSpec.id;
                      var numArgs = opSpec.numArgs;
                      var argsLength = args !== null ? args.length : 0;
                      if (!opSpec.variableArgs) {
                        if (argsLength !== numArgs) {
                          var nonProcessedArgs = this.nonProcessedArgs;
                          while (argsLength > numArgs) {
                            nonProcessedArgs.push(args.shift());
                            argsLength--;
                          }
                          while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                            if (args === null) {
                              args = [];
                            }
                            args.unshift(nonProcessedArgs.pop());
                            argsLength++;
                          }
                        }
                        if (argsLength < numArgs) {
                          const partialMsg = `command ${cmd}: expected ${numArgs} args, but received ${argsLength} args.`;
                          if (fn >= _util2.OPS.moveTo && fn <= _util2.OPS.endPath && ++this._numInvalidPathOPS > MAX_INVALID_PATH_OPS) {
                            throw new _util2.FormatError(`Invalid ${partialMsg}`);
                          }
                          (0, _util2.warn)(`Skipping ${partialMsg}`);
                          if (args !== null) {
                            args.length = 0;
                          }
                          continue;
                        }
                      } else if (argsLength > numArgs) {
                        (0, _util2.info)(`Command ${cmd}: expected [0, ${numArgs}] args, but received ${argsLength} args.`);
                      }
                      this.preprocessCommand(fn, args);
                      operation.fn = fn;
                      operation.args = args;
                      return true;
                    }
                    if (obj === _primitives.EOF) {
                      return false;
                    }
                    if (obj !== null) {
                      if (args === null) {
                        args = [];
                      }
                      args.push(obj);
                      if (args.length > 33) {
                        throw new _util2.FormatError("Too many arguments");
                      }
                    }
                  }
                },
                preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
                  switch (fn | 0) {
                    case _util2.OPS.save:
                      this.stateManager.save();
                      break;
                    case _util2.OPS.restore:
                      this.stateManager.restore();
                      break;
                    case _util2.OPS.transform:
                      this.stateManager.transform(args);
                      break;
                  }
                }
              };
              return EvaluatorPreprocessor2;
            }();
          },
          /* 26 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CMapFactory = exports3.IdentityCMap = exports3.CMap = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _parser = __w_pdfjs_require__2(10);
            var _core_utils = __w_pdfjs_require__2(7);
            var _stream = __w_pdfjs_require__2(11);
            var BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
            class CMap {
              constructor(builtInCMap = false) {
                this.codespaceRanges = [[], [], [], []];
                this.numCodespaceRanges = 0;
                this._map = [];
                this.name = "";
                this.vertical = false;
                this.useCMap = null;
                this.builtInCMap = builtInCMap;
              }
              addCodespaceRange(n2, low, high) {
                this.codespaceRanges[n2 - 1].push(low, high);
                this.numCodespaceRanges++;
              }
              mapCidRange(low, high, dstLow) {
                while (low <= high) {
                  this._map[low++] = dstLow++;
                }
              }
              mapBfRange(low, high, dstLow) {
                var lastByte = dstLow.length - 1;
                while (low <= high) {
                  this._map[low++] = dstLow;
                  dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
                }
              }
              mapBfRangeToArray(low, high, array) {
                const ii = array.length;
                let i2 = 0;
                while (low <= high && i2 < ii) {
                  this._map[low] = array[i2++];
                  ++low;
                }
              }
              mapOne(src, dst) {
                this._map[src] = dst;
              }
              lookup(code) {
                return this._map[code];
              }
              contains(code) {
                return this._map[code] !== void 0;
              }
              forEach(callback) {
                const map = this._map;
                const length = map.length;
                if (length <= 65536) {
                  for (let i2 = 0; i2 < length; i2++) {
                    if (map[i2] !== void 0) {
                      callback(i2, map[i2]);
                    }
                  }
                } else {
                  for (const i2 in map) {
                    callback(i2, map[i2]);
                  }
                }
              }
              charCodeOf(value) {
                const map = this._map;
                if (map.length <= 65536) {
                  return map.indexOf(value);
                }
                for (const charCode in map) {
                  if (map[charCode] === value) {
                    return charCode | 0;
                  }
                }
                return -1;
              }
              getMap() {
                return this._map;
              }
              readCharCode(str, offset, out) {
                let c2 = 0;
                const codespaceRanges = this.codespaceRanges;
                for (let n2 = 0, nn = codespaceRanges.length; n2 < nn; n2++) {
                  c2 = (c2 << 8 | str.charCodeAt(offset + n2)) >>> 0;
                  const codespaceRange = codespaceRanges[n2];
                  for (let k2 = 0, kk = codespaceRange.length; k2 < kk; ) {
                    const low = codespaceRange[k2++];
                    const high = codespaceRange[k2++];
                    if (c2 >= low && c2 <= high) {
                      out.charcode = c2;
                      out.length = n2 + 1;
                      return;
                    }
                  }
                }
                out.charcode = 0;
                out.length = 1;
              }
              get length() {
                return this._map.length;
              }
              get isIdentityCMap() {
                if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
                  return false;
                }
                if (this._map.length !== 65536) {
                  return false;
                }
                for (let i2 = 0; i2 < 65536; i2++) {
                  if (this._map[i2] !== i2) {
                    return false;
                  }
                }
                return true;
              }
            }
            exports3.CMap = CMap;
            class IdentityCMap extends CMap {
              constructor(vertical, n2) {
                super();
                this.vertical = vertical;
                this.addCodespaceRange(n2, 0, 65535);
              }
              mapCidRange(low, high, dstLow) {
                (0, _util2.unreachable)("should not call mapCidRange");
              }
              mapBfRange(low, high, dstLow) {
                (0, _util2.unreachable)("should not call mapBfRange");
              }
              mapBfRangeToArray(low, high, array) {
                (0, _util2.unreachable)("should not call mapBfRangeToArray");
              }
              mapOne(src, dst) {
                (0, _util2.unreachable)("should not call mapCidOne");
              }
              lookup(code) {
                return Number.isInteger(code) && code <= 65535 ? code : void 0;
              }
              contains(code) {
                return Number.isInteger(code) && code <= 65535;
              }
              forEach(callback) {
                for (let i2 = 0; i2 <= 65535; i2++) {
                  callback(i2, i2);
                }
              }
              charCodeOf(value) {
                return Number.isInteger(value) && value <= 65535 ? value : -1;
              }
              getMap() {
                const map = new Array(65536);
                for (let i2 = 0; i2 <= 65535; i2++) {
                  map[i2] = i2;
                }
                return map;
              }
              get length() {
                return 65536;
              }
              get isIdentityCMap() {
                (0, _util2.unreachable)("should not access .isIdentityCMap");
              }
            }
            exports3.IdentityCMap = IdentityCMap;
            var BinaryCMapReader = function BinaryCMapReaderClosure() {
              function hexToInt(a2, size) {
                var n2 = 0;
                for (var i2 = 0; i2 <= size; i2++) {
                  n2 = n2 << 8 | a2[i2];
                }
                return n2 >>> 0;
              }
              function hexToStr(a2, size) {
                if (size === 1) {
                  return String.fromCharCode(a2[0], a2[1]);
                }
                if (size === 3) {
                  return String.fromCharCode(a2[0], a2[1], a2[2], a2[3]);
                }
                return String.fromCharCode.apply(null, a2.subarray(0, size + 1));
              }
              function addHex(a2, b2, size) {
                var c2 = 0;
                for (var i2 = size; i2 >= 0; i2--) {
                  c2 += a2[i2] + b2[i2];
                  a2[i2] = c2 & 255;
                  c2 >>= 8;
                }
              }
              function incHex(a2, size) {
                var c2 = 1;
                for (var i2 = size; i2 >= 0 && c2 > 0; i2--) {
                  c2 += a2[i2];
                  a2[i2] = c2 & 255;
                  c2 >>= 8;
                }
              }
              var MAX_NUM_SIZE = 16;
              var MAX_ENCODED_NUM_SIZE = 19;
              function BinaryCMapStream(data) {
                this.buffer = data;
                this.pos = 0;
                this.end = data.length;
                this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
              }
              BinaryCMapStream.prototype = {
                readByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.buffer[this.pos++];
                },
                readNumber() {
                  var n2 = 0;
                  var last;
                  do {
                    var b2 = this.readByte();
                    if (b2 < 0) {
                      throw new _util2.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b2 & 128);
                    n2 = n2 << 7 | b2 & 127;
                  } while (!last);
                  return n2;
                },
                readSigned() {
                  var n2 = this.readNumber();
                  return n2 & 1 ? ~(n2 >>> 1) : n2 >>> 1;
                },
                readHex(num, size) {
                  num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                  this.pos += size + 1;
                },
                readHexNumber(num, size) {
                  var last;
                  var stack = this.tmpBuf, sp = 0;
                  do {
                    var b2 = this.readByte();
                    if (b2 < 0) {
                      throw new _util2.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b2 & 128);
                    stack[sp++] = b2 & 127;
                  } while (!last);
                  var i2 = size, buffer = 0, bufferSize = 0;
                  while (i2 >= 0) {
                    while (bufferSize < 8 && stack.length > 0) {
                      buffer = stack[--sp] << bufferSize | buffer;
                      bufferSize += 7;
                    }
                    num[i2] = buffer & 255;
                    i2--;
                    buffer >>= 8;
                    bufferSize -= 8;
                  }
                },
                readHexSigned(num, size) {
                  this.readHexNumber(num, size);
                  var sign = num[size] & 1 ? 255 : 0;
                  var c2 = 0;
                  for (var i2 = 0; i2 <= size; i2++) {
                    c2 = (c2 & 1) << 8 | num[i2];
                    num[i2] = c2 >> 1 ^ sign;
                  }
                },
                readString() {
                  var len = this.readNumber();
                  var s2 = "";
                  for (var i2 = 0; i2 < len; i2++) {
                    s2 += String.fromCharCode(this.readNumber());
                  }
                  return s2;
                }
              };
              function processBinaryCMap(data, cMap, extend) {
                return new Promise(function(resolve, reject) {
                  var stream = new BinaryCMapStream(data);
                  var header = stream.readByte();
                  cMap.vertical = !!(header & 1);
                  var useCMap = null;
                  var start = new Uint8Array(MAX_NUM_SIZE);
                  var end = new Uint8Array(MAX_NUM_SIZE);
                  var char = new Uint8Array(MAX_NUM_SIZE);
                  var charCode = new Uint8Array(MAX_NUM_SIZE);
                  var tmp = new Uint8Array(MAX_NUM_SIZE);
                  var code;
                  var b2;
                  while ((b2 = stream.readByte()) >= 0) {
                    var type = b2 >> 5;
                    if (type === 7) {
                      switch (b2 & 31) {
                        case 0:
                          stream.readString();
                          break;
                        case 1:
                          useCMap = stream.readString();
                          break;
                      }
                      continue;
                    }
                    var sequence = !!(b2 & 16);
                    var dataSize = b2 & 15;
                    if (dataSize + 1 > MAX_NUM_SIZE) {
                      throw new Error("processBinaryCMap: Invalid dataSize.");
                    }
                    var ucs2DataSize = 1;
                    var subitemsCount = stream.readNumber();
                    var i2;
                    switch (type) {
                      case 0:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(end, dataSize);
                          stream.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        }
                        break;
                      case 1:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        stream.readNumber();
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(end, dataSize);
                          stream.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          stream.readNumber();
                        }
                        break;
                      case 2:
                        stream.readHex(char, dataSize);
                        code = stream.readNumber();
                        cMap.mapOne(hexToInt(char, dataSize), code);
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(char, dataSize);
                          if (!sequence) {
                            stream.readHexNumber(tmp, dataSize);
                            addHex(char, tmp, dataSize);
                          }
                          code = stream.readSigned() + (code + 1);
                          cMap.mapOne(hexToInt(char, dataSize), code);
                        }
                        break;
                      case 3:
                        stream.readHex(start, dataSize);
                        stream.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        code = stream.readNumber();
                        cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(end, dataSize);
                          if (!sequence) {
                            stream.readHexNumber(start, dataSize);
                            addHex(start, end, dataSize);
                          } else {
                            start.set(end);
                          }
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          code = stream.readNumber();
                          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        }
                        break;
                      case 4:
                        stream.readHex(char, ucs2DataSize);
                        stream.readHex(charCode, dataSize);
                        cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(char, ucs2DataSize);
                          if (!sequence) {
                            stream.readHexNumber(tmp, ucs2DataSize);
                            addHex(char, tmp, ucs2DataSize);
                          }
                          incHex(charCode, dataSize);
                          stream.readHexSigned(tmp, dataSize);
                          addHex(charCode, tmp, dataSize);
                          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      case 5:
                        stream.readHex(start, ucs2DataSize);
                        stream.readHexNumber(end, ucs2DataSize);
                        addHex(end, start, ucs2DataSize);
                        stream.readHex(charCode, dataSize);
                        cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (i2 = 1; i2 < subitemsCount; i2++) {
                          incHex(end, ucs2DataSize);
                          if (!sequence) {
                            stream.readHexNumber(start, ucs2DataSize);
                            addHex(start, end, ucs2DataSize);
                          } else {
                            start.set(end);
                          }
                          stream.readHexNumber(end, ucs2DataSize);
                          addHex(end, start, ucs2DataSize);
                          stream.readHex(charCode, dataSize);
                          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      default:
                        reject(new Error("processBinaryCMap: Unknown type: " + type));
                        return;
                    }
                  }
                  if (useCMap) {
                    resolve(extend(useCMap));
                    return;
                  }
                  resolve(cMap);
                });
              }
              function BinaryCMapReader2() {
              }
              BinaryCMapReader2.prototype = {
                process: processBinaryCMap
              };
              return BinaryCMapReader2;
            }();
            var CMapFactory = function CMapFactoryClosure() {
              function strToInt(str) {
                var a2 = 0;
                for (var i2 = 0; i2 < str.length; i2++) {
                  a2 = a2 << 8 | str.charCodeAt(i2);
                }
                return a2 >>> 0;
              }
              function expectString(obj) {
                if (!(0, _util2.isString)(obj)) {
                  throw new _util2.FormatError("Malformed CMap: expected string.");
                }
              }
              function expectInt(obj) {
                if (!Number.isInteger(obj)) {
                  throw new _util2.FormatError("Malformed CMap: expected int.");
                }
              }
              function parseBfChar(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfchar")) {
                    return;
                  }
                  expectString(obj);
                  var src = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseBfRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfrange")) {
                    return;
                  }
                  expectString(obj);
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var high = strToInt(obj);
                  obj = lexer.getObj();
                  if (Number.isInteger(obj) || (0, _util2.isString)(obj)) {
                    var dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
                    cMap.mapBfRange(low, high, dstLow);
                  } else if ((0, _primitives.isCmd)(obj, "[")) {
                    obj = lexer.getObj();
                    var array = [];
                    while (!(0, _primitives.isCmd)(obj, "]") && !(0, _primitives.isEOF)(obj)) {
                      array.push(obj);
                      obj = lexer.getObj();
                    }
                    cMap.mapBfRangeToArray(low, high, array);
                  } else {
                    break;
                  }
                }
                throw new _util2.FormatError("Invalid bf range.");
              }
              function parseCidChar(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidchar")) {
                    return;
                  }
                  expectString(obj);
                  var src = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  var dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseCidRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidrange")) {
                    return;
                  }
                  expectString(obj);
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var high = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  var dstLow = obj;
                  cMap.mapCidRange(low, high, dstLow);
                }
              }
              function parseCodespaceRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
                    return;
                  }
                  if (!(0, _util2.isString)(obj)) {
                    break;
                  }
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  if (!(0, _util2.isString)(obj)) {
                    break;
                  }
                  var high = strToInt(obj);
                  cMap.addCodespaceRange(obj.length, low, high);
                }
                throw new _util2.FormatError("Invalid codespace range.");
              }
              function parseWMode(cMap, lexer) {
                var obj = lexer.getObj();
                if (Number.isInteger(obj)) {
                  cMap.vertical = !!obj;
                }
              }
              function parseCMapName(cMap, lexer) {
                var obj = lexer.getObj();
                if ((0, _primitives.isName)(obj) && (0, _util2.isString)(obj.name)) {
                  cMap.name = obj.name;
                }
              }
              function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
                var previous;
                var embeddedUseCMap;
                objLoop:
                  while (true) {
                    try {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      } else if ((0, _primitives.isName)(obj)) {
                        if (obj.name === "WMode") {
                          parseWMode(cMap, lexer);
                        } else if (obj.name === "CMapName") {
                          parseCMapName(cMap, lexer);
                        }
                        previous = obj;
                      } else if ((0, _primitives.isCmd)(obj)) {
                        switch (obj.cmd) {
                          case "endcmap":
                            break objLoop;
                          case "usecmap":
                            if ((0, _primitives.isName)(previous)) {
                              embeddedUseCMap = previous.name;
                            }
                            break;
                          case "begincodespacerange":
                            parseCodespaceRange(cMap, lexer);
                            break;
                          case "beginbfchar":
                            parseBfChar(cMap, lexer);
                            break;
                          case "begincidchar":
                            parseCidChar(cMap, lexer);
                            break;
                          case "beginbfrange":
                            parseBfRange(cMap, lexer);
                            break;
                          case "begincidrange":
                            parseCidRange(cMap, lexer);
                            break;
                        }
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)("Invalid cMap data: " + ex);
                      continue;
                    }
                  }
                if (!useCMap && embeddedUseCMap) {
                  useCMap = embeddedUseCMap;
                }
                if (useCMap) {
                  return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                }
                return Promise.resolve(cMap);
              }
              function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
                return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function(newCMap) {
                  cMap.useCMap = newCMap;
                  if (cMap.numCodespaceRanges === 0) {
                    var useCodespaceRanges = cMap.useCMap.codespaceRanges;
                    for (var i2 = 0; i2 < useCodespaceRanges.length; i2++) {
                      cMap.codespaceRanges[i2] = useCodespaceRanges[i2].slice();
                    }
                    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                  }
                  cMap.useCMap.forEach(function(key, value) {
                    if (!cMap.contains(key)) {
                      cMap.mapOne(key, cMap.useCMap.lookup(key));
                    }
                  });
                  return cMap;
                });
              }
              function createBuiltInCMap(name, fetchBuiltInCMap) {
                if (name === "Identity-H") {
                  return Promise.resolve(new IdentityCMap(false, 2));
                } else if (name === "Identity-V") {
                  return Promise.resolve(new IdentityCMap(true, 2));
                }
                if (!BUILT_IN_CMAPS.includes(name)) {
                  return Promise.reject(new Error("Unknown CMap name: " + name));
                }
                if (!fetchBuiltInCMap) {
                  return Promise.reject(new Error("Built-in CMap parameters are not provided."));
                }
                return fetchBuiltInCMap(name).then(function(data) {
                  var cMapData = data.cMapData, compressionType = data.compressionType;
                  var cMap = new CMap(true);
                  if (compressionType === _util2.CMapCompressionType.BINARY) {
                    return new BinaryCMapReader().process(cMapData, cMap, function(useCMap) {
                      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                    });
                  }
                  if (compressionType === _util2.CMapCompressionType.NONE) {
                    var lexer = new _parser.Lexer(new _stream.Stream(cMapData));
                    return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
                  }
                  return Promise.reject(new Error("TODO: Only BINARY/NONE CMap compression is currently supported."));
                });
              }
              return {
                async create(params) {
                  var encoding = params.encoding;
                  var fetchBuiltInCMap = params.fetchBuiltInCMap;
                  var useCMap = params.useCMap;
                  if ((0, _primitives.isName)(encoding)) {
                    return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
                  } else if ((0, _primitives.isStream)(encoding)) {
                    var cMap = new CMap();
                    var lexer = new _parser.Lexer(encoding);
                    return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function(parsedCMap) {
                      if (parsedCMap.isIdentityCMap) {
                        return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                      }
                      return parsedCMap;
                    });
                  }
                  throw new Error("Encoding required.");
                }
              };
            }();
            exports3.CMapFactory = CMapFactory;
          },
          /* 27 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getFontType = getFontType;
            exports3.IdentityToUnicodeMap = exports3.ToUnicodeMap = exports3.FontFlags = exports3.Font = exports3.ErrorFont = exports3.SEAC_ANALYSIS_ENABLED = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _cff_parser = __w_pdfjs_require__2(28);
            var _glyphlist = __w_pdfjs_require__2(31);
            var _encodings = __w_pdfjs_require__2(30);
            var _standard_fonts = __w_pdfjs_require__2(32);
            var _unicode = __w_pdfjs_require__2(33);
            var _core_utils = __w_pdfjs_require__2(7);
            var _font_renderer = __w_pdfjs_require__2(34);
            var _cmap = __w_pdfjs_require__2(26);
            var _stream = __w_pdfjs_require__2(11);
            var _type1_parser = __w_pdfjs_require__2(35);
            const PRIVATE_USE_AREAS = [[57344, 63743], [1048576, 1114109]];
            var PDF_GLYPH_SPACE_UNITS = 1e3;
            var SEAC_ANALYSIS_ENABLED = true;
            exports3.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
            var FontFlags = {
              FixedPitch: 1,
              Serif: 2,
              Symbolic: 4,
              Script: 8,
              Nonsymbolic: 32,
              Italic: 64,
              AllCap: 65536,
              SmallCap: 131072,
              ForceBold: 262144
            };
            exports3.FontFlags = FontFlags;
            var MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
            function adjustWidths(properties) {
              if (!properties.fontMatrix) {
                return;
              }
              if (properties.fontMatrix[0] === _util2.FONT_IDENTITY_MATRIX[0]) {
                return;
              }
              var scale = 1e-3 / properties.fontMatrix[0];
              var glyphsWidths = properties.widths;
              for (var glyph in glyphsWidths) {
                glyphsWidths[glyph] *= scale;
              }
              properties.defaultWidth *= scale;
            }
            function adjustToUnicode(properties, builtInEncoding) {
              if (properties.hasIncludedToUnicodeMap) {
                return;
              }
              if (properties.hasEncoding) {
                return;
              }
              if (builtInEncoding === properties.defaultEncoding) {
                return;
              }
              if (properties.toUnicode instanceof IdentityToUnicodeMap) {
                return;
              }
              var toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
              for (var charCode in builtInEncoding) {
                var glyphName = builtInEncoding[charCode];
                var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                if (unicode !== -1) {
                  toUnicode[charCode] = String.fromCharCode(unicode);
                }
              }
              properties.toUnicode.amend(toUnicode);
            }
            function getFontType(type, subtype) {
              switch (type) {
                case "Type1":
                  return subtype === "Type1C" ? _util2.FontType.TYPE1C : _util2.FontType.TYPE1;
                case "CIDFontType0":
                  return subtype === "CIDFontType0C" ? _util2.FontType.CIDFONTTYPE0C : _util2.FontType.CIDFONTTYPE0;
                case "OpenType":
                  return _util2.FontType.OPENTYPE;
                case "TrueType":
                  return _util2.FontType.TRUETYPE;
                case "CIDFontType2":
                  return _util2.FontType.CIDFONTTYPE2;
                case "MMType1":
                  return _util2.FontType.MMTYPE1;
                case "Type0":
                  return _util2.FontType.TYPE0;
                default:
                  return _util2.FontType.UNKNOWN;
              }
            }
            function recoverGlyphName(name, glyphsUnicodeMap) {
              if (glyphsUnicodeMap[name] !== void 0) {
                return name;
              }
              var unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
              if (unicode !== -1) {
                for (var key in glyphsUnicodeMap) {
                  if (glyphsUnicodeMap[key] === unicode) {
                    return key;
                  }
                }
              }
              (0, _util2.info)("Unable to recover a standard glyph name for: " + name);
              return name;
            }
            var Glyph = function GlyphClosure() {
              function Glyph2(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                this.fontChar = fontChar;
                this.unicode = unicode;
                this.accent = accent;
                this.width = width;
                this.vmetric = vmetric;
                this.operatorListId = operatorListId;
                this.isSpace = isSpace;
                this.isInFont = isInFont;
              }
              Glyph2.prototype.matchesForCache = function(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
              };
              return Glyph2;
            }();
            var ToUnicodeMap = function ToUnicodeMapClosure() {
              function ToUnicodeMap2(cmap = []) {
                this._map = cmap;
              }
              ToUnicodeMap2.prototype = {
                get length() {
                  return this._map.length;
                },
                forEach(callback) {
                  for (var charCode in this._map) {
                    callback(charCode, this._map[charCode].charCodeAt(0));
                  }
                },
                has(i2) {
                  return this._map[i2] !== void 0;
                },
                get(i2) {
                  return this._map[i2];
                },
                charCodeOf(value) {
                  const map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (const charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                },
                amend(map) {
                  for (var charCode in map) {
                    this._map[charCode] = map[charCode];
                  }
                }
              };
              return ToUnicodeMap2;
            }();
            exports3.ToUnicodeMap = ToUnicodeMap;
            var IdentityToUnicodeMap = function IdentityToUnicodeMapClosure() {
              function IdentityToUnicodeMap2(firstChar, lastChar) {
                this.firstChar = firstChar;
                this.lastChar = lastChar;
              }
              IdentityToUnicodeMap2.prototype = {
                get length() {
                  return this.lastChar + 1 - this.firstChar;
                },
                forEach(callback) {
                  for (var i2 = this.firstChar, ii = this.lastChar; i2 <= ii; i2++) {
                    callback(i2, i2);
                  }
                },
                has(i2) {
                  return this.firstChar <= i2 && i2 <= this.lastChar;
                },
                get(i2) {
                  if (this.firstChar <= i2 && i2 <= this.lastChar) {
                    return String.fromCharCode(i2);
                  }
                  return void 0;
                },
                charCodeOf(v2) {
                  return Number.isInteger(v2) && v2 >= this.firstChar && v2 <= this.lastChar ? v2 : -1;
                },
                amend(map) {
                  (0, _util2.unreachable)("Should not call amend()");
                }
              };
              return IdentityToUnicodeMap2;
            }();
            exports3.IdentityToUnicodeMap = IdentityToUnicodeMap;
            var OpenTypeFileBuilder = function OpenTypeFileBuilderClosure() {
              function writeInt16(dest, offset, num) {
                dest[offset] = num >> 8 & 255;
                dest[offset + 1] = num & 255;
              }
              function writeInt32(dest, offset, num) {
                dest[offset] = num >> 24 & 255;
                dest[offset + 1] = num >> 16 & 255;
                dest[offset + 2] = num >> 8 & 255;
                dest[offset + 3] = num & 255;
              }
              function writeData(dest, offset, data) {
                var i2, ii;
                if (data instanceof Uint8Array) {
                  dest.set(data, offset);
                } else if (typeof data === "string") {
                  for (i2 = 0, ii = data.length; i2 < ii; i2++) {
                    dest[offset++] = data.charCodeAt(i2) & 255;
                  }
                } else {
                  for (i2 = 0, ii = data.length; i2 < ii; i2++) {
                    dest[offset++] = data[i2] & 255;
                  }
                }
              }
              function OpenTypeFileBuilder2(sfnt) {
                this.sfnt = sfnt;
                this.tables = /* @__PURE__ */ Object.create(null);
              }
              OpenTypeFileBuilder2.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
                var maxPower2 = 1, log2 = 0;
                while ((maxPower2 ^ entriesCount) > maxPower2) {
                  maxPower2 <<= 1;
                  log2++;
                }
                var searchRange = maxPower2 * entrySize;
                return {
                  range: searchRange,
                  entry: log2,
                  rangeShift: entrySize * entriesCount - searchRange
                };
              };
              var OTF_HEADER_SIZE = 12;
              var OTF_TABLE_ENTRY_SIZE = 16;
              OpenTypeFileBuilder2.prototype = {
                toArray: function OpenTypeFileBuilder_toArray() {
                  var sfnt = this.sfnt;
                  var tables = this.tables;
                  var tablesNames = Object.keys(tables);
                  tablesNames.sort();
                  var numTables = tablesNames.length;
                  var i2, j2, jj, table, tableName;
                  var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                  var tableOffsets = [offset];
                  for (i2 = 0; i2 < numTables; i2++) {
                    table = tables[tablesNames[i2]];
                    var paddedLength = (table.length + 3 & ~3) >>> 0;
                    offset += paddedLength;
                    tableOffsets.push(offset);
                  }
                  var file = new Uint8Array(offset);
                  for (i2 = 0; i2 < numTables; i2++) {
                    table = tables[tablesNames[i2]];
                    writeData(file, tableOffsets[i2], table);
                  }
                  if (sfnt === "true") {
                    sfnt = (0, _util2.string32)(65536);
                  }
                  file[0] = sfnt.charCodeAt(0) & 255;
                  file[1] = sfnt.charCodeAt(1) & 255;
                  file[2] = sfnt.charCodeAt(2) & 255;
                  file[3] = sfnt.charCodeAt(3) & 255;
                  writeInt16(file, 4, numTables);
                  var searchParams = OpenTypeFileBuilder2.getSearchParams(numTables, 16);
                  writeInt16(file, 6, searchParams.range);
                  writeInt16(file, 8, searchParams.entry);
                  writeInt16(file, 10, searchParams.rangeShift);
                  offset = OTF_HEADER_SIZE;
                  for (i2 = 0; i2 < numTables; i2++) {
                    tableName = tablesNames[i2];
                    file[offset] = tableName.charCodeAt(0) & 255;
                    file[offset + 1] = tableName.charCodeAt(1) & 255;
                    file[offset + 2] = tableName.charCodeAt(2) & 255;
                    file[offset + 3] = tableName.charCodeAt(3) & 255;
                    var checksum = 0;
                    for (j2 = tableOffsets[i2], jj = tableOffsets[i2 + 1]; j2 < jj; j2 += 4) {
                      var quad = (0, _core_utils.readUint32)(file, j2);
                      checksum = checksum + quad >>> 0;
                    }
                    writeInt32(file, offset + 4, checksum);
                    writeInt32(file, offset + 8, tableOffsets[i2]);
                    writeInt32(file, offset + 12, tables[tableName].length);
                    offset += OTF_TABLE_ENTRY_SIZE;
                  }
                  return file;
                },
                addTable: function OpenTypeFileBuilder_addTable(tag, data) {
                  if (tag in this.tables) {
                    throw new Error("Table " + tag + " already exists");
                  }
                  this.tables[tag] = data;
                }
              };
              return OpenTypeFileBuilder2;
            }();
            var Font = function FontClosure() {
              function Font2(name, file, properties) {
                var charCode;
                this.name = name;
                this.loadedName = properties.loadedName;
                this.isType3Font = properties.isType3Font;
                this.sizes = [];
                this.missingFile = false;
                this.glyphCache = /* @__PURE__ */ Object.create(null);
                this.isSerifFont = !!(properties.flags & FontFlags.Serif);
                this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
                var type = properties.type;
                var subtype = properties.subtype;
                this.type = type;
                this.subtype = subtype;
                let fallbackName = "sans-serif";
                if (this.isMonospace) {
                  fallbackName = "monospace";
                } else if (this.isSerifFont) {
                  fallbackName = "serif";
                }
                this.fallbackName = fallbackName;
                this.differences = properties.differences;
                this.widths = properties.widths;
                this.defaultWidth = properties.defaultWidth;
                this.composite = properties.composite;
                this.wideChars = properties.wideChars;
                this.cMap = properties.cMap;
                this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                this.fontMatrix = properties.fontMatrix;
                this.bbox = properties.bbox;
                this.defaultEncoding = properties.defaultEncoding;
                this.toUnicode = properties.toUnicode;
                this.fallbackToUnicode = properties.fallbackToUnicode || new ToUnicodeMap();
                this.toFontChar = [];
                if (properties.type === "Type3") {
                  for (charCode = 0; charCode < 256; charCode++) {
                    this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
                  }
                  this.fontType = _util2.FontType.TYPE3;
                  return;
                }
                this.cidEncoding = properties.cidEncoding;
                this.vertical = properties.vertical;
                if (this.vertical) {
                  this.vmetrics = properties.vmetrics;
                  this.defaultVMetrics = properties.defaultVMetrics;
                }
                if (!file || file.isEmpty) {
                  if (file) {
                    (0, _util2.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
                  }
                  this.fallbackToSystemFont();
                  return;
                }
                [type, subtype] = getFontFileType(file, properties);
                if (type !== this.type || subtype !== this.subtype) {
                  (0, _util2.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
                }
                try {
                  var data;
                  switch (type) {
                    case "MMType1":
                      (0, _util2.info)("MMType1 font (" + name + "), falling back to Type1.");
                    case "Type1":
                    case "CIDFontType0":
                      this.mimetype = "font/opentype";
                      var cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
                      adjustWidths(properties);
                      data = this.convert(name, cff, properties);
                      break;
                    case "OpenType":
                    case "TrueType":
                    case "CIDFontType2":
                      this.mimetype = "font/opentype";
                      data = this.checkAndRepair(name, file, properties);
                      if (this.isOpenType) {
                        adjustWidths(properties);
                        type = "OpenType";
                      }
                      break;
                    default:
                      throw new _util2.FormatError(`Font ${type} is not supported`);
                  }
                } catch (e2) {
                  (0, _util2.warn)(e2);
                  this.fallbackToSystemFont();
                  return;
                }
                this.data = data;
                this.fontType = getFontType(type, subtype);
                this.fontMatrix = properties.fontMatrix;
                this.widths = properties.widths;
                this.defaultWidth = properties.defaultWidth;
                this.toUnicode = properties.toUnicode;
                this.encoding = properties.baseEncoding;
                this.seacMap = properties.seacMap;
              }
              Font2.getFontID = function() {
                var ID = 1;
                return function Font_getFontID() {
                  return String(ID++);
                };
              }();
              function int16(b0, b1) {
                return (b0 << 8) + b1;
              }
              function writeSignedInt16(bytes, index, value) {
                bytes[index + 1] = value;
                bytes[index] = value >>> 8;
              }
              function signedInt16(b0, b1) {
                var value = (b0 << 8) + b1;
                return value & 1 << 15 ? value - 65536 : value;
              }
              function int32(b0, b1, b2, b3) {
                return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
              }
              function string16(value) {
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function safeString16(value) {
                if (value > 32767) {
                  value = 32767;
                } else if (value < -32768) {
                  value = -32768;
                }
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function isTrueTypeFile(file) {
                var header = file.peekBytes(4);
                return (0, _core_utils.readUint32)(header, 0) === 65536 || (0, _util2.bytesToString)(header) === "true";
              }
              function isTrueTypeCollectionFile(file) {
                const header = file.peekBytes(4);
                return (0, _util2.bytesToString)(header) === "ttcf";
              }
              function isOpenTypeFile(file) {
                var header = file.peekBytes(4);
                return (0, _util2.bytesToString)(header) === "OTTO";
              }
              function isType1File(file) {
                var header = file.peekBytes(2);
                if (header[0] === 37 && header[1] === 33) {
                  return true;
                }
                if (header[0] === 128 && header[1] === 1) {
                  return true;
                }
                return false;
              }
              function isCFFFile(file) {
                const header = file.peekBytes(4);
                if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
                  return true;
                }
                return false;
              }
              function getFontFileType(file, {
                type,
                subtype,
                composite
              }) {
                let fileType, fileSubtype;
                if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType2";
                  } else {
                    fileType = "TrueType";
                  }
                } else if (isOpenTypeFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType2";
                  } else {
                    fileType = "OpenType";
                  }
                } else if (isType1File(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                  }
                } else if (isCFFFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                    fileSubtype = "CIDFontType0C";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                    fileSubtype = "Type1C";
                  }
                } else {
                  (0, _util2.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
                  fileType = type;
                  fileSubtype = subtype;
                }
                return [fileType, fileSubtype];
              }
              function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
                var toFontChar = [], unicode;
                for (var i2 = 0, ii = encoding.length; i2 < ii; i2++) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i2], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[i2] = unicode;
                  }
                }
                for (var charCode in differences) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[+charCode] = unicode;
                  }
                }
                return toFontChar;
              }
              function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId) {
                var newMap = /* @__PURE__ */ Object.create(null);
                var toFontChar = [];
                var privateUseAreaIndex = 0;
                var nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                var privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                for (var originalCharCode in charCodeToGlyphId) {
                  originalCharCode |= 0;
                  var glyphId = charCodeToGlyphId[originalCharCode];
                  if (!hasGlyph(glyphId)) {
                    continue;
                  }
                  if (nextAvailableFontCharCode > privateUseOffetEnd) {
                    privateUseAreaIndex++;
                    if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
                      (0, _util2.warn)("Ran out of space in font private use area.");
                      break;
                    }
                    nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                    privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                  }
                  var fontCharCode = nextAvailableFontCharCode++;
                  if (glyphId === 0) {
                    glyphId = newGlyphZeroId;
                  }
                  newMap[fontCharCode] = glyphId;
                  toFontChar[originalCharCode] = fontCharCode;
                }
                return {
                  toFontChar,
                  charCodeToGlyphId: newMap,
                  nextAvailableFontCharCode
                };
              }
              function getRanges(glyphs, numGlyphs) {
                var codes = [];
                for (var charCode in glyphs) {
                  if (glyphs[charCode] >= numGlyphs) {
                    continue;
                  }
                  codes.push({
                    fontCharCode: charCode | 0,
                    glyphId: glyphs[charCode]
                  });
                }
                if (codes.length === 0) {
                  codes.push({
                    fontCharCode: 0,
                    glyphId: 0
                  });
                }
                codes.sort(function fontGetRangesSort(a2, b2) {
                  return a2.fontCharCode - b2.fontCharCode;
                });
                var ranges = [];
                var length = codes.length;
                for (var n2 = 0; n2 < length; ) {
                  var start = codes[n2].fontCharCode;
                  var codeIndices = [codes[n2].glyphId];
                  ++n2;
                  var end = start;
                  while (n2 < length && end + 1 === codes[n2].fontCharCode) {
                    codeIndices.push(codes[n2].glyphId);
                    ++end;
                    ++n2;
                    if (end === 65535) {
                      break;
                    }
                  }
                  ranges.push([start, end, codeIndices]);
                }
                return ranges;
              }
              function createCmapTable(glyphs, numGlyphs) {
                var ranges = getRanges(glyphs, numGlyphs);
                var numTables = ranges[ranges.length - 1][1] > 65535 ? 2 : 1;
                var cmap = "\0\0" + string16(numTables) + "\0\0" + (0, _util2.string32)(4 + numTables * 8);
                var i2, ii, j2, jj;
                for (i2 = ranges.length - 1; i2 >= 0; --i2) {
                  if (ranges[i2][0] <= 65535) {
                    break;
                  }
                }
                var bmpLength = i2 + 1;
                if (ranges[i2][0] < 65535 && ranges[i2][1] === 65535) {
                  ranges[i2][1] = 65534;
                }
                var trailingRangesCount = ranges[i2][1] < 65535 ? 1 : 0;
                var segCount = bmpLength + trailingRangesCount;
                var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
                var startCount = "";
                var endCount = "";
                var idDeltas = "";
                var idRangeOffsets = "";
                var glyphsIds = "";
                var bias = 0;
                var range, start, end, codes;
                for (i2 = 0, ii = bmpLength; i2 < ii; i2++) {
                  range = ranges[i2];
                  start = range[0];
                  end = range[1];
                  startCount += string16(start);
                  endCount += string16(end);
                  codes = range[2];
                  var contiguous = true;
                  for (j2 = 1, jj = codes.length; j2 < jj; ++j2) {
                    if (codes[j2] !== codes[j2 - 1] + 1) {
                      contiguous = false;
                      break;
                    }
                  }
                  if (!contiguous) {
                    var offset = (segCount - i2) * 2 + bias * 2;
                    bias += end - start + 1;
                    idDeltas += string16(0);
                    idRangeOffsets += string16(offset);
                    for (j2 = 0, jj = codes.length; j2 < jj; ++j2) {
                      glyphsIds += string16(codes[j2]);
                    }
                  } else {
                    var startCode = codes[0];
                    idDeltas += string16(startCode - start & 65535);
                    idRangeOffsets += string16(0);
                  }
                }
                if (trailingRangesCount > 0) {
                  endCount += "ÿÿ";
                  startCount += "ÿÿ";
                  idDeltas += "\0";
                  idRangeOffsets += "\0\0";
                }
                var format314 = "\0\0" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
                var format31012 = "";
                var header31012 = "";
                if (numTables > 1) {
                  cmap += "\0\0\n" + (0, _util2.string32)(4 + numTables * 8 + 4 + format314.length);
                  format31012 = "";
                  for (i2 = 0, ii = ranges.length; i2 < ii; i2++) {
                    range = ranges[i2];
                    start = range[0];
                    codes = range[2];
                    var code = codes[0];
                    for (j2 = 1, jj = codes.length; j2 < jj; ++j2) {
                      if (codes[j2] !== codes[j2 - 1] + 1) {
                        end = range[0] + j2 - 1;
                        format31012 += (0, _util2.string32)(start) + (0, _util2.string32)(end) + (0, _util2.string32)(code);
                        start = end + 1;
                        code = codes[j2];
                      }
                    }
                    format31012 += (0, _util2.string32)(start) + (0, _util2.string32)(range[1]) + (0, _util2.string32)(code);
                  }
                  header31012 = "\0\f\0\0" + (0, _util2.string32)(format31012.length + 16) + "\0\0\0\0" + (0, _util2.string32)(format31012.length / 12);
                }
                return cmap + "\0" + string16(format314.length + 4) + format314 + header31012 + format31012;
              }
              function validateOS2Table(os2) {
                var stream = new _stream.Stream(os2.data);
                var version2 = stream.getUint16();
                stream.getBytes(60);
                var selection = stream.getUint16();
                if (version2 < 4 && selection & 768) {
                  return false;
                }
                var firstChar = stream.getUint16();
                var lastChar = stream.getUint16();
                if (firstChar > lastChar) {
                  return false;
                }
                stream.getBytes(6);
                var usWinAscent = stream.getUint16();
                if (usWinAscent === 0) {
                  return false;
                }
                os2.data[8] = os2.data[9] = 0;
                return true;
              }
              function createOS2Table(properties, charstrings, override) {
                override = override || {
                  unitsPerEm: 0,
                  yMax: 0,
                  yMin: 0,
                  ascent: 0,
                  descent: 0
                };
                var ulUnicodeRange1 = 0;
                var ulUnicodeRange2 = 0;
                var ulUnicodeRange3 = 0;
                var ulUnicodeRange4 = 0;
                var firstCharIndex = null;
                var lastCharIndex = 0;
                if (charstrings) {
                  for (var code in charstrings) {
                    code |= 0;
                    if (firstCharIndex > code || !firstCharIndex) {
                      firstCharIndex = code;
                    }
                    if (lastCharIndex < code) {
                      lastCharIndex = code;
                    }
                    var position = (0, _unicode.getUnicodeRangeFor)(code);
                    if (position < 32) {
                      ulUnicodeRange1 |= 1 << position;
                    } else if (position < 64) {
                      ulUnicodeRange2 |= 1 << position - 32;
                    } else if (position < 96) {
                      ulUnicodeRange3 |= 1 << position - 64;
                    } else if (position < 123) {
                      ulUnicodeRange4 |= 1 << position - 96;
                    } else {
                      throw new _util2.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                    }
                  }
                  if (lastCharIndex > 65535) {
                    lastCharIndex = 65535;
                  }
                } else {
                  firstCharIndex = 0;
                  lastCharIndex = 255;
                }
                var bbox = properties.bbox || [0, 0, 0, 0];
                var unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX)[0];
                var scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
                var typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
                var typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
                if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                  typoDescent = -typoDescent;
                }
                var winAscent = override.yMax || typoAscent;
                var winDescent = -override.yMin || -typoDescent;
                return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, _util2.string32)(ulUnicodeRange1) + (0, _util2.string32)(ulUnicodeRange2) + (0, _util2.string32)(ulUnicodeRange3) + (0, _util2.string32)(ulUnicodeRange4) + "*21*" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\0d" + string16(winAscent) + string16(winDescent) + "\0\0\0\0\0\0\0\0" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\0";
              }
              function createPostTable(properties) {
                var angle = Math.floor(properties.italicAngle * 2 ** 16);
                return "\0\0\0" + (0, _util2.string32)(angle) + "\0\0\0\0" + (0, _util2.string32)(properties.fixedPitch) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              }
              function createNameTable(name, proto) {
                if (!proto) {
                  proto = [[], []];
                }
                var strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || "", proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
                var stringsUnicode = [];
                var i2, ii, j2, jj, str;
                for (i2 = 0, ii = strings.length; i2 < ii; i2++) {
                  str = proto[1][i2] || strings[i2];
                  var strBufUnicode = [];
                  for (j2 = 0, jj = str.length; j2 < jj; j2++) {
                    strBufUnicode.push(string16(str.charCodeAt(j2)));
                  }
                  stringsUnicode.push(strBufUnicode.join(""));
                }
                var names = [strings, stringsUnicode];
                var platforms = ["\0", "\0"];
                var encodings = ["\0\0", "\0"];
                var languages = ["\0\0", "	"];
                var namesRecordCount = strings.length * platforms.length;
                var nameTable = "\0\0" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
                var strOffset = 0;
                for (i2 = 0, ii = platforms.length; i2 < ii; i2++) {
                  var strs = names[i2];
                  for (j2 = 0, jj = strs.length; j2 < jj; j2++) {
                    str = strs[j2];
                    var nameRecord = platforms[i2] + encodings[i2] + languages[i2] + string16(j2) + string16(str.length) + string16(strOffset);
                    nameTable += nameRecord;
                    strOffset += str.length;
                  }
                }
                nameTable += strings.join("") + stringsUnicode.join("");
                return nameTable;
              }
              Font2.prototype = {
                name: null,
                font: null,
                mimetype: null,
                encoding: null,
                disableFontFace: false,
                get renderer() {
                  var renderer = _font_renderer.FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
                  return (0, _util2.shadow)(this, "renderer", renderer);
                },
                exportData: function Font_exportData() {
                  var data = {};
                  for (var i2 in this) {
                    if (this.hasOwnProperty(i2)) {
                      data[i2] = this[i2];
                    }
                  }
                  return data;
                },
                fallbackToSystemFont: function Font_fallbackToSystemFont() {
                  this.missingFile = true;
                  var charCode, unicode;
                  var name = this.name;
                  var type = this.type;
                  var subtype = this.subtype;
                  let fontName = name.replace(/[,_]/g, "-").replace(/\s/g, "");
                  var stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
                  var isStandardFont = !!stdFontMap[fontName] || !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                  fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                  this.bold = fontName.search(/bold/gi) !== -1;
                  this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
                  this.black = name.search(/Black/g) !== -1;
                  this.remeasure = Object.keys(this.widths).length > 0;
                  if (isStandardFont && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                    const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();
                    const map = [];
                    for (charCode in GlyphMapForStandardFonts) {
                      map[+charCode] = GlyphMapForStandardFonts[charCode];
                    }
                    if (/Arial-?Black/i.test(name)) {
                      var SupplementalGlyphMapForArialBlack = (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)();
                      for (charCode in SupplementalGlyphMapForArialBlack) {
                        map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
                      }
                    } else if (/Calibri/i.test(name)) {
                      const SupplementalGlyphMapForCalibri = (0, _standard_fonts.getSupplementalGlyphMapForCalibri)();
                      for (charCode in SupplementalGlyphMapForCalibri) {
                        map[+charCode] = SupplementalGlyphMapForCalibri[charCode];
                      }
                    }
                    var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
                    if (!isIdentityUnicode) {
                      this.toUnicode.forEach(function(charCode2, unicodeCharCode) {
                        map[+charCode2] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                    this.toUnicode = new ToUnicodeMap(map);
                  } else if (/Symbol/i.test(fontName)) {
                    this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else if (/Dingbats/i.test(fontName)) {
                    if (/Wingdings/i.test(name)) {
                      (0, _util2.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
                    }
                    this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
                  } else if (isStandardFont) {
                    this.toFontChar = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else {
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    const map = [];
                    this.toUnicode.forEach((charCode2, unicodeCharCode) => {
                      if (!this.composite) {
                        var glyphName = this.differences[charCode2] || this.defaultEncoding[charCode2];
                        unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                        if (unicode !== -1) {
                          unicodeCharCode = unicode;
                        }
                      }
                      map[+charCode2] = unicodeCharCode;
                    });
                    if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
                      if (/Verdana/i.test(name)) {
                        const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();
                        for (charCode in GlyphMapForStandardFonts) {
                          map[+charCode] = GlyphMapForStandardFonts[charCode];
                        }
                      }
                    }
                    this.toFontChar = map;
                  }
                  this.loadedName = fontName.split("-")[0];
                  this.fontType = getFontType(type, subtype);
                },
                checkAndRepair: function Font_checkAndRepair(name, font, properties) {
                  const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
                  function readTables(file, numTables) {
                    const tables2 = /* @__PURE__ */ Object.create(null);
                    tables2["OS/2"] = null;
                    tables2["cmap"] = null;
                    tables2["head"] = null;
                    tables2["hhea"] = null;
                    tables2["hmtx"] = null;
                    tables2["maxp"] = null;
                    tables2["name"] = null;
                    tables2["post"] = null;
                    for (let i2 = 0; i2 < numTables; i2++) {
                      const table = readTableEntry(font);
                      if (!VALID_TABLES.includes(table.tag)) {
                        continue;
                      }
                      if (table.length === 0) {
                        continue;
                      }
                      tables2[table.tag] = table;
                    }
                    return tables2;
                  }
                  function readTableEntry(file) {
                    var tag = (0, _util2.bytesToString)(file.getBytes(4));
                    var checksum = file.getInt32() >>> 0;
                    var offset = file.getInt32() >>> 0;
                    var length = file.getInt32() >>> 0;
                    var previousPosition = file.pos;
                    file.pos = file.start ? file.start : 0;
                    file.skip(offset);
                    var data = file.getBytes(length);
                    file.pos = previousPosition;
                    if (tag === "head") {
                      data[8] = data[9] = data[10] = data[11] = 0;
                      data[17] |= 32;
                    }
                    return {
                      tag,
                      checksum,
                      length,
                      offset,
                      data
                    };
                  }
                  function readOpenTypeHeader(ttf) {
                    return {
                      version: (0, _util2.bytesToString)(ttf.getBytes(4)),
                      numTables: ttf.getUint16(),
                      searchRange: ttf.getUint16(),
                      entrySelector: ttf.getUint16(),
                      rangeShift: ttf.getUint16()
                    };
                  }
                  function readTrueTypeCollectionHeader(ttc) {
                    const ttcTag = (0, _util2.bytesToString)(ttc.getBytes(4));
                    (0, _util2.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
                    const majorVersion = ttc.getUint16();
                    const minorVersion = ttc.getUint16();
                    const numFonts = ttc.getInt32() >>> 0;
                    const offsetTable = [];
                    for (let i2 = 0; i2 < numFonts; i2++) {
                      offsetTable.push(ttc.getInt32() >>> 0);
                    }
                    const header2 = {
                      ttcTag,
                      majorVersion,
                      minorVersion,
                      numFonts,
                      offsetTable
                    };
                    switch (majorVersion) {
                      case 1:
                        return header2;
                      case 2:
                        header2.dsigTag = ttc.getInt32() >>> 0;
                        header2.dsigLength = ttc.getInt32() >>> 0;
                        header2.dsigOffset = ttc.getInt32() >>> 0;
                        return header2;
                    }
                    throw new _util2.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
                  }
                  function readTrueTypeCollectionData(ttc, fontName) {
                    const {
                      numFonts,
                      offsetTable
                    } = readTrueTypeCollectionHeader(ttc);
                    for (let i2 = 0; i2 < numFonts; i2++) {
                      ttc.pos = (ttc.start || 0) + offsetTable[i2];
                      const potentialHeader = readOpenTypeHeader(ttc);
                      const potentialTables = readTables(ttc, potentialHeader.numTables);
                      if (!potentialTables["name"]) {
                        throw new _util2.FormatError('TrueType Collection font must contain a "name" table.');
                      }
                      const nameTable = readNameTable(potentialTables["name"]);
                      for (let j2 = 0, jj = nameTable.length; j2 < jj; j2++) {
                        for (let k2 = 0, kk = nameTable[j2].length; k2 < kk; k2++) {
                          const nameEntry = nameTable[j2][k2];
                          if (nameEntry && nameEntry.replace(/\s/g, "") === fontName) {
                            return {
                              header: potentialHeader,
                              tables: potentialTables
                            };
                          }
                        }
                      }
                    }
                    throw new _util2.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
                  }
                  function readCmapTable(cmap, font2, isSymbolicFont, hasEncoding) {
                    if (!cmap) {
                      (0, _util2.warn)("No cmap table available.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    var segment;
                    var start = (font2.start ? font2.start : 0) + cmap.offset;
                    font2.pos = start;
                    font2.getUint16();
                    var numTables = font2.getUint16();
                    var potentialTable;
                    var canBreak = false;
                    for (var i2 = 0; i2 < numTables; i2++) {
                      var platformId = font2.getUint16();
                      var encodingId = font2.getUint16();
                      var offset = font2.getInt32() >>> 0;
                      var useTable = false;
                      if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
                        continue;
                      }
                      if (platformId === 0 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 1 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
                        useTable = true;
                        if (!isSymbolicFont) {
                          canBreak = true;
                        }
                      } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                        useTable = true;
                        canBreak = true;
                      }
                      if (useTable) {
                        potentialTable = {
                          platformId,
                          encodingId,
                          offset
                        };
                      }
                      if (canBreak) {
                        break;
                      }
                    }
                    if (potentialTable) {
                      font2.pos = start + potentialTable.offset;
                    }
                    if (!potentialTable || font2.peekByte() === -1) {
                      (0, _util2.warn)("Could not find a preferred cmap table.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    var format = font2.getUint16();
                    font2.getUint16();
                    font2.getUint16();
                    var hasShortCmap = false;
                    var mappings = [];
                    var j2, glyphId2;
                    if (format === 0) {
                      for (j2 = 0; j2 < 256; j2++) {
                        var index = font2.getByte();
                        if (!index) {
                          continue;
                        }
                        mappings.push({
                          charCode: j2,
                          glyphId: index
                        });
                      }
                      hasShortCmap = true;
                    } else if (format === 4) {
                      var segCount = font2.getUint16() >> 1;
                      font2.getBytes(6);
                      var segIndex, segments = [];
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments.push({
                          end: font2.getUint16()
                        });
                      }
                      font2.getUint16();
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].start = font2.getUint16();
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].delta = font2.getUint16();
                      }
                      var offsetsCount = 0;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        var rangeOffset = font2.getUint16();
                        if (!rangeOffset) {
                          segment.offsetIndex = -1;
                          continue;
                        }
                        var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                        segment.offsetIndex = offsetIndex;
                        offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
                      }
                      var offsets = [];
                      for (j2 = 0; j2 < offsetsCount; j2++) {
                        offsets.push(font2.getUint16());
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        start = segment.start;
                        var end = segment.end;
                        var delta = segment.delta;
                        offsetIndex = segment.offsetIndex;
                        for (j2 = start; j2 <= end; j2++) {
                          if (j2 === 65535) {
                            continue;
                          }
                          glyphId2 = offsetIndex < 0 ? j2 : offsets[offsetIndex + j2 - start];
                          glyphId2 = glyphId2 + delta & 65535;
                          mappings.push({
                            charCode: j2,
                            glyphId: glyphId2
                          });
                        }
                      }
                    } else if (format === 6) {
                      var firstCode = font2.getUint16();
                      var entryCount = font2.getUint16();
                      for (j2 = 0; j2 < entryCount; j2++) {
                        glyphId2 = font2.getUint16();
                        var charCode2 = firstCode + j2;
                        mappings.push({
                          charCode: charCode2,
                          glyphId: glyphId2
                        });
                      }
                    } else {
                      (0, _util2.warn)("cmap table has unsupported format: " + format);
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    mappings.sort(function(a2, b2) {
                      return a2.charCode - b2.charCode;
                    });
                    for (i2 = 1; i2 < mappings.length; i2++) {
                      if (mappings[i2 - 1].charCode === mappings[i2].charCode) {
                        mappings.splice(i2, 1);
                        i2--;
                      }
                    }
                    return {
                      platformId: potentialTable.platformId,
                      encodingId: potentialTable.encodingId,
                      mappings,
                      hasShortCmap
                    };
                  }
                  function sanitizeMetrics(font2, header2, metrics, numGlyphs2, dupFirstEntry2) {
                    if (!header2) {
                      if (metrics) {
                        metrics.data = null;
                      }
                      return;
                    }
                    font2.pos = (font2.start ? font2.start : 0) + header2.offset;
                    font2.pos += 4;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 2;
                    font2.pos += 8;
                    font2.pos += 2;
                    var numOfMetrics = font2.getUint16();
                    if (numOfMetrics > numGlyphs2) {
                      (0, _util2.info)("The numOfMetrics (" + numOfMetrics + ") should not be greater than the numGlyphs (" + numGlyphs2 + ")");
                      numOfMetrics = numGlyphs2;
                      header2.data[34] = (numOfMetrics & 65280) >> 8;
                      header2.data[35] = numOfMetrics & 255;
                    }
                    var numOfSidebearings = numGlyphs2 - numOfMetrics;
                    var numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
                    if (numMissing > 0) {
                      var entries = new Uint8Array(metrics.length + numMissing * 2);
                      entries.set(metrics.data);
                      if (dupFirstEntry2) {
                        entries[metrics.length] = metrics.data[2];
                        entries[metrics.length + 1] = metrics.data[3];
                      }
                      metrics.data = entries;
                    }
                  }
                  function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
                    var glyphProfile = {
                      length: 0,
                      sizeOfInstructions: 0
                    };
                    if (sourceEnd - sourceStart <= 12) {
                      return glyphProfile;
                    }
                    var glyf = source.subarray(sourceStart, sourceEnd);
                    var contoursCount = signedInt16(glyf[0], glyf[1]);
                    if (contoursCount < 0) {
                      contoursCount = -1;
                      writeSignedInt16(glyf, 0, contoursCount);
                      dest.set(glyf, destStart);
                      glyphProfile.length = glyf.length;
                      return glyphProfile;
                    }
                    var i2, j2 = 10, flagsCount = 0;
                    for (i2 = 0; i2 < contoursCount; i2++) {
                      var endPoint = glyf[j2] << 8 | glyf[j2 + 1];
                      flagsCount = endPoint + 1;
                      j2 += 2;
                    }
                    var instructionsStart = j2;
                    var instructionsLength = glyf[j2] << 8 | glyf[j2 + 1];
                    glyphProfile.sizeOfInstructions = instructionsLength;
                    j2 += 2 + instructionsLength;
                    var instructionsEnd = j2;
                    var coordinatesLength = 0;
                    for (i2 = 0; i2 < flagsCount; i2++) {
                      var flag = glyf[j2++];
                      if (flag & 192) {
                        glyf[j2 - 1] = flag & 63;
                      }
                      let xLength = 2;
                      if (flag & 2) {
                        xLength = 1;
                      } else if (flag & 16) {
                        xLength = 0;
                      }
                      let yLength = 2;
                      if (flag & 4) {
                        yLength = 1;
                      } else if (flag & 32) {
                        yLength = 0;
                      }
                      const xyLength = xLength + yLength;
                      coordinatesLength += xyLength;
                      if (flag & 8) {
                        var repeat = glyf[j2++];
                        i2 += repeat;
                        coordinatesLength += repeat * xyLength;
                      }
                    }
                    if (coordinatesLength === 0) {
                      return glyphProfile;
                    }
                    var glyphDataLength = j2 + coordinatesLength;
                    if (glyphDataLength > glyf.length) {
                      return glyphProfile;
                    }
                    if (!hintsValid2 && instructionsLength > 0) {
                      dest.set(glyf.subarray(0, instructionsStart), destStart);
                      dest.set([0, 0], destStart + instructionsStart);
                      dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                      glyphDataLength -= instructionsLength;
                      if (glyf.length - glyphDataLength > 3) {
                        glyphDataLength = glyphDataLength + 3 & ~3;
                      }
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    if (glyf.length - glyphDataLength > 3) {
                      glyphDataLength = glyphDataLength + 3 & ~3;
                      dest.set(glyf.subarray(0, glyphDataLength), destStart);
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    dest.set(glyf, destStart);
                    glyphProfile.length = glyf.length;
                    return glyphProfile;
                  }
                  function sanitizeHead(head, numGlyphs2, locaLength) {
                    var data = head.data;
                    var version3 = int32(data[0], data[1], data[2], data[3]);
                    if (version3 >> 16 !== 1) {
                      (0, _util2.info)("Attempting to fix invalid version in head table: " + version3);
                      data[0] = 0;
                      data[1] = 1;
                      data[2] = 0;
                      data[3] = 0;
                    }
                    var indexToLocFormat = int16(data[50], data[51]);
                    if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                      (0, _util2.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
                      var numGlyphsPlusOne = numGlyphs2 + 1;
                      if (locaLength === numGlyphsPlusOne << 1) {
                        data[50] = 0;
                        data[51] = 0;
                      } else if (locaLength === numGlyphsPlusOne << 2) {
                        data[50] = 0;
                        data[51] = 1;
                      } else {
                        throw new _util2.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
                      }
                    }
                  }
                  function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong2, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
                    var itemSize, itemDecode, itemEncode;
                    if (isGlyphLocationsLong2) {
                      itemSize = 4;
                      itemDecode = function fontItemDecodeLong(data, offset) {
                        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                      };
                      itemEncode = function fontItemEncodeLong(data, offset, value) {
                        data[offset] = value >>> 24 & 255;
                        data[offset + 1] = value >> 16 & 255;
                        data[offset + 2] = value >> 8 & 255;
                        data[offset + 3] = value & 255;
                      };
                    } else {
                      itemSize = 2;
                      itemDecode = function fontItemDecode(data, offset) {
                        return data[offset] << 9 | data[offset + 1] << 1;
                      };
                      itemEncode = function fontItemEncode(data, offset, value) {
                        data[offset] = value >> 9 & 255;
                        data[offset + 1] = value >> 1 & 255;
                      };
                    }
                    var numGlyphsOut2 = dupFirstEntry2 ? numGlyphs2 + 1 : numGlyphs2;
                    var locaDataSize = itemSize * (1 + numGlyphsOut2);
                    var locaData = new Uint8Array(locaDataSize);
                    locaData.set(loca.data.subarray(0, locaDataSize));
                    loca.data = locaData;
                    var oldGlyfData = glyf.data;
                    var oldGlyfDataLength = oldGlyfData.length;
                    var newGlyfData = new Uint8Array(oldGlyfDataLength);
                    var startOffset = itemDecode(locaData, 0);
                    var writeOffset = 0;
                    var missingGlyphs2 = /* @__PURE__ */ Object.create(null);
                    itemEncode(locaData, 0, writeOffset);
                    var i2, j2;
                    for (i2 = 0, j2 = itemSize; i2 < numGlyphs2; i2++, j2 += itemSize) {
                      var endOffset = itemDecode(locaData, j2);
                      if (endOffset === 0) {
                        endOffset = startOffset;
                      }
                      if (endOffset > oldGlyfDataLength && (oldGlyfDataLength + 3 & ~3) === endOffset) {
                        endOffset = oldGlyfDataLength;
                      }
                      if (endOffset > oldGlyfDataLength) {
                        startOffset = endOffset;
                      }
                      var glyphProfile = sanitizeGlyph(oldGlyfData, startOffset, endOffset, newGlyfData, writeOffset, hintsValid2);
                      var newLength = glyphProfile.length;
                      if (newLength === 0) {
                        missingGlyphs2[i2] = true;
                      }
                      if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
                        maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
                      }
                      writeOffset += newLength;
                      itemEncode(locaData, j2, writeOffset);
                      startOffset = endOffset;
                    }
                    if (writeOffset === 0) {
                      var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                      for (i2 = 0, j2 = itemSize; i2 < numGlyphsOut2; i2++, j2 += itemSize) {
                        itemEncode(locaData, j2, simpleGlyph.length);
                      }
                      glyf.data = simpleGlyph;
                    } else if (dupFirstEntry2) {
                      var firstEntryLength = itemDecode(locaData, itemSize);
                      if (newGlyfData.length > firstEntryLength + writeOffset) {
                        glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                      } else {
                        glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                        glyf.data.set(newGlyfData.subarray(0, writeOffset));
                      }
                      glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                      itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                    } else {
                      glyf.data = newGlyfData.subarray(0, writeOffset);
                    }
                    return {
                      missingGlyphs: missingGlyphs2,
                      maxSizeOfInstructions: maxSizeOfInstructions2
                    };
                  }
                  function readPostScriptTable(post, properties2, maxpNumGlyphs) {
                    var start = (font.start ? font.start : 0) + post.offset;
                    font.pos = start;
                    var length = post.length, end = start + length;
                    var version3 = font.getInt32();
                    font.getBytes(28);
                    var glyphNames;
                    var valid = true;
                    var i2;
                    switch (version3) {
                      case 65536:
                        glyphNames = MacStandardGlyphOrdering;
                        break;
                      case 131072:
                        var numGlyphs2 = font.getUint16();
                        if (numGlyphs2 !== maxpNumGlyphs) {
                          valid = false;
                          break;
                        }
                        var glyphNameIndexes = [];
                        for (i2 = 0; i2 < numGlyphs2; ++i2) {
                          var index = font.getUint16();
                          if (index >= 32768) {
                            valid = false;
                            break;
                          }
                          glyphNameIndexes.push(index);
                        }
                        if (!valid) {
                          break;
                        }
                        var customNames = [];
                        var strBuf = [];
                        while (font.pos < end) {
                          var stringLength = font.getByte();
                          strBuf.length = stringLength;
                          for (i2 = 0; i2 < stringLength; ++i2) {
                            strBuf[i2] = String.fromCharCode(font.getByte());
                          }
                          customNames.push(strBuf.join(""));
                        }
                        glyphNames = [];
                        for (i2 = 0; i2 < numGlyphs2; ++i2) {
                          var j2 = glyphNameIndexes[i2];
                          if (j2 < 258) {
                            glyphNames.push(MacStandardGlyphOrdering[j2]);
                            continue;
                          }
                          glyphNames.push(customNames[j2 - 258]);
                        }
                        break;
                      case 196608:
                        break;
                      default:
                        (0, _util2.warn)("Unknown/unsupported post table version " + version3);
                        valid = false;
                        if (properties2.defaultEncoding) {
                          glyphNames = properties2.defaultEncoding;
                        }
                        break;
                    }
                    properties2.glyphNames = glyphNames;
                    return valid;
                  }
                  function readNameTable(nameTable) {
                    var start = (font.start ? font.start : 0) + nameTable.offset;
                    font.pos = start;
                    var names = [[], []];
                    var length = nameTable.length, end = start + length;
                    var format = font.getUint16();
                    var FORMAT_0_HEADER_LENGTH = 6;
                    if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                      return names;
                    }
                    var numRecords = font.getUint16();
                    var stringsStart = font.getUint16();
                    var records = [];
                    var NAME_RECORD_LENGTH = 12;
                    var i2, ii;
                    for (i2 = 0; i2 < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i2++) {
                      var r2 = {
                        platform: font.getUint16(),
                        encoding: font.getUint16(),
                        language: font.getUint16(),
                        name: font.getUint16(),
                        length: font.getUint16(),
                        offset: font.getUint16()
                      };
                      if (r2.platform === 1 && r2.encoding === 0 && r2.language === 0 || r2.platform === 3 && r2.encoding === 1 && r2.language === 1033) {
                        records.push(r2);
                      }
                    }
                    for (i2 = 0, ii = records.length; i2 < ii; i2++) {
                      var record = records[i2];
                      if (record.length <= 0) {
                        continue;
                      }
                      var pos = start + stringsStart + record.offset;
                      if (pos + record.length > end) {
                        continue;
                      }
                      font.pos = pos;
                      var nameIndex = record.name;
                      if (record.encoding) {
                        var str = "";
                        for (var j2 = 0, jj = record.length; j2 < jj; j2 += 2) {
                          str += String.fromCharCode(font.getUint16());
                        }
                        names[1][nameIndex] = str;
                      } else {
                        names[0][nameIndex] = (0, _util2.bytesToString)(font.getBytes(record.length));
                      }
                    }
                    return names;
                  }
                  var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
                  function sanitizeTTProgram(table, ttContext) {
                    var data = table.data;
                    var i2 = 0, j2, n2, b2, funcId, pc, lastEndf = 0, lastDeff = 0;
                    var stack = [];
                    var callstack = [];
                    var functionsCalled = [];
                    var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                    var inFDEF = false, ifLevel = 0, inELSE = 0;
                    for (var ii = data.length; i2 < ii; ) {
                      var op = data[i2++];
                      if (op === 64) {
                        n2 = data[i2++];
                        if (inFDEF || inELSE) {
                          i2 += n2;
                        } else {
                          for (j2 = 0; j2 < n2; j2++) {
                            stack.push(data[i2++]);
                          }
                        }
                      } else if (op === 65) {
                        n2 = data[i2++];
                        if (inFDEF || inELSE) {
                          i2 += n2 * 2;
                        } else {
                          for (j2 = 0; j2 < n2; j2++) {
                            b2 = data[i2++];
                            stack.push(b2 << 8 | data[i2++]);
                          }
                        }
                      } else if ((op & 248) === 176) {
                        n2 = op - 176 + 1;
                        if (inFDEF || inELSE) {
                          i2 += n2;
                        } else {
                          for (j2 = 0; j2 < n2; j2++) {
                            stack.push(data[i2++]);
                          }
                        }
                      } else if ((op & 248) === 184) {
                        n2 = op - 184 + 1;
                        if (inFDEF || inELSE) {
                          i2 += n2 * 2;
                        } else {
                          for (j2 = 0; j2 < n2; j2++) {
                            b2 = data[i2++];
                            stack.push(b2 << 8 | data[i2++]);
                          }
                        }
                      } else if (op === 43 && !tooComplexToFollowFunctions) {
                        if (!inFDEF && !inELSE) {
                          funcId = stack[stack.length - 1];
                          if (isNaN(funcId)) {
                            (0, _util2.info)("TT: CALL empty stack (or invalid entry).");
                          } else {
                            ttContext.functionsUsed[funcId] = true;
                            if (funcId in ttContext.functionsStackDeltas) {
                              const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                              if (newStackLength < 0) {
                                (0, _util2.warn)("TT: CALL invalid functions stack delta.");
                                ttContext.hintsValid = false;
                                return;
                              }
                              stack.length = newStackLength;
                            } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                              callstack.push({
                                data,
                                i: i2,
                                stackTop: stack.length - 1
                              });
                              functionsCalled.push(funcId);
                              pc = ttContext.functionsDefined[funcId];
                              if (!pc) {
                                (0, _util2.warn)("TT: CALL non-existent function");
                                ttContext.hintsValid = false;
                                return;
                              }
                              data = pc.data;
                              i2 = pc.i;
                            }
                          }
                        }
                      } else if (op === 44 && !tooComplexToFollowFunctions) {
                        if (inFDEF || inELSE) {
                          (0, _util2.warn)("TT: nested FDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i2;
                        funcId = stack.pop();
                        ttContext.functionsDefined[funcId] = {
                          data,
                          i: i2
                        };
                      } else if (op === 45) {
                        if (inFDEF) {
                          inFDEF = false;
                          lastEndf = i2;
                        } else {
                          pc = callstack.pop();
                          if (!pc) {
                            (0, _util2.warn)("TT: ENDF bad stack");
                            ttContext.hintsValid = false;
                            return;
                          }
                          funcId = functionsCalled.pop();
                          data = pc.data;
                          i2 = pc.i;
                          ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                        }
                      } else if (op === 137) {
                        if (inFDEF || inELSE) {
                          (0, _util2.warn)("TT: nested IDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i2;
                      } else if (op === 88) {
                        ++ifLevel;
                      } else if (op === 27) {
                        inELSE = ifLevel;
                      } else if (op === 89) {
                        if (inELSE === ifLevel) {
                          inELSE = 0;
                        }
                        --ifLevel;
                      } else if (op === 28) {
                        if (!inFDEF && !inELSE) {
                          var offset = stack[stack.length - 1];
                          if (offset > 0) {
                            i2 += offset - 1;
                          }
                        }
                      }
                      if (!inFDEF && !inELSE) {
                        let stackDelta = 0;
                        if (op <= 142) {
                          stackDelta = TTOpsStackDeltas[op];
                        } else if (op >= 192 && op <= 223) {
                          stackDelta = -1;
                        } else if (op >= 224) {
                          stackDelta = -2;
                        }
                        if (op >= 113 && op <= 117) {
                          n2 = stack.pop();
                          if (!isNaN(n2)) {
                            stackDelta = -n2 * 2;
                          }
                        }
                        while (stackDelta < 0 && stack.length > 0) {
                          stack.pop();
                          stackDelta++;
                        }
                        while (stackDelta > 0) {
                          stack.push(NaN);
                          stackDelta--;
                        }
                      }
                    }
                    ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                    var content = [data];
                    if (i2 > data.length) {
                      content.push(new Uint8Array(i2 - data.length));
                    }
                    if (lastDeff > lastEndf) {
                      (0, _util2.warn)("TT: complementing a missing function tail");
                      content.push(new Uint8Array([34, 45]));
                    }
                    foldTTTable(table, content);
                  }
                  function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
                    if (ttContext.tooComplexToFollowFunctions) {
                      return;
                    }
                    if (ttContext.functionsDefined.length > maxFunctionDefs2) {
                      (0, _util2.warn)("TT: more functions defined than expected");
                      ttContext.hintsValid = false;
                      return;
                    }
                    for (var j2 = 0, jj = ttContext.functionsUsed.length; j2 < jj; j2++) {
                      if (j2 > maxFunctionDefs2) {
                        (0, _util2.warn)("TT: invalid function id: " + j2);
                        ttContext.hintsValid = false;
                        return;
                      }
                      if (ttContext.functionsUsed[j2] && !ttContext.functionsDefined[j2]) {
                        (0, _util2.warn)("TT: undefined function: " + j2);
                        ttContext.hintsValid = false;
                        return;
                      }
                    }
                  }
                  function foldTTTable(table, content) {
                    if (content.length > 1) {
                      var newLength = 0;
                      var j2, jj;
                      for (j2 = 0, jj = content.length; j2 < jj; j2++) {
                        newLength += content[j2].length;
                      }
                      newLength = newLength + 3 & ~3;
                      var result = new Uint8Array(newLength);
                      var pos = 0;
                      for (j2 = 0, jj = content.length; j2 < jj; j2++) {
                        result.set(content[j2], pos);
                        pos += content[j2].length;
                      }
                      table.data = result;
                      table.length = newLength;
                    }
                  }
                  function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
                    var ttContext = {
                      functionsDefined: [],
                      functionsUsed: [],
                      functionsStackDeltas: [],
                      tooComplexToFollowFunctions: false,
                      hintsValid: true
                    };
                    if (fpgm) {
                      sanitizeTTProgram(fpgm, ttContext);
                    }
                    if (prep) {
                      sanitizeTTProgram(prep, ttContext);
                    }
                    if (fpgm) {
                      checkInvalidFunctions(ttContext, maxFunctionDefs2);
                    }
                    if (cvt && cvt.length & 1) {
                      var cvtData = new Uint8Array(cvt.length + 1);
                      cvtData.set(cvt.data);
                      cvt.data = cvtData;
                    }
                    return ttContext.hintsValid;
                  }
                  font = new _stream.Stream(new Uint8Array(font.getBytes()));
                  let header, tables;
                  if (isTrueTypeCollectionFile(font)) {
                    const ttcData = readTrueTypeCollectionData(font, this.name);
                    header = ttcData.header;
                    tables = ttcData.tables;
                  } else {
                    header = readOpenTypeHeader(font);
                    tables = readTables(font, header.numTables);
                  }
                  let cff, cffFile;
                  var isTrueType = !tables["CFF "];
                  if (!isTrueType) {
                    const isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
                    if (header.version === "OTTO" && !isComposite || !tables["head"] || !tables["hhea"] || !tables["maxp"] || !tables["post"]) {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      cff = new CFFFont(cffFile, properties);
                      adjustWidths(properties);
                      return this.convert(name, cff, properties);
                    }
                    delete tables["glyf"];
                    delete tables["loca"];
                    delete tables["fpgm"];
                    delete tables["prep"];
                    delete tables["cvt "];
                    this.isOpenType = true;
                  } else {
                    if (!tables["loca"]) {
                      throw new _util2.FormatError('Required "loca" table is not found');
                    }
                    if (!tables["glyf"]) {
                      (0, _util2.warn)('Required "glyf" table is not found -- trying to recover.');
                      tables["glyf"] = {
                        tag: "glyf",
                        data: new Uint8Array(0)
                      };
                    }
                    this.isOpenType = false;
                  }
                  if (!tables["maxp"]) {
                    throw new _util2.FormatError('Required "maxp" table is not found');
                  }
                  font.pos = (font.start || 0) + tables["maxp"].offset;
                  var version2 = font.getInt32();
                  const numGlyphs = font.getUint16();
                  let numGlyphsOut = numGlyphs + 1;
                  let dupFirstEntry = true;
                  if (numGlyphsOut > 65535) {
                    dupFirstEntry = false;
                    numGlyphsOut = numGlyphs;
                    (0, _util2.warn)("Not enough space in glyfs to duplicate first glyph.");
                  }
                  var maxFunctionDefs = 0;
                  var maxSizeOfInstructions = 0;
                  if (version2 >= 65536 && tables["maxp"].length >= 22) {
                    font.pos += 8;
                    var maxZones = font.getUint16();
                    if (maxZones > 2) {
                      tables["maxp"].data[14] = 0;
                      tables["maxp"].data[15] = 2;
                    }
                    font.pos += 4;
                    maxFunctionDefs = font.getUint16();
                    font.pos += 4;
                    maxSizeOfInstructions = font.getUint16();
                  }
                  tables["maxp"].data[4] = numGlyphsOut >> 8;
                  tables["maxp"].data[5] = numGlyphsOut & 255;
                  var hintsValid = sanitizeTTPrograms(tables["fpgm"], tables["prep"], tables["cvt "], maxFunctionDefs);
                  if (!hintsValid) {
                    delete tables["fpgm"];
                    delete tables["prep"];
                    delete tables["cvt "];
                  }
                  sanitizeMetrics(font, tables["hhea"], tables["hmtx"], numGlyphsOut, dupFirstEntry);
                  if (!tables["head"]) {
                    throw new _util2.FormatError('Required "head" table is not found');
                  }
                  sanitizeHead(tables["head"], numGlyphs, isTrueType ? tables["loca"].length : 0);
                  var missingGlyphs = /* @__PURE__ */ Object.create(null);
                  if (isTrueType) {
                    var isGlyphLocationsLong = int16(tables["head"].data[50], tables["head"].data[51]);
                    var glyphsInfo = sanitizeGlyphLocations(tables["loca"], tables["glyf"], numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
                    missingGlyphs = glyphsInfo.missingGlyphs;
                    if (version2 >= 65536 && tables["maxp"].length >= 22) {
                      tables["maxp"].data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
                      tables["maxp"].data[27] = glyphsInfo.maxSizeOfInstructions & 255;
                    }
                  }
                  if (!tables["hhea"]) {
                    throw new _util2.FormatError('Required "hhea" table is not found');
                  }
                  if (tables["hhea"].data[10] === 0 && tables["hhea"].data[11] === 0) {
                    tables["hhea"].data[10] = 255;
                    tables["hhea"].data[11] = 255;
                  }
                  var metricsOverride = {
                    unitsPerEm: int16(tables["head"].data[18], tables["head"].data[19]),
                    yMax: int16(tables["head"].data[42], tables["head"].data[43]),
                    yMin: signedInt16(tables["head"].data[38], tables["head"].data[39]),
                    ascent: int16(tables["hhea"].data[4], tables["hhea"].data[5]),
                    descent: signedInt16(tables["hhea"].data[6], tables["hhea"].data[7])
                  };
                  this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                  this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                  if (tables["post"]) {
                    readPostScriptTable(tables["post"], properties, numGlyphs);
                  }
                  tables["post"] = {
                    tag: "post",
                    data: createPostTable(properties)
                  };
                  var charCodeToGlyphId = [], charCode;
                  function hasGlyph(glyphId2) {
                    return !missingGlyphs[glyphId2];
                  }
                  if (properties.composite) {
                    var cidToGidMap = properties.cidToGidMap || [];
                    var isCidToGidMapEmpty = cidToGidMap.length === 0;
                    properties.cMap.forEach(function(charCode2, cid) {
                      if (cid > 65535) {
                        throw new _util2.FormatError("Max size of CID is 65,535");
                      }
                      var glyphId2 = -1;
                      if (isCidToGidMapEmpty) {
                        glyphId2 = cid;
                      } else if (cidToGidMap[cid] !== void 0) {
                        glyphId2 = cidToGidMap[cid];
                      }
                      if (glyphId2 >= 0 && glyphId2 < numGlyphs && hasGlyph(glyphId2)) {
                        charCodeToGlyphId[charCode2] = glyphId2;
                      }
                    });
                  } else {
                    var cmapTable = readCmapTable(tables["cmap"], font, this.isSymbolicFont, properties.hasEncoding);
                    var cmapPlatformId = cmapTable.platformId;
                    var cmapEncodingId = cmapTable.encodingId;
                    var cmapMappings = cmapTable.mappings;
                    var cmapMappingsLength = cmapMappings.length;
                    if (properties.hasEncoding && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0) || cmapPlatformId === -1 && cmapEncodingId === -1 && !!(0, _encodings.getEncoding)(properties.baseEncodingName)) {
                      var baseEncoding = [];
                      if (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding") {
                        baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                      }
                      var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      for (charCode = 0; charCode < 256; charCode++) {
                        var glyphName, standardGlyphName;
                        if (this.differences && charCode in this.differences) {
                          glyphName = this.differences[charCode];
                        } else if (charCode in baseEncoding && baseEncoding[charCode] !== "") {
                          glyphName = baseEncoding[charCode];
                        } else {
                          glyphName = _encodings.StandardEncoding[charCode];
                        }
                        if (!glyphName) {
                          continue;
                        }
                        standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                        var unicodeOrCharCode;
                        if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                          unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
                        } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                          unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
                        }
                        var found = false;
                        for (let i2 = 0; i2 < cmapMappingsLength; ++i2) {
                          if (cmapMappings[i2].charCode !== unicodeOrCharCode) {
                            continue;
                          }
                          charCodeToGlyphId[charCode] = cmapMappings[i2].glyphId;
                          found = true;
                          break;
                        }
                        if (!found && properties.glyphNames) {
                          var glyphId = properties.glyphNames.indexOf(glyphName);
                          if (glyphId === -1 && standardGlyphName !== glyphName) {
                            glyphId = properties.glyphNames.indexOf(standardGlyphName);
                          }
                          if (glyphId > 0 && hasGlyph(glyphId)) {
                            charCodeToGlyphId[charCode] = glyphId;
                          }
                        }
                      }
                    } else if (cmapPlatformId === 0 && cmapEncodingId === 0) {
                      for (let i2 = 0; i2 < cmapMappingsLength; ++i2) {
                        charCodeToGlyphId[cmapMappings[i2].charCode] = cmapMappings[i2].glyphId;
                      }
                    } else {
                      for (let i2 = 0; i2 < cmapMappingsLength; ++i2) {
                        charCode = cmapMappings[i2].charCode;
                        if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
                          charCode &= 255;
                        }
                        charCodeToGlyphId[charCode] = cmapMappings[i2].glyphId;
                      }
                    }
                  }
                  if (charCodeToGlyphId.length === 0) {
                    charCodeToGlyphId[0] = 0;
                  }
                  let glyphZeroId = numGlyphsOut - 1;
                  if (!dupFirstEntry) {
                    glyphZeroId = 0;
                  }
                  var newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId);
                  this.toFontChar = newMapping.toFontChar;
                  tables["cmap"] = {
                    tag: "cmap",
                    data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphsOut)
                  };
                  if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"])) {
                    tables["OS/2"] = {
                      tag: "OS/2",
                      data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
                    };
                  }
                  if (!isTrueType) {
                    try {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      var parser = new _cff_parser.CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
                      cff = parser.parse();
                      cff.duplicateFirstGlyph();
                      var compiler = new _cff_parser.CFFCompiler(cff);
                      tables["CFF "].data = compiler.compile();
                    } catch (e2) {
                      (0, _util2.warn)("Failed to compile font " + properties.loadedName);
                    }
                  }
                  if (!tables["name"]) {
                    tables["name"] = {
                      tag: "name",
                      data: createNameTable(this.name)
                    };
                  } else {
                    var namePrototype = readNameTable(tables["name"]);
                    tables["name"].data = createNameTable(name, namePrototype);
                  }
                  var builder = new OpenTypeFileBuilder(header.version);
                  for (var tableTag in tables) {
                    builder.addTable(tableTag, tables[tableTag].data);
                  }
                  return builder.toArray();
                },
                convert: function Font_convert(fontName, font, properties) {
                  properties.fixedPitch = false;
                  if (properties.builtInEncoding) {
                    adjustToUnicode(properties, properties.builtInEncoding);
                  }
                  let glyphZeroId = 1;
                  if (font instanceof CFFFont) {
                    glyphZeroId = font.numGlyphs - 1;
                  }
                  var mapping = font.getGlyphMapping(properties);
                  var newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId);
                  this.toFontChar = newMapping.toFontChar;
                  var numGlyphs = font.numGlyphs;
                  function getCharCodes(charCodeToGlyphId2, glyphId2) {
                    var charCodes2 = null;
                    for (var charCode2 in charCodeToGlyphId2) {
                      if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                        if (!charCodes2) {
                          charCodes2 = [];
                        }
                        charCodes2.push(charCode2 | 0);
                      }
                    }
                    return charCodes2;
                  }
                  function createCharCode(charCodeToGlyphId2, glyphId2) {
                    for (var charCode2 in charCodeToGlyphId2) {
                      if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                        return charCode2 | 0;
                      }
                    }
                    newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId2;
                    return newMapping.nextAvailableFontCharCode++;
                  }
                  var seacs = font.seacs;
                  if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
                    var matrix = properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    var charset = font.getCharset();
                    var seacMap = /* @__PURE__ */ Object.create(null);
                    for (var glyphId in seacs) {
                      glyphId |= 0;
                      var seac = seacs[glyphId];
                      var baseGlyphName = _encodings.StandardEncoding[seac[2]];
                      var accentGlyphName = _encodings.StandardEncoding[seac[3]];
                      var baseGlyphId = charset.indexOf(baseGlyphName);
                      var accentGlyphId = charset.indexOf(accentGlyphName);
                      if (baseGlyphId < 0 || accentGlyphId < 0) {
                        continue;
                      }
                      var accentOffset = {
                        x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
                        y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
                      };
                      var charCodes = getCharCodes(mapping, glyphId);
                      if (!charCodes) {
                        continue;
                      }
                      for (var i2 = 0, ii = charCodes.length; i2 < ii; i2++) {
                        var charCode = charCodes[i2];
                        var charCodeToGlyphId = newMapping.charCodeToGlyphId;
                        var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                        var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                        seacMap[charCode] = {
                          baseFontCharCode,
                          accentFontCharCode,
                          accentOffset
                        };
                      }
                    }
                    properties.seacMap = seacMap;
                  }
                  var unitsPerEm = 1 / (properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX)[0];
                  var builder = new OpenTypeFileBuilder("OTTO");
                  builder.addTable("CFF ", font.data);
                  builder.addTable("OS/2", createOS2Table(properties, newMapping.charCodeToGlyphId));
                  builder.addTable("cmap", createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
                  builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(unitsPerEm) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(properties.descent) + "ÿ" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
                  builder.addTable("hhea", "\0\0\0" + safeString16(properties.ascent) + safeString16(properties.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(numGlyphs));
                  builder.addTable("hmtx", function fontFieldsHmtx() {
                    var charstrings = font.charstrings;
                    var cffWidths = font.cff ? font.cff.widths : null;
                    var hmtx = "\0\0\0\0";
                    for (var i3 = 1, ii2 = numGlyphs; i3 < ii2; i3++) {
                      var width = 0;
                      if (charstrings) {
                        var charstring = charstrings[i3 - 1];
                        width = "width" in charstring ? charstring.width : 0;
                      } else if (cffWidths) {
                        width = Math.ceil(cffWidths[i3] || 0);
                      }
                      hmtx += string16(width) + string16(0);
                    }
                    return hmtx;
                  }());
                  builder.addTable("maxp", "\0\0P\0" + string16(numGlyphs));
                  builder.addTable("name", createNameTable(fontName));
                  builder.addTable("post", createPostTable(properties));
                  return builder.toArray();
                },
                get spaceWidth() {
                  if ("_shadowWidth" in this) {
                    return this._shadowWidth;
                  }
                  var possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
                  var width;
                  for (var i2 = 0, ii = possibleSpaceReplacements.length; i2 < ii; i2++) {
                    var glyphName = possibleSpaceReplacements[i2];
                    if (glyphName in this.widths) {
                      width = this.widths[glyphName];
                      break;
                    }
                    var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    var glyphUnicode = glyphsUnicodeMap[glyphName];
                    var charcode = 0;
                    if (this.composite) {
                      if (this.cMap.contains(glyphUnicode)) {
                        charcode = this.cMap.lookup(glyphUnicode);
                      }
                    }
                    if (!charcode && this.toUnicode) {
                      charcode = this.toUnicode.charCodeOf(glyphUnicode);
                    }
                    if (charcode <= 0) {
                      charcode = glyphUnicode;
                    }
                    width = this.widths[charcode];
                    if (width) {
                      break;
                    }
                  }
                  width = width || this.defaultWidth;
                  this._shadowWidth = width;
                  return width;
                },
                charToGlyph: function Font_charToGlyph(charcode, isSpace) {
                  var fontCharCode, width, operatorListId;
                  var widthCode = charcode;
                  if (this.cMap && this.cMap.contains(charcode)) {
                    widthCode = this.cMap.lookup(charcode);
                  }
                  width = this.widths[widthCode];
                  width = (0, _util2.isNum)(width) ? width : this.defaultWidth;
                  var vmetric = this.vmetrics && this.vmetrics[widthCode];
                  let unicode = this.toUnicode.get(charcode) || this.fallbackToUnicode.get(charcode) || charcode;
                  if (typeof unicode === "number") {
                    unicode = String.fromCharCode(unicode);
                  }
                  var isInFont = charcode in this.toFontChar;
                  fontCharCode = this.toFontChar[charcode] || charcode;
                  if (this.missingFile) {
                    const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
                    if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
                      fontCharCode = 32;
                    }
                    fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
                  }
                  if (this.isType3Font) {
                    operatorListId = fontCharCode;
                  }
                  var accent = null;
                  if (this.seacMap && this.seacMap[charcode]) {
                    isInFont = true;
                    var seac = this.seacMap[charcode];
                    fontCharCode = seac.baseFontCharCode;
                    accent = {
                      fontChar: String.fromCodePoint(seac.accentFontCharCode),
                      offset: seac.accentOffset
                    };
                  }
                  var fontChar = typeof fontCharCode === "number" ? String.fromCodePoint(fontCharCode) : "";
                  var glyph = this.glyphCache[charcode];
                  if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
                    glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
                    this.glyphCache[charcode] = glyph;
                  }
                  return glyph;
                },
                charsToGlyphs: function Font_charsToGlyphs(chars) {
                  var charsCache = this.charsCache;
                  var glyphs, glyph, charcode;
                  if (charsCache) {
                    glyphs = charsCache[chars];
                    if (glyphs) {
                      return glyphs;
                    }
                  }
                  if (!charsCache) {
                    charsCache = this.charsCache = /* @__PURE__ */ Object.create(null);
                  }
                  glyphs = [];
                  var charsCacheKey = chars;
                  var i2 = 0, ii;
                  if (this.cMap) {
                    var c2 = /* @__PURE__ */ Object.create(null);
                    while (i2 < chars.length) {
                      this.cMap.readCharCode(chars, i2, c2);
                      charcode = c2.charcode;
                      var length = c2.length;
                      i2 += length;
                      var isSpace = length === 1 && chars.charCodeAt(i2 - 1) === 32;
                      glyph = this.charToGlyph(charcode, isSpace);
                      glyphs.push(glyph);
                    }
                  } else {
                    for (i2 = 0, ii = chars.length; i2 < ii; ++i2) {
                      charcode = chars.charCodeAt(i2);
                      glyph = this.charToGlyph(charcode, charcode === 32);
                      glyphs.push(glyph);
                    }
                  }
                  return charsCache[charsCacheKey] = glyphs;
                },
                get glyphCacheValues() {
                  return Object.values(this.glyphCache);
                }
              };
              return Font2;
            }();
            exports3.Font = Font;
            var ErrorFont = function ErrorFontClosure() {
              function ErrorFont2(error) {
                this.error = error;
                this.loadedName = "g_font_error";
                this.missingFile = true;
              }
              ErrorFont2.prototype = {
                charsToGlyphs: function ErrorFont_charsToGlyphs() {
                  return [];
                },
                exportData: function ErrorFont_exportData() {
                  return {
                    error: this.error
                  };
                }
              };
              return ErrorFont2;
            }();
            exports3.ErrorFont = ErrorFont;
            function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
              var charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
              var glyphId, charCode, baseEncoding;
              var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
              if (properties.baseEncodingName) {
                baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                  glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              } else if (isSymbolicFont) {
                for (charCode in builtInEncoding) {
                  charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                }
              } else {
                baseEncoding = _encodings.StandardEncoding;
                for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                  glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              }
              var differences = properties.differences, glyphsUnicodeMap;
              if (differences) {
                for (charCode in differences) {
                  var glyphName = differences[charCode];
                  glyphId = glyphNames.indexOf(glyphName);
                  if (glyphId === -1) {
                    if (!glyphsUnicodeMap) {
                      glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    }
                    var standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                    if (standardGlyphName !== glyphName) {
                      glyphId = glyphNames.indexOf(standardGlyphName);
                    }
                  }
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              }
              return charCodeToGlyphId;
            }
            var Type1Font = function Type1FontClosure() {
              function findBlock(streamBytes, signature, startIndex) {
                var streamBytesLength = streamBytes.length;
                var signatureLength = signature.length;
                var scanLength = streamBytesLength - signatureLength;
                var i2 = startIndex, j2, found = false;
                while (i2 < scanLength) {
                  j2 = 0;
                  while (j2 < signatureLength && streamBytes[i2 + j2] === signature[j2]) {
                    j2++;
                  }
                  if (j2 >= signatureLength) {
                    i2 += j2;
                    while (i2 < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i2])) {
                      i2++;
                    }
                    found = true;
                    break;
                  }
                  i2++;
                }
                return {
                  found,
                  length: i2
                };
              }
              function getHeaderBlock(stream, suggestedLength) {
                var EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
                var streamStartPos = stream.pos;
                var headerBytes, headerBytesLength, block;
                try {
                  headerBytes = stream.getBytes(suggestedLength);
                  headerBytesLength = headerBytes.length;
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                }
                if (headerBytesLength === suggestedLength) {
                  block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
                  if (block.found && block.length === suggestedLength) {
                    return {
                      stream: new _stream.Stream(headerBytes),
                      length: suggestedLength
                    };
                  }
                }
                (0, _util2.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
                stream.pos = streamStartPos;
                var SCAN_BLOCK_LENGTH = 2048;
                var actualLength;
                while (true) {
                  var scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                  block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
                  if (block.length === 0) {
                    break;
                  }
                  stream.pos += block.length;
                  if (block.found) {
                    actualLength = stream.pos - streamStartPos;
                    break;
                  }
                }
                stream.pos = streamStartPos;
                if (actualLength) {
                  return {
                    stream: new _stream.Stream(stream.getBytes(actualLength)),
                    length: actualLength
                  };
                }
                (0, _util2.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
                return {
                  stream: new _stream.Stream(stream.getBytes(suggestedLength)),
                  length: suggestedLength
                };
              }
              function getEexecBlock(stream, suggestedLength) {
                var eexecBytes = stream.getBytes();
                return {
                  stream: new _stream.Stream(eexecBytes),
                  length: eexecBytes.length
                };
              }
              function Type1Font2(name, file, properties) {
                var PFB_HEADER_SIZE = 6;
                var headerBlockLength = properties.length1;
                var eexecBlockLength = properties.length2;
                var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                var pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
                if (pfbHeaderPresent) {
                  file.skip(PFB_HEADER_SIZE);
                  headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                }
                var headerBlock = getHeaderBlock(file, headerBlockLength);
                var headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
                headerBlockParser.extractFontHeader(properties);
                if (pfbHeaderPresent) {
                  pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                  eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                }
                var eexecBlock = getEexecBlock(file, eexecBlockLength);
                var eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
                var data = eexecBlockParser.extractFontProgram(properties);
                for (var info in data.properties) {
                  properties[info] = data.properties[info];
                }
                var charstrings = data.charstrings;
                var type2Charstrings = this.getType2Charstrings(charstrings);
                var subrs = this.getType2Subrs(data.subrs);
                this.charstrings = charstrings;
                this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                this.seacs = this.getSeacs(data.charstrings);
              }
              Type1Font2.prototype = {
                get numGlyphs() {
                  return this.charstrings.length + 1;
                },
                getCharset: function Type1Font_getCharset() {
                  var charset = [".notdef"];
                  var charstrings = this.charstrings;
                  for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    charset.push(charstrings[glyphId].glyphName);
                  }
                  return charset;
                },
                getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
                  var charstrings = this.charstrings;
                  var glyphNames = [".notdef"], glyphId;
                  for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    glyphNames.push(charstrings[glyphId].glyphName);
                  }
                  var encoding = properties.builtInEncoding;
                  if (encoding) {
                    var builtInEncoding = /* @__PURE__ */ Object.create(null);
                    for (var charCode in encoding) {
                      glyphId = glyphNames.indexOf(encoding[charCode]);
                      if (glyphId >= 0) {
                        builtInEncoding[charCode] = glyphId;
                      }
                    }
                  }
                  return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
                },
                hasGlyphId: function Type1Font_hasGlyphID(id) {
                  if (id < 0 || id >= this.numGlyphs) {
                    return false;
                  }
                  if (id === 0) {
                    return true;
                  }
                  var glyph = this.charstrings[id - 1];
                  return glyph.charstring.length > 0;
                },
                getSeacs: function Type1Font_getSeacs(charstrings) {
                  var i2, ii;
                  var seacMap = [];
                  for (i2 = 0, ii = charstrings.length; i2 < ii; i2++) {
                    var charstring = charstrings[i2];
                    if (charstring.seac) {
                      seacMap[i2 + 1] = charstring.seac;
                    }
                  }
                  return seacMap;
                },
                getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
                  var type2Charstrings = [];
                  for (var i2 = 0, ii = type1Charstrings.length; i2 < ii; i2++) {
                    type2Charstrings.push(type1Charstrings[i2].charstring);
                  }
                  return type2Charstrings;
                },
                getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
                  var bias = 0;
                  var count = type1Subrs.length;
                  if (count < 1133) {
                    bias = 107;
                  } else if (count < 33769) {
                    bias = 1131;
                  } else {
                    bias = 32768;
                  }
                  var type2Subrs = [];
                  var i2;
                  for (i2 = 0; i2 < bias; i2++) {
                    type2Subrs.push([11]);
                  }
                  for (i2 = 0; i2 < count; i2++) {
                    type2Subrs.push(type1Subrs[i2]);
                  }
                  return type2Subrs;
                },
                wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
                  var cff = new _cff_parser.CFF();
                  cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
                  cff.names = [name];
                  var topDict = new _cff_parser.CFFTopDict();
                  topDict.setByName("version", 391);
                  topDict.setByName("Notice", 392);
                  topDict.setByName("FullName", 393);
                  topDict.setByName("FamilyName", 394);
                  topDict.setByName("Weight", 395);
                  topDict.setByName("Encoding", null);
                  topDict.setByName("FontMatrix", properties.fontMatrix);
                  topDict.setByName("FontBBox", properties.bbox);
                  topDict.setByName("charset", null);
                  topDict.setByName("CharStrings", null);
                  topDict.setByName("Private", null);
                  cff.topDict = topDict;
                  var strings = new _cff_parser.CFFStrings();
                  strings.add("Version 0.11");
                  strings.add("See original notice");
                  strings.add(name);
                  strings.add(name);
                  strings.add("Medium");
                  cff.strings = strings;
                  cff.globalSubrIndex = new _cff_parser.CFFIndex();
                  var count = glyphs.length;
                  var charsetArray = [".notdef"];
                  var i2, ii;
                  for (i2 = 0; i2 < count; i2++) {
                    const glyphName = charstrings[i2].glyphName;
                    const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
                    if (index === -1) {
                      strings.add(glyphName);
                    }
                    charsetArray.push(glyphName);
                  }
                  cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
                  var charStringsIndex = new _cff_parser.CFFIndex();
                  charStringsIndex.add([139, 14]);
                  for (i2 = 0; i2 < count; i2++) {
                    charStringsIndex.add(glyphs[i2]);
                  }
                  cff.charStrings = charStringsIndex;
                  var privateDict = new _cff_parser.CFFPrivateDict();
                  privateDict.setByName("Subrs", null);
                  var fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
                  for (i2 = 0, ii = fields.length; i2 < ii; i2++) {
                    var field = fields[i2];
                    if (!(field in properties.privateData)) {
                      continue;
                    }
                    var value = properties.privateData[field];
                    if (Array.isArray(value)) {
                      for (var j2 = value.length - 1; j2 > 0; j2--) {
                        value[j2] -= value[j2 - 1];
                      }
                    }
                    privateDict.setByName(field, value);
                  }
                  cff.topDict.privateDict = privateDict;
                  var subrIndex = new _cff_parser.CFFIndex();
                  for (i2 = 0, ii = subrs.length; i2 < ii; i2++) {
                    subrIndex.add(subrs[i2]);
                  }
                  privateDict.subrsIndex = subrIndex;
                  var compiler = new _cff_parser.CFFCompiler(cff);
                  return compiler.compile();
                }
              };
              return Type1Font2;
            }();
            var CFFFont = function CFFFontClosure() {
              function CFFFont2(file, properties) {
                this.properties = properties;
                var parser = new _cff_parser.CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
                this.cff = parser.parse();
                this.cff.duplicateFirstGlyph();
                var compiler = new _cff_parser.CFFCompiler(this.cff);
                this.seacs = this.cff.seacs;
                try {
                  this.data = compiler.compile();
                } catch (e2) {
                  (0, _util2.warn)("Failed to compile font " + properties.loadedName);
                  this.data = file;
                }
              }
              CFFFont2.prototype = {
                get numGlyphs() {
                  return this.cff.charStrings.count;
                },
                getCharset: function CFFFont_getCharset() {
                  return this.cff.charset.charset;
                },
                getGlyphMapping: function CFFFont_getGlyphMapping() {
                  var cff = this.cff;
                  var properties = this.properties;
                  var charsets = cff.charset.charset;
                  var charCodeToGlyphId;
                  var glyphId;
                  if (properties.composite) {
                    charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    let charCode;
                    if (cff.isCIDFont) {
                      for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                        var cid = charsets[glyphId];
                        charCode = properties.cMap.charCodeOf(cid);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    } else {
                      for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                        charCode = properties.cMap.charCodeOf(glyphId);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    }
                    return charCodeToGlyphId;
                  }
                  var encoding = cff.encoding ? cff.encoding.encoding : null;
                  charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
                  return charCodeToGlyphId;
                },
                hasGlyphId: function CFFFont_hasGlyphID(id) {
                  return this.cff.hasGlyphId(id);
                }
              };
              return CFFFont2;
            }();
          },
          /* 28 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CFFFDSelect = exports3.CFFCompiler = exports3.CFFPrivateDict = exports3.CFFTopDict = exports3.CFFCharset = exports3.CFFIndex = exports3.CFFStrings = exports3.CFFHeader = exports3.CFF = exports3.CFFParser = exports3.CFFStandardStrings = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _charsets = __w_pdfjs_require__2(29);
            var _encodings = __w_pdfjs_require__2(30);
            var MAX_SUBR_NESTING = 10;
            var CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
            exports3.CFFStandardStrings = CFFStandardStrings;
            const NUM_STANDARD_CFF_STRINGS = 391;
            var CFFParser = function CFFParserClosure() {
              var CharstringValidationData = [null, {
                id: "hstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, null, {
                id: "vstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "vmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "rlineto",
                min: 2,
                resetStack: true
              }, {
                id: "hlineto",
                min: 1,
                resetStack: true
              }, {
                id: "vlineto",
                min: 1,
                resetStack: true
              }, {
                id: "rrcurveto",
                min: 6,
                resetStack: true
              }, null, {
                id: "callsubr",
                min: 1,
                undefStack: true
              }, {
                id: "return",
                min: 0,
                undefStack: true
              }, null, null, {
                id: "endchar",
                min: 0,
                stackClearing: true
              }, null, null, null, {
                id: "hstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "hintmask",
                min: 0,
                stackClearing: true
              }, {
                id: "cntrmask",
                min: 0,
                stackClearing: true
              }, {
                id: "rmoveto",
                min: 2,
                stackClearing: true
              }, {
                id: "hmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "vstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "rcurveline",
                min: 8,
                resetStack: true
              }, {
                id: "rlinecurve",
                min: 8,
                resetStack: true
              }, {
                id: "vvcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hhcurveto",
                min: 4,
                resetStack: true
              }, null, {
                id: "callgsubr",
                min: 1,
                undefStack: true
              }, {
                id: "vhcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hvcurveto",
                min: 4,
                resetStack: true
              }];
              var CharstringValidationData12 = [null, null, null, {
                id: "and",
                min: 2,
                stackDelta: -1
              }, {
                id: "or",
                min: 2,
                stackDelta: -1
              }, {
                id: "not",
                min: 1,
                stackDelta: 0
              }, null, null, null, {
                id: "abs",
                min: 1,
                stackDelta: 0
              }, {
                id: "add",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] + stack[index - 1];
                }
              }, {
                id: "sub",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] - stack[index - 1];
                }
              }, {
                id: "div",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] / stack[index - 1];
                }
              }, null, {
                id: "neg",
                min: 1,
                stackDelta: 0,
                stackFn: function stack_div(stack, index) {
                  stack[index - 1] = -stack[index - 1];
                }
              }, {
                id: "eq",
                min: 2,
                stackDelta: -1
              }, null, null, {
                id: "drop",
                min: 1,
                stackDelta: -1
              }, null, {
                id: "put",
                min: 2,
                stackDelta: -2
              }, {
                id: "get",
                min: 1,
                stackDelta: 0
              }, {
                id: "ifelse",
                min: 4,
                stackDelta: -3
              }, {
                id: "random",
                min: 0,
                stackDelta: 1
              }, {
                id: "mul",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] * stack[index - 1];
                }
              }, null, {
                id: "sqrt",
                min: 1,
                stackDelta: 0
              }, {
                id: "dup",
                min: 1,
                stackDelta: 1
              }, {
                id: "exch",
                min: 2,
                stackDelta: 0
              }, {
                id: "index",
                min: 2,
                stackDelta: 0
              }, {
                id: "roll",
                min: 3,
                stackDelta: -2
              }, null, null, null, {
                id: "hflex",
                min: 7,
                resetStack: true
              }, {
                id: "flex",
                min: 13,
                resetStack: true
              }, {
                id: "hflex1",
                min: 9,
                resetStack: true
              }, {
                id: "flex1",
                min: 11,
                resetStack: true
              }];
              function CFFParser2(file, properties, seacAnalysisEnabled) {
                this.bytes = file.getBytes();
                this.properties = properties;
                this.seacAnalysisEnabled = !!seacAnalysisEnabled;
              }
              CFFParser2.prototype = {
                parse: function CFFParser_parse() {
                  var properties = this.properties;
                  var cff = new CFF();
                  this.cff = cff;
                  var header = this.parseHeader();
                  var nameIndex = this.parseIndex(header.endPos);
                  var topDictIndex = this.parseIndex(nameIndex.endPos);
                  var stringIndex = this.parseIndex(topDictIndex.endPos);
                  var globalSubrIndex = this.parseIndex(stringIndex.endPos);
                  var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                  var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                  cff.header = header.obj;
                  cff.names = this.parseNameIndex(nameIndex.obj);
                  cff.strings = this.parseStringIndex(stringIndex.obj);
                  cff.topDict = topDict;
                  cff.globalSubrIndex = globalSubrIndex.obj;
                  this.parsePrivateDict(cff.topDict);
                  cff.isCIDFont = topDict.hasName("ROS");
                  var charStringOffset = topDict.getByName("CharStrings");
                  var charStringIndex = this.parseIndex(charStringOffset).obj;
                  var fontMatrix = topDict.getByName("FontMatrix");
                  if (fontMatrix) {
                    properties.fontMatrix = fontMatrix;
                  }
                  var fontBBox = topDict.getByName("FontBBox");
                  if (fontBBox) {
                    properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                    properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                    properties.ascentScaled = true;
                  }
                  var charset, encoding;
                  if (cff.isCIDFont) {
                    var fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
                    for (var i2 = 0, ii = fdArrayIndex.count; i2 < ii; ++i2) {
                      var dictRaw = fdArrayIndex.get(i2);
                      var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                      this.parsePrivateDict(fontDict);
                      cff.fdArray.push(fontDict);
                    }
                    encoding = null;
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
                    cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
                  } else {
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
                    encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
                  }
                  cff.charset = charset;
                  cff.encoding = encoding;
                  var charStringsAndSeacs = this.parseCharStrings({
                    charStrings: charStringIndex,
                    localSubrIndex: topDict.privateDict.subrsIndex,
                    globalSubrIndex: globalSubrIndex.obj,
                    fdSelect: cff.fdSelect,
                    fdArray: cff.fdArray,
                    privateDict: topDict.privateDict
                  });
                  cff.charStrings = charStringsAndSeacs.charStrings;
                  cff.seacs = charStringsAndSeacs.seacs;
                  cff.widths = charStringsAndSeacs.widths;
                  return cff;
                },
                parseHeader: function CFFParser_parseHeader() {
                  var bytes = this.bytes;
                  var bytesLength = bytes.length;
                  var offset = 0;
                  while (offset < bytesLength && bytes[offset] !== 1) {
                    ++offset;
                  }
                  if (offset >= bytesLength) {
                    throw new _util2.FormatError("Invalid CFF header");
                  }
                  if (offset !== 0) {
                    (0, _util2.info)("cff data is shifted");
                    bytes = bytes.subarray(offset);
                    this.bytes = bytes;
                  }
                  var major = bytes[0];
                  var minor = bytes[1];
                  var hdrSize = bytes[2];
                  var offSize = bytes[3];
                  var header = new CFFHeader(major, minor, hdrSize, offSize);
                  return {
                    obj: header,
                    endPos: hdrSize
                  };
                },
                parseDict: function CFFParser_parseDict(dict) {
                  var pos = 0;
                  function parseOperand() {
                    var value = dict[pos++];
                    if (value === 30) {
                      return parseFloatOperand();
                    } else if (value === 28) {
                      value = dict[pos++];
                      value = (value << 24 | dict[pos++] << 16) >> 16;
                      return value;
                    } else if (value === 29) {
                      value = dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      return value;
                    } else if (value >= 32 && value <= 246) {
                      return value - 139;
                    } else if (value >= 247 && value <= 250) {
                      return (value - 247) * 256 + dict[pos++] + 108;
                    } else if (value >= 251 && value <= 254) {
                      return -((value - 251) * 256) - dict[pos++] - 108;
                    }
                    (0, _util2.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
                    return NaN;
                  }
                  function parseFloatOperand() {
                    var str = "";
                    var eof = 15;
                    const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                    var length = dict.length;
                    while (pos < length) {
                      var b3 = dict[pos++];
                      var b1 = b3 >> 4;
                      var b22 = b3 & 15;
                      if (b1 === eof) {
                        break;
                      }
                      str += lookup[b1];
                      if (b22 === eof) {
                        break;
                      }
                      str += lookup[b22];
                    }
                    return parseFloat(str);
                  }
                  var operands = [];
                  var entries = [];
                  pos = 0;
                  var end = dict.length;
                  while (pos < end) {
                    var b2 = dict[pos];
                    if (b2 <= 21) {
                      if (b2 === 12) {
                        b2 = b2 << 8 | dict[++pos];
                      }
                      entries.push([b2, operands]);
                      operands = [];
                      ++pos;
                    } else {
                      operands.push(parseOperand());
                    }
                  }
                  return entries;
                },
                parseIndex: function CFFParser_parseIndex(pos) {
                  var cffIndex = new CFFIndex();
                  var bytes = this.bytes;
                  var count = bytes[pos++] << 8 | bytes[pos++];
                  var offsets = [];
                  var end = pos;
                  var i2, ii;
                  if (count !== 0) {
                    var offsetSize = bytes[pos++];
                    var startPos = pos + (count + 1) * offsetSize - 1;
                    for (i2 = 0, ii = count + 1; i2 < ii; ++i2) {
                      var offset = 0;
                      for (var j2 = 0; j2 < offsetSize; ++j2) {
                        offset <<= 8;
                        offset += bytes[pos++];
                      }
                      offsets.push(startPos + offset);
                    }
                    end = offsets[count];
                  }
                  for (i2 = 0, ii = offsets.length - 1; i2 < ii; ++i2) {
                    var offsetStart = offsets[i2];
                    var offsetEnd = offsets[i2 + 1];
                    cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                  }
                  return {
                    obj: cffIndex,
                    endPos: end
                  };
                },
                parseNameIndex: function CFFParser_parseNameIndex(index) {
                  var names = [];
                  for (var i2 = 0, ii = index.count; i2 < ii; ++i2) {
                    var name = index.get(i2);
                    names.push((0, _util2.bytesToString)(name));
                  }
                  return names;
                },
                parseStringIndex: function CFFParser_parseStringIndex(index) {
                  var strings = new CFFStrings();
                  for (var i2 = 0, ii = index.count; i2 < ii; ++i2) {
                    var data = index.get(i2);
                    strings.add((0, _util2.bytesToString)(data));
                  }
                  return strings;
                },
                createDict: function CFFParser_createDict(Type, dict, strings) {
                  var cffDict = new Type(strings);
                  for (var i2 = 0, ii = dict.length; i2 < ii; ++i2) {
                    var pair = dict[i2];
                    var key = pair[0];
                    var value = pair[1];
                    cffDict.setByKey(key, value);
                  }
                  return cffDict;
                },
                parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                  if (!data || state.callDepth > MAX_SUBR_NESTING) {
                    return false;
                  }
                  var stackSize = state.stackSize;
                  var stack = state.stack;
                  var length = data.length;
                  for (var j2 = 0; j2 < length; ) {
                    var value = data[j2++];
                    var validationCommand = null;
                    if (value === 12) {
                      var q2 = data[j2++];
                      if (q2 === 0) {
                        data[j2 - 2] = 139;
                        data[j2 - 1] = 22;
                        stackSize = 0;
                      } else {
                        validationCommand = CharstringValidationData12[q2];
                      }
                    } else if (value === 28) {
                      stack[stackSize] = (data[j2] << 24 | data[j2 + 1] << 16) >> 16;
                      j2 += 2;
                      stackSize++;
                    } else if (value === 14) {
                      if (stackSize >= 4) {
                        stackSize -= 4;
                        if (this.seacAnalysisEnabled) {
                          state.seac = stack.slice(stackSize, stackSize + 4);
                          return false;
                        }
                      }
                      validationCommand = CharstringValidationData[value];
                    } else if (value >= 32 && value <= 246) {
                      stack[stackSize] = value - 139;
                      stackSize++;
                    } else if (value >= 247 && value <= 254) {
                      stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j2] + 108 : -(value - 251 << 8) - data[j2] - 108;
                      j2++;
                      stackSize++;
                    } else if (value === 255) {
                      stack[stackSize] = (data[j2] << 24 | data[j2 + 1] << 16 | data[j2 + 2] << 8 | data[j2 + 3]) / 65536;
                      j2 += 4;
                      stackSize++;
                    } else if (value === 19 || value === 20) {
                      state.hints += stackSize >> 1;
                      j2 += state.hints + 7 >> 3;
                      stackSize %= 2;
                      validationCommand = CharstringValidationData[value];
                    } else if (value === 10 || value === 29) {
                      var subrsIndex;
                      if (value === 10) {
                        subrsIndex = localSubrIndex;
                      } else {
                        subrsIndex = globalSubrIndex;
                      }
                      if (!subrsIndex) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util2.warn)("Missing subrsIndex for " + validationCommand.id);
                        return false;
                      }
                      var bias = 32768;
                      if (subrsIndex.count < 1240) {
                        bias = 107;
                      } else if (subrsIndex.count < 33900) {
                        bias = 1131;
                      }
                      var subrNumber = stack[--stackSize] + bias;
                      if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util2.warn)("Out of bounds subrIndex for " + validationCommand.id);
                        return false;
                      }
                      state.stackSize = stackSize;
                      state.callDepth++;
                      var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                      if (!valid) {
                        return false;
                      }
                      state.callDepth--;
                      stackSize = state.stackSize;
                      continue;
                    } else if (value === 11) {
                      state.stackSize = stackSize;
                      return true;
                    } else {
                      validationCommand = CharstringValidationData[value];
                    }
                    if (validationCommand) {
                      if (validationCommand.stem) {
                        state.hints += stackSize >> 1;
                        if (value === 3 || value === 23) {
                          state.hasVStems = true;
                        } else if (state.hasVStems && (value === 1 || value === 18)) {
                          (0, _util2.warn)("CFF stem hints are in wrong order");
                          data[j2 - 1] = value === 1 ? 3 : 23;
                        }
                      }
                      if ("min" in validationCommand) {
                        if (!state.undefStack && stackSize < validationCommand.min) {
                          (0, _util2.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                          return false;
                        }
                      }
                      if (state.firstStackClearing && validationCommand.stackClearing) {
                        state.firstStackClearing = false;
                        stackSize -= validationCommand.min;
                        if (stackSize >= 2 && validationCommand.stem) {
                          stackSize %= 2;
                        } else if (stackSize > 1) {
                          (0, _util2.warn)("Found too many parameters for stack-clearing command");
                        }
                        if (stackSize > 0 && stack[stackSize - 1] >= 0) {
                          state.width = stack[stackSize - 1];
                        }
                      }
                      if ("stackDelta" in validationCommand) {
                        if ("stackFn" in validationCommand) {
                          validationCommand.stackFn(stack, stackSize);
                        }
                        stackSize += validationCommand.stackDelta;
                      } else if (validationCommand.stackClearing) {
                        stackSize = 0;
                      } else if (validationCommand.resetStack) {
                        stackSize = 0;
                        state.undefStack = false;
                      } else if (validationCommand.undefStack) {
                        stackSize = 0;
                        state.undefStack = true;
                        state.firstStackClearing = false;
                      }
                    }
                  }
                  state.stackSize = stackSize;
                  return true;
                },
                parseCharStrings({
                  charStrings,
                  localSubrIndex,
                  globalSubrIndex,
                  fdSelect,
                  fdArray,
                  privateDict
                }) {
                  var seacs = [];
                  var widths = [];
                  var count = charStrings.count;
                  for (var i2 = 0; i2 < count; i2++) {
                    var charstring = charStrings.get(i2);
                    var state = {
                      callDepth: 0,
                      stackSize: 0,
                      stack: [],
                      undefStack: true,
                      hints: 0,
                      firstStackClearing: true,
                      seac: null,
                      width: null,
                      hasVStems: false
                    };
                    var valid = true;
                    var localSubrToUse = null;
                    var privateDictToUse = privateDict;
                    if (fdSelect && fdArray.length) {
                      var fdIndex = fdSelect.getFDIndex(i2);
                      if (fdIndex === -1) {
                        (0, _util2.warn)("Glyph index is not in fd select.");
                        valid = false;
                      }
                      if (fdIndex >= fdArray.length) {
                        (0, _util2.warn)("Invalid fd index for glyph index.");
                        valid = false;
                      }
                      if (valid) {
                        privateDictToUse = fdArray[fdIndex].privateDict;
                        localSubrToUse = privateDictToUse.subrsIndex;
                      }
                    } else if (localSubrIndex) {
                      localSubrToUse = localSubrIndex;
                    }
                    if (valid) {
                      valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                    }
                    if (state.width !== null) {
                      const nominalWidth = privateDictToUse.getByName("nominalWidthX");
                      widths[i2] = nominalWidth + state.width;
                    } else {
                      const defaultWidth = privateDictToUse.getByName("defaultWidthX");
                      widths[i2] = defaultWidth;
                    }
                    if (state.seac !== null) {
                      seacs[i2] = state.seac;
                    }
                    if (!valid) {
                      charStrings.set(i2, new Uint8Array([14]));
                    }
                  }
                  return {
                    charStrings,
                    seacs,
                    widths
                  };
                },
                emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
                  var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                  parentDict.setByKey(18, [0, 0]);
                  parentDict.privateDict = privateDict;
                },
                parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
                  if (!parentDict.hasName("Private")) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var privateOffset = parentDict.getByName("Private");
                  if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
                    parentDict.removeByName("Private");
                    return;
                  }
                  var size = privateOffset[0];
                  var offset = privateOffset[1];
                  if (size === 0 || offset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var privateDictEnd = offset + size;
                  var dictData = this.bytes.subarray(offset, privateDictEnd);
                  var dict = this.parseDict(dictData);
                  var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                  parentDict.privateDict = privateDict;
                  if (!privateDict.getByName("Subrs")) {
                    return;
                  }
                  var subrsOffset = privateDict.getByName("Subrs");
                  var relativeOffset = offset + subrsOffset;
                  if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var subrsIndex = this.parseIndex(relativeOffset);
                  privateDict.subrsIndex = subrsIndex.obj;
                },
                parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
                  if (pos === 0) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
                  } else if (pos === 1) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
                  } else if (pos === 2) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
                  }
                  var bytes = this.bytes;
                  var start = pos;
                  var format = bytes[pos++];
                  var charset = [".notdef"];
                  var id, count, i2;
                  length -= 1;
                  switch (format) {
                    case 0:
                      for (i2 = 0; i2 < length; i2++) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        charset.push(cid ? id : strings.get(id));
                      }
                      break;
                    case 1:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++];
                        for (i2 = 0; i2 <= count; i2++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    case 2:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++] << 8 | bytes[pos++];
                        for (i2 = 0; i2 <= count; i2++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    default:
                      throw new _util2.FormatError("Unknown charset format");
                  }
                  var end = pos;
                  var raw = bytes.subarray(start, end);
                  return new CFFCharset(false, format, charset, raw);
                },
                parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
                  var encoding = /* @__PURE__ */ Object.create(null);
                  var bytes = this.bytes;
                  var predefined = false;
                  var format, i2, ii;
                  var raw = null;
                  function readSupplement() {
                    var supplementsCount = bytes[pos++];
                    for (i2 = 0; i2 < supplementsCount; i2++) {
                      var code = bytes[pos++];
                      var sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
                      encoding[code] = charset.indexOf(strings.get(sid));
                    }
                  }
                  if (pos === 0 || pos === 1) {
                    predefined = true;
                    format = pos;
                    var baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
                    for (i2 = 0, ii = charset.length; i2 < ii; i2++) {
                      var index = baseEncoding.indexOf(charset[i2]);
                      if (index !== -1) {
                        encoding[index] = i2;
                      }
                    }
                  } else {
                    var dataStart = pos;
                    format = bytes[pos++];
                    switch (format & 127) {
                      case 0:
                        var glyphsCount = bytes[pos++];
                        for (i2 = 1; i2 <= glyphsCount; i2++) {
                          encoding[bytes[pos++]] = i2;
                        }
                        break;
                      case 1:
                        var rangesCount = bytes[pos++];
                        var gid = 1;
                        for (i2 = 0; i2 < rangesCount; i2++) {
                          var start = bytes[pos++];
                          var left = bytes[pos++];
                          for (var j2 = start; j2 <= start + left; j2++) {
                            encoding[j2] = gid++;
                          }
                        }
                        break;
                      default:
                        throw new _util2.FormatError(`Unknown encoding format: ${format} in CFF`);
                    }
                    var dataEnd = pos;
                    if (format & 128) {
                      bytes[dataStart] &= 127;
                      readSupplement();
                    }
                    raw = bytes.subarray(dataStart, dataEnd);
                  }
                  format = format & 127;
                  return new CFFEncoding(predefined, format, encoding, raw);
                },
                parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
                  var bytes = this.bytes;
                  var format = bytes[pos++];
                  var fdSelect = [];
                  var i2;
                  switch (format) {
                    case 0:
                      for (i2 = 0; i2 < length; ++i2) {
                        var id = bytes[pos++];
                        fdSelect.push(id);
                      }
                      break;
                    case 3:
                      var rangesCount = bytes[pos++] << 8 | bytes[pos++];
                      for (i2 = 0; i2 < rangesCount; ++i2) {
                        var first = bytes[pos++] << 8 | bytes[pos++];
                        if (i2 === 0 && first !== 0) {
                          (0, _util2.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                          first = 0;
                        }
                        var fdIndex = bytes[pos++];
                        var next = bytes[pos] << 8 | bytes[pos + 1];
                        for (var j2 = first; j2 < next; ++j2) {
                          fdSelect.push(fdIndex);
                        }
                      }
                      pos += 2;
                      break;
                    default:
                      throw new _util2.FormatError(`parseFDSelect: Unknown format "${format}".`);
                  }
                  if (fdSelect.length !== length) {
                    throw new _util2.FormatError("parseFDSelect: Invalid font data.");
                  }
                  return new CFFFDSelect(format, fdSelect);
                }
              };
              return CFFParser2;
            }();
            exports3.CFFParser = CFFParser;
            var CFF = function CFFClosure() {
              function CFF2() {
                this.header = null;
                this.names = [];
                this.topDict = null;
                this.strings = new CFFStrings();
                this.globalSubrIndex = null;
                this.encoding = null;
                this.charset = null;
                this.charStrings = null;
                this.fdArray = [];
                this.fdSelect = null;
                this.isCIDFont = false;
              }
              CFF2.prototype = {
                duplicateFirstGlyph: function CFF_duplicateFirstGlyph() {
                  if (this.charStrings.count >= 65535) {
                    (0, _util2.warn)("Not enough space in charstrings to duplicate first glyph.");
                    return;
                  }
                  var glyphZero = this.charStrings.get(0);
                  this.charStrings.add(glyphZero);
                  if (this.isCIDFont) {
                    this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
                  }
                },
                hasGlyphId: function CFF_hasGlyphID(id) {
                  if (id < 0 || id >= this.charStrings.count) {
                    return false;
                  }
                  var glyph = this.charStrings.get(id);
                  return glyph.length > 0;
                }
              };
              return CFF2;
            }();
            exports3.CFF = CFF;
            var CFFHeader = function CFFHeaderClosure() {
              function CFFHeader2(major, minor, hdrSize, offSize) {
                this.major = major;
                this.minor = minor;
                this.hdrSize = hdrSize;
                this.offSize = offSize;
              }
              return CFFHeader2;
            }();
            exports3.CFFHeader = CFFHeader;
            var CFFStrings = function CFFStringsClosure() {
              function CFFStrings2() {
                this.strings = [];
              }
              CFFStrings2.prototype = {
                get: function CFFStrings_get(index) {
                  if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
                    return CFFStandardStrings[index];
                  }
                  if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
                    return this.strings[index - NUM_STANDARD_CFF_STRINGS];
                  }
                  return CFFStandardStrings[0];
                },
                getSID: function CFFStrings_getSID(str) {
                  let index = CFFStandardStrings.indexOf(str);
                  if (index !== -1) {
                    return index;
                  }
                  index = this.strings.indexOf(str);
                  if (index !== -1) {
                    return index + NUM_STANDARD_CFF_STRINGS;
                  }
                  return -1;
                },
                add: function CFFStrings_add(value) {
                  this.strings.push(value);
                },
                get count() {
                  return this.strings.length;
                }
              };
              return CFFStrings2;
            }();
            exports3.CFFStrings = CFFStrings;
            var CFFIndex = function CFFIndexClosure() {
              function CFFIndex2() {
                this.objects = [];
                this.length = 0;
              }
              CFFIndex2.prototype = {
                add: function CFFIndex_add(data) {
                  this.length += data.length;
                  this.objects.push(data);
                },
                set: function CFFIndex_set(index, data) {
                  this.length += data.length - this.objects[index].length;
                  this.objects[index] = data;
                },
                get: function CFFIndex_get(index) {
                  return this.objects[index];
                },
                get count() {
                  return this.objects.length;
                }
              };
              return CFFIndex2;
            }();
            exports3.CFFIndex = CFFIndex;
            var CFFDict = function CFFDictClosure() {
              function CFFDict2(tables, strings) {
                this.keyToNameMap = tables.keyToNameMap;
                this.nameToKeyMap = tables.nameToKeyMap;
                this.defaults = tables.defaults;
                this.types = tables.types;
                this.opcodes = tables.opcodes;
                this.order = tables.order;
                this.strings = strings;
                this.values = /* @__PURE__ */ Object.create(null);
              }
              CFFDict2.prototype = {
                setByKey: function CFFDict_setByKey(key, value) {
                  if (!(key in this.keyToNameMap)) {
                    return false;
                  }
                  var valueLength = value.length;
                  if (valueLength === 0) {
                    return true;
                  }
                  for (var i2 = 0; i2 < valueLength; i2++) {
                    if (isNaN(value[i2])) {
                      (0, _util2.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
                      return true;
                    }
                  }
                  var type = this.types[key];
                  if (type === "num" || type === "sid" || type === "offset") {
                    value = value[0];
                  }
                  this.values[key] = value;
                  return true;
                },
                setByName: function CFFDict_setByName(name, value) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util2.FormatError(`Invalid dictionary name "${name}"`);
                  }
                  this.values[this.nameToKeyMap[name]] = value;
                },
                hasName: function CFFDict_hasName(name) {
                  return this.nameToKeyMap[name] in this.values;
                },
                getByName: function CFFDict_getByName(name) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util2.FormatError(`Invalid dictionary name ${name}"`);
                  }
                  var key = this.nameToKeyMap[name];
                  if (!(key in this.values)) {
                    return this.defaults[key];
                  }
                  return this.values[key];
                },
                removeByName: function CFFDict_removeByName(name) {
                  delete this.values[this.nameToKeyMap[name]];
                }
              };
              CFFDict2.createTables = function CFFDict_createTables(layout) {
                var tables = {
                  keyToNameMap: {},
                  nameToKeyMap: {},
                  defaults: {},
                  types: {},
                  opcodes: {},
                  order: []
                };
                for (var i2 = 0, ii = layout.length; i2 < ii; ++i2) {
                  var entry = layout[i2];
                  var key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                  tables.keyToNameMap[key] = entry[1];
                  tables.nameToKeyMap[entry[1]] = key;
                  tables.types[key] = entry[2];
                  tables.defaults[key] = entry[3];
                  tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
                  tables.order.push(key);
                }
                return tables;
              };
              return CFFDict2;
            }();
            var CFFTopDict = function CFFTopDictClosure() {
              var layout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
              var tables = null;
              function CFFTopDict2(strings) {
                if (tables === null) {
                  tables = CFFDict.createTables(layout);
                }
                CFFDict.call(this, tables, strings);
                this.privateDict = null;
              }
              CFFTopDict2.prototype = Object.create(CFFDict.prototype);
              return CFFTopDict2;
            }();
            exports3.CFFTopDict = CFFTopDict;
            var CFFPrivateDict = function CFFPrivateDictClosure() {
              var layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
              var tables = null;
              function CFFPrivateDict2(strings) {
                if (tables === null) {
                  tables = CFFDict.createTables(layout);
                }
                CFFDict.call(this, tables, strings);
                this.subrsIndex = null;
              }
              CFFPrivateDict2.prototype = Object.create(CFFDict.prototype);
              return CFFPrivateDict2;
            }();
            exports3.CFFPrivateDict = CFFPrivateDict;
            var CFFCharsetPredefinedTypes = {
              ISO_ADOBE: 0,
              EXPERT: 1,
              EXPERT_SUBSET: 2
            };
            var CFFCharset = function CFFCharsetClosure() {
              function CFFCharset2(predefined, format, charset, raw) {
                this.predefined = predefined;
                this.format = format;
                this.charset = charset;
                this.raw = raw;
              }
              return CFFCharset2;
            }();
            exports3.CFFCharset = CFFCharset;
            var CFFEncoding = function CFFEncodingClosure() {
              function CFFEncoding2(predefined, format, encoding, raw) {
                this.predefined = predefined;
                this.format = format;
                this.encoding = encoding;
                this.raw = raw;
              }
              return CFFEncoding2;
            }();
            var CFFFDSelect = function CFFFDSelectClosure() {
              function CFFFDSelect2(format, fdSelect) {
                this.format = format;
                this.fdSelect = fdSelect;
              }
              CFFFDSelect2.prototype = {
                getFDIndex: function CFFFDSelect_get(glyphIndex) {
                  if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                    return -1;
                  }
                  return this.fdSelect[glyphIndex];
                }
              };
              return CFFFDSelect2;
            }();
            exports3.CFFFDSelect = CFFFDSelect;
            var CFFOffsetTracker = function CFFOffsetTrackerClosure() {
              function CFFOffsetTracker2() {
                this.offsets = /* @__PURE__ */ Object.create(null);
              }
              CFFOffsetTracker2.prototype = {
                isTracking: function CFFOffsetTracker_isTracking(key) {
                  return key in this.offsets;
                },
                track: function CFFOffsetTracker_track(key, location) {
                  if (key in this.offsets) {
                    throw new _util2.FormatError(`Already tracking location of ${key}`);
                  }
                  this.offsets[key] = location;
                },
                offset: function CFFOffsetTracker_offset(value) {
                  for (var key in this.offsets) {
                    this.offsets[key] += value;
                  }
                },
                setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
                  if (!(key in this.offsets)) {
                    throw new _util2.FormatError(`Not tracking location of ${key}`);
                  }
                  var data = output.data;
                  var dataOffset = this.offsets[key];
                  var size = 5;
                  for (var i2 = 0, ii = values.length; i2 < ii; ++i2) {
                    var offset0 = i2 * size + dataOffset;
                    var offset1 = offset0 + 1;
                    var offset2 = offset0 + 2;
                    var offset3 = offset0 + 3;
                    var offset4 = offset0 + 4;
                    if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                      throw new _util2.FormatError("writing to an offset that is not empty");
                    }
                    var value = values[i2];
                    data[offset0] = 29;
                    data[offset1] = value >> 24 & 255;
                    data[offset2] = value >> 16 & 255;
                    data[offset3] = value >> 8 & 255;
                    data[offset4] = value & 255;
                  }
                }
              };
              return CFFOffsetTracker2;
            }();
            var CFFCompiler = function CFFCompilerClosure() {
              function CFFCompiler2(cff) {
                this.cff = cff;
              }
              CFFCompiler2.prototype = {
                compile: function CFFCompiler_compile() {
                  var cff = this.cff;
                  var output = {
                    data: [],
                    length: 0,
                    add: function CFFCompiler_add(data) {
                      this.data = this.data.concat(data);
                      this.length = this.data.length;
                    }
                  };
                  var header = this.compileHeader(cff.header);
                  output.add(header);
                  var nameIndex = this.compileNameIndex(cff.names);
                  output.add(nameIndex);
                  if (cff.isCIDFont) {
                    if (cff.topDict.hasName("FontMatrix")) {
                      var base = cff.topDict.getByName("FontMatrix");
                      cff.topDict.removeByName("FontMatrix");
                      for (var i2 = 0, ii = cff.fdArray.length; i2 < ii; i2++) {
                        var subDict = cff.fdArray[i2];
                        var matrix = base.slice(0);
                        if (subDict.hasName("FontMatrix")) {
                          matrix = _util2.Util.transform(matrix, subDict.getByName("FontMatrix"));
                        }
                        subDict.setByName("FontMatrix", matrix);
                      }
                    }
                  }
                  cff.topDict.setByName("charset", 0);
                  var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                  output.add(compiled.output);
                  var topDictTracker = compiled.trackers[0];
                  var stringIndex = this.compileStringIndex(cff.strings.strings);
                  output.add(stringIndex);
                  var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                  output.add(globalSubrIndex);
                  if (cff.encoding && cff.topDict.hasName("Encoding")) {
                    if (cff.encoding.predefined) {
                      topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
                    } else {
                      var encoding = this.compileEncoding(cff.encoding);
                      topDictTracker.setEntryLocation("Encoding", [output.length], output);
                      output.add(encoding);
                    }
                  }
                  var charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
                  topDictTracker.setEntryLocation("charset", [output.length], output);
                  output.add(charset);
                  var charStrings = this.compileCharStrings(cff.charStrings);
                  topDictTracker.setEntryLocation("CharStrings", [output.length], output);
                  output.add(charStrings);
                  if (cff.isCIDFont) {
                    topDictTracker.setEntryLocation("FDSelect", [output.length], output);
                    var fdSelect = this.compileFDSelect(cff.fdSelect);
                    output.add(fdSelect);
                    compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                    topDictTracker.setEntryLocation("FDArray", [output.length], output);
                    output.add(compiled.output);
                    var fontDictTrackers = compiled.trackers;
                    this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                  }
                  this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                  output.add([0]);
                  return output.data;
                },
                encodeNumber: function CFFCompiler_encodeNumber(value) {
                  if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
                    return this.encodeInteger(value);
                  }
                  return this.encodeFloat(value);
                },
                encodeFloat: function CFFCompiler_encodeFloat(num) {
                  var value = num.toString();
                  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                  if (m) {
                    var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
                    value = (Math.round(num * epsilon) / epsilon).toString();
                  }
                  var nibbles = "";
                  var i2, ii;
                  for (i2 = 0, ii = value.length; i2 < ii; ++i2) {
                    var a2 = value[i2];
                    if (a2 === "e") {
                      nibbles += value[++i2] === "-" ? "c" : "b";
                    } else if (a2 === ".") {
                      nibbles += "a";
                    } else if (a2 === "-") {
                      nibbles += "e";
                    } else {
                      nibbles += a2;
                    }
                  }
                  nibbles += nibbles.length & 1 ? "f" : "ff";
                  var out = [30];
                  for (i2 = 0, ii = nibbles.length; i2 < ii; i2 += 2) {
                    out.push(parseInt(nibbles.substring(i2, i2 + 2), 16));
                  }
                  return out;
                },
                encodeInteger: function CFFCompiler_encodeInteger(value) {
                  var code;
                  if (value >= -107 && value <= 107) {
                    code = [value + 139];
                  } else if (value >= 108 && value <= 1131) {
                    value = value - 108;
                    code = [(value >> 8) + 247, value & 255];
                  } else if (value >= -1131 && value <= -108) {
                    value = -value - 108;
                    code = [(value >> 8) + 251, value & 255];
                  } else if (value >= -32768 && value <= 32767) {
                    code = [28, value >> 8 & 255, value & 255];
                  } else {
                    code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
                  }
                  return code;
                },
                compileHeader: function CFFCompiler_compileHeader(header) {
                  return [header.major, header.minor, header.hdrSize, header.offSize];
                },
                compileNameIndex: function CFFCompiler_compileNameIndex(names) {
                  var nameIndex = new CFFIndex();
                  for (var i2 = 0, ii = names.length; i2 < ii; ++i2) {
                    var name = names[i2];
                    var length = Math.min(name.length, 127);
                    var sanitizedName = new Array(length);
                    for (var j2 = 0; j2 < length; j2++) {
                      var char = name[j2];
                      if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
                        char = "_";
                      }
                      sanitizedName[j2] = char;
                    }
                    sanitizedName = sanitizedName.join("");
                    if (sanitizedName === "") {
                      sanitizedName = "Bad_Font_Name";
                    }
                    nameIndex.add((0, _util2.stringToBytes)(sanitizedName));
                  }
                  return this.compileIndex(nameIndex);
                },
                compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
                  var fontDictTrackers = [];
                  var fdArrayIndex = new CFFIndex();
                  for (var i2 = 0, ii = dicts.length; i2 < ii; ++i2) {
                    var fontDict = dicts[i2];
                    if (removeCidKeys) {
                      fontDict.removeByName("CIDFontVersion");
                      fontDict.removeByName("CIDFontRevision");
                      fontDict.removeByName("CIDFontType");
                      fontDict.removeByName("CIDCount");
                      fontDict.removeByName("UIDBase");
                    }
                    var fontDictTracker = new CFFOffsetTracker();
                    var fontDictData = this.compileDict(fontDict, fontDictTracker);
                    fontDictTrackers.push(fontDictTracker);
                    fdArrayIndex.add(fontDictData);
                    fontDictTracker.offset(length);
                  }
                  fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                  return {
                    trackers: fontDictTrackers,
                    output: fdArrayIndex
                  };
                },
                compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
                  for (var i2 = 0, ii = dicts.length; i2 < ii; ++i2) {
                    var fontDict = dicts[i2];
                    var privateDict = fontDict.privateDict;
                    if (!privateDict || !fontDict.hasName("Private")) {
                      throw new _util2.FormatError("There must be a private dictionary.");
                    }
                    var privateDictTracker = new CFFOffsetTracker();
                    var privateDictData = this.compileDict(privateDict, privateDictTracker);
                    var outputLength = output.length;
                    privateDictTracker.offset(outputLength);
                    if (!privateDictData.length) {
                      outputLength = 0;
                    }
                    trackers[i2].setEntryLocation("Private", [privateDictData.length, outputLength], output);
                    output.add(privateDictData);
                    if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
                      var subrs = this.compileIndex(privateDict.subrsIndex);
                      privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
                      output.add(subrs);
                    }
                  }
                },
                compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
                  var out = [];
                  var order = dict.order;
                  for (var i2 = 0; i2 < order.length; ++i2) {
                    var key = order[i2];
                    if (!(key in dict.values)) {
                      continue;
                    }
                    var values = dict.values[key];
                    var types = dict.types[key];
                    if (!Array.isArray(types)) {
                      types = [types];
                    }
                    if (!Array.isArray(values)) {
                      values = [values];
                    }
                    if (values.length === 0) {
                      continue;
                    }
                    for (var j2 = 0, jj = types.length; j2 < jj; ++j2) {
                      var type = types[j2];
                      var value = values[j2];
                      switch (type) {
                        case "num":
                        case "sid":
                          out = out.concat(this.encodeNumber(value));
                          break;
                        case "offset":
                          var name = dict.keyToNameMap[key];
                          if (!offsetTracker.isTracking(name)) {
                            offsetTracker.track(name, out.length);
                          }
                          out = out.concat([29, 0, 0, 0, 0]);
                          break;
                        case "array":
                        case "delta":
                          out = out.concat(this.encodeNumber(value));
                          for (var k2 = 1, kk = values.length; k2 < kk; ++k2) {
                            out = out.concat(this.encodeNumber(values[k2]));
                          }
                          break;
                        default:
                          throw new _util2.FormatError(`Unknown data type of ${type}`);
                      }
                    }
                    out = out.concat(dict.opcodes[key]);
                  }
                  return out;
                },
                compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
                  var stringIndex = new CFFIndex();
                  for (var i2 = 0, ii = strings.length; i2 < ii; ++i2) {
                    stringIndex.add((0, _util2.stringToBytes)(strings[i2]));
                  }
                  return this.compileIndex(stringIndex);
                },
                compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
                  var globalSubrIndex = this.cff.globalSubrIndex;
                  this.out.writeByteArray(this.compileIndex(globalSubrIndex));
                },
                compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
                  var charStringsIndex = new CFFIndex();
                  for (var i2 = 0; i2 < charStrings.count; i2++) {
                    var glyph = charStrings.get(i2);
                    if (glyph.length === 0) {
                      charStringsIndex.add(new Uint8Array([139, 14]));
                      continue;
                    }
                    charStringsIndex.add(glyph);
                  }
                  return this.compileIndex(charStringsIndex);
                },
                compileCharset: function CFFCompiler_compileCharset(charset, numGlyphs, strings, isCIDFont) {
                  let out;
                  const numGlyphsLessNotDef = numGlyphs - 1;
                  if (isCIDFont) {
                    out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 255, numGlyphsLessNotDef & 255]);
                  } else {
                    const length = 1 + numGlyphsLessNotDef * 2;
                    out = new Uint8Array(length);
                    out[0] = 0;
                    let charsetIndex = 0;
                    const numCharsets = charset.charset.length;
                    let warned = false;
                    for (let i2 = 1; i2 < out.length; i2 += 2) {
                      let sid = 0;
                      if (charsetIndex < numCharsets) {
                        const name = charset.charset[charsetIndex++];
                        sid = strings.getSID(name);
                        if (sid === -1) {
                          sid = 0;
                          if (!warned) {
                            warned = true;
                            (0, _util2.warn)(`Couldn't find ${name} in CFF strings`);
                          }
                        }
                      }
                      out[i2] = sid >> 8 & 255;
                      out[i2 + 1] = sid & 255;
                    }
                  }
                  return this.compileTypedArray(out);
                },
                compileEncoding: function CFFCompiler_compileEncoding(encoding) {
                  return this.compileTypedArray(encoding.raw);
                },
                compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
                  const format = fdSelect.format;
                  let out, i2;
                  switch (format) {
                    case 0:
                      out = new Uint8Array(1 + fdSelect.fdSelect.length);
                      out[0] = format;
                      for (i2 = 0; i2 < fdSelect.fdSelect.length; i2++) {
                        out[i2 + 1] = fdSelect.fdSelect[i2];
                      }
                      break;
                    case 3:
                      const start = 0;
                      let lastFD = fdSelect.fdSelect[0];
                      const ranges = [format, 0, 0, start >> 8 & 255, start & 255, lastFD];
                      for (i2 = 1; i2 < fdSelect.fdSelect.length; i2++) {
                        const currentFD = fdSelect.fdSelect[i2];
                        if (currentFD !== lastFD) {
                          ranges.push(i2 >> 8 & 255, i2 & 255, currentFD);
                          lastFD = currentFD;
                        }
                      }
                      const numRanges = (ranges.length - 3) / 3;
                      ranges[1] = numRanges >> 8 & 255;
                      ranges[2] = numRanges & 255;
                      ranges.push(i2 >> 8 & 255, i2 & 255);
                      out = new Uint8Array(ranges);
                      break;
                  }
                  return this.compileTypedArray(out);
                },
                compileTypedArray: function CFFCompiler_compileTypedArray(data) {
                  var out = [];
                  for (var i2 = 0, ii = data.length; i2 < ii; ++i2) {
                    out[i2] = data[i2];
                  }
                  return out;
                },
                compileIndex: function CFFCompiler_compileIndex(index, trackers) {
                  trackers = trackers || [];
                  var objects = index.objects;
                  var count = objects.length;
                  if (count === 0) {
                    return [0, 0, 0];
                  }
                  var data = [count >> 8 & 255, count & 255];
                  var lastOffset = 1, i2;
                  for (i2 = 0; i2 < count; ++i2) {
                    lastOffset += objects[i2].length;
                  }
                  var offsetSize;
                  if (lastOffset < 256) {
                    offsetSize = 1;
                  } else if (lastOffset < 65536) {
                    offsetSize = 2;
                  } else if (lastOffset < 16777216) {
                    offsetSize = 3;
                  } else {
                    offsetSize = 4;
                  }
                  data.push(offsetSize);
                  var relativeOffset = 1;
                  for (i2 = 0; i2 < count + 1; i2++) {
                    if (offsetSize === 1) {
                      data.push(relativeOffset & 255);
                    } else if (offsetSize === 2) {
                      data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else if (offsetSize === 3) {
                      data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else {
                      data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    }
                    if (objects[i2]) {
                      relativeOffset += objects[i2].length;
                    }
                  }
                  for (i2 = 0; i2 < count; i2++) {
                    if (trackers[i2]) {
                      trackers[i2].offset(data.length);
                    }
                    for (var j2 = 0, jj = objects[i2].length; j2 < jj; j2++) {
                      data.push(objects[i2][j2]);
                    }
                  }
                  return data;
                }
              };
              return CFFCompiler2;
            }();
            exports3.CFFCompiler = CFFCompiler;
          },
          /* 29 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ExpertSubsetCharset = exports3.ExpertCharset = exports3.ISOAdobeCharset = void 0;
            const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
            exports3.ISOAdobeCharset = ISOAdobeCharset;
            const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            exports3.ExpertCharset = ExpertCharset;
            const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
            exports3.ExpertSubsetCharset = ExpertSubsetCharset;
          },
          /* 30 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getEncoding = getEncoding;
            exports3.ExpertEncoding = exports3.ZapfDingbatsEncoding = exports3.SymbolSetEncoding = exports3.MacRomanEncoding = exports3.StandardEncoding = exports3.WinAnsiEncoding = void 0;
            const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            exports3.ExpertEncoding = ExpertEncoding;
            const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
            const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
            exports3.MacRomanEncoding = MacRomanEncoding;
            const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
            exports3.StandardEncoding = StandardEncoding;
            const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
            exports3.WinAnsiEncoding = WinAnsiEncoding;
            const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
            exports3.SymbolSetEncoding = SymbolSetEncoding;
            const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
            exports3.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
            function getEncoding(encodingName) {
              switch (encodingName) {
                case "WinAnsiEncoding":
                  return WinAnsiEncoding;
                case "StandardEncoding":
                  return StandardEncoding;
                case "MacRomanEncoding":
                  return MacRomanEncoding;
                case "SymbolSetEncoding":
                  return SymbolSetEncoding;
                case "ZapfDingbatsEncoding":
                  return ZapfDingbatsEncoding;
                case "ExpertEncoding":
                  return ExpertEncoding;
                case "MacExpertEncoding":
                  return MacExpertEncoding;
                default:
                  return null;
              }
            }
          },
          /* 31 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            var getLookupTableFactory = __w_pdfjs_require__2(7).getLookupTableFactory;
            var getGlyphsUnicode = getLookupTableFactory(function(t2) {
              t2["A"] = 65;
              t2["AE"] = 198;
              t2["AEacute"] = 508;
              t2["AEmacron"] = 482;
              t2["AEsmall"] = 63462;
              t2["Aacute"] = 193;
              t2["Aacutesmall"] = 63457;
              t2["Abreve"] = 258;
              t2["Abreveacute"] = 7854;
              t2["Abrevecyrillic"] = 1232;
              t2["Abrevedotbelow"] = 7862;
              t2["Abrevegrave"] = 7856;
              t2["Abrevehookabove"] = 7858;
              t2["Abrevetilde"] = 7860;
              t2["Acaron"] = 461;
              t2["Acircle"] = 9398;
              t2["Acircumflex"] = 194;
              t2["Acircumflexacute"] = 7844;
              t2["Acircumflexdotbelow"] = 7852;
              t2["Acircumflexgrave"] = 7846;
              t2["Acircumflexhookabove"] = 7848;
              t2["Acircumflexsmall"] = 63458;
              t2["Acircumflextilde"] = 7850;
              t2["Acute"] = 63177;
              t2["Acutesmall"] = 63412;
              t2["Acyrillic"] = 1040;
              t2["Adblgrave"] = 512;
              t2["Adieresis"] = 196;
              t2["Adieresiscyrillic"] = 1234;
              t2["Adieresismacron"] = 478;
              t2["Adieresissmall"] = 63460;
              t2["Adotbelow"] = 7840;
              t2["Adotmacron"] = 480;
              t2["Agrave"] = 192;
              t2["Agravesmall"] = 63456;
              t2["Ahookabove"] = 7842;
              t2["Aiecyrillic"] = 1236;
              t2["Ainvertedbreve"] = 514;
              t2["Alpha"] = 913;
              t2["Alphatonos"] = 902;
              t2["Amacron"] = 256;
              t2["Amonospace"] = 65313;
              t2["Aogonek"] = 260;
              t2["Aring"] = 197;
              t2["Aringacute"] = 506;
              t2["Aringbelow"] = 7680;
              t2["Aringsmall"] = 63461;
              t2["Asmall"] = 63329;
              t2["Atilde"] = 195;
              t2["Atildesmall"] = 63459;
              t2["Aybarmenian"] = 1329;
              t2["B"] = 66;
              t2["Bcircle"] = 9399;
              t2["Bdotaccent"] = 7682;
              t2["Bdotbelow"] = 7684;
              t2["Becyrillic"] = 1041;
              t2["Benarmenian"] = 1330;
              t2["Beta"] = 914;
              t2["Bhook"] = 385;
              t2["Blinebelow"] = 7686;
              t2["Bmonospace"] = 65314;
              t2["Brevesmall"] = 63220;
              t2["Bsmall"] = 63330;
              t2["Btopbar"] = 386;
              t2["C"] = 67;
              t2["Caarmenian"] = 1342;
              t2["Cacute"] = 262;
              t2["Caron"] = 63178;
              t2["Caronsmall"] = 63221;
              t2["Ccaron"] = 268;
              t2["Ccedilla"] = 199;
              t2["Ccedillaacute"] = 7688;
              t2["Ccedillasmall"] = 63463;
              t2["Ccircle"] = 9400;
              t2["Ccircumflex"] = 264;
              t2["Cdot"] = 266;
              t2["Cdotaccent"] = 266;
              t2["Cedillasmall"] = 63416;
              t2["Chaarmenian"] = 1353;
              t2["Cheabkhasiancyrillic"] = 1212;
              t2["Checyrillic"] = 1063;
              t2["Chedescenderabkhasiancyrillic"] = 1214;
              t2["Chedescendercyrillic"] = 1206;
              t2["Chedieresiscyrillic"] = 1268;
              t2["Cheharmenian"] = 1347;
              t2["Chekhakassiancyrillic"] = 1227;
              t2["Cheverticalstrokecyrillic"] = 1208;
              t2["Chi"] = 935;
              t2["Chook"] = 391;
              t2["Circumflexsmall"] = 63222;
              t2["Cmonospace"] = 65315;
              t2["Coarmenian"] = 1361;
              t2["Csmall"] = 63331;
              t2["D"] = 68;
              t2["DZ"] = 497;
              t2["DZcaron"] = 452;
              t2["Daarmenian"] = 1332;
              t2["Dafrican"] = 393;
              t2["Dcaron"] = 270;
              t2["Dcedilla"] = 7696;
              t2["Dcircle"] = 9401;
              t2["Dcircumflexbelow"] = 7698;
              t2["Dcroat"] = 272;
              t2["Ddotaccent"] = 7690;
              t2["Ddotbelow"] = 7692;
              t2["Decyrillic"] = 1044;
              t2["Deicoptic"] = 1006;
              t2["Delta"] = 8710;
              t2["Deltagreek"] = 916;
              t2["Dhook"] = 394;
              t2["Dieresis"] = 63179;
              t2["DieresisAcute"] = 63180;
              t2["DieresisGrave"] = 63181;
              t2["Dieresissmall"] = 63400;
              t2["Digammagreek"] = 988;
              t2["Djecyrillic"] = 1026;
              t2["Dlinebelow"] = 7694;
              t2["Dmonospace"] = 65316;
              t2["Dotaccentsmall"] = 63223;
              t2["Dslash"] = 272;
              t2["Dsmall"] = 63332;
              t2["Dtopbar"] = 395;
              t2["Dz"] = 498;
              t2["Dzcaron"] = 453;
              t2["Dzeabkhasiancyrillic"] = 1248;
              t2["Dzecyrillic"] = 1029;
              t2["Dzhecyrillic"] = 1039;
              t2["E"] = 69;
              t2["Eacute"] = 201;
              t2["Eacutesmall"] = 63465;
              t2["Ebreve"] = 276;
              t2["Ecaron"] = 282;
              t2["Ecedillabreve"] = 7708;
              t2["Echarmenian"] = 1333;
              t2["Ecircle"] = 9402;
              t2["Ecircumflex"] = 202;
              t2["Ecircumflexacute"] = 7870;
              t2["Ecircumflexbelow"] = 7704;
              t2["Ecircumflexdotbelow"] = 7878;
              t2["Ecircumflexgrave"] = 7872;
              t2["Ecircumflexhookabove"] = 7874;
              t2["Ecircumflexsmall"] = 63466;
              t2["Ecircumflextilde"] = 7876;
              t2["Ecyrillic"] = 1028;
              t2["Edblgrave"] = 516;
              t2["Edieresis"] = 203;
              t2["Edieresissmall"] = 63467;
              t2["Edot"] = 278;
              t2["Edotaccent"] = 278;
              t2["Edotbelow"] = 7864;
              t2["Efcyrillic"] = 1060;
              t2["Egrave"] = 200;
              t2["Egravesmall"] = 63464;
              t2["Eharmenian"] = 1335;
              t2["Ehookabove"] = 7866;
              t2["Eightroman"] = 8551;
              t2["Einvertedbreve"] = 518;
              t2["Eiotifiedcyrillic"] = 1124;
              t2["Elcyrillic"] = 1051;
              t2["Elevenroman"] = 8554;
              t2["Emacron"] = 274;
              t2["Emacronacute"] = 7702;
              t2["Emacrongrave"] = 7700;
              t2["Emcyrillic"] = 1052;
              t2["Emonospace"] = 65317;
              t2["Encyrillic"] = 1053;
              t2["Endescendercyrillic"] = 1186;
              t2["Eng"] = 330;
              t2["Enghecyrillic"] = 1188;
              t2["Enhookcyrillic"] = 1223;
              t2["Eogonek"] = 280;
              t2["Eopen"] = 400;
              t2["Epsilon"] = 917;
              t2["Epsilontonos"] = 904;
              t2["Ercyrillic"] = 1056;
              t2["Ereversed"] = 398;
              t2["Ereversedcyrillic"] = 1069;
              t2["Escyrillic"] = 1057;
              t2["Esdescendercyrillic"] = 1194;
              t2["Esh"] = 425;
              t2["Esmall"] = 63333;
              t2["Eta"] = 919;
              t2["Etarmenian"] = 1336;
              t2["Etatonos"] = 905;
              t2["Eth"] = 208;
              t2["Ethsmall"] = 63472;
              t2["Etilde"] = 7868;
              t2["Etildebelow"] = 7706;
              t2["Euro"] = 8364;
              t2["Ezh"] = 439;
              t2["Ezhcaron"] = 494;
              t2["Ezhreversed"] = 440;
              t2["F"] = 70;
              t2["Fcircle"] = 9403;
              t2["Fdotaccent"] = 7710;
              t2["Feharmenian"] = 1366;
              t2["Feicoptic"] = 996;
              t2["Fhook"] = 401;
              t2["Fitacyrillic"] = 1138;
              t2["Fiveroman"] = 8548;
              t2["Fmonospace"] = 65318;
              t2["Fourroman"] = 8547;
              t2["Fsmall"] = 63334;
              t2["G"] = 71;
              t2["GBsquare"] = 13191;
              t2["Gacute"] = 500;
              t2["Gamma"] = 915;
              t2["Gammaafrican"] = 404;
              t2["Gangiacoptic"] = 1002;
              t2["Gbreve"] = 286;
              t2["Gcaron"] = 486;
              t2["Gcedilla"] = 290;
              t2["Gcircle"] = 9404;
              t2["Gcircumflex"] = 284;
              t2["Gcommaaccent"] = 290;
              t2["Gdot"] = 288;
              t2["Gdotaccent"] = 288;
              t2["Gecyrillic"] = 1043;
              t2["Ghadarmenian"] = 1346;
              t2["Ghemiddlehookcyrillic"] = 1172;
              t2["Ghestrokecyrillic"] = 1170;
              t2["Gheupturncyrillic"] = 1168;
              t2["Ghook"] = 403;
              t2["Gimarmenian"] = 1331;
              t2["Gjecyrillic"] = 1027;
              t2["Gmacron"] = 7712;
              t2["Gmonospace"] = 65319;
              t2["Grave"] = 63182;
              t2["Gravesmall"] = 63328;
              t2["Gsmall"] = 63335;
              t2["Gsmallhook"] = 667;
              t2["Gstroke"] = 484;
              t2["H"] = 72;
              t2["H18533"] = 9679;
              t2["H18543"] = 9642;
              t2["H18551"] = 9643;
              t2["H22073"] = 9633;
              t2["HPsquare"] = 13259;
              t2["Haabkhasiancyrillic"] = 1192;
              t2["Hadescendercyrillic"] = 1202;
              t2["Hardsigncyrillic"] = 1066;
              t2["Hbar"] = 294;
              t2["Hbrevebelow"] = 7722;
              t2["Hcedilla"] = 7720;
              t2["Hcircle"] = 9405;
              t2["Hcircumflex"] = 292;
              t2["Hdieresis"] = 7718;
              t2["Hdotaccent"] = 7714;
              t2["Hdotbelow"] = 7716;
              t2["Hmonospace"] = 65320;
              t2["Hoarmenian"] = 1344;
              t2["Horicoptic"] = 1e3;
              t2["Hsmall"] = 63336;
              t2["Hungarumlaut"] = 63183;
              t2["Hungarumlautsmall"] = 63224;
              t2["Hzsquare"] = 13200;
              t2["I"] = 73;
              t2["IAcyrillic"] = 1071;
              t2["IJ"] = 306;
              t2["IUcyrillic"] = 1070;
              t2["Iacute"] = 205;
              t2["Iacutesmall"] = 63469;
              t2["Ibreve"] = 300;
              t2["Icaron"] = 463;
              t2["Icircle"] = 9406;
              t2["Icircumflex"] = 206;
              t2["Icircumflexsmall"] = 63470;
              t2["Icyrillic"] = 1030;
              t2["Idblgrave"] = 520;
              t2["Idieresis"] = 207;
              t2["Idieresisacute"] = 7726;
              t2["Idieresiscyrillic"] = 1252;
              t2["Idieresissmall"] = 63471;
              t2["Idot"] = 304;
              t2["Idotaccent"] = 304;
              t2["Idotbelow"] = 7882;
              t2["Iebrevecyrillic"] = 1238;
              t2["Iecyrillic"] = 1045;
              t2["Ifraktur"] = 8465;
              t2["Igrave"] = 204;
              t2["Igravesmall"] = 63468;
              t2["Ihookabove"] = 7880;
              t2["Iicyrillic"] = 1048;
              t2["Iinvertedbreve"] = 522;
              t2["Iishortcyrillic"] = 1049;
              t2["Imacron"] = 298;
              t2["Imacroncyrillic"] = 1250;
              t2["Imonospace"] = 65321;
              t2["Iniarmenian"] = 1339;
              t2["Iocyrillic"] = 1025;
              t2["Iogonek"] = 302;
              t2["Iota"] = 921;
              t2["Iotaafrican"] = 406;
              t2["Iotadieresis"] = 938;
              t2["Iotatonos"] = 906;
              t2["Ismall"] = 63337;
              t2["Istroke"] = 407;
              t2["Itilde"] = 296;
              t2["Itildebelow"] = 7724;
              t2["Izhitsacyrillic"] = 1140;
              t2["Izhitsadblgravecyrillic"] = 1142;
              t2["J"] = 74;
              t2["Jaarmenian"] = 1345;
              t2["Jcircle"] = 9407;
              t2["Jcircumflex"] = 308;
              t2["Jecyrillic"] = 1032;
              t2["Jheharmenian"] = 1355;
              t2["Jmonospace"] = 65322;
              t2["Jsmall"] = 63338;
              t2["K"] = 75;
              t2["KBsquare"] = 13189;
              t2["KKsquare"] = 13261;
              t2["Kabashkircyrillic"] = 1184;
              t2["Kacute"] = 7728;
              t2["Kacyrillic"] = 1050;
              t2["Kadescendercyrillic"] = 1178;
              t2["Kahookcyrillic"] = 1219;
              t2["Kappa"] = 922;
              t2["Kastrokecyrillic"] = 1182;
              t2["Kaverticalstrokecyrillic"] = 1180;
              t2["Kcaron"] = 488;
              t2["Kcedilla"] = 310;
              t2["Kcircle"] = 9408;
              t2["Kcommaaccent"] = 310;
              t2["Kdotbelow"] = 7730;
              t2["Keharmenian"] = 1364;
              t2["Kenarmenian"] = 1343;
              t2["Khacyrillic"] = 1061;
              t2["Kheicoptic"] = 998;
              t2["Khook"] = 408;
              t2["Kjecyrillic"] = 1036;
              t2["Klinebelow"] = 7732;
              t2["Kmonospace"] = 65323;
              t2["Koppacyrillic"] = 1152;
              t2["Koppagreek"] = 990;
              t2["Ksicyrillic"] = 1134;
              t2["Ksmall"] = 63339;
              t2["L"] = 76;
              t2["LJ"] = 455;
              t2["LL"] = 63167;
              t2["Lacute"] = 313;
              t2["Lambda"] = 923;
              t2["Lcaron"] = 317;
              t2["Lcedilla"] = 315;
              t2["Lcircle"] = 9409;
              t2["Lcircumflexbelow"] = 7740;
              t2["Lcommaaccent"] = 315;
              t2["Ldot"] = 319;
              t2["Ldotaccent"] = 319;
              t2["Ldotbelow"] = 7734;
              t2["Ldotbelowmacron"] = 7736;
              t2["Liwnarmenian"] = 1340;
              t2["Lj"] = 456;
              t2["Ljecyrillic"] = 1033;
              t2["Llinebelow"] = 7738;
              t2["Lmonospace"] = 65324;
              t2["Lslash"] = 321;
              t2["Lslashsmall"] = 63225;
              t2["Lsmall"] = 63340;
              t2["M"] = 77;
              t2["MBsquare"] = 13190;
              t2["Macron"] = 63184;
              t2["Macronsmall"] = 63407;
              t2["Macute"] = 7742;
              t2["Mcircle"] = 9410;
              t2["Mdotaccent"] = 7744;
              t2["Mdotbelow"] = 7746;
              t2["Menarmenian"] = 1348;
              t2["Mmonospace"] = 65325;
              t2["Msmall"] = 63341;
              t2["Mturned"] = 412;
              t2["Mu"] = 924;
              t2["N"] = 78;
              t2["NJ"] = 458;
              t2["Nacute"] = 323;
              t2["Ncaron"] = 327;
              t2["Ncedilla"] = 325;
              t2["Ncircle"] = 9411;
              t2["Ncircumflexbelow"] = 7754;
              t2["Ncommaaccent"] = 325;
              t2["Ndotaccent"] = 7748;
              t2["Ndotbelow"] = 7750;
              t2["Nhookleft"] = 413;
              t2["Nineroman"] = 8552;
              t2["Nj"] = 459;
              t2["Njecyrillic"] = 1034;
              t2["Nlinebelow"] = 7752;
              t2["Nmonospace"] = 65326;
              t2["Nowarmenian"] = 1350;
              t2["Nsmall"] = 63342;
              t2["Ntilde"] = 209;
              t2["Ntildesmall"] = 63473;
              t2["Nu"] = 925;
              t2["O"] = 79;
              t2["OE"] = 338;
              t2["OEsmall"] = 63226;
              t2["Oacute"] = 211;
              t2["Oacutesmall"] = 63475;
              t2["Obarredcyrillic"] = 1256;
              t2["Obarreddieresiscyrillic"] = 1258;
              t2["Obreve"] = 334;
              t2["Ocaron"] = 465;
              t2["Ocenteredtilde"] = 415;
              t2["Ocircle"] = 9412;
              t2["Ocircumflex"] = 212;
              t2["Ocircumflexacute"] = 7888;
              t2["Ocircumflexdotbelow"] = 7896;
              t2["Ocircumflexgrave"] = 7890;
              t2["Ocircumflexhookabove"] = 7892;
              t2["Ocircumflexsmall"] = 63476;
              t2["Ocircumflextilde"] = 7894;
              t2["Ocyrillic"] = 1054;
              t2["Odblacute"] = 336;
              t2["Odblgrave"] = 524;
              t2["Odieresis"] = 214;
              t2["Odieresiscyrillic"] = 1254;
              t2["Odieresissmall"] = 63478;
              t2["Odotbelow"] = 7884;
              t2["Ogoneksmall"] = 63227;
              t2["Ograve"] = 210;
              t2["Ogravesmall"] = 63474;
              t2["Oharmenian"] = 1365;
              t2["Ohm"] = 8486;
              t2["Ohookabove"] = 7886;
              t2["Ohorn"] = 416;
              t2["Ohornacute"] = 7898;
              t2["Ohorndotbelow"] = 7906;
              t2["Ohorngrave"] = 7900;
              t2["Ohornhookabove"] = 7902;
              t2["Ohorntilde"] = 7904;
              t2["Ohungarumlaut"] = 336;
              t2["Oi"] = 418;
              t2["Oinvertedbreve"] = 526;
              t2["Omacron"] = 332;
              t2["Omacronacute"] = 7762;
              t2["Omacrongrave"] = 7760;
              t2["Omega"] = 8486;
              t2["Omegacyrillic"] = 1120;
              t2["Omegagreek"] = 937;
              t2["Omegaroundcyrillic"] = 1146;
              t2["Omegatitlocyrillic"] = 1148;
              t2["Omegatonos"] = 911;
              t2["Omicron"] = 927;
              t2["Omicrontonos"] = 908;
              t2["Omonospace"] = 65327;
              t2["Oneroman"] = 8544;
              t2["Oogonek"] = 490;
              t2["Oogonekmacron"] = 492;
              t2["Oopen"] = 390;
              t2["Oslash"] = 216;
              t2["Oslashacute"] = 510;
              t2["Oslashsmall"] = 63480;
              t2["Osmall"] = 63343;
              t2["Ostrokeacute"] = 510;
              t2["Otcyrillic"] = 1150;
              t2["Otilde"] = 213;
              t2["Otildeacute"] = 7756;
              t2["Otildedieresis"] = 7758;
              t2["Otildesmall"] = 63477;
              t2["P"] = 80;
              t2["Pacute"] = 7764;
              t2["Pcircle"] = 9413;
              t2["Pdotaccent"] = 7766;
              t2["Pecyrillic"] = 1055;
              t2["Peharmenian"] = 1354;
              t2["Pemiddlehookcyrillic"] = 1190;
              t2["Phi"] = 934;
              t2["Phook"] = 420;
              t2["Pi"] = 928;
              t2["Piwrarmenian"] = 1363;
              t2["Pmonospace"] = 65328;
              t2["Psi"] = 936;
              t2["Psicyrillic"] = 1136;
              t2["Psmall"] = 63344;
              t2["Q"] = 81;
              t2["Qcircle"] = 9414;
              t2["Qmonospace"] = 65329;
              t2["Qsmall"] = 63345;
              t2["R"] = 82;
              t2["Raarmenian"] = 1356;
              t2["Racute"] = 340;
              t2["Rcaron"] = 344;
              t2["Rcedilla"] = 342;
              t2["Rcircle"] = 9415;
              t2["Rcommaaccent"] = 342;
              t2["Rdblgrave"] = 528;
              t2["Rdotaccent"] = 7768;
              t2["Rdotbelow"] = 7770;
              t2["Rdotbelowmacron"] = 7772;
              t2["Reharmenian"] = 1360;
              t2["Rfraktur"] = 8476;
              t2["Rho"] = 929;
              t2["Ringsmall"] = 63228;
              t2["Rinvertedbreve"] = 530;
              t2["Rlinebelow"] = 7774;
              t2["Rmonospace"] = 65330;
              t2["Rsmall"] = 63346;
              t2["Rsmallinverted"] = 641;
              t2["Rsmallinvertedsuperior"] = 694;
              t2["S"] = 83;
              t2["SF010000"] = 9484;
              t2["SF020000"] = 9492;
              t2["SF030000"] = 9488;
              t2["SF040000"] = 9496;
              t2["SF050000"] = 9532;
              t2["SF060000"] = 9516;
              t2["SF070000"] = 9524;
              t2["SF080000"] = 9500;
              t2["SF090000"] = 9508;
              t2["SF100000"] = 9472;
              t2["SF110000"] = 9474;
              t2["SF190000"] = 9569;
              t2["SF200000"] = 9570;
              t2["SF210000"] = 9558;
              t2["SF220000"] = 9557;
              t2["SF230000"] = 9571;
              t2["SF240000"] = 9553;
              t2["SF250000"] = 9559;
              t2["SF260000"] = 9565;
              t2["SF270000"] = 9564;
              t2["SF280000"] = 9563;
              t2["SF360000"] = 9566;
              t2["SF370000"] = 9567;
              t2["SF380000"] = 9562;
              t2["SF390000"] = 9556;
              t2["SF400000"] = 9577;
              t2["SF410000"] = 9574;
              t2["SF420000"] = 9568;
              t2["SF430000"] = 9552;
              t2["SF440000"] = 9580;
              t2["SF450000"] = 9575;
              t2["SF460000"] = 9576;
              t2["SF470000"] = 9572;
              t2["SF480000"] = 9573;
              t2["SF490000"] = 9561;
              t2["SF500000"] = 9560;
              t2["SF510000"] = 9554;
              t2["SF520000"] = 9555;
              t2["SF530000"] = 9579;
              t2["SF540000"] = 9578;
              t2["Sacute"] = 346;
              t2["Sacutedotaccent"] = 7780;
              t2["Sampigreek"] = 992;
              t2["Scaron"] = 352;
              t2["Scarondotaccent"] = 7782;
              t2["Scaronsmall"] = 63229;
              t2["Scedilla"] = 350;
              t2["Schwa"] = 399;
              t2["Schwacyrillic"] = 1240;
              t2["Schwadieresiscyrillic"] = 1242;
              t2["Scircle"] = 9416;
              t2["Scircumflex"] = 348;
              t2["Scommaaccent"] = 536;
              t2["Sdotaccent"] = 7776;
              t2["Sdotbelow"] = 7778;
              t2["Sdotbelowdotaccent"] = 7784;
              t2["Seharmenian"] = 1357;
              t2["Sevenroman"] = 8550;
              t2["Shaarmenian"] = 1351;
              t2["Shacyrillic"] = 1064;
              t2["Shchacyrillic"] = 1065;
              t2["Sheicoptic"] = 994;
              t2["Shhacyrillic"] = 1210;
              t2["Shimacoptic"] = 1004;
              t2["Sigma"] = 931;
              t2["Sixroman"] = 8549;
              t2["Smonospace"] = 65331;
              t2["Softsigncyrillic"] = 1068;
              t2["Ssmall"] = 63347;
              t2["Stigmagreek"] = 986;
              t2["T"] = 84;
              t2["Tau"] = 932;
              t2["Tbar"] = 358;
              t2["Tcaron"] = 356;
              t2["Tcedilla"] = 354;
              t2["Tcircle"] = 9417;
              t2["Tcircumflexbelow"] = 7792;
              t2["Tcommaaccent"] = 354;
              t2["Tdotaccent"] = 7786;
              t2["Tdotbelow"] = 7788;
              t2["Tecyrillic"] = 1058;
              t2["Tedescendercyrillic"] = 1196;
              t2["Tenroman"] = 8553;
              t2["Tetsecyrillic"] = 1204;
              t2["Theta"] = 920;
              t2["Thook"] = 428;
              t2["Thorn"] = 222;
              t2["Thornsmall"] = 63486;
              t2["Threeroman"] = 8546;
              t2["Tildesmall"] = 63230;
              t2["Tiwnarmenian"] = 1359;
              t2["Tlinebelow"] = 7790;
              t2["Tmonospace"] = 65332;
              t2["Toarmenian"] = 1337;
              t2["Tonefive"] = 444;
              t2["Tonesix"] = 388;
              t2["Tonetwo"] = 423;
              t2["Tretroflexhook"] = 430;
              t2["Tsecyrillic"] = 1062;
              t2["Tshecyrillic"] = 1035;
              t2["Tsmall"] = 63348;
              t2["Twelveroman"] = 8555;
              t2["Tworoman"] = 8545;
              t2["U"] = 85;
              t2["Uacute"] = 218;
              t2["Uacutesmall"] = 63482;
              t2["Ubreve"] = 364;
              t2["Ucaron"] = 467;
              t2["Ucircle"] = 9418;
              t2["Ucircumflex"] = 219;
              t2["Ucircumflexbelow"] = 7798;
              t2["Ucircumflexsmall"] = 63483;
              t2["Ucyrillic"] = 1059;
              t2["Udblacute"] = 368;
              t2["Udblgrave"] = 532;
              t2["Udieresis"] = 220;
              t2["Udieresisacute"] = 471;
              t2["Udieresisbelow"] = 7794;
              t2["Udieresiscaron"] = 473;
              t2["Udieresiscyrillic"] = 1264;
              t2["Udieresisgrave"] = 475;
              t2["Udieresismacron"] = 469;
              t2["Udieresissmall"] = 63484;
              t2["Udotbelow"] = 7908;
              t2["Ugrave"] = 217;
              t2["Ugravesmall"] = 63481;
              t2["Uhookabove"] = 7910;
              t2["Uhorn"] = 431;
              t2["Uhornacute"] = 7912;
              t2["Uhorndotbelow"] = 7920;
              t2["Uhorngrave"] = 7914;
              t2["Uhornhookabove"] = 7916;
              t2["Uhorntilde"] = 7918;
              t2["Uhungarumlaut"] = 368;
              t2["Uhungarumlautcyrillic"] = 1266;
              t2["Uinvertedbreve"] = 534;
              t2["Ukcyrillic"] = 1144;
              t2["Umacron"] = 362;
              t2["Umacroncyrillic"] = 1262;
              t2["Umacrondieresis"] = 7802;
              t2["Umonospace"] = 65333;
              t2["Uogonek"] = 370;
              t2["Upsilon"] = 933;
              t2["Upsilon1"] = 978;
              t2["Upsilonacutehooksymbolgreek"] = 979;
              t2["Upsilonafrican"] = 433;
              t2["Upsilondieresis"] = 939;
              t2["Upsilondieresishooksymbolgreek"] = 980;
              t2["Upsilonhooksymbol"] = 978;
              t2["Upsilontonos"] = 910;
              t2["Uring"] = 366;
              t2["Ushortcyrillic"] = 1038;
              t2["Usmall"] = 63349;
              t2["Ustraightcyrillic"] = 1198;
              t2["Ustraightstrokecyrillic"] = 1200;
              t2["Utilde"] = 360;
              t2["Utildeacute"] = 7800;
              t2["Utildebelow"] = 7796;
              t2["V"] = 86;
              t2["Vcircle"] = 9419;
              t2["Vdotbelow"] = 7806;
              t2["Vecyrillic"] = 1042;
              t2["Vewarmenian"] = 1358;
              t2["Vhook"] = 434;
              t2["Vmonospace"] = 65334;
              t2["Voarmenian"] = 1352;
              t2["Vsmall"] = 63350;
              t2["Vtilde"] = 7804;
              t2["W"] = 87;
              t2["Wacute"] = 7810;
              t2["Wcircle"] = 9420;
              t2["Wcircumflex"] = 372;
              t2["Wdieresis"] = 7812;
              t2["Wdotaccent"] = 7814;
              t2["Wdotbelow"] = 7816;
              t2["Wgrave"] = 7808;
              t2["Wmonospace"] = 65335;
              t2["Wsmall"] = 63351;
              t2["X"] = 88;
              t2["Xcircle"] = 9421;
              t2["Xdieresis"] = 7820;
              t2["Xdotaccent"] = 7818;
              t2["Xeharmenian"] = 1341;
              t2["Xi"] = 926;
              t2["Xmonospace"] = 65336;
              t2["Xsmall"] = 63352;
              t2["Y"] = 89;
              t2["Yacute"] = 221;
              t2["Yacutesmall"] = 63485;
              t2["Yatcyrillic"] = 1122;
              t2["Ycircle"] = 9422;
              t2["Ycircumflex"] = 374;
              t2["Ydieresis"] = 376;
              t2["Ydieresissmall"] = 63487;
              t2["Ydotaccent"] = 7822;
              t2["Ydotbelow"] = 7924;
              t2["Yericyrillic"] = 1067;
              t2["Yerudieresiscyrillic"] = 1272;
              t2["Ygrave"] = 7922;
              t2["Yhook"] = 435;
              t2["Yhookabove"] = 7926;
              t2["Yiarmenian"] = 1349;
              t2["Yicyrillic"] = 1031;
              t2["Yiwnarmenian"] = 1362;
              t2["Ymonospace"] = 65337;
              t2["Ysmall"] = 63353;
              t2["Ytilde"] = 7928;
              t2["Yusbigcyrillic"] = 1130;
              t2["Yusbigiotifiedcyrillic"] = 1132;
              t2["Yuslittlecyrillic"] = 1126;
              t2["Yuslittleiotifiedcyrillic"] = 1128;
              t2["Z"] = 90;
              t2["Zaarmenian"] = 1334;
              t2["Zacute"] = 377;
              t2["Zcaron"] = 381;
              t2["Zcaronsmall"] = 63231;
              t2["Zcircle"] = 9423;
              t2["Zcircumflex"] = 7824;
              t2["Zdot"] = 379;
              t2["Zdotaccent"] = 379;
              t2["Zdotbelow"] = 7826;
              t2["Zecyrillic"] = 1047;
              t2["Zedescendercyrillic"] = 1176;
              t2["Zedieresiscyrillic"] = 1246;
              t2["Zeta"] = 918;
              t2["Zhearmenian"] = 1338;
              t2["Zhebrevecyrillic"] = 1217;
              t2["Zhecyrillic"] = 1046;
              t2["Zhedescendercyrillic"] = 1174;
              t2["Zhedieresiscyrillic"] = 1244;
              t2["Zlinebelow"] = 7828;
              t2["Zmonospace"] = 65338;
              t2["Zsmall"] = 63354;
              t2["Zstroke"] = 437;
              t2["a"] = 97;
              t2["aabengali"] = 2438;
              t2["aacute"] = 225;
              t2["aadeva"] = 2310;
              t2["aagujarati"] = 2694;
              t2["aagurmukhi"] = 2566;
              t2["aamatragurmukhi"] = 2622;
              t2["aarusquare"] = 13059;
              t2["aavowelsignbengali"] = 2494;
              t2["aavowelsigndeva"] = 2366;
              t2["aavowelsigngujarati"] = 2750;
              t2["abbreviationmarkarmenian"] = 1375;
              t2["abbreviationsigndeva"] = 2416;
              t2["abengali"] = 2437;
              t2["abopomofo"] = 12570;
              t2["abreve"] = 259;
              t2["abreveacute"] = 7855;
              t2["abrevecyrillic"] = 1233;
              t2["abrevedotbelow"] = 7863;
              t2["abrevegrave"] = 7857;
              t2["abrevehookabove"] = 7859;
              t2["abrevetilde"] = 7861;
              t2["acaron"] = 462;
              t2["acircle"] = 9424;
              t2["acircumflex"] = 226;
              t2["acircumflexacute"] = 7845;
              t2["acircumflexdotbelow"] = 7853;
              t2["acircumflexgrave"] = 7847;
              t2["acircumflexhookabove"] = 7849;
              t2["acircumflextilde"] = 7851;
              t2["acute"] = 180;
              t2["acutebelowcmb"] = 791;
              t2["acutecmb"] = 769;
              t2["acutecomb"] = 769;
              t2["acutedeva"] = 2388;
              t2["acutelowmod"] = 719;
              t2["acutetonecmb"] = 833;
              t2["acyrillic"] = 1072;
              t2["adblgrave"] = 513;
              t2["addakgurmukhi"] = 2673;
              t2["adeva"] = 2309;
              t2["adieresis"] = 228;
              t2["adieresiscyrillic"] = 1235;
              t2["adieresismacron"] = 479;
              t2["adotbelow"] = 7841;
              t2["adotmacron"] = 481;
              t2["ae"] = 230;
              t2["aeacute"] = 509;
              t2["aekorean"] = 12624;
              t2["aemacron"] = 483;
              t2["afii00208"] = 8213;
              t2["afii08941"] = 8356;
              t2["afii10017"] = 1040;
              t2["afii10018"] = 1041;
              t2["afii10019"] = 1042;
              t2["afii10020"] = 1043;
              t2["afii10021"] = 1044;
              t2["afii10022"] = 1045;
              t2["afii10023"] = 1025;
              t2["afii10024"] = 1046;
              t2["afii10025"] = 1047;
              t2["afii10026"] = 1048;
              t2["afii10027"] = 1049;
              t2["afii10028"] = 1050;
              t2["afii10029"] = 1051;
              t2["afii10030"] = 1052;
              t2["afii10031"] = 1053;
              t2["afii10032"] = 1054;
              t2["afii10033"] = 1055;
              t2["afii10034"] = 1056;
              t2["afii10035"] = 1057;
              t2["afii10036"] = 1058;
              t2["afii10037"] = 1059;
              t2["afii10038"] = 1060;
              t2["afii10039"] = 1061;
              t2["afii10040"] = 1062;
              t2["afii10041"] = 1063;
              t2["afii10042"] = 1064;
              t2["afii10043"] = 1065;
              t2["afii10044"] = 1066;
              t2["afii10045"] = 1067;
              t2["afii10046"] = 1068;
              t2["afii10047"] = 1069;
              t2["afii10048"] = 1070;
              t2["afii10049"] = 1071;
              t2["afii10050"] = 1168;
              t2["afii10051"] = 1026;
              t2["afii10052"] = 1027;
              t2["afii10053"] = 1028;
              t2["afii10054"] = 1029;
              t2["afii10055"] = 1030;
              t2["afii10056"] = 1031;
              t2["afii10057"] = 1032;
              t2["afii10058"] = 1033;
              t2["afii10059"] = 1034;
              t2["afii10060"] = 1035;
              t2["afii10061"] = 1036;
              t2["afii10062"] = 1038;
              t2["afii10063"] = 63172;
              t2["afii10064"] = 63173;
              t2["afii10065"] = 1072;
              t2["afii10066"] = 1073;
              t2["afii10067"] = 1074;
              t2["afii10068"] = 1075;
              t2["afii10069"] = 1076;
              t2["afii10070"] = 1077;
              t2["afii10071"] = 1105;
              t2["afii10072"] = 1078;
              t2["afii10073"] = 1079;
              t2["afii10074"] = 1080;
              t2["afii10075"] = 1081;
              t2["afii10076"] = 1082;
              t2["afii10077"] = 1083;
              t2["afii10078"] = 1084;
              t2["afii10079"] = 1085;
              t2["afii10080"] = 1086;
              t2["afii10081"] = 1087;
              t2["afii10082"] = 1088;
              t2["afii10083"] = 1089;
              t2["afii10084"] = 1090;
              t2["afii10085"] = 1091;
              t2["afii10086"] = 1092;
              t2["afii10087"] = 1093;
              t2["afii10088"] = 1094;
              t2["afii10089"] = 1095;
              t2["afii10090"] = 1096;
              t2["afii10091"] = 1097;
              t2["afii10092"] = 1098;
              t2["afii10093"] = 1099;
              t2["afii10094"] = 1100;
              t2["afii10095"] = 1101;
              t2["afii10096"] = 1102;
              t2["afii10097"] = 1103;
              t2["afii10098"] = 1169;
              t2["afii10099"] = 1106;
              t2["afii10100"] = 1107;
              t2["afii10101"] = 1108;
              t2["afii10102"] = 1109;
              t2["afii10103"] = 1110;
              t2["afii10104"] = 1111;
              t2["afii10105"] = 1112;
              t2["afii10106"] = 1113;
              t2["afii10107"] = 1114;
              t2["afii10108"] = 1115;
              t2["afii10109"] = 1116;
              t2["afii10110"] = 1118;
              t2["afii10145"] = 1039;
              t2["afii10146"] = 1122;
              t2["afii10147"] = 1138;
              t2["afii10148"] = 1140;
              t2["afii10192"] = 63174;
              t2["afii10193"] = 1119;
              t2["afii10194"] = 1123;
              t2["afii10195"] = 1139;
              t2["afii10196"] = 1141;
              t2["afii10831"] = 63175;
              t2["afii10832"] = 63176;
              t2["afii10846"] = 1241;
              t2["afii299"] = 8206;
              t2["afii300"] = 8207;
              t2["afii301"] = 8205;
              t2["afii57381"] = 1642;
              t2["afii57388"] = 1548;
              t2["afii57392"] = 1632;
              t2["afii57393"] = 1633;
              t2["afii57394"] = 1634;
              t2["afii57395"] = 1635;
              t2["afii57396"] = 1636;
              t2["afii57397"] = 1637;
              t2["afii57398"] = 1638;
              t2["afii57399"] = 1639;
              t2["afii57400"] = 1640;
              t2["afii57401"] = 1641;
              t2["afii57403"] = 1563;
              t2["afii57407"] = 1567;
              t2["afii57409"] = 1569;
              t2["afii57410"] = 1570;
              t2["afii57411"] = 1571;
              t2["afii57412"] = 1572;
              t2["afii57413"] = 1573;
              t2["afii57414"] = 1574;
              t2["afii57415"] = 1575;
              t2["afii57416"] = 1576;
              t2["afii57417"] = 1577;
              t2["afii57418"] = 1578;
              t2["afii57419"] = 1579;
              t2["afii57420"] = 1580;
              t2["afii57421"] = 1581;
              t2["afii57422"] = 1582;
              t2["afii57423"] = 1583;
              t2["afii57424"] = 1584;
              t2["afii57425"] = 1585;
              t2["afii57426"] = 1586;
              t2["afii57427"] = 1587;
              t2["afii57428"] = 1588;
              t2["afii57429"] = 1589;
              t2["afii57430"] = 1590;
              t2["afii57431"] = 1591;
              t2["afii57432"] = 1592;
              t2["afii57433"] = 1593;
              t2["afii57434"] = 1594;
              t2["afii57440"] = 1600;
              t2["afii57441"] = 1601;
              t2["afii57442"] = 1602;
              t2["afii57443"] = 1603;
              t2["afii57444"] = 1604;
              t2["afii57445"] = 1605;
              t2["afii57446"] = 1606;
              t2["afii57448"] = 1608;
              t2["afii57449"] = 1609;
              t2["afii57450"] = 1610;
              t2["afii57451"] = 1611;
              t2["afii57452"] = 1612;
              t2["afii57453"] = 1613;
              t2["afii57454"] = 1614;
              t2["afii57455"] = 1615;
              t2["afii57456"] = 1616;
              t2["afii57457"] = 1617;
              t2["afii57458"] = 1618;
              t2["afii57470"] = 1607;
              t2["afii57505"] = 1700;
              t2["afii57506"] = 1662;
              t2["afii57507"] = 1670;
              t2["afii57508"] = 1688;
              t2["afii57509"] = 1711;
              t2["afii57511"] = 1657;
              t2["afii57512"] = 1672;
              t2["afii57513"] = 1681;
              t2["afii57514"] = 1722;
              t2["afii57519"] = 1746;
              t2["afii57534"] = 1749;
              t2["afii57636"] = 8362;
              t2["afii57645"] = 1470;
              t2["afii57658"] = 1475;
              t2["afii57664"] = 1488;
              t2["afii57665"] = 1489;
              t2["afii57666"] = 1490;
              t2["afii57667"] = 1491;
              t2["afii57668"] = 1492;
              t2["afii57669"] = 1493;
              t2["afii57670"] = 1494;
              t2["afii57671"] = 1495;
              t2["afii57672"] = 1496;
              t2["afii57673"] = 1497;
              t2["afii57674"] = 1498;
              t2["afii57675"] = 1499;
              t2["afii57676"] = 1500;
              t2["afii57677"] = 1501;
              t2["afii57678"] = 1502;
              t2["afii57679"] = 1503;
              t2["afii57680"] = 1504;
              t2["afii57681"] = 1505;
              t2["afii57682"] = 1506;
              t2["afii57683"] = 1507;
              t2["afii57684"] = 1508;
              t2["afii57685"] = 1509;
              t2["afii57686"] = 1510;
              t2["afii57687"] = 1511;
              t2["afii57688"] = 1512;
              t2["afii57689"] = 1513;
              t2["afii57690"] = 1514;
              t2["afii57694"] = 64298;
              t2["afii57695"] = 64299;
              t2["afii57700"] = 64331;
              t2["afii57705"] = 64287;
              t2["afii57716"] = 1520;
              t2["afii57717"] = 1521;
              t2["afii57718"] = 1522;
              t2["afii57723"] = 64309;
              t2["afii57793"] = 1460;
              t2["afii57794"] = 1461;
              t2["afii57795"] = 1462;
              t2["afii57796"] = 1467;
              t2["afii57797"] = 1464;
              t2["afii57798"] = 1463;
              t2["afii57799"] = 1456;
              t2["afii57800"] = 1458;
              t2["afii57801"] = 1457;
              t2["afii57802"] = 1459;
              t2["afii57803"] = 1474;
              t2["afii57804"] = 1473;
              t2["afii57806"] = 1465;
              t2["afii57807"] = 1468;
              t2["afii57839"] = 1469;
              t2["afii57841"] = 1471;
              t2["afii57842"] = 1472;
              t2["afii57929"] = 700;
              t2["afii61248"] = 8453;
              t2["afii61289"] = 8467;
              t2["afii61352"] = 8470;
              t2["afii61573"] = 8236;
              t2["afii61574"] = 8237;
              t2["afii61575"] = 8238;
              t2["afii61664"] = 8204;
              t2["afii63167"] = 1645;
              t2["afii64937"] = 701;
              t2["agrave"] = 224;
              t2["agujarati"] = 2693;
              t2["agurmukhi"] = 2565;
              t2["ahiragana"] = 12354;
              t2["ahookabove"] = 7843;
              t2["aibengali"] = 2448;
              t2["aibopomofo"] = 12574;
              t2["aideva"] = 2320;
              t2["aiecyrillic"] = 1237;
              t2["aigujarati"] = 2704;
              t2["aigurmukhi"] = 2576;
              t2["aimatragurmukhi"] = 2632;
              t2["ainarabic"] = 1593;
              t2["ainfinalarabic"] = 65226;
              t2["aininitialarabic"] = 65227;
              t2["ainmedialarabic"] = 65228;
              t2["ainvertedbreve"] = 515;
              t2["aivowelsignbengali"] = 2504;
              t2["aivowelsigndeva"] = 2376;
              t2["aivowelsigngujarati"] = 2760;
              t2["akatakana"] = 12450;
              t2["akatakanahalfwidth"] = 65393;
              t2["akorean"] = 12623;
              t2["alef"] = 1488;
              t2["alefarabic"] = 1575;
              t2["alefdageshhebrew"] = 64304;
              t2["aleffinalarabic"] = 65166;
              t2["alefhamzaabovearabic"] = 1571;
              t2["alefhamzaabovefinalarabic"] = 65156;
              t2["alefhamzabelowarabic"] = 1573;
              t2["alefhamzabelowfinalarabic"] = 65160;
              t2["alefhebrew"] = 1488;
              t2["aleflamedhebrew"] = 64335;
              t2["alefmaddaabovearabic"] = 1570;
              t2["alefmaddaabovefinalarabic"] = 65154;
              t2["alefmaksuraarabic"] = 1609;
              t2["alefmaksurafinalarabic"] = 65264;
              t2["alefmaksurainitialarabic"] = 65267;
              t2["alefmaksuramedialarabic"] = 65268;
              t2["alefpatahhebrew"] = 64302;
              t2["alefqamatshebrew"] = 64303;
              t2["aleph"] = 8501;
              t2["allequal"] = 8780;
              t2["alpha"] = 945;
              t2["alphatonos"] = 940;
              t2["amacron"] = 257;
              t2["amonospace"] = 65345;
              t2["ampersand"] = 38;
              t2["ampersandmonospace"] = 65286;
              t2["ampersandsmall"] = 63270;
              t2["amsquare"] = 13250;
              t2["anbopomofo"] = 12578;
              t2["angbopomofo"] = 12580;
              t2["angbracketleft"] = 12296;
              t2["angbracketright"] = 12297;
              t2["angkhankhuthai"] = 3674;
              t2["angle"] = 8736;
              t2["anglebracketleft"] = 12296;
              t2["anglebracketleftvertical"] = 65087;
              t2["anglebracketright"] = 12297;
              t2["anglebracketrightvertical"] = 65088;
              t2["angleleft"] = 9001;
              t2["angleright"] = 9002;
              t2["angstrom"] = 8491;
              t2["anoteleia"] = 903;
              t2["anudattadeva"] = 2386;
              t2["anusvarabengali"] = 2434;
              t2["anusvaradeva"] = 2306;
              t2["anusvaragujarati"] = 2690;
              t2["aogonek"] = 261;
              t2["apaatosquare"] = 13056;
              t2["aparen"] = 9372;
              t2["apostrophearmenian"] = 1370;
              t2["apostrophemod"] = 700;
              t2["apple"] = 63743;
              t2["approaches"] = 8784;
              t2["approxequal"] = 8776;
              t2["approxequalorimage"] = 8786;
              t2["approximatelyequal"] = 8773;
              t2["araeaekorean"] = 12686;
              t2["araeakorean"] = 12685;
              t2["arc"] = 8978;
              t2["arighthalfring"] = 7834;
              t2["aring"] = 229;
              t2["aringacute"] = 507;
              t2["aringbelow"] = 7681;
              t2["arrowboth"] = 8596;
              t2["arrowdashdown"] = 8675;
              t2["arrowdashleft"] = 8672;
              t2["arrowdashright"] = 8674;
              t2["arrowdashup"] = 8673;
              t2["arrowdblboth"] = 8660;
              t2["arrowdbldown"] = 8659;
              t2["arrowdblleft"] = 8656;
              t2["arrowdblright"] = 8658;
              t2["arrowdblup"] = 8657;
              t2["arrowdown"] = 8595;
              t2["arrowdownleft"] = 8601;
              t2["arrowdownright"] = 8600;
              t2["arrowdownwhite"] = 8681;
              t2["arrowheaddownmod"] = 709;
              t2["arrowheadleftmod"] = 706;
              t2["arrowheadrightmod"] = 707;
              t2["arrowheadupmod"] = 708;
              t2["arrowhorizex"] = 63719;
              t2["arrowleft"] = 8592;
              t2["arrowleftdbl"] = 8656;
              t2["arrowleftdblstroke"] = 8653;
              t2["arrowleftoverright"] = 8646;
              t2["arrowleftwhite"] = 8678;
              t2["arrowright"] = 8594;
              t2["arrowrightdblstroke"] = 8655;
              t2["arrowrightheavy"] = 10142;
              t2["arrowrightoverleft"] = 8644;
              t2["arrowrightwhite"] = 8680;
              t2["arrowtableft"] = 8676;
              t2["arrowtabright"] = 8677;
              t2["arrowup"] = 8593;
              t2["arrowupdn"] = 8597;
              t2["arrowupdnbse"] = 8616;
              t2["arrowupdownbase"] = 8616;
              t2["arrowupleft"] = 8598;
              t2["arrowupleftofdown"] = 8645;
              t2["arrowupright"] = 8599;
              t2["arrowupwhite"] = 8679;
              t2["arrowvertex"] = 63718;
              t2["asciicircum"] = 94;
              t2["asciicircummonospace"] = 65342;
              t2["asciitilde"] = 126;
              t2["asciitildemonospace"] = 65374;
              t2["ascript"] = 593;
              t2["ascriptturned"] = 594;
              t2["asmallhiragana"] = 12353;
              t2["asmallkatakana"] = 12449;
              t2["asmallkatakanahalfwidth"] = 65383;
              t2["asterisk"] = 42;
              t2["asteriskaltonearabic"] = 1645;
              t2["asteriskarabic"] = 1645;
              t2["asteriskmath"] = 8727;
              t2["asteriskmonospace"] = 65290;
              t2["asterisksmall"] = 65121;
              t2["asterism"] = 8258;
              t2["asuperior"] = 63209;
              t2["asymptoticallyequal"] = 8771;
              t2["at"] = 64;
              t2["atilde"] = 227;
              t2["atmonospace"] = 65312;
              t2["atsmall"] = 65131;
              t2["aturned"] = 592;
              t2["aubengali"] = 2452;
              t2["aubopomofo"] = 12576;
              t2["audeva"] = 2324;
              t2["augujarati"] = 2708;
              t2["augurmukhi"] = 2580;
              t2["aulengthmarkbengali"] = 2519;
              t2["aumatragurmukhi"] = 2636;
              t2["auvowelsignbengali"] = 2508;
              t2["auvowelsigndeva"] = 2380;
              t2["auvowelsigngujarati"] = 2764;
              t2["avagrahadeva"] = 2365;
              t2["aybarmenian"] = 1377;
              t2["ayin"] = 1506;
              t2["ayinaltonehebrew"] = 64288;
              t2["ayinhebrew"] = 1506;
              t2["b"] = 98;
              t2["babengali"] = 2476;
              t2["backslash"] = 92;
              t2["backslashmonospace"] = 65340;
              t2["badeva"] = 2348;
              t2["bagujarati"] = 2732;
              t2["bagurmukhi"] = 2604;
              t2["bahiragana"] = 12400;
              t2["bahtthai"] = 3647;
              t2["bakatakana"] = 12496;
              t2["bar"] = 124;
              t2["barmonospace"] = 65372;
              t2["bbopomofo"] = 12549;
              t2["bcircle"] = 9425;
              t2["bdotaccent"] = 7683;
              t2["bdotbelow"] = 7685;
              t2["beamedsixteenthnotes"] = 9836;
              t2["because"] = 8757;
              t2["becyrillic"] = 1073;
              t2["beharabic"] = 1576;
              t2["behfinalarabic"] = 65168;
              t2["behinitialarabic"] = 65169;
              t2["behiragana"] = 12409;
              t2["behmedialarabic"] = 65170;
              t2["behmeeminitialarabic"] = 64671;
              t2["behmeemisolatedarabic"] = 64520;
              t2["behnoonfinalarabic"] = 64621;
              t2["bekatakana"] = 12505;
              t2["benarmenian"] = 1378;
              t2["bet"] = 1489;
              t2["beta"] = 946;
              t2["betasymbolgreek"] = 976;
              t2["betdagesh"] = 64305;
              t2["betdageshhebrew"] = 64305;
              t2["bethebrew"] = 1489;
              t2["betrafehebrew"] = 64332;
              t2["bhabengali"] = 2477;
              t2["bhadeva"] = 2349;
              t2["bhagujarati"] = 2733;
              t2["bhagurmukhi"] = 2605;
              t2["bhook"] = 595;
              t2["bihiragana"] = 12403;
              t2["bikatakana"] = 12499;
              t2["bilabialclick"] = 664;
              t2["bindigurmukhi"] = 2562;
              t2["birusquare"] = 13105;
              t2["blackcircle"] = 9679;
              t2["blackdiamond"] = 9670;
              t2["blackdownpointingtriangle"] = 9660;
              t2["blackleftpointingpointer"] = 9668;
              t2["blackleftpointingtriangle"] = 9664;
              t2["blacklenticularbracketleft"] = 12304;
              t2["blacklenticularbracketleftvertical"] = 65083;
              t2["blacklenticularbracketright"] = 12305;
              t2["blacklenticularbracketrightvertical"] = 65084;
              t2["blacklowerlefttriangle"] = 9699;
              t2["blacklowerrighttriangle"] = 9698;
              t2["blackrectangle"] = 9644;
              t2["blackrightpointingpointer"] = 9658;
              t2["blackrightpointingtriangle"] = 9654;
              t2["blacksmallsquare"] = 9642;
              t2["blacksmilingface"] = 9787;
              t2["blacksquare"] = 9632;
              t2["blackstar"] = 9733;
              t2["blackupperlefttriangle"] = 9700;
              t2["blackupperrighttriangle"] = 9701;
              t2["blackuppointingsmalltriangle"] = 9652;
              t2["blackuppointingtriangle"] = 9650;
              t2["blank"] = 9251;
              t2["blinebelow"] = 7687;
              t2["block"] = 9608;
              t2["bmonospace"] = 65346;
              t2["bobaimaithai"] = 3610;
              t2["bohiragana"] = 12412;
              t2["bokatakana"] = 12508;
              t2["bparen"] = 9373;
              t2["bqsquare"] = 13251;
              t2["braceex"] = 63732;
              t2["braceleft"] = 123;
              t2["braceleftbt"] = 63731;
              t2["braceleftmid"] = 63730;
              t2["braceleftmonospace"] = 65371;
              t2["braceleftsmall"] = 65115;
              t2["bracelefttp"] = 63729;
              t2["braceleftvertical"] = 65079;
              t2["braceright"] = 125;
              t2["bracerightbt"] = 63742;
              t2["bracerightmid"] = 63741;
              t2["bracerightmonospace"] = 65373;
              t2["bracerightsmall"] = 65116;
              t2["bracerighttp"] = 63740;
              t2["bracerightvertical"] = 65080;
              t2["bracketleft"] = 91;
              t2["bracketleftbt"] = 63728;
              t2["bracketleftex"] = 63727;
              t2["bracketleftmonospace"] = 65339;
              t2["bracketlefttp"] = 63726;
              t2["bracketright"] = 93;
              t2["bracketrightbt"] = 63739;
              t2["bracketrightex"] = 63738;
              t2["bracketrightmonospace"] = 65341;
              t2["bracketrighttp"] = 63737;
              t2["breve"] = 728;
              t2["brevebelowcmb"] = 814;
              t2["brevecmb"] = 774;
              t2["breveinvertedbelowcmb"] = 815;
              t2["breveinvertedcmb"] = 785;
              t2["breveinverteddoublecmb"] = 865;
              t2["bridgebelowcmb"] = 810;
              t2["bridgeinvertedbelowcmb"] = 826;
              t2["brokenbar"] = 166;
              t2["bstroke"] = 384;
              t2["bsuperior"] = 63210;
              t2["btopbar"] = 387;
              t2["buhiragana"] = 12406;
              t2["bukatakana"] = 12502;
              t2["bullet"] = 8226;
              t2["bulletinverse"] = 9688;
              t2["bulletoperator"] = 8729;
              t2["bullseye"] = 9678;
              t2["c"] = 99;
              t2["caarmenian"] = 1390;
              t2["cabengali"] = 2458;
              t2["cacute"] = 263;
              t2["cadeva"] = 2330;
              t2["cagujarati"] = 2714;
              t2["cagurmukhi"] = 2586;
              t2["calsquare"] = 13192;
              t2["candrabindubengali"] = 2433;
              t2["candrabinducmb"] = 784;
              t2["candrabindudeva"] = 2305;
              t2["candrabindugujarati"] = 2689;
              t2["capslock"] = 8682;
              t2["careof"] = 8453;
              t2["caron"] = 711;
              t2["caronbelowcmb"] = 812;
              t2["caroncmb"] = 780;
              t2["carriagereturn"] = 8629;
              t2["cbopomofo"] = 12568;
              t2["ccaron"] = 269;
              t2["ccedilla"] = 231;
              t2["ccedillaacute"] = 7689;
              t2["ccircle"] = 9426;
              t2["ccircumflex"] = 265;
              t2["ccurl"] = 597;
              t2["cdot"] = 267;
              t2["cdotaccent"] = 267;
              t2["cdsquare"] = 13253;
              t2["cedilla"] = 184;
              t2["cedillacmb"] = 807;
              t2["cent"] = 162;
              t2["centigrade"] = 8451;
              t2["centinferior"] = 63199;
              t2["centmonospace"] = 65504;
              t2["centoldstyle"] = 63394;
              t2["centsuperior"] = 63200;
              t2["chaarmenian"] = 1401;
              t2["chabengali"] = 2459;
              t2["chadeva"] = 2331;
              t2["chagujarati"] = 2715;
              t2["chagurmukhi"] = 2587;
              t2["chbopomofo"] = 12564;
              t2["cheabkhasiancyrillic"] = 1213;
              t2["checkmark"] = 10003;
              t2["checyrillic"] = 1095;
              t2["chedescenderabkhasiancyrillic"] = 1215;
              t2["chedescendercyrillic"] = 1207;
              t2["chedieresiscyrillic"] = 1269;
              t2["cheharmenian"] = 1395;
              t2["chekhakassiancyrillic"] = 1228;
              t2["cheverticalstrokecyrillic"] = 1209;
              t2["chi"] = 967;
              t2["chieuchacirclekorean"] = 12919;
              t2["chieuchaparenkorean"] = 12823;
              t2["chieuchcirclekorean"] = 12905;
              t2["chieuchkorean"] = 12618;
              t2["chieuchparenkorean"] = 12809;
              t2["chochangthai"] = 3594;
              t2["chochanthai"] = 3592;
              t2["chochingthai"] = 3593;
              t2["chochoethai"] = 3596;
              t2["chook"] = 392;
              t2["cieucacirclekorean"] = 12918;
              t2["cieucaparenkorean"] = 12822;
              t2["cieuccirclekorean"] = 12904;
              t2["cieuckorean"] = 12616;
              t2["cieucparenkorean"] = 12808;
              t2["cieucuparenkorean"] = 12828;
              t2["circle"] = 9675;
              t2["circlecopyrt"] = 169;
              t2["circlemultiply"] = 8855;
              t2["circleot"] = 8857;
              t2["circleplus"] = 8853;
              t2["circlepostalmark"] = 12342;
              t2["circlewithlefthalfblack"] = 9680;
              t2["circlewithrighthalfblack"] = 9681;
              t2["circumflex"] = 710;
              t2["circumflexbelowcmb"] = 813;
              t2["circumflexcmb"] = 770;
              t2["clear"] = 8999;
              t2["clickalveolar"] = 450;
              t2["clickdental"] = 448;
              t2["clicklateral"] = 449;
              t2["clickretroflex"] = 451;
              t2["club"] = 9827;
              t2["clubsuitblack"] = 9827;
              t2["clubsuitwhite"] = 9831;
              t2["cmcubedsquare"] = 13220;
              t2["cmonospace"] = 65347;
              t2["cmsquaredsquare"] = 13216;
              t2["coarmenian"] = 1409;
              t2["colon"] = 58;
              t2["colonmonetary"] = 8353;
              t2["colonmonospace"] = 65306;
              t2["colonsign"] = 8353;
              t2["colonsmall"] = 65109;
              t2["colontriangularhalfmod"] = 721;
              t2["colontriangularmod"] = 720;
              t2["comma"] = 44;
              t2["commaabovecmb"] = 787;
              t2["commaaboverightcmb"] = 789;
              t2["commaaccent"] = 63171;
              t2["commaarabic"] = 1548;
              t2["commaarmenian"] = 1373;
              t2["commainferior"] = 63201;
              t2["commamonospace"] = 65292;
              t2["commareversedabovecmb"] = 788;
              t2["commareversedmod"] = 701;
              t2["commasmall"] = 65104;
              t2["commasuperior"] = 63202;
              t2["commaturnedabovecmb"] = 786;
              t2["commaturnedmod"] = 699;
              t2["compass"] = 9788;
              t2["congruent"] = 8773;
              t2["contourintegral"] = 8750;
              t2["control"] = 8963;
              t2["controlACK"] = 6;
              t2["controlBEL"] = 7;
              t2["controlBS"] = 8;
              t2["controlCAN"] = 24;
              t2["controlCR"] = 13;
              t2["controlDC1"] = 17;
              t2["controlDC2"] = 18;
              t2["controlDC3"] = 19;
              t2["controlDC4"] = 20;
              t2["controlDEL"] = 127;
              t2["controlDLE"] = 16;
              t2["controlEM"] = 25;
              t2["controlENQ"] = 5;
              t2["controlEOT"] = 4;
              t2["controlESC"] = 27;
              t2["controlETB"] = 23;
              t2["controlETX"] = 3;
              t2["controlFF"] = 12;
              t2["controlFS"] = 28;
              t2["controlGS"] = 29;
              t2["controlHT"] = 9;
              t2["controlLF"] = 10;
              t2["controlNAK"] = 21;
              t2["controlNULL"] = 0;
              t2["controlRS"] = 30;
              t2["controlSI"] = 15;
              t2["controlSO"] = 14;
              t2["controlSOT"] = 2;
              t2["controlSTX"] = 1;
              t2["controlSUB"] = 26;
              t2["controlSYN"] = 22;
              t2["controlUS"] = 31;
              t2["controlVT"] = 11;
              t2["copyright"] = 169;
              t2["copyrightsans"] = 63721;
              t2["copyrightserif"] = 63193;
              t2["cornerbracketleft"] = 12300;
              t2["cornerbracketlefthalfwidth"] = 65378;
              t2["cornerbracketleftvertical"] = 65089;
              t2["cornerbracketright"] = 12301;
              t2["cornerbracketrighthalfwidth"] = 65379;
              t2["cornerbracketrightvertical"] = 65090;
              t2["corporationsquare"] = 13183;
              t2["cosquare"] = 13255;
              t2["coverkgsquare"] = 13254;
              t2["cparen"] = 9374;
              t2["cruzeiro"] = 8354;
              t2["cstretched"] = 663;
              t2["curlyand"] = 8911;
              t2["curlyor"] = 8910;
              t2["currency"] = 164;
              t2["cyrBreve"] = 63185;
              t2["cyrFlex"] = 63186;
              t2["cyrbreve"] = 63188;
              t2["cyrflex"] = 63189;
              t2["d"] = 100;
              t2["daarmenian"] = 1380;
              t2["dabengali"] = 2470;
              t2["dadarabic"] = 1590;
              t2["dadeva"] = 2342;
              t2["dadfinalarabic"] = 65214;
              t2["dadinitialarabic"] = 65215;
              t2["dadmedialarabic"] = 65216;
              t2["dagesh"] = 1468;
              t2["dageshhebrew"] = 1468;
              t2["dagger"] = 8224;
              t2["daggerdbl"] = 8225;
              t2["dagujarati"] = 2726;
              t2["dagurmukhi"] = 2598;
              t2["dahiragana"] = 12384;
              t2["dakatakana"] = 12480;
              t2["dalarabic"] = 1583;
              t2["dalet"] = 1491;
              t2["daletdagesh"] = 64307;
              t2["daletdageshhebrew"] = 64307;
              t2["dalethebrew"] = 1491;
              t2["dalfinalarabic"] = 65194;
              t2["dammaarabic"] = 1615;
              t2["dammalowarabic"] = 1615;
              t2["dammatanaltonearabic"] = 1612;
              t2["dammatanarabic"] = 1612;
              t2["danda"] = 2404;
              t2["dargahebrew"] = 1447;
              t2["dargalefthebrew"] = 1447;
              t2["dasiapneumatacyrilliccmb"] = 1157;
              t2["dblGrave"] = 63187;
              t2["dblanglebracketleft"] = 12298;
              t2["dblanglebracketleftvertical"] = 65085;
              t2["dblanglebracketright"] = 12299;
              t2["dblanglebracketrightvertical"] = 65086;
              t2["dblarchinvertedbelowcmb"] = 811;
              t2["dblarrowleft"] = 8660;
              t2["dblarrowright"] = 8658;
              t2["dbldanda"] = 2405;
              t2["dblgrave"] = 63190;
              t2["dblgravecmb"] = 783;
              t2["dblintegral"] = 8748;
              t2["dbllowline"] = 8215;
              t2["dbllowlinecmb"] = 819;
              t2["dbloverlinecmb"] = 831;
              t2["dblprimemod"] = 698;
              t2["dblverticalbar"] = 8214;
              t2["dblverticallineabovecmb"] = 782;
              t2["dbopomofo"] = 12553;
              t2["dbsquare"] = 13256;
              t2["dcaron"] = 271;
              t2["dcedilla"] = 7697;
              t2["dcircle"] = 9427;
              t2["dcircumflexbelow"] = 7699;
              t2["dcroat"] = 273;
              t2["ddabengali"] = 2465;
              t2["ddadeva"] = 2337;
              t2["ddagujarati"] = 2721;
              t2["ddagurmukhi"] = 2593;
              t2["ddalarabic"] = 1672;
              t2["ddalfinalarabic"] = 64393;
              t2["dddhadeva"] = 2396;
              t2["ddhabengali"] = 2466;
              t2["ddhadeva"] = 2338;
              t2["ddhagujarati"] = 2722;
              t2["ddhagurmukhi"] = 2594;
              t2["ddotaccent"] = 7691;
              t2["ddotbelow"] = 7693;
              t2["decimalseparatorarabic"] = 1643;
              t2["decimalseparatorpersian"] = 1643;
              t2["decyrillic"] = 1076;
              t2["degree"] = 176;
              t2["dehihebrew"] = 1453;
              t2["dehiragana"] = 12391;
              t2["deicoptic"] = 1007;
              t2["dekatakana"] = 12487;
              t2["deleteleft"] = 9003;
              t2["deleteright"] = 8998;
              t2["delta"] = 948;
              t2["deltaturned"] = 397;
              t2["denominatorminusonenumeratorbengali"] = 2552;
              t2["dezh"] = 676;
              t2["dhabengali"] = 2471;
              t2["dhadeva"] = 2343;
              t2["dhagujarati"] = 2727;
              t2["dhagurmukhi"] = 2599;
              t2["dhook"] = 599;
              t2["dialytikatonos"] = 901;
              t2["dialytikatonoscmb"] = 836;
              t2["diamond"] = 9830;
              t2["diamondsuitwhite"] = 9826;
              t2["dieresis"] = 168;
              t2["dieresisacute"] = 63191;
              t2["dieresisbelowcmb"] = 804;
              t2["dieresiscmb"] = 776;
              t2["dieresisgrave"] = 63192;
              t2["dieresistonos"] = 901;
              t2["dihiragana"] = 12386;
              t2["dikatakana"] = 12482;
              t2["dittomark"] = 12291;
              t2["divide"] = 247;
              t2["divides"] = 8739;
              t2["divisionslash"] = 8725;
              t2["djecyrillic"] = 1106;
              t2["dkshade"] = 9619;
              t2["dlinebelow"] = 7695;
              t2["dlsquare"] = 13207;
              t2["dmacron"] = 273;
              t2["dmonospace"] = 65348;
              t2["dnblock"] = 9604;
              t2["dochadathai"] = 3598;
              t2["dodekthai"] = 3604;
              t2["dohiragana"] = 12393;
              t2["dokatakana"] = 12489;
              t2["dollar"] = 36;
              t2["dollarinferior"] = 63203;
              t2["dollarmonospace"] = 65284;
              t2["dollaroldstyle"] = 63268;
              t2["dollarsmall"] = 65129;
              t2["dollarsuperior"] = 63204;
              t2["dong"] = 8363;
              t2["dorusquare"] = 13094;
              t2["dotaccent"] = 729;
              t2["dotaccentcmb"] = 775;
              t2["dotbelowcmb"] = 803;
              t2["dotbelowcomb"] = 803;
              t2["dotkatakana"] = 12539;
              t2["dotlessi"] = 305;
              t2["dotlessj"] = 63166;
              t2["dotlessjstrokehook"] = 644;
              t2["dotmath"] = 8901;
              t2["dottedcircle"] = 9676;
              t2["doubleyodpatah"] = 64287;
              t2["doubleyodpatahhebrew"] = 64287;
              t2["downtackbelowcmb"] = 798;
              t2["downtackmod"] = 725;
              t2["dparen"] = 9375;
              t2["dsuperior"] = 63211;
              t2["dtail"] = 598;
              t2["dtopbar"] = 396;
              t2["duhiragana"] = 12389;
              t2["dukatakana"] = 12485;
              t2["dz"] = 499;
              t2["dzaltone"] = 675;
              t2["dzcaron"] = 454;
              t2["dzcurl"] = 677;
              t2["dzeabkhasiancyrillic"] = 1249;
              t2["dzecyrillic"] = 1109;
              t2["dzhecyrillic"] = 1119;
              t2["e"] = 101;
              t2["eacute"] = 233;
              t2["earth"] = 9793;
              t2["ebengali"] = 2447;
              t2["ebopomofo"] = 12572;
              t2["ebreve"] = 277;
              t2["ecandradeva"] = 2317;
              t2["ecandragujarati"] = 2701;
              t2["ecandravowelsigndeva"] = 2373;
              t2["ecandravowelsigngujarati"] = 2757;
              t2["ecaron"] = 283;
              t2["ecedillabreve"] = 7709;
              t2["echarmenian"] = 1381;
              t2["echyiwnarmenian"] = 1415;
              t2["ecircle"] = 9428;
              t2["ecircumflex"] = 234;
              t2["ecircumflexacute"] = 7871;
              t2["ecircumflexbelow"] = 7705;
              t2["ecircumflexdotbelow"] = 7879;
              t2["ecircumflexgrave"] = 7873;
              t2["ecircumflexhookabove"] = 7875;
              t2["ecircumflextilde"] = 7877;
              t2["ecyrillic"] = 1108;
              t2["edblgrave"] = 517;
              t2["edeva"] = 2319;
              t2["edieresis"] = 235;
              t2["edot"] = 279;
              t2["edotaccent"] = 279;
              t2["edotbelow"] = 7865;
              t2["eegurmukhi"] = 2575;
              t2["eematragurmukhi"] = 2631;
              t2["efcyrillic"] = 1092;
              t2["egrave"] = 232;
              t2["egujarati"] = 2703;
              t2["eharmenian"] = 1383;
              t2["ehbopomofo"] = 12573;
              t2["ehiragana"] = 12360;
              t2["ehookabove"] = 7867;
              t2["eibopomofo"] = 12575;
              t2["eight"] = 56;
              t2["eightarabic"] = 1640;
              t2["eightbengali"] = 2542;
              t2["eightcircle"] = 9319;
              t2["eightcircleinversesansserif"] = 10129;
              t2["eightdeva"] = 2414;
              t2["eighteencircle"] = 9329;
              t2["eighteenparen"] = 9349;
              t2["eighteenperiod"] = 9369;
              t2["eightgujarati"] = 2798;
              t2["eightgurmukhi"] = 2670;
              t2["eighthackarabic"] = 1640;
              t2["eighthangzhou"] = 12328;
              t2["eighthnotebeamed"] = 9835;
              t2["eightideographicparen"] = 12839;
              t2["eightinferior"] = 8328;
              t2["eightmonospace"] = 65304;
              t2["eightoldstyle"] = 63288;
              t2["eightparen"] = 9339;
              t2["eightperiod"] = 9359;
              t2["eightpersian"] = 1784;
              t2["eightroman"] = 8567;
              t2["eightsuperior"] = 8312;
              t2["eightthai"] = 3672;
              t2["einvertedbreve"] = 519;
              t2["eiotifiedcyrillic"] = 1125;
              t2["ekatakana"] = 12456;
              t2["ekatakanahalfwidth"] = 65396;
              t2["ekonkargurmukhi"] = 2676;
              t2["ekorean"] = 12628;
              t2["elcyrillic"] = 1083;
              t2["element"] = 8712;
              t2["elevencircle"] = 9322;
              t2["elevenparen"] = 9342;
              t2["elevenperiod"] = 9362;
              t2["elevenroman"] = 8570;
              t2["ellipsis"] = 8230;
              t2["ellipsisvertical"] = 8942;
              t2["emacron"] = 275;
              t2["emacronacute"] = 7703;
              t2["emacrongrave"] = 7701;
              t2["emcyrillic"] = 1084;
              t2["emdash"] = 8212;
              t2["emdashvertical"] = 65073;
              t2["emonospace"] = 65349;
              t2["emphasismarkarmenian"] = 1371;
              t2["emptyset"] = 8709;
              t2["enbopomofo"] = 12579;
              t2["encyrillic"] = 1085;
              t2["endash"] = 8211;
              t2["endashvertical"] = 65074;
              t2["endescendercyrillic"] = 1187;
              t2["eng"] = 331;
              t2["engbopomofo"] = 12581;
              t2["enghecyrillic"] = 1189;
              t2["enhookcyrillic"] = 1224;
              t2["enspace"] = 8194;
              t2["eogonek"] = 281;
              t2["eokorean"] = 12627;
              t2["eopen"] = 603;
              t2["eopenclosed"] = 666;
              t2["eopenreversed"] = 604;
              t2["eopenreversedclosed"] = 606;
              t2["eopenreversedhook"] = 605;
              t2["eparen"] = 9376;
              t2["epsilon"] = 949;
              t2["epsilontonos"] = 941;
              t2["equal"] = 61;
              t2["equalmonospace"] = 65309;
              t2["equalsmall"] = 65126;
              t2["equalsuperior"] = 8316;
              t2["equivalence"] = 8801;
              t2["erbopomofo"] = 12582;
              t2["ercyrillic"] = 1088;
              t2["ereversed"] = 600;
              t2["ereversedcyrillic"] = 1101;
              t2["escyrillic"] = 1089;
              t2["esdescendercyrillic"] = 1195;
              t2["esh"] = 643;
              t2["eshcurl"] = 646;
              t2["eshortdeva"] = 2318;
              t2["eshortvowelsigndeva"] = 2374;
              t2["eshreversedloop"] = 426;
              t2["eshsquatreversed"] = 645;
              t2["esmallhiragana"] = 12359;
              t2["esmallkatakana"] = 12455;
              t2["esmallkatakanahalfwidth"] = 65386;
              t2["estimated"] = 8494;
              t2["esuperior"] = 63212;
              t2["eta"] = 951;
              t2["etarmenian"] = 1384;
              t2["etatonos"] = 942;
              t2["eth"] = 240;
              t2["etilde"] = 7869;
              t2["etildebelow"] = 7707;
              t2["etnahtafoukhhebrew"] = 1425;
              t2["etnahtafoukhlefthebrew"] = 1425;
              t2["etnahtahebrew"] = 1425;
              t2["etnahtalefthebrew"] = 1425;
              t2["eturned"] = 477;
              t2["eukorean"] = 12641;
              t2["euro"] = 8364;
              t2["evowelsignbengali"] = 2503;
              t2["evowelsigndeva"] = 2375;
              t2["evowelsigngujarati"] = 2759;
              t2["exclam"] = 33;
              t2["exclamarmenian"] = 1372;
              t2["exclamdbl"] = 8252;
              t2["exclamdown"] = 161;
              t2["exclamdownsmall"] = 63393;
              t2["exclammonospace"] = 65281;
              t2["exclamsmall"] = 63265;
              t2["existential"] = 8707;
              t2["ezh"] = 658;
              t2["ezhcaron"] = 495;
              t2["ezhcurl"] = 659;
              t2["ezhreversed"] = 441;
              t2["ezhtail"] = 442;
              t2["f"] = 102;
              t2["fadeva"] = 2398;
              t2["fagurmukhi"] = 2654;
              t2["fahrenheit"] = 8457;
              t2["fathaarabic"] = 1614;
              t2["fathalowarabic"] = 1614;
              t2["fathatanarabic"] = 1611;
              t2["fbopomofo"] = 12552;
              t2["fcircle"] = 9429;
              t2["fdotaccent"] = 7711;
              t2["feharabic"] = 1601;
              t2["feharmenian"] = 1414;
              t2["fehfinalarabic"] = 65234;
              t2["fehinitialarabic"] = 65235;
              t2["fehmedialarabic"] = 65236;
              t2["feicoptic"] = 997;
              t2["female"] = 9792;
              t2["ff"] = 64256;
              t2["f_f"] = 64256;
              t2["ffi"] = 64259;
              t2["ffl"] = 64260;
              t2["fi"] = 64257;
              t2["fifteencircle"] = 9326;
              t2["fifteenparen"] = 9346;
              t2["fifteenperiod"] = 9366;
              t2["figuredash"] = 8210;
              t2["filledbox"] = 9632;
              t2["filledrect"] = 9644;
              t2["finalkaf"] = 1498;
              t2["finalkafdagesh"] = 64314;
              t2["finalkafdageshhebrew"] = 64314;
              t2["finalkafhebrew"] = 1498;
              t2["finalmem"] = 1501;
              t2["finalmemhebrew"] = 1501;
              t2["finalnun"] = 1503;
              t2["finalnunhebrew"] = 1503;
              t2["finalpe"] = 1507;
              t2["finalpehebrew"] = 1507;
              t2["finaltsadi"] = 1509;
              t2["finaltsadihebrew"] = 1509;
              t2["firsttonechinese"] = 713;
              t2["fisheye"] = 9673;
              t2["fitacyrillic"] = 1139;
              t2["five"] = 53;
              t2["fivearabic"] = 1637;
              t2["fivebengali"] = 2539;
              t2["fivecircle"] = 9316;
              t2["fivecircleinversesansserif"] = 10126;
              t2["fivedeva"] = 2411;
              t2["fiveeighths"] = 8541;
              t2["fivegujarati"] = 2795;
              t2["fivegurmukhi"] = 2667;
              t2["fivehackarabic"] = 1637;
              t2["fivehangzhou"] = 12325;
              t2["fiveideographicparen"] = 12836;
              t2["fiveinferior"] = 8325;
              t2["fivemonospace"] = 65301;
              t2["fiveoldstyle"] = 63285;
              t2["fiveparen"] = 9336;
              t2["fiveperiod"] = 9356;
              t2["fivepersian"] = 1781;
              t2["fiveroman"] = 8564;
              t2["fivesuperior"] = 8309;
              t2["fivethai"] = 3669;
              t2["fl"] = 64258;
              t2["florin"] = 402;
              t2["fmonospace"] = 65350;
              t2["fmsquare"] = 13209;
              t2["fofanthai"] = 3615;
              t2["fofathai"] = 3613;
              t2["fongmanthai"] = 3663;
              t2["forall"] = 8704;
              t2["four"] = 52;
              t2["fourarabic"] = 1636;
              t2["fourbengali"] = 2538;
              t2["fourcircle"] = 9315;
              t2["fourcircleinversesansserif"] = 10125;
              t2["fourdeva"] = 2410;
              t2["fourgujarati"] = 2794;
              t2["fourgurmukhi"] = 2666;
              t2["fourhackarabic"] = 1636;
              t2["fourhangzhou"] = 12324;
              t2["fourideographicparen"] = 12835;
              t2["fourinferior"] = 8324;
              t2["fourmonospace"] = 65300;
              t2["fournumeratorbengali"] = 2551;
              t2["fouroldstyle"] = 63284;
              t2["fourparen"] = 9335;
              t2["fourperiod"] = 9355;
              t2["fourpersian"] = 1780;
              t2["fourroman"] = 8563;
              t2["foursuperior"] = 8308;
              t2["fourteencircle"] = 9325;
              t2["fourteenparen"] = 9345;
              t2["fourteenperiod"] = 9365;
              t2["fourthai"] = 3668;
              t2["fourthtonechinese"] = 715;
              t2["fparen"] = 9377;
              t2["fraction"] = 8260;
              t2["franc"] = 8355;
              t2["g"] = 103;
              t2["gabengali"] = 2455;
              t2["gacute"] = 501;
              t2["gadeva"] = 2327;
              t2["gafarabic"] = 1711;
              t2["gaffinalarabic"] = 64403;
              t2["gafinitialarabic"] = 64404;
              t2["gafmedialarabic"] = 64405;
              t2["gagujarati"] = 2711;
              t2["gagurmukhi"] = 2583;
              t2["gahiragana"] = 12364;
              t2["gakatakana"] = 12460;
              t2["gamma"] = 947;
              t2["gammalatinsmall"] = 611;
              t2["gammasuperior"] = 736;
              t2["gangiacoptic"] = 1003;
              t2["gbopomofo"] = 12557;
              t2["gbreve"] = 287;
              t2["gcaron"] = 487;
              t2["gcedilla"] = 291;
              t2["gcircle"] = 9430;
              t2["gcircumflex"] = 285;
              t2["gcommaaccent"] = 291;
              t2["gdot"] = 289;
              t2["gdotaccent"] = 289;
              t2["gecyrillic"] = 1075;
              t2["gehiragana"] = 12370;
              t2["gekatakana"] = 12466;
              t2["geometricallyequal"] = 8785;
              t2["gereshaccenthebrew"] = 1436;
              t2["gereshhebrew"] = 1523;
              t2["gereshmuqdamhebrew"] = 1437;
              t2["germandbls"] = 223;
              t2["gershayimaccenthebrew"] = 1438;
              t2["gershayimhebrew"] = 1524;
              t2["getamark"] = 12307;
              t2["ghabengali"] = 2456;
              t2["ghadarmenian"] = 1394;
              t2["ghadeva"] = 2328;
              t2["ghagujarati"] = 2712;
              t2["ghagurmukhi"] = 2584;
              t2["ghainarabic"] = 1594;
              t2["ghainfinalarabic"] = 65230;
              t2["ghaininitialarabic"] = 65231;
              t2["ghainmedialarabic"] = 65232;
              t2["ghemiddlehookcyrillic"] = 1173;
              t2["ghestrokecyrillic"] = 1171;
              t2["gheupturncyrillic"] = 1169;
              t2["ghhadeva"] = 2394;
              t2["ghhagurmukhi"] = 2650;
              t2["ghook"] = 608;
              t2["ghzsquare"] = 13203;
              t2["gihiragana"] = 12366;
              t2["gikatakana"] = 12462;
              t2["gimarmenian"] = 1379;
              t2["gimel"] = 1490;
              t2["gimeldagesh"] = 64306;
              t2["gimeldageshhebrew"] = 64306;
              t2["gimelhebrew"] = 1490;
              t2["gjecyrillic"] = 1107;
              t2["glottalinvertedstroke"] = 446;
              t2["glottalstop"] = 660;
              t2["glottalstopinverted"] = 662;
              t2["glottalstopmod"] = 704;
              t2["glottalstopreversed"] = 661;
              t2["glottalstopreversedmod"] = 705;
              t2["glottalstopreversedsuperior"] = 740;
              t2["glottalstopstroke"] = 673;
              t2["glottalstopstrokereversed"] = 674;
              t2["gmacron"] = 7713;
              t2["gmonospace"] = 65351;
              t2["gohiragana"] = 12372;
              t2["gokatakana"] = 12468;
              t2["gparen"] = 9378;
              t2["gpasquare"] = 13228;
              t2["gradient"] = 8711;
              t2["grave"] = 96;
              t2["gravebelowcmb"] = 790;
              t2["gravecmb"] = 768;
              t2["gravecomb"] = 768;
              t2["gravedeva"] = 2387;
              t2["gravelowmod"] = 718;
              t2["gravemonospace"] = 65344;
              t2["gravetonecmb"] = 832;
              t2["greater"] = 62;
              t2["greaterequal"] = 8805;
              t2["greaterequalorless"] = 8923;
              t2["greatermonospace"] = 65310;
              t2["greaterorequivalent"] = 8819;
              t2["greaterorless"] = 8823;
              t2["greateroverequal"] = 8807;
              t2["greatersmall"] = 65125;
              t2["gscript"] = 609;
              t2["gstroke"] = 485;
              t2["guhiragana"] = 12368;
              t2["guillemotleft"] = 171;
              t2["guillemotright"] = 187;
              t2["guilsinglleft"] = 8249;
              t2["guilsinglright"] = 8250;
              t2["gukatakana"] = 12464;
              t2["guramusquare"] = 13080;
              t2["gysquare"] = 13257;
              t2["h"] = 104;
              t2["haabkhasiancyrillic"] = 1193;
              t2["haaltonearabic"] = 1729;
              t2["habengali"] = 2489;
              t2["hadescendercyrillic"] = 1203;
              t2["hadeva"] = 2361;
              t2["hagujarati"] = 2745;
              t2["hagurmukhi"] = 2617;
              t2["haharabic"] = 1581;
              t2["hahfinalarabic"] = 65186;
              t2["hahinitialarabic"] = 65187;
              t2["hahiragana"] = 12399;
              t2["hahmedialarabic"] = 65188;
              t2["haitusquare"] = 13098;
              t2["hakatakana"] = 12495;
              t2["hakatakanahalfwidth"] = 65418;
              t2["halantgurmukhi"] = 2637;
              t2["hamzaarabic"] = 1569;
              t2["hamzalowarabic"] = 1569;
              t2["hangulfiller"] = 12644;
              t2["hardsigncyrillic"] = 1098;
              t2["harpoonleftbarbup"] = 8636;
              t2["harpoonrightbarbup"] = 8640;
              t2["hasquare"] = 13258;
              t2["hatafpatah"] = 1458;
              t2["hatafpatah16"] = 1458;
              t2["hatafpatah23"] = 1458;
              t2["hatafpatah2f"] = 1458;
              t2["hatafpatahhebrew"] = 1458;
              t2["hatafpatahnarrowhebrew"] = 1458;
              t2["hatafpatahquarterhebrew"] = 1458;
              t2["hatafpatahwidehebrew"] = 1458;
              t2["hatafqamats"] = 1459;
              t2["hatafqamats1b"] = 1459;
              t2["hatafqamats28"] = 1459;
              t2["hatafqamats34"] = 1459;
              t2["hatafqamatshebrew"] = 1459;
              t2["hatafqamatsnarrowhebrew"] = 1459;
              t2["hatafqamatsquarterhebrew"] = 1459;
              t2["hatafqamatswidehebrew"] = 1459;
              t2["hatafsegol"] = 1457;
              t2["hatafsegol17"] = 1457;
              t2["hatafsegol24"] = 1457;
              t2["hatafsegol30"] = 1457;
              t2["hatafsegolhebrew"] = 1457;
              t2["hatafsegolnarrowhebrew"] = 1457;
              t2["hatafsegolquarterhebrew"] = 1457;
              t2["hatafsegolwidehebrew"] = 1457;
              t2["hbar"] = 295;
              t2["hbopomofo"] = 12559;
              t2["hbrevebelow"] = 7723;
              t2["hcedilla"] = 7721;
              t2["hcircle"] = 9431;
              t2["hcircumflex"] = 293;
              t2["hdieresis"] = 7719;
              t2["hdotaccent"] = 7715;
              t2["hdotbelow"] = 7717;
              t2["he"] = 1492;
              t2["heart"] = 9829;
              t2["heartsuitblack"] = 9829;
              t2["heartsuitwhite"] = 9825;
              t2["hedagesh"] = 64308;
              t2["hedageshhebrew"] = 64308;
              t2["hehaltonearabic"] = 1729;
              t2["heharabic"] = 1607;
              t2["hehebrew"] = 1492;
              t2["hehfinalaltonearabic"] = 64423;
              t2["hehfinalalttwoarabic"] = 65258;
              t2["hehfinalarabic"] = 65258;
              t2["hehhamzaabovefinalarabic"] = 64421;
              t2["hehhamzaaboveisolatedarabic"] = 64420;
              t2["hehinitialaltonearabic"] = 64424;
              t2["hehinitialarabic"] = 65259;
              t2["hehiragana"] = 12408;
              t2["hehmedialaltonearabic"] = 64425;
              t2["hehmedialarabic"] = 65260;
              t2["heiseierasquare"] = 13179;
              t2["hekatakana"] = 12504;
              t2["hekatakanahalfwidth"] = 65421;
              t2["hekutaarusquare"] = 13110;
              t2["henghook"] = 615;
              t2["herutusquare"] = 13113;
              t2["het"] = 1495;
              t2["hethebrew"] = 1495;
              t2["hhook"] = 614;
              t2["hhooksuperior"] = 689;
              t2["hieuhacirclekorean"] = 12923;
              t2["hieuhaparenkorean"] = 12827;
              t2["hieuhcirclekorean"] = 12909;
              t2["hieuhkorean"] = 12622;
              t2["hieuhparenkorean"] = 12813;
              t2["hihiragana"] = 12402;
              t2["hikatakana"] = 12498;
              t2["hikatakanahalfwidth"] = 65419;
              t2["hiriq"] = 1460;
              t2["hiriq14"] = 1460;
              t2["hiriq21"] = 1460;
              t2["hiriq2d"] = 1460;
              t2["hiriqhebrew"] = 1460;
              t2["hiriqnarrowhebrew"] = 1460;
              t2["hiriqquarterhebrew"] = 1460;
              t2["hiriqwidehebrew"] = 1460;
              t2["hlinebelow"] = 7830;
              t2["hmonospace"] = 65352;
              t2["hoarmenian"] = 1392;
              t2["hohipthai"] = 3627;
              t2["hohiragana"] = 12411;
              t2["hokatakana"] = 12507;
              t2["hokatakanahalfwidth"] = 65422;
              t2["holam"] = 1465;
              t2["holam19"] = 1465;
              t2["holam26"] = 1465;
              t2["holam32"] = 1465;
              t2["holamhebrew"] = 1465;
              t2["holamnarrowhebrew"] = 1465;
              t2["holamquarterhebrew"] = 1465;
              t2["holamwidehebrew"] = 1465;
              t2["honokhukthai"] = 3630;
              t2["hookabovecomb"] = 777;
              t2["hookcmb"] = 777;
              t2["hookpalatalizedbelowcmb"] = 801;
              t2["hookretroflexbelowcmb"] = 802;
              t2["hoonsquare"] = 13122;
              t2["horicoptic"] = 1001;
              t2["horizontalbar"] = 8213;
              t2["horncmb"] = 795;
              t2["hotsprings"] = 9832;
              t2["house"] = 8962;
              t2["hparen"] = 9379;
              t2["hsuperior"] = 688;
              t2["hturned"] = 613;
              t2["huhiragana"] = 12405;
              t2["huiitosquare"] = 13107;
              t2["hukatakana"] = 12501;
              t2["hukatakanahalfwidth"] = 65420;
              t2["hungarumlaut"] = 733;
              t2["hungarumlautcmb"] = 779;
              t2["hv"] = 405;
              t2["hyphen"] = 45;
              t2["hypheninferior"] = 63205;
              t2["hyphenmonospace"] = 65293;
              t2["hyphensmall"] = 65123;
              t2["hyphensuperior"] = 63206;
              t2["hyphentwo"] = 8208;
              t2["i"] = 105;
              t2["iacute"] = 237;
              t2["iacyrillic"] = 1103;
              t2["ibengali"] = 2439;
              t2["ibopomofo"] = 12583;
              t2["ibreve"] = 301;
              t2["icaron"] = 464;
              t2["icircle"] = 9432;
              t2["icircumflex"] = 238;
              t2["icyrillic"] = 1110;
              t2["idblgrave"] = 521;
              t2["ideographearthcircle"] = 12943;
              t2["ideographfirecircle"] = 12939;
              t2["ideographicallianceparen"] = 12863;
              t2["ideographiccallparen"] = 12858;
              t2["ideographiccentrecircle"] = 12965;
              t2["ideographicclose"] = 12294;
              t2["ideographiccomma"] = 12289;
              t2["ideographiccommaleft"] = 65380;
              t2["ideographiccongratulationparen"] = 12855;
              t2["ideographiccorrectcircle"] = 12963;
              t2["ideographicearthparen"] = 12847;
              t2["ideographicenterpriseparen"] = 12861;
              t2["ideographicexcellentcircle"] = 12957;
              t2["ideographicfestivalparen"] = 12864;
              t2["ideographicfinancialcircle"] = 12950;
              t2["ideographicfinancialparen"] = 12854;
              t2["ideographicfireparen"] = 12843;
              t2["ideographichaveparen"] = 12850;
              t2["ideographichighcircle"] = 12964;
              t2["ideographiciterationmark"] = 12293;
              t2["ideographiclaborcircle"] = 12952;
              t2["ideographiclaborparen"] = 12856;
              t2["ideographicleftcircle"] = 12967;
              t2["ideographiclowcircle"] = 12966;
              t2["ideographicmedicinecircle"] = 12969;
              t2["ideographicmetalparen"] = 12846;
              t2["ideographicmoonparen"] = 12842;
              t2["ideographicnameparen"] = 12852;
              t2["ideographicperiod"] = 12290;
              t2["ideographicprintcircle"] = 12958;
              t2["ideographicreachparen"] = 12867;
              t2["ideographicrepresentparen"] = 12857;
              t2["ideographicresourceparen"] = 12862;
              t2["ideographicrightcircle"] = 12968;
              t2["ideographicsecretcircle"] = 12953;
              t2["ideographicselfparen"] = 12866;
              t2["ideographicsocietyparen"] = 12851;
              t2["ideographicspace"] = 12288;
              t2["ideographicspecialparen"] = 12853;
              t2["ideographicstockparen"] = 12849;
              t2["ideographicstudyparen"] = 12859;
              t2["ideographicsunparen"] = 12848;
              t2["ideographicsuperviseparen"] = 12860;
              t2["ideographicwaterparen"] = 12844;
              t2["ideographicwoodparen"] = 12845;
              t2["ideographiczero"] = 12295;
              t2["ideographmetalcircle"] = 12942;
              t2["ideographmooncircle"] = 12938;
              t2["ideographnamecircle"] = 12948;
              t2["ideographsuncircle"] = 12944;
              t2["ideographwatercircle"] = 12940;
              t2["ideographwoodcircle"] = 12941;
              t2["ideva"] = 2311;
              t2["idieresis"] = 239;
              t2["idieresisacute"] = 7727;
              t2["idieresiscyrillic"] = 1253;
              t2["idotbelow"] = 7883;
              t2["iebrevecyrillic"] = 1239;
              t2["iecyrillic"] = 1077;
              t2["ieungacirclekorean"] = 12917;
              t2["ieungaparenkorean"] = 12821;
              t2["ieungcirclekorean"] = 12903;
              t2["ieungkorean"] = 12615;
              t2["ieungparenkorean"] = 12807;
              t2["igrave"] = 236;
              t2["igujarati"] = 2695;
              t2["igurmukhi"] = 2567;
              t2["ihiragana"] = 12356;
              t2["ihookabove"] = 7881;
              t2["iibengali"] = 2440;
              t2["iicyrillic"] = 1080;
              t2["iideva"] = 2312;
              t2["iigujarati"] = 2696;
              t2["iigurmukhi"] = 2568;
              t2["iimatragurmukhi"] = 2624;
              t2["iinvertedbreve"] = 523;
              t2["iishortcyrillic"] = 1081;
              t2["iivowelsignbengali"] = 2496;
              t2["iivowelsigndeva"] = 2368;
              t2["iivowelsigngujarati"] = 2752;
              t2["ij"] = 307;
              t2["ikatakana"] = 12452;
              t2["ikatakanahalfwidth"] = 65394;
              t2["ikorean"] = 12643;
              t2["ilde"] = 732;
              t2["iluyhebrew"] = 1452;
              t2["imacron"] = 299;
              t2["imacroncyrillic"] = 1251;
              t2["imageorapproximatelyequal"] = 8787;
              t2["imatragurmukhi"] = 2623;
              t2["imonospace"] = 65353;
              t2["increment"] = 8710;
              t2["infinity"] = 8734;
              t2["iniarmenian"] = 1387;
              t2["integral"] = 8747;
              t2["integralbottom"] = 8993;
              t2["integralbt"] = 8993;
              t2["integralex"] = 63733;
              t2["integraltop"] = 8992;
              t2["integraltp"] = 8992;
              t2["intersection"] = 8745;
              t2["intisquare"] = 13061;
              t2["invbullet"] = 9688;
              t2["invcircle"] = 9689;
              t2["invsmileface"] = 9787;
              t2["iocyrillic"] = 1105;
              t2["iogonek"] = 303;
              t2["iota"] = 953;
              t2["iotadieresis"] = 970;
              t2["iotadieresistonos"] = 912;
              t2["iotalatin"] = 617;
              t2["iotatonos"] = 943;
              t2["iparen"] = 9380;
              t2["irigurmukhi"] = 2674;
              t2["ismallhiragana"] = 12355;
              t2["ismallkatakana"] = 12451;
              t2["ismallkatakanahalfwidth"] = 65384;
              t2["issharbengali"] = 2554;
              t2["istroke"] = 616;
              t2["isuperior"] = 63213;
              t2["iterationhiragana"] = 12445;
              t2["iterationkatakana"] = 12541;
              t2["itilde"] = 297;
              t2["itildebelow"] = 7725;
              t2["iubopomofo"] = 12585;
              t2["iucyrillic"] = 1102;
              t2["ivowelsignbengali"] = 2495;
              t2["ivowelsigndeva"] = 2367;
              t2["ivowelsigngujarati"] = 2751;
              t2["izhitsacyrillic"] = 1141;
              t2["izhitsadblgravecyrillic"] = 1143;
              t2["j"] = 106;
              t2["jaarmenian"] = 1393;
              t2["jabengali"] = 2460;
              t2["jadeva"] = 2332;
              t2["jagujarati"] = 2716;
              t2["jagurmukhi"] = 2588;
              t2["jbopomofo"] = 12560;
              t2["jcaron"] = 496;
              t2["jcircle"] = 9433;
              t2["jcircumflex"] = 309;
              t2["jcrossedtail"] = 669;
              t2["jdotlessstroke"] = 607;
              t2["jecyrillic"] = 1112;
              t2["jeemarabic"] = 1580;
              t2["jeemfinalarabic"] = 65182;
              t2["jeeminitialarabic"] = 65183;
              t2["jeemmedialarabic"] = 65184;
              t2["jeharabic"] = 1688;
              t2["jehfinalarabic"] = 64395;
              t2["jhabengali"] = 2461;
              t2["jhadeva"] = 2333;
              t2["jhagujarati"] = 2717;
              t2["jhagurmukhi"] = 2589;
              t2["jheharmenian"] = 1403;
              t2["jis"] = 12292;
              t2["jmonospace"] = 65354;
              t2["jparen"] = 9381;
              t2["jsuperior"] = 690;
              t2["k"] = 107;
              t2["kabashkircyrillic"] = 1185;
              t2["kabengali"] = 2453;
              t2["kacute"] = 7729;
              t2["kacyrillic"] = 1082;
              t2["kadescendercyrillic"] = 1179;
              t2["kadeva"] = 2325;
              t2["kaf"] = 1499;
              t2["kafarabic"] = 1603;
              t2["kafdagesh"] = 64315;
              t2["kafdageshhebrew"] = 64315;
              t2["kaffinalarabic"] = 65242;
              t2["kafhebrew"] = 1499;
              t2["kafinitialarabic"] = 65243;
              t2["kafmedialarabic"] = 65244;
              t2["kafrafehebrew"] = 64333;
              t2["kagujarati"] = 2709;
              t2["kagurmukhi"] = 2581;
              t2["kahiragana"] = 12363;
              t2["kahookcyrillic"] = 1220;
              t2["kakatakana"] = 12459;
              t2["kakatakanahalfwidth"] = 65398;
              t2["kappa"] = 954;
              t2["kappasymbolgreek"] = 1008;
              t2["kapyeounmieumkorean"] = 12657;
              t2["kapyeounphieuphkorean"] = 12676;
              t2["kapyeounpieupkorean"] = 12664;
              t2["kapyeounssangpieupkorean"] = 12665;
              t2["karoriisquare"] = 13069;
              t2["kashidaautoarabic"] = 1600;
              t2["kashidaautonosidebearingarabic"] = 1600;
              t2["kasmallkatakana"] = 12533;
              t2["kasquare"] = 13188;
              t2["kasraarabic"] = 1616;
              t2["kasratanarabic"] = 1613;
              t2["kastrokecyrillic"] = 1183;
              t2["katahiraprolongmarkhalfwidth"] = 65392;
              t2["kaverticalstrokecyrillic"] = 1181;
              t2["kbopomofo"] = 12558;
              t2["kcalsquare"] = 13193;
              t2["kcaron"] = 489;
              t2["kcedilla"] = 311;
              t2["kcircle"] = 9434;
              t2["kcommaaccent"] = 311;
              t2["kdotbelow"] = 7731;
              t2["keharmenian"] = 1412;
              t2["kehiragana"] = 12369;
              t2["kekatakana"] = 12465;
              t2["kekatakanahalfwidth"] = 65401;
              t2["kenarmenian"] = 1391;
              t2["kesmallkatakana"] = 12534;
              t2["kgreenlandic"] = 312;
              t2["khabengali"] = 2454;
              t2["khacyrillic"] = 1093;
              t2["khadeva"] = 2326;
              t2["khagujarati"] = 2710;
              t2["khagurmukhi"] = 2582;
              t2["khaharabic"] = 1582;
              t2["khahfinalarabic"] = 65190;
              t2["khahinitialarabic"] = 65191;
              t2["khahmedialarabic"] = 65192;
              t2["kheicoptic"] = 999;
              t2["khhadeva"] = 2393;
              t2["khhagurmukhi"] = 2649;
              t2["khieukhacirclekorean"] = 12920;
              t2["khieukhaparenkorean"] = 12824;
              t2["khieukhcirclekorean"] = 12906;
              t2["khieukhkorean"] = 12619;
              t2["khieukhparenkorean"] = 12810;
              t2["khokhaithai"] = 3586;
              t2["khokhonthai"] = 3589;
              t2["khokhuatthai"] = 3587;
              t2["khokhwaithai"] = 3588;
              t2["khomutthai"] = 3675;
              t2["khook"] = 409;
              t2["khorakhangthai"] = 3590;
              t2["khzsquare"] = 13201;
              t2["kihiragana"] = 12365;
              t2["kikatakana"] = 12461;
              t2["kikatakanahalfwidth"] = 65399;
              t2["kiroguramusquare"] = 13077;
              t2["kiromeetorusquare"] = 13078;
              t2["kirosquare"] = 13076;
              t2["kiyeokacirclekorean"] = 12910;
              t2["kiyeokaparenkorean"] = 12814;
              t2["kiyeokcirclekorean"] = 12896;
              t2["kiyeokkorean"] = 12593;
              t2["kiyeokparenkorean"] = 12800;
              t2["kiyeoksioskorean"] = 12595;
              t2["kjecyrillic"] = 1116;
              t2["klinebelow"] = 7733;
              t2["klsquare"] = 13208;
              t2["kmcubedsquare"] = 13222;
              t2["kmonospace"] = 65355;
              t2["kmsquaredsquare"] = 13218;
              t2["kohiragana"] = 12371;
              t2["kohmsquare"] = 13248;
              t2["kokaithai"] = 3585;
              t2["kokatakana"] = 12467;
              t2["kokatakanahalfwidth"] = 65402;
              t2["kooposquare"] = 13086;
              t2["koppacyrillic"] = 1153;
              t2["koreanstandardsymbol"] = 12927;
              t2["koroniscmb"] = 835;
              t2["kparen"] = 9382;
              t2["kpasquare"] = 13226;
              t2["ksicyrillic"] = 1135;
              t2["ktsquare"] = 13263;
              t2["kturned"] = 670;
              t2["kuhiragana"] = 12367;
              t2["kukatakana"] = 12463;
              t2["kukatakanahalfwidth"] = 65400;
              t2["kvsquare"] = 13240;
              t2["kwsquare"] = 13246;
              t2["l"] = 108;
              t2["labengali"] = 2482;
              t2["lacute"] = 314;
              t2["ladeva"] = 2354;
              t2["lagujarati"] = 2738;
              t2["lagurmukhi"] = 2610;
              t2["lakkhangyaothai"] = 3653;
              t2["lamaleffinalarabic"] = 65276;
              t2["lamalefhamzaabovefinalarabic"] = 65272;
              t2["lamalefhamzaaboveisolatedarabic"] = 65271;
              t2["lamalefhamzabelowfinalarabic"] = 65274;
              t2["lamalefhamzabelowisolatedarabic"] = 65273;
              t2["lamalefisolatedarabic"] = 65275;
              t2["lamalefmaddaabovefinalarabic"] = 65270;
              t2["lamalefmaddaaboveisolatedarabic"] = 65269;
              t2["lamarabic"] = 1604;
              t2["lambda"] = 955;
              t2["lambdastroke"] = 411;
              t2["lamed"] = 1500;
              t2["lameddagesh"] = 64316;
              t2["lameddageshhebrew"] = 64316;
              t2["lamedhebrew"] = 1500;
              t2["lamfinalarabic"] = 65246;
              t2["lamhahinitialarabic"] = 64714;
              t2["laminitialarabic"] = 65247;
              t2["lamjeeminitialarabic"] = 64713;
              t2["lamkhahinitialarabic"] = 64715;
              t2["lamlamhehisolatedarabic"] = 65010;
              t2["lammedialarabic"] = 65248;
              t2["lammeemhahinitialarabic"] = 64904;
              t2["lammeeminitialarabic"] = 64716;
              t2["largecircle"] = 9711;
              t2["lbar"] = 410;
              t2["lbelt"] = 620;
              t2["lbopomofo"] = 12556;
              t2["lcaron"] = 318;
              t2["lcedilla"] = 316;
              t2["lcircle"] = 9435;
              t2["lcircumflexbelow"] = 7741;
              t2["lcommaaccent"] = 316;
              t2["ldot"] = 320;
              t2["ldotaccent"] = 320;
              t2["ldotbelow"] = 7735;
              t2["ldotbelowmacron"] = 7737;
              t2["leftangleabovecmb"] = 794;
              t2["lefttackbelowcmb"] = 792;
              t2["less"] = 60;
              t2["lessequal"] = 8804;
              t2["lessequalorgreater"] = 8922;
              t2["lessmonospace"] = 65308;
              t2["lessorequivalent"] = 8818;
              t2["lessorgreater"] = 8822;
              t2["lessoverequal"] = 8806;
              t2["lesssmall"] = 65124;
              t2["lezh"] = 622;
              t2["lfblock"] = 9612;
              t2["lhookretroflex"] = 621;
              t2["lira"] = 8356;
              t2["liwnarmenian"] = 1388;
              t2["lj"] = 457;
              t2["ljecyrillic"] = 1113;
              t2["ll"] = 63168;
              t2["lladeva"] = 2355;
              t2["llagujarati"] = 2739;
              t2["llinebelow"] = 7739;
              t2["llladeva"] = 2356;
              t2["llvocalicbengali"] = 2529;
              t2["llvocalicdeva"] = 2401;
              t2["llvocalicvowelsignbengali"] = 2531;
              t2["llvocalicvowelsigndeva"] = 2403;
              t2["lmiddletilde"] = 619;
              t2["lmonospace"] = 65356;
              t2["lmsquare"] = 13264;
              t2["lochulathai"] = 3628;
              t2["logicaland"] = 8743;
              t2["logicalnot"] = 172;
              t2["logicalnotreversed"] = 8976;
              t2["logicalor"] = 8744;
              t2["lolingthai"] = 3621;
              t2["longs"] = 383;
              t2["lowlinecenterline"] = 65102;
              t2["lowlinecmb"] = 818;
              t2["lowlinedashed"] = 65101;
              t2["lozenge"] = 9674;
              t2["lparen"] = 9383;
              t2["lslash"] = 322;
              t2["lsquare"] = 8467;
              t2["lsuperior"] = 63214;
              t2["ltshade"] = 9617;
              t2["luthai"] = 3622;
              t2["lvocalicbengali"] = 2444;
              t2["lvocalicdeva"] = 2316;
              t2["lvocalicvowelsignbengali"] = 2530;
              t2["lvocalicvowelsigndeva"] = 2402;
              t2["lxsquare"] = 13267;
              t2["m"] = 109;
              t2["mabengali"] = 2478;
              t2["macron"] = 175;
              t2["macronbelowcmb"] = 817;
              t2["macroncmb"] = 772;
              t2["macronlowmod"] = 717;
              t2["macronmonospace"] = 65507;
              t2["macute"] = 7743;
              t2["madeva"] = 2350;
              t2["magujarati"] = 2734;
              t2["magurmukhi"] = 2606;
              t2["mahapakhhebrew"] = 1444;
              t2["mahapakhlefthebrew"] = 1444;
              t2["mahiragana"] = 12414;
              t2["maichattawalowleftthai"] = 63637;
              t2["maichattawalowrightthai"] = 63636;
              t2["maichattawathai"] = 3659;
              t2["maichattawaupperleftthai"] = 63635;
              t2["maieklowleftthai"] = 63628;
              t2["maieklowrightthai"] = 63627;
              t2["maiekthai"] = 3656;
              t2["maiekupperleftthai"] = 63626;
              t2["maihanakatleftthai"] = 63620;
              t2["maihanakatthai"] = 3633;
              t2["maitaikhuleftthai"] = 63625;
              t2["maitaikhuthai"] = 3655;
              t2["maitholowleftthai"] = 63631;
              t2["maitholowrightthai"] = 63630;
              t2["maithothai"] = 3657;
              t2["maithoupperleftthai"] = 63629;
              t2["maitrilowleftthai"] = 63634;
              t2["maitrilowrightthai"] = 63633;
              t2["maitrithai"] = 3658;
              t2["maitriupperleftthai"] = 63632;
              t2["maiyamokthai"] = 3654;
              t2["makatakana"] = 12510;
              t2["makatakanahalfwidth"] = 65423;
              t2["male"] = 9794;
              t2["mansyonsquare"] = 13127;
              t2["maqafhebrew"] = 1470;
              t2["mars"] = 9794;
              t2["masoracirclehebrew"] = 1455;
              t2["masquare"] = 13187;
              t2["mbopomofo"] = 12551;
              t2["mbsquare"] = 13268;
              t2["mcircle"] = 9436;
              t2["mcubedsquare"] = 13221;
              t2["mdotaccent"] = 7745;
              t2["mdotbelow"] = 7747;
              t2["meemarabic"] = 1605;
              t2["meemfinalarabic"] = 65250;
              t2["meeminitialarabic"] = 65251;
              t2["meemmedialarabic"] = 65252;
              t2["meemmeeminitialarabic"] = 64721;
              t2["meemmeemisolatedarabic"] = 64584;
              t2["meetorusquare"] = 13133;
              t2["mehiragana"] = 12417;
              t2["meizierasquare"] = 13182;
              t2["mekatakana"] = 12513;
              t2["mekatakanahalfwidth"] = 65426;
              t2["mem"] = 1502;
              t2["memdagesh"] = 64318;
              t2["memdageshhebrew"] = 64318;
              t2["memhebrew"] = 1502;
              t2["menarmenian"] = 1396;
              t2["merkhahebrew"] = 1445;
              t2["merkhakefulahebrew"] = 1446;
              t2["merkhakefulalefthebrew"] = 1446;
              t2["merkhalefthebrew"] = 1445;
              t2["mhook"] = 625;
              t2["mhzsquare"] = 13202;
              t2["middledotkatakanahalfwidth"] = 65381;
              t2["middot"] = 183;
              t2["mieumacirclekorean"] = 12914;
              t2["mieumaparenkorean"] = 12818;
              t2["mieumcirclekorean"] = 12900;
              t2["mieumkorean"] = 12609;
              t2["mieumpansioskorean"] = 12656;
              t2["mieumparenkorean"] = 12804;
              t2["mieumpieupkorean"] = 12654;
              t2["mieumsioskorean"] = 12655;
              t2["mihiragana"] = 12415;
              t2["mikatakana"] = 12511;
              t2["mikatakanahalfwidth"] = 65424;
              t2["minus"] = 8722;
              t2["minusbelowcmb"] = 800;
              t2["minuscircle"] = 8854;
              t2["minusmod"] = 727;
              t2["minusplus"] = 8723;
              t2["minute"] = 8242;
              t2["miribaarusquare"] = 13130;
              t2["mirisquare"] = 13129;
              t2["mlonglegturned"] = 624;
              t2["mlsquare"] = 13206;
              t2["mmcubedsquare"] = 13219;
              t2["mmonospace"] = 65357;
              t2["mmsquaredsquare"] = 13215;
              t2["mohiragana"] = 12418;
              t2["mohmsquare"] = 13249;
              t2["mokatakana"] = 12514;
              t2["mokatakanahalfwidth"] = 65427;
              t2["molsquare"] = 13270;
              t2["momathai"] = 3617;
              t2["moverssquare"] = 13223;
              t2["moverssquaredsquare"] = 13224;
              t2["mparen"] = 9384;
              t2["mpasquare"] = 13227;
              t2["mssquare"] = 13235;
              t2["msuperior"] = 63215;
              t2["mturned"] = 623;
              t2["mu"] = 181;
              t2["mu1"] = 181;
              t2["muasquare"] = 13186;
              t2["muchgreater"] = 8811;
              t2["muchless"] = 8810;
              t2["mufsquare"] = 13196;
              t2["mugreek"] = 956;
              t2["mugsquare"] = 13197;
              t2["muhiragana"] = 12416;
              t2["mukatakana"] = 12512;
              t2["mukatakanahalfwidth"] = 65425;
              t2["mulsquare"] = 13205;
              t2["multiply"] = 215;
              t2["mumsquare"] = 13211;
              t2["munahhebrew"] = 1443;
              t2["munahlefthebrew"] = 1443;
              t2["musicalnote"] = 9834;
              t2["musicalnotedbl"] = 9835;
              t2["musicflatsign"] = 9837;
              t2["musicsharpsign"] = 9839;
              t2["mussquare"] = 13234;
              t2["muvsquare"] = 13238;
              t2["muwsquare"] = 13244;
              t2["mvmegasquare"] = 13241;
              t2["mvsquare"] = 13239;
              t2["mwmegasquare"] = 13247;
              t2["mwsquare"] = 13245;
              t2["n"] = 110;
              t2["nabengali"] = 2472;
              t2["nabla"] = 8711;
              t2["nacute"] = 324;
              t2["nadeva"] = 2344;
              t2["nagujarati"] = 2728;
              t2["nagurmukhi"] = 2600;
              t2["nahiragana"] = 12394;
              t2["nakatakana"] = 12490;
              t2["nakatakanahalfwidth"] = 65413;
              t2["napostrophe"] = 329;
              t2["nasquare"] = 13185;
              t2["nbopomofo"] = 12555;
              t2["nbspace"] = 160;
              t2["ncaron"] = 328;
              t2["ncedilla"] = 326;
              t2["ncircle"] = 9437;
              t2["ncircumflexbelow"] = 7755;
              t2["ncommaaccent"] = 326;
              t2["ndotaccent"] = 7749;
              t2["ndotbelow"] = 7751;
              t2["nehiragana"] = 12397;
              t2["nekatakana"] = 12493;
              t2["nekatakanahalfwidth"] = 65416;
              t2["newsheqelsign"] = 8362;
              t2["nfsquare"] = 13195;
              t2["ngabengali"] = 2457;
              t2["ngadeva"] = 2329;
              t2["ngagujarati"] = 2713;
              t2["ngagurmukhi"] = 2585;
              t2["ngonguthai"] = 3591;
              t2["nhiragana"] = 12435;
              t2["nhookleft"] = 626;
              t2["nhookretroflex"] = 627;
              t2["nieunacirclekorean"] = 12911;
              t2["nieunaparenkorean"] = 12815;
              t2["nieuncieuckorean"] = 12597;
              t2["nieuncirclekorean"] = 12897;
              t2["nieunhieuhkorean"] = 12598;
              t2["nieunkorean"] = 12596;
              t2["nieunpansioskorean"] = 12648;
              t2["nieunparenkorean"] = 12801;
              t2["nieunsioskorean"] = 12647;
              t2["nieuntikeutkorean"] = 12646;
              t2["nihiragana"] = 12395;
              t2["nikatakana"] = 12491;
              t2["nikatakanahalfwidth"] = 65414;
              t2["nikhahitleftthai"] = 63641;
              t2["nikhahitthai"] = 3661;
              t2["nine"] = 57;
              t2["ninearabic"] = 1641;
              t2["ninebengali"] = 2543;
              t2["ninecircle"] = 9320;
              t2["ninecircleinversesansserif"] = 10130;
              t2["ninedeva"] = 2415;
              t2["ninegujarati"] = 2799;
              t2["ninegurmukhi"] = 2671;
              t2["ninehackarabic"] = 1641;
              t2["ninehangzhou"] = 12329;
              t2["nineideographicparen"] = 12840;
              t2["nineinferior"] = 8329;
              t2["ninemonospace"] = 65305;
              t2["nineoldstyle"] = 63289;
              t2["nineparen"] = 9340;
              t2["nineperiod"] = 9360;
              t2["ninepersian"] = 1785;
              t2["nineroman"] = 8568;
              t2["ninesuperior"] = 8313;
              t2["nineteencircle"] = 9330;
              t2["nineteenparen"] = 9350;
              t2["nineteenperiod"] = 9370;
              t2["ninethai"] = 3673;
              t2["nj"] = 460;
              t2["njecyrillic"] = 1114;
              t2["nkatakana"] = 12531;
              t2["nkatakanahalfwidth"] = 65437;
              t2["nlegrightlong"] = 414;
              t2["nlinebelow"] = 7753;
              t2["nmonospace"] = 65358;
              t2["nmsquare"] = 13210;
              t2["nnabengali"] = 2467;
              t2["nnadeva"] = 2339;
              t2["nnagujarati"] = 2723;
              t2["nnagurmukhi"] = 2595;
              t2["nnnadeva"] = 2345;
              t2["nohiragana"] = 12398;
              t2["nokatakana"] = 12494;
              t2["nokatakanahalfwidth"] = 65417;
              t2["nonbreakingspace"] = 160;
              t2["nonenthai"] = 3603;
              t2["nonuthai"] = 3609;
              t2["noonarabic"] = 1606;
              t2["noonfinalarabic"] = 65254;
              t2["noonghunnaarabic"] = 1722;
              t2["noonghunnafinalarabic"] = 64415;
              t2["nooninitialarabic"] = 65255;
              t2["noonjeeminitialarabic"] = 64722;
              t2["noonjeemisolatedarabic"] = 64587;
              t2["noonmedialarabic"] = 65256;
              t2["noonmeeminitialarabic"] = 64725;
              t2["noonmeemisolatedarabic"] = 64590;
              t2["noonnoonfinalarabic"] = 64653;
              t2["notcontains"] = 8716;
              t2["notelement"] = 8713;
              t2["notelementof"] = 8713;
              t2["notequal"] = 8800;
              t2["notgreater"] = 8815;
              t2["notgreaternorequal"] = 8817;
              t2["notgreaternorless"] = 8825;
              t2["notidentical"] = 8802;
              t2["notless"] = 8814;
              t2["notlessnorequal"] = 8816;
              t2["notparallel"] = 8742;
              t2["notprecedes"] = 8832;
              t2["notsubset"] = 8836;
              t2["notsucceeds"] = 8833;
              t2["notsuperset"] = 8837;
              t2["nowarmenian"] = 1398;
              t2["nparen"] = 9385;
              t2["nssquare"] = 13233;
              t2["nsuperior"] = 8319;
              t2["ntilde"] = 241;
              t2["nu"] = 957;
              t2["nuhiragana"] = 12396;
              t2["nukatakana"] = 12492;
              t2["nukatakanahalfwidth"] = 65415;
              t2["nuktabengali"] = 2492;
              t2["nuktadeva"] = 2364;
              t2["nuktagujarati"] = 2748;
              t2["nuktagurmukhi"] = 2620;
              t2["numbersign"] = 35;
              t2["numbersignmonospace"] = 65283;
              t2["numbersignsmall"] = 65119;
              t2["numeralsigngreek"] = 884;
              t2["numeralsignlowergreek"] = 885;
              t2["numero"] = 8470;
              t2["nun"] = 1504;
              t2["nundagesh"] = 64320;
              t2["nundageshhebrew"] = 64320;
              t2["nunhebrew"] = 1504;
              t2["nvsquare"] = 13237;
              t2["nwsquare"] = 13243;
              t2["nyabengali"] = 2462;
              t2["nyadeva"] = 2334;
              t2["nyagujarati"] = 2718;
              t2["nyagurmukhi"] = 2590;
              t2["o"] = 111;
              t2["oacute"] = 243;
              t2["oangthai"] = 3629;
              t2["obarred"] = 629;
              t2["obarredcyrillic"] = 1257;
              t2["obarreddieresiscyrillic"] = 1259;
              t2["obengali"] = 2451;
              t2["obopomofo"] = 12571;
              t2["obreve"] = 335;
              t2["ocandradeva"] = 2321;
              t2["ocandragujarati"] = 2705;
              t2["ocandravowelsigndeva"] = 2377;
              t2["ocandravowelsigngujarati"] = 2761;
              t2["ocaron"] = 466;
              t2["ocircle"] = 9438;
              t2["ocircumflex"] = 244;
              t2["ocircumflexacute"] = 7889;
              t2["ocircumflexdotbelow"] = 7897;
              t2["ocircumflexgrave"] = 7891;
              t2["ocircumflexhookabove"] = 7893;
              t2["ocircumflextilde"] = 7895;
              t2["ocyrillic"] = 1086;
              t2["odblacute"] = 337;
              t2["odblgrave"] = 525;
              t2["odeva"] = 2323;
              t2["odieresis"] = 246;
              t2["odieresiscyrillic"] = 1255;
              t2["odotbelow"] = 7885;
              t2["oe"] = 339;
              t2["oekorean"] = 12634;
              t2["ogonek"] = 731;
              t2["ogonekcmb"] = 808;
              t2["ograve"] = 242;
              t2["ogujarati"] = 2707;
              t2["oharmenian"] = 1413;
              t2["ohiragana"] = 12362;
              t2["ohookabove"] = 7887;
              t2["ohorn"] = 417;
              t2["ohornacute"] = 7899;
              t2["ohorndotbelow"] = 7907;
              t2["ohorngrave"] = 7901;
              t2["ohornhookabove"] = 7903;
              t2["ohorntilde"] = 7905;
              t2["ohungarumlaut"] = 337;
              t2["oi"] = 419;
              t2["oinvertedbreve"] = 527;
              t2["okatakana"] = 12458;
              t2["okatakanahalfwidth"] = 65397;
              t2["okorean"] = 12631;
              t2["olehebrew"] = 1451;
              t2["omacron"] = 333;
              t2["omacronacute"] = 7763;
              t2["omacrongrave"] = 7761;
              t2["omdeva"] = 2384;
              t2["omega"] = 969;
              t2["omega1"] = 982;
              t2["omegacyrillic"] = 1121;
              t2["omegalatinclosed"] = 631;
              t2["omegaroundcyrillic"] = 1147;
              t2["omegatitlocyrillic"] = 1149;
              t2["omegatonos"] = 974;
              t2["omgujarati"] = 2768;
              t2["omicron"] = 959;
              t2["omicrontonos"] = 972;
              t2["omonospace"] = 65359;
              t2["one"] = 49;
              t2["onearabic"] = 1633;
              t2["onebengali"] = 2535;
              t2["onecircle"] = 9312;
              t2["onecircleinversesansserif"] = 10122;
              t2["onedeva"] = 2407;
              t2["onedotenleader"] = 8228;
              t2["oneeighth"] = 8539;
              t2["onefitted"] = 63196;
              t2["onegujarati"] = 2791;
              t2["onegurmukhi"] = 2663;
              t2["onehackarabic"] = 1633;
              t2["onehalf"] = 189;
              t2["onehangzhou"] = 12321;
              t2["oneideographicparen"] = 12832;
              t2["oneinferior"] = 8321;
              t2["onemonospace"] = 65297;
              t2["onenumeratorbengali"] = 2548;
              t2["oneoldstyle"] = 63281;
              t2["oneparen"] = 9332;
              t2["oneperiod"] = 9352;
              t2["onepersian"] = 1777;
              t2["onequarter"] = 188;
              t2["oneroman"] = 8560;
              t2["onesuperior"] = 185;
              t2["onethai"] = 3665;
              t2["onethird"] = 8531;
              t2["oogonek"] = 491;
              t2["oogonekmacron"] = 493;
              t2["oogurmukhi"] = 2579;
              t2["oomatragurmukhi"] = 2635;
              t2["oopen"] = 596;
              t2["oparen"] = 9386;
              t2["openbullet"] = 9702;
              t2["option"] = 8997;
              t2["ordfeminine"] = 170;
              t2["ordmasculine"] = 186;
              t2["orthogonal"] = 8735;
              t2["oshortdeva"] = 2322;
              t2["oshortvowelsigndeva"] = 2378;
              t2["oslash"] = 248;
              t2["oslashacute"] = 511;
              t2["osmallhiragana"] = 12361;
              t2["osmallkatakana"] = 12457;
              t2["osmallkatakanahalfwidth"] = 65387;
              t2["ostrokeacute"] = 511;
              t2["osuperior"] = 63216;
              t2["otcyrillic"] = 1151;
              t2["otilde"] = 245;
              t2["otildeacute"] = 7757;
              t2["otildedieresis"] = 7759;
              t2["oubopomofo"] = 12577;
              t2["overline"] = 8254;
              t2["overlinecenterline"] = 65098;
              t2["overlinecmb"] = 773;
              t2["overlinedashed"] = 65097;
              t2["overlinedblwavy"] = 65100;
              t2["overlinewavy"] = 65099;
              t2["overscore"] = 175;
              t2["ovowelsignbengali"] = 2507;
              t2["ovowelsigndeva"] = 2379;
              t2["ovowelsigngujarati"] = 2763;
              t2["p"] = 112;
              t2["paampssquare"] = 13184;
              t2["paasentosquare"] = 13099;
              t2["pabengali"] = 2474;
              t2["pacute"] = 7765;
              t2["padeva"] = 2346;
              t2["pagedown"] = 8671;
              t2["pageup"] = 8670;
              t2["pagujarati"] = 2730;
              t2["pagurmukhi"] = 2602;
              t2["pahiragana"] = 12401;
              t2["paiyannoithai"] = 3631;
              t2["pakatakana"] = 12497;
              t2["palatalizationcyrilliccmb"] = 1156;
              t2["palochkacyrillic"] = 1216;
              t2["pansioskorean"] = 12671;
              t2["paragraph"] = 182;
              t2["parallel"] = 8741;
              t2["parenleft"] = 40;
              t2["parenleftaltonearabic"] = 64830;
              t2["parenleftbt"] = 63725;
              t2["parenleftex"] = 63724;
              t2["parenleftinferior"] = 8333;
              t2["parenleftmonospace"] = 65288;
              t2["parenleftsmall"] = 65113;
              t2["parenleftsuperior"] = 8317;
              t2["parenlefttp"] = 63723;
              t2["parenleftvertical"] = 65077;
              t2["parenright"] = 41;
              t2["parenrightaltonearabic"] = 64831;
              t2["parenrightbt"] = 63736;
              t2["parenrightex"] = 63735;
              t2["parenrightinferior"] = 8334;
              t2["parenrightmonospace"] = 65289;
              t2["parenrightsmall"] = 65114;
              t2["parenrightsuperior"] = 8318;
              t2["parenrighttp"] = 63734;
              t2["parenrightvertical"] = 65078;
              t2["partialdiff"] = 8706;
              t2["paseqhebrew"] = 1472;
              t2["pashtahebrew"] = 1433;
              t2["pasquare"] = 13225;
              t2["patah"] = 1463;
              t2["patah11"] = 1463;
              t2["patah1d"] = 1463;
              t2["patah2a"] = 1463;
              t2["patahhebrew"] = 1463;
              t2["patahnarrowhebrew"] = 1463;
              t2["patahquarterhebrew"] = 1463;
              t2["patahwidehebrew"] = 1463;
              t2["pazerhebrew"] = 1441;
              t2["pbopomofo"] = 12550;
              t2["pcircle"] = 9439;
              t2["pdotaccent"] = 7767;
              t2["pe"] = 1508;
              t2["pecyrillic"] = 1087;
              t2["pedagesh"] = 64324;
              t2["pedageshhebrew"] = 64324;
              t2["peezisquare"] = 13115;
              t2["pefinaldageshhebrew"] = 64323;
              t2["peharabic"] = 1662;
              t2["peharmenian"] = 1402;
              t2["pehebrew"] = 1508;
              t2["pehfinalarabic"] = 64343;
              t2["pehinitialarabic"] = 64344;
              t2["pehiragana"] = 12410;
              t2["pehmedialarabic"] = 64345;
              t2["pekatakana"] = 12506;
              t2["pemiddlehookcyrillic"] = 1191;
              t2["perafehebrew"] = 64334;
              t2["percent"] = 37;
              t2["percentarabic"] = 1642;
              t2["percentmonospace"] = 65285;
              t2["percentsmall"] = 65130;
              t2["period"] = 46;
              t2["periodarmenian"] = 1417;
              t2["periodcentered"] = 183;
              t2["periodhalfwidth"] = 65377;
              t2["periodinferior"] = 63207;
              t2["periodmonospace"] = 65294;
              t2["periodsmall"] = 65106;
              t2["periodsuperior"] = 63208;
              t2["perispomenigreekcmb"] = 834;
              t2["perpendicular"] = 8869;
              t2["perthousand"] = 8240;
              t2["peseta"] = 8359;
              t2["pfsquare"] = 13194;
              t2["phabengali"] = 2475;
              t2["phadeva"] = 2347;
              t2["phagujarati"] = 2731;
              t2["phagurmukhi"] = 2603;
              t2["phi"] = 966;
              t2["phi1"] = 981;
              t2["phieuphacirclekorean"] = 12922;
              t2["phieuphaparenkorean"] = 12826;
              t2["phieuphcirclekorean"] = 12908;
              t2["phieuphkorean"] = 12621;
              t2["phieuphparenkorean"] = 12812;
              t2["philatin"] = 632;
              t2["phinthuthai"] = 3642;
              t2["phisymbolgreek"] = 981;
              t2["phook"] = 421;
              t2["phophanthai"] = 3614;
              t2["phophungthai"] = 3612;
              t2["phosamphaothai"] = 3616;
              t2["pi"] = 960;
              t2["pieupacirclekorean"] = 12915;
              t2["pieupaparenkorean"] = 12819;
              t2["pieupcieuckorean"] = 12662;
              t2["pieupcirclekorean"] = 12901;
              t2["pieupkiyeokkorean"] = 12658;
              t2["pieupkorean"] = 12610;
              t2["pieupparenkorean"] = 12805;
              t2["pieupsioskiyeokkorean"] = 12660;
              t2["pieupsioskorean"] = 12612;
              t2["pieupsiostikeutkorean"] = 12661;
              t2["pieupthieuthkorean"] = 12663;
              t2["pieuptikeutkorean"] = 12659;
              t2["pihiragana"] = 12404;
              t2["pikatakana"] = 12500;
              t2["pisymbolgreek"] = 982;
              t2["piwrarmenian"] = 1411;
              t2["plus"] = 43;
              t2["plusbelowcmb"] = 799;
              t2["pluscircle"] = 8853;
              t2["plusminus"] = 177;
              t2["plusmod"] = 726;
              t2["plusmonospace"] = 65291;
              t2["plussmall"] = 65122;
              t2["plussuperior"] = 8314;
              t2["pmonospace"] = 65360;
              t2["pmsquare"] = 13272;
              t2["pohiragana"] = 12413;
              t2["pointingindexdownwhite"] = 9759;
              t2["pointingindexleftwhite"] = 9756;
              t2["pointingindexrightwhite"] = 9758;
              t2["pointingindexupwhite"] = 9757;
              t2["pokatakana"] = 12509;
              t2["poplathai"] = 3611;
              t2["postalmark"] = 12306;
              t2["postalmarkface"] = 12320;
              t2["pparen"] = 9387;
              t2["precedes"] = 8826;
              t2["prescription"] = 8478;
              t2["primemod"] = 697;
              t2["primereversed"] = 8245;
              t2["product"] = 8719;
              t2["projective"] = 8965;
              t2["prolongedkana"] = 12540;
              t2["propellor"] = 8984;
              t2["propersubset"] = 8834;
              t2["propersuperset"] = 8835;
              t2["proportion"] = 8759;
              t2["proportional"] = 8733;
              t2["psi"] = 968;
              t2["psicyrillic"] = 1137;
              t2["psilipneumatacyrilliccmb"] = 1158;
              t2["pssquare"] = 13232;
              t2["puhiragana"] = 12407;
              t2["pukatakana"] = 12503;
              t2["pvsquare"] = 13236;
              t2["pwsquare"] = 13242;
              t2["q"] = 113;
              t2["qadeva"] = 2392;
              t2["qadmahebrew"] = 1448;
              t2["qafarabic"] = 1602;
              t2["qaffinalarabic"] = 65238;
              t2["qafinitialarabic"] = 65239;
              t2["qafmedialarabic"] = 65240;
              t2["qamats"] = 1464;
              t2["qamats10"] = 1464;
              t2["qamats1a"] = 1464;
              t2["qamats1c"] = 1464;
              t2["qamats27"] = 1464;
              t2["qamats29"] = 1464;
              t2["qamats33"] = 1464;
              t2["qamatsde"] = 1464;
              t2["qamatshebrew"] = 1464;
              t2["qamatsnarrowhebrew"] = 1464;
              t2["qamatsqatanhebrew"] = 1464;
              t2["qamatsqatannarrowhebrew"] = 1464;
              t2["qamatsqatanquarterhebrew"] = 1464;
              t2["qamatsqatanwidehebrew"] = 1464;
              t2["qamatsquarterhebrew"] = 1464;
              t2["qamatswidehebrew"] = 1464;
              t2["qarneyparahebrew"] = 1439;
              t2["qbopomofo"] = 12561;
              t2["qcircle"] = 9440;
              t2["qhook"] = 672;
              t2["qmonospace"] = 65361;
              t2["qof"] = 1511;
              t2["qofdagesh"] = 64327;
              t2["qofdageshhebrew"] = 64327;
              t2["qofhebrew"] = 1511;
              t2["qparen"] = 9388;
              t2["quarternote"] = 9833;
              t2["qubuts"] = 1467;
              t2["qubuts18"] = 1467;
              t2["qubuts25"] = 1467;
              t2["qubuts31"] = 1467;
              t2["qubutshebrew"] = 1467;
              t2["qubutsnarrowhebrew"] = 1467;
              t2["qubutsquarterhebrew"] = 1467;
              t2["qubutswidehebrew"] = 1467;
              t2["question"] = 63;
              t2["questionarabic"] = 1567;
              t2["questionarmenian"] = 1374;
              t2["questiondown"] = 191;
              t2["questiondownsmall"] = 63423;
              t2["questiongreek"] = 894;
              t2["questionmonospace"] = 65311;
              t2["questionsmall"] = 63295;
              t2["quotedbl"] = 34;
              t2["quotedblbase"] = 8222;
              t2["quotedblleft"] = 8220;
              t2["quotedblmonospace"] = 65282;
              t2["quotedblprime"] = 12318;
              t2["quotedblprimereversed"] = 12317;
              t2["quotedblright"] = 8221;
              t2["quoteleft"] = 8216;
              t2["quoteleftreversed"] = 8219;
              t2["quotereversed"] = 8219;
              t2["quoteright"] = 8217;
              t2["quoterightn"] = 329;
              t2["quotesinglbase"] = 8218;
              t2["quotesingle"] = 39;
              t2["quotesinglemonospace"] = 65287;
              t2["r"] = 114;
              t2["raarmenian"] = 1404;
              t2["rabengali"] = 2480;
              t2["racute"] = 341;
              t2["radeva"] = 2352;
              t2["radical"] = 8730;
              t2["radicalex"] = 63717;
              t2["radoverssquare"] = 13230;
              t2["radoverssquaredsquare"] = 13231;
              t2["radsquare"] = 13229;
              t2["rafe"] = 1471;
              t2["rafehebrew"] = 1471;
              t2["ragujarati"] = 2736;
              t2["ragurmukhi"] = 2608;
              t2["rahiragana"] = 12425;
              t2["rakatakana"] = 12521;
              t2["rakatakanahalfwidth"] = 65431;
              t2["ralowerdiagonalbengali"] = 2545;
              t2["ramiddlediagonalbengali"] = 2544;
              t2["ramshorn"] = 612;
              t2["ratio"] = 8758;
              t2["rbopomofo"] = 12566;
              t2["rcaron"] = 345;
              t2["rcedilla"] = 343;
              t2["rcircle"] = 9441;
              t2["rcommaaccent"] = 343;
              t2["rdblgrave"] = 529;
              t2["rdotaccent"] = 7769;
              t2["rdotbelow"] = 7771;
              t2["rdotbelowmacron"] = 7773;
              t2["referencemark"] = 8251;
              t2["reflexsubset"] = 8838;
              t2["reflexsuperset"] = 8839;
              t2["registered"] = 174;
              t2["registersans"] = 63720;
              t2["registerserif"] = 63194;
              t2["reharabic"] = 1585;
              t2["reharmenian"] = 1408;
              t2["rehfinalarabic"] = 65198;
              t2["rehiragana"] = 12428;
              t2["rekatakana"] = 12524;
              t2["rekatakanahalfwidth"] = 65434;
              t2["resh"] = 1512;
              t2["reshdageshhebrew"] = 64328;
              t2["reshhebrew"] = 1512;
              t2["reversedtilde"] = 8765;
              t2["reviahebrew"] = 1431;
              t2["reviamugrashhebrew"] = 1431;
              t2["revlogicalnot"] = 8976;
              t2["rfishhook"] = 638;
              t2["rfishhookreversed"] = 639;
              t2["rhabengali"] = 2525;
              t2["rhadeva"] = 2397;
              t2["rho"] = 961;
              t2["rhook"] = 637;
              t2["rhookturned"] = 635;
              t2["rhookturnedsuperior"] = 693;
              t2["rhosymbolgreek"] = 1009;
              t2["rhotichookmod"] = 734;
              t2["rieulacirclekorean"] = 12913;
              t2["rieulaparenkorean"] = 12817;
              t2["rieulcirclekorean"] = 12899;
              t2["rieulhieuhkorean"] = 12608;
              t2["rieulkiyeokkorean"] = 12602;
              t2["rieulkiyeoksioskorean"] = 12649;
              t2["rieulkorean"] = 12601;
              t2["rieulmieumkorean"] = 12603;
              t2["rieulpansioskorean"] = 12652;
              t2["rieulparenkorean"] = 12803;
              t2["rieulphieuphkorean"] = 12607;
              t2["rieulpieupkorean"] = 12604;
              t2["rieulpieupsioskorean"] = 12651;
              t2["rieulsioskorean"] = 12605;
              t2["rieulthieuthkorean"] = 12606;
              t2["rieultikeutkorean"] = 12650;
              t2["rieulyeorinhieuhkorean"] = 12653;
              t2["rightangle"] = 8735;
              t2["righttackbelowcmb"] = 793;
              t2["righttriangle"] = 8895;
              t2["rihiragana"] = 12426;
              t2["rikatakana"] = 12522;
              t2["rikatakanahalfwidth"] = 65432;
              t2["ring"] = 730;
              t2["ringbelowcmb"] = 805;
              t2["ringcmb"] = 778;
              t2["ringhalfleft"] = 703;
              t2["ringhalfleftarmenian"] = 1369;
              t2["ringhalfleftbelowcmb"] = 796;
              t2["ringhalfleftcentered"] = 723;
              t2["ringhalfright"] = 702;
              t2["ringhalfrightbelowcmb"] = 825;
              t2["ringhalfrightcentered"] = 722;
              t2["rinvertedbreve"] = 531;
              t2["rittorusquare"] = 13137;
              t2["rlinebelow"] = 7775;
              t2["rlongleg"] = 636;
              t2["rlonglegturned"] = 634;
              t2["rmonospace"] = 65362;
              t2["rohiragana"] = 12429;
              t2["rokatakana"] = 12525;
              t2["rokatakanahalfwidth"] = 65435;
              t2["roruathai"] = 3619;
              t2["rparen"] = 9389;
              t2["rrabengali"] = 2524;
              t2["rradeva"] = 2353;
              t2["rragurmukhi"] = 2652;
              t2["rreharabic"] = 1681;
              t2["rrehfinalarabic"] = 64397;
              t2["rrvocalicbengali"] = 2528;
              t2["rrvocalicdeva"] = 2400;
              t2["rrvocalicgujarati"] = 2784;
              t2["rrvocalicvowelsignbengali"] = 2500;
              t2["rrvocalicvowelsigndeva"] = 2372;
              t2["rrvocalicvowelsigngujarati"] = 2756;
              t2["rsuperior"] = 63217;
              t2["rtblock"] = 9616;
              t2["rturned"] = 633;
              t2["rturnedsuperior"] = 692;
              t2["ruhiragana"] = 12427;
              t2["rukatakana"] = 12523;
              t2["rukatakanahalfwidth"] = 65433;
              t2["rupeemarkbengali"] = 2546;
              t2["rupeesignbengali"] = 2547;
              t2["rupiah"] = 63197;
              t2["ruthai"] = 3620;
              t2["rvocalicbengali"] = 2443;
              t2["rvocalicdeva"] = 2315;
              t2["rvocalicgujarati"] = 2699;
              t2["rvocalicvowelsignbengali"] = 2499;
              t2["rvocalicvowelsigndeva"] = 2371;
              t2["rvocalicvowelsigngujarati"] = 2755;
              t2["s"] = 115;
              t2["sabengali"] = 2488;
              t2["sacute"] = 347;
              t2["sacutedotaccent"] = 7781;
              t2["sadarabic"] = 1589;
              t2["sadeva"] = 2360;
              t2["sadfinalarabic"] = 65210;
              t2["sadinitialarabic"] = 65211;
              t2["sadmedialarabic"] = 65212;
              t2["sagujarati"] = 2744;
              t2["sagurmukhi"] = 2616;
              t2["sahiragana"] = 12373;
              t2["sakatakana"] = 12469;
              t2["sakatakanahalfwidth"] = 65403;
              t2["sallallahoualayhewasallamarabic"] = 65018;
              t2["samekh"] = 1505;
              t2["samekhdagesh"] = 64321;
              t2["samekhdageshhebrew"] = 64321;
              t2["samekhhebrew"] = 1505;
              t2["saraaathai"] = 3634;
              t2["saraaethai"] = 3649;
              t2["saraaimaimalaithai"] = 3652;
              t2["saraaimaimuanthai"] = 3651;
              t2["saraamthai"] = 3635;
              t2["saraathai"] = 3632;
              t2["saraethai"] = 3648;
              t2["saraiileftthai"] = 63622;
              t2["saraiithai"] = 3637;
              t2["saraileftthai"] = 63621;
              t2["saraithai"] = 3636;
              t2["saraothai"] = 3650;
              t2["saraueeleftthai"] = 63624;
              t2["saraueethai"] = 3639;
              t2["saraueleftthai"] = 63623;
              t2["sarauethai"] = 3638;
              t2["sarauthai"] = 3640;
              t2["sarauuthai"] = 3641;
              t2["sbopomofo"] = 12569;
              t2["scaron"] = 353;
              t2["scarondotaccent"] = 7783;
              t2["scedilla"] = 351;
              t2["schwa"] = 601;
              t2["schwacyrillic"] = 1241;
              t2["schwadieresiscyrillic"] = 1243;
              t2["schwahook"] = 602;
              t2["scircle"] = 9442;
              t2["scircumflex"] = 349;
              t2["scommaaccent"] = 537;
              t2["sdotaccent"] = 7777;
              t2["sdotbelow"] = 7779;
              t2["sdotbelowdotaccent"] = 7785;
              t2["seagullbelowcmb"] = 828;
              t2["second"] = 8243;
              t2["secondtonechinese"] = 714;
              t2["section"] = 167;
              t2["seenarabic"] = 1587;
              t2["seenfinalarabic"] = 65202;
              t2["seeninitialarabic"] = 65203;
              t2["seenmedialarabic"] = 65204;
              t2["segol"] = 1462;
              t2["segol13"] = 1462;
              t2["segol1f"] = 1462;
              t2["segol2c"] = 1462;
              t2["segolhebrew"] = 1462;
              t2["segolnarrowhebrew"] = 1462;
              t2["segolquarterhebrew"] = 1462;
              t2["segoltahebrew"] = 1426;
              t2["segolwidehebrew"] = 1462;
              t2["seharmenian"] = 1405;
              t2["sehiragana"] = 12379;
              t2["sekatakana"] = 12475;
              t2["sekatakanahalfwidth"] = 65406;
              t2["semicolon"] = 59;
              t2["semicolonarabic"] = 1563;
              t2["semicolonmonospace"] = 65307;
              t2["semicolonsmall"] = 65108;
              t2["semivoicedmarkkana"] = 12444;
              t2["semivoicedmarkkanahalfwidth"] = 65439;
              t2["sentisquare"] = 13090;
              t2["sentosquare"] = 13091;
              t2["seven"] = 55;
              t2["sevenarabic"] = 1639;
              t2["sevenbengali"] = 2541;
              t2["sevencircle"] = 9318;
              t2["sevencircleinversesansserif"] = 10128;
              t2["sevendeva"] = 2413;
              t2["seveneighths"] = 8542;
              t2["sevengujarati"] = 2797;
              t2["sevengurmukhi"] = 2669;
              t2["sevenhackarabic"] = 1639;
              t2["sevenhangzhou"] = 12327;
              t2["sevenideographicparen"] = 12838;
              t2["seveninferior"] = 8327;
              t2["sevenmonospace"] = 65303;
              t2["sevenoldstyle"] = 63287;
              t2["sevenparen"] = 9338;
              t2["sevenperiod"] = 9358;
              t2["sevenpersian"] = 1783;
              t2["sevenroman"] = 8566;
              t2["sevensuperior"] = 8311;
              t2["seventeencircle"] = 9328;
              t2["seventeenparen"] = 9348;
              t2["seventeenperiod"] = 9368;
              t2["seventhai"] = 3671;
              t2["sfthyphen"] = 173;
              t2["shaarmenian"] = 1399;
              t2["shabengali"] = 2486;
              t2["shacyrillic"] = 1096;
              t2["shaddaarabic"] = 1617;
              t2["shaddadammaarabic"] = 64609;
              t2["shaddadammatanarabic"] = 64606;
              t2["shaddafathaarabic"] = 64608;
              t2["shaddakasraarabic"] = 64610;
              t2["shaddakasratanarabic"] = 64607;
              t2["shade"] = 9618;
              t2["shadedark"] = 9619;
              t2["shadelight"] = 9617;
              t2["shademedium"] = 9618;
              t2["shadeva"] = 2358;
              t2["shagujarati"] = 2742;
              t2["shagurmukhi"] = 2614;
              t2["shalshelethebrew"] = 1427;
              t2["shbopomofo"] = 12565;
              t2["shchacyrillic"] = 1097;
              t2["sheenarabic"] = 1588;
              t2["sheenfinalarabic"] = 65206;
              t2["sheeninitialarabic"] = 65207;
              t2["sheenmedialarabic"] = 65208;
              t2["sheicoptic"] = 995;
              t2["sheqel"] = 8362;
              t2["sheqelhebrew"] = 8362;
              t2["sheva"] = 1456;
              t2["sheva115"] = 1456;
              t2["sheva15"] = 1456;
              t2["sheva22"] = 1456;
              t2["sheva2e"] = 1456;
              t2["shevahebrew"] = 1456;
              t2["shevanarrowhebrew"] = 1456;
              t2["shevaquarterhebrew"] = 1456;
              t2["shevawidehebrew"] = 1456;
              t2["shhacyrillic"] = 1211;
              t2["shimacoptic"] = 1005;
              t2["shin"] = 1513;
              t2["shindagesh"] = 64329;
              t2["shindageshhebrew"] = 64329;
              t2["shindageshshindot"] = 64300;
              t2["shindageshshindothebrew"] = 64300;
              t2["shindageshsindot"] = 64301;
              t2["shindageshsindothebrew"] = 64301;
              t2["shindothebrew"] = 1473;
              t2["shinhebrew"] = 1513;
              t2["shinshindot"] = 64298;
              t2["shinshindothebrew"] = 64298;
              t2["shinsindot"] = 64299;
              t2["shinsindothebrew"] = 64299;
              t2["shook"] = 642;
              t2["sigma"] = 963;
              t2["sigma1"] = 962;
              t2["sigmafinal"] = 962;
              t2["sigmalunatesymbolgreek"] = 1010;
              t2["sihiragana"] = 12375;
              t2["sikatakana"] = 12471;
              t2["sikatakanahalfwidth"] = 65404;
              t2["siluqhebrew"] = 1469;
              t2["siluqlefthebrew"] = 1469;
              t2["similar"] = 8764;
              t2["sindothebrew"] = 1474;
              t2["siosacirclekorean"] = 12916;
              t2["siosaparenkorean"] = 12820;
              t2["sioscieuckorean"] = 12670;
              t2["sioscirclekorean"] = 12902;
              t2["sioskiyeokkorean"] = 12666;
              t2["sioskorean"] = 12613;
              t2["siosnieunkorean"] = 12667;
              t2["siosparenkorean"] = 12806;
              t2["siospieupkorean"] = 12669;
              t2["siostikeutkorean"] = 12668;
              t2["six"] = 54;
              t2["sixarabic"] = 1638;
              t2["sixbengali"] = 2540;
              t2["sixcircle"] = 9317;
              t2["sixcircleinversesansserif"] = 10127;
              t2["sixdeva"] = 2412;
              t2["sixgujarati"] = 2796;
              t2["sixgurmukhi"] = 2668;
              t2["sixhackarabic"] = 1638;
              t2["sixhangzhou"] = 12326;
              t2["sixideographicparen"] = 12837;
              t2["sixinferior"] = 8326;
              t2["sixmonospace"] = 65302;
              t2["sixoldstyle"] = 63286;
              t2["sixparen"] = 9337;
              t2["sixperiod"] = 9357;
              t2["sixpersian"] = 1782;
              t2["sixroman"] = 8565;
              t2["sixsuperior"] = 8310;
              t2["sixteencircle"] = 9327;
              t2["sixteencurrencydenominatorbengali"] = 2553;
              t2["sixteenparen"] = 9347;
              t2["sixteenperiod"] = 9367;
              t2["sixthai"] = 3670;
              t2["slash"] = 47;
              t2["slashmonospace"] = 65295;
              t2["slong"] = 383;
              t2["slongdotaccent"] = 7835;
              t2["smileface"] = 9786;
              t2["smonospace"] = 65363;
              t2["sofpasuqhebrew"] = 1475;
              t2["softhyphen"] = 173;
              t2["softsigncyrillic"] = 1100;
              t2["sohiragana"] = 12381;
              t2["sokatakana"] = 12477;
              t2["sokatakanahalfwidth"] = 65407;
              t2["soliduslongoverlaycmb"] = 824;
              t2["solidusshortoverlaycmb"] = 823;
              t2["sorusithai"] = 3625;
              t2["sosalathai"] = 3624;
              t2["sosothai"] = 3595;
              t2["sosuathai"] = 3626;
              t2["space"] = 32;
              t2["spacehackarabic"] = 32;
              t2["spade"] = 9824;
              t2["spadesuitblack"] = 9824;
              t2["spadesuitwhite"] = 9828;
              t2["sparen"] = 9390;
              t2["squarebelowcmb"] = 827;
              t2["squarecc"] = 13252;
              t2["squarecm"] = 13213;
              t2["squarediagonalcrosshatchfill"] = 9641;
              t2["squarehorizontalfill"] = 9636;
              t2["squarekg"] = 13199;
              t2["squarekm"] = 13214;
              t2["squarekmcapital"] = 13262;
              t2["squareln"] = 13265;
              t2["squarelog"] = 13266;
              t2["squaremg"] = 13198;
              t2["squaremil"] = 13269;
              t2["squaremm"] = 13212;
              t2["squaremsquared"] = 13217;
              t2["squareorthogonalcrosshatchfill"] = 9638;
              t2["squareupperlefttolowerrightfill"] = 9639;
              t2["squareupperrighttolowerleftfill"] = 9640;
              t2["squareverticalfill"] = 9637;
              t2["squarewhitewithsmallblack"] = 9635;
              t2["srsquare"] = 13275;
              t2["ssabengali"] = 2487;
              t2["ssadeva"] = 2359;
              t2["ssagujarati"] = 2743;
              t2["ssangcieuckorean"] = 12617;
              t2["ssanghieuhkorean"] = 12677;
              t2["ssangieungkorean"] = 12672;
              t2["ssangkiyeokkorean"] = 12594;
              t2["ssangnieunkorean"] = 12645;
              t2["ssangpieupkorean"] = 12611;
              t2["ssangsioskorean"] = 12614;
              t2["ssangtikeutkorean"] = 12600;
              t2["ssuperior"] = 63218;
              t2["sterling"] = 163;
              t2["sterlingmonospace"] = 65505;
              t2["strokelongoverlaycmb"] = 822;
              t2["strokeshortoverlaycmb"] = 821;
              t2["subset"] = 8834;
              t2["subsetnotequal"] = 8842;
              t2["subsetorequal"] = 8838;
              t2["succeeds"] = 8827;
              t2["suchthat"] = 8715;
              t2["suhiragana"] = 12377;
              t2["sukatakana"] = 12473;
              t2["sukatakanahalfwidth"] = 65405;
              t2["sukunarabic"] = 1618;
              t2["summation"] = 8721;
              t2["sun"] = 9788;
              t2["superset"] = 8835;
              t2["supersetnotequal"] = 8843;
              t2["supersetorequal"] = 8839;
              t2["svsquare"] = 13276;
              t2["syouwaerasquare"] = 13180;
              t2["t"] = 116;
              t2["tabengali"] = 2468;
              t2["tackdown"] = 8868;
              t2["tackleft"] = 8867;
              t2["tadeva"] = 2340;
              t2["tagujarati"] = 2724;
              t2["tagurmukhi"] = 2596;
              t2["taharabic"] = 1591;
              t2["tahfinalarabic"] = 65218;
              t2["tahinitialarabic"] = 65219;
              t2["tahiragana"] = 12383;
              t2["tahmedialarabic"] = 65220;
              t2["taisyouerasquare"] = 13181;
              t2["takatakana"] = 12479;
              t2["takatakanahalfwidth"] = 65408;
              t2["tatweelarabic"] = 1600;
              t2["tau"] = 964;
              t2["tav"] = 1514;
              t2["tavdages"] = 64330;
              t2["tavdagesh"] = 64330;
              t2["tavdageshhebrew"] = 64330;
              t2["tavhebrew"] = 1514;
              t2["tbar"] = 359;
              t2["tbopomofo"] = 12554;
              t2["tcaron"] = 357;
              t2["tccurl"] = 680;
              t2["tcedilla"] = 355;
              t2["tcheharabic"] = 1670;
              t2["tchehfinalarabic"] = 64379;
              t2["tchehinitialarabic"] = 64380;
              t2["tchehmedialarabic"] = 64381;
              t2["tcircle"] = 9443;
              t2["tcircumflexbelow"] = 7793;
              t2["tcommaaccent"] = 355;
              t2["tdieresis"] = 7831;
              t2["tdotaccent"] = 7787;
              t2["tdotbelow"] = 7789;
              t2["tecyrillic"] = 1090;
              t2["tedescendercyrillic"] = 1197;
              t2["teharabic"] = 1578;
              t2["tehfinalarabic"] = 65174;
              t2["tehhahinitialarabic"] = 64674;
              t2["tehhahisolatedarabic"] = 64524;
              t2["tehinitialarabic"] = 65175;
              t2["tehiragana"] = 12390;
              t2["tehjeeminitialarabic"] = 64673;
              t2["tehjeemisolatedarabic"] = 64523;
              t2["tehmarbutaarabic"] = 1577;
              t2["tehmarbutafinalarabic"] = 65172;
              t2["tehmedialarabic"] = 65176;
              t2["tehmeeminitialarabic"] = 64676;
              t2["tehmeemisolatedarabic"] = 64526;
              t2["tehnoonfinalarabic"] = 64627;
              t2["tekatakana"] = 12486;
              t2["tekatakanahalfwidth"] = 65411;
              t2["telephone"] = 8481;
              t2["telephoneblack"] = 9742;
              t2["telishagedolahebrew"] = 1440;
              t2["telishaqetanahebrew"] = 1449;
              t2["tencircle"] = 9321;
              t2["tenideographicparen"] = 12841;
              t2["tenparen"] = 9341;
              t2["tenperiod"] = 9361;
              t2["tenroman"] = 8569;
              t2["tesh"] = 679;
              t2["tet"] = 1496;
              t2["tetdagesh"] = 64312;
              t2["tetdageshhebrew"] = 64312;
              t2["tethebrew"] = 1496;
              t2["tetsecyrillic"] = 1205;
              t2["tevirhebrew"] = 1435;
              t2["tevirlefthebrew"] = 1435;
              t2["thabengali"] = 2469;
              t2["thadeva"] = 2341;
              t2["thagujarati"] = 2725;
              t2["thagurmukhi"] = 2597;
              t2["thalarabic"] = 1584;
              t2["thalfinalarabic"] = 65196;
              t2["thanthakhatlowleftthai"] = 63640;
              t2["thanthakhatlowrightthai"] = 63639;
              t2["thanthakhatthai"] = 3660;
              t2["thanthakhatupperleftthai"] = 63638;
              t2["theharabic"] = 1579;
              t2["thehfinalarabic"] = 65178;
              t2["thehinitialarabic"] = 65179;
              t2["thehmedialarabic"] = 65180;
              t2["thereexists"] = 8707;
              t2["therefore"] = 8756;
              t2["theta"] = 952;
              t2["theta1"] = 977;
              t2["thetasymbolgreek"] = 977;
              t2["thieuthacirclekorean"] = 12921;
              t2["thieuthaparenkorean"] = 12825;
              t2["thieuthcirclekorean"] = 12907;
              t2["thieuthkorean"] = 12620;
              t2["thieuthparenkorean"] = 12811;
              t2["thirteencircle"] = 9324;
              t2["thirteenparen"] = 9344;
              t2["thirteenperiod"] = 9364;
              t2["thonangmonthothai"] = 3601;
              t2["thook"] = 429;
              t2["thophuthaothai"] = 3602;
              t2["thorn"] = 254;
              t2["thothahanthai"] = 3607;
              t2["thothanthai"] = 3600;
              t2["thothongthai"] = 3608;
              t2["thothungthai"] = 3606;
              t2["thousandcyrillic"] = 1154;
              t2["thousandsseparatorarabic"] = 1644;
              t2["thousandsseparatorpersian"] = 1644;
              t2["three"] = 51;
              t2["threearabic"] = 1635;
              t2["threebengali"] = 2537;
              t2["threecircle"] = 9314;
              t2["threecircleinversesansserif"] = 10124;
              t2["threedeva"] = 2409;
              t2["threeeighths"] = 8540;
              t2["threegujarati"] = 2793;
              t2["threegurmukhi"] = 2665;
              t2["threehackarabic"] = 1635;
              t2["threehangzhou"] = 12323;
              t2["threeideographicparen"] = 12834;
              t2["threeinferior"] = 8323;
              t2["threemonospace"] = 65299;
              t2["threenumeratorbengali"] = 2550;
              t2["threeoldstyle"] = 63283;
              t2["threeparen"] = 9334;
              t2["threeperiod"] = 9354;
              t2["threepersian"] = 1779;
              t2["threequarters"] = 190;
              t2["threequartersemdash"] = 63198;
              t2["threeroman"] = 8562;
              t2["threesuperior"] = 179;
              t2["threethai"] = 3667;
              t2["thzsquare"] = 13204;
              t2["tihiragana"] = 12385;
              t2["tikatakana"] = 12481;
              t2["tikatakanahalfwidth"] = 65409;
              t2["tikeutacirclekorean"] = 12912;
              t2["tikeutaparenkorean"] = 12816;
              t2["tikeutcirclekorean"] = 12898;
              t2["tikeutkorean"] = 12599;
              t2["tikeutparenkorean"] = 12802;
              t2["tilde"] = 732;
              t2["tildebelowcmb"] = 816;
              t2["tildecmb"] = 771;
              t2["tildecomb"] = 771;
              t2["tildedoublecmb"] = 864;
              t2["tildeoperator"] = 8764;
              t2["tildeoverlaycmb"] = 820;
              t2["tildeverticalcmb"] = 830;
              t2["timescircle"] = 8855;
              t2["tipehahebrew"] = 1430;
              t2["tipehalefthebrew"] = 1430;
              t2["tippigurmukhi"] = 2672;
              t2["titlocyrilliccmb"] = 1155;
              t2["tiwnarmenian"] = 1407;
              t2["tlinebelow"] = 7791;
              t2["tmonospace"] = 65364;
              t2["toarmenian"] = 1385;
              t2["tohiragana"] = 12392;
              t2["tokatakana"] = 12488;
              t2["tokatakanahalfwidth"] = 65412;
              t2["tonebarextrahighmod"] = 741;
              t2["tonebarextralowmod"] = 745;
              t2["tonebarhighmod"] = 742;
              t2["tonebarlowmod"] = 744;
              t2["tonebarmidmod"] = 743;
              t2["tonefive"] = 445;
              t2["tonesix"] = 389;
              t2["tonetwo"] = 424;
              t2["tonos"] = 900;
              t2["tonsquare"] = 13095;
              t2["topatakthai"] = 3599;
              t2["tortoiseshellbracketleft"] = 12308;
              t2["tortoiseshellbracketleftsmall"] = 65117;
              t2["tortoiseshellbracketleftvertical"] = 65081;
              t2["tortoiseshellbracketright"] = 12309;
              t2["tortoiseshellbracketrightsmall"] = 65118;
              t2["tortoiseshellbracketrightvertical"] = 65082;
              t2["totaothai"] = 3605;
              t2["tpalatalhook"] = 427;
              t2["tparen"] = 9391;
              t2["trademark"] = 8482;
              t2["trademarksans"] = 63722;
              t2["trademarkserif"] = 63195;
              t2["tretroflexhook"] = 648;
              t2["triagdn"] = 9660;
              t2["triaglf"] = 9668;
              t2["triagrt"] = 9658;
              t2["triagup"] = 9650;
              t2["ts"] = 678;
              t2["tsadi"] = 1510;
              t2["tsadidagesh"] = 64326;
              t2["tsadidageshhebrew"] = 64326;
              t2["tsadihebrew"] = 1510;
              t2["tsecyrillic"] = 1094;
              t2["tsere"] = 1461;
              t2["tsere12"] = 1461;
              t2["tsere1e"] = 1461;
              t2["tsere2b"] = 1461;
              t2["tserehebrew"] = 1461;
              t2["tserenarrowhebrew"] = 1461;
              t2["tserequarterhebrew"] = 1461;
              t2["tserewidehebrew"] = 1461;
              t2["tshecyrillic"] = 1115;
              t2["tsuperior"] = 63219;
              t2["ttabengali"] = 2463;
              t2["ttadeva"] = 2335;
              t2["ttagujarati"] = 2719;
              t2["ttagurmukhi"] = 2591;
              t2["tteharabic"] = 1657;
              t2["ttehfinalarabic"] = 64359;
              t2["ttehinitialarabic"] = 64360;
              t2["ttehmedialarabic"] = 64361;
              t2["tthabengali"] = 2464;
              t2["tthadeva"] = 2336;
              t2["tthagujarati"] = 2720;
              t2["tthagurmukhi"] = 2592;
              t2["tturned"] = 647;
              t2["tuhiragana"] = 12388;
              t2["tukatakana"] = 12484;
              t2["tukatakanahalfwidth"] = 65410;
              t2["tusmallhiragana"] = 12387;
              t2["tusmallkatakana"] = 12483;
              t2["tusmallkatakanahalfwidth"] = 65391;
              t2["twelvecircle"] = 9323;
              t2["twelveparen"] = 9343;
              t2["twelveperiod"] = 9363;
              t2["twelveroman"] = 8571;
              t2["twentycircle"] = 9331;
              t2["twentyhangzhou"] = 21316;
              t2["twentyparen"] = 9351;
              t2["twentyperiod"] = 9371;
              t2["two"] = 50;
              t2["twoarabic"] = 1634;
              t2["twobengali"] = 2536;
              t2["twocircle"] = 9313;
              t2["twocircleinversesansserif"] = 10123;
              t2["twodeva"] = 2408;
              t2["twodotenleader"] = 8229;
              t2["twodotleader"] = 8229;
              t2["twodotleadervertical"] = 65072;
              t2["twogujarati"] = 2792;
              t2["twogurmukhi"] = 2664;
              t2["twohackarabic"] = 1634;
              t2["twohangzhou"] = 12322;
              t2["twoideographicparen"] = 12833;
              t2["twoinferior"] = 8322;
              t2["twomonospace"] = 65298;
              t2["twonumeratorbengali"] = 2549;
              t2["twooldstyle"] = 63282;
              t2["twoparen"] = 9333;
              t2["twoperiod"] = 9353;
              t2["twopersian"] = 1778;
              t2["tworoman"] = 8561;
              t2["twostroke"] = 443;
              t2["twosuperior"] = 178;
              t2["twothai"] = 3666;
              t2["twothirds"] = 8532;
              t2["u"] = 117;
              t2["uacute"] = 250;
              t2["ubar"] = 649;
              t2["ubengali"] = 2441;
              t2["ubopomofo"] = 12584;
              t2["ubreve"] = 365;
              t2["ucaron"] = 468;
              t2["ucircle"] = 9444;
              t2["ucircumflex"] = 251;
              t2["ucircumflexbelow"] = 7799;
              t2["ucyrillic"] = 1091;
              t2["udattadeva"] = 2385;
              t2["udblacute"] = 369;
              t2["udblgrave"] = 533;
              t2["udeva"] = 2313;
              t2["udieresis"] = 252;
              t2["udieresisacute"] = 472;
              t2["udieresisbelow"] = 7795;
              t2["udieresiscaron"] = 474;
              t2["udieresiscyrillic"] = 1265;
              t2["udieresisgrave"] = 476;
              t2["udieresismacron"] = 470;
              t2["udotbelow"] = 7909;
              t2["ugrave"] = 249;
              t2["ugujarati"] = 2697;
              t2["ugurmukhi"] = 2569;
              t2["uhiragana"] = 12358;
              t2["uhookabove"] = 7911;
              t2["uhorn"] = 432;
              t2["uhornacute"] = 7913;
              t2["uhorndotbelow"] = 7921;
              t2["uhorngrave"] = 7915;
              t2["uhornhookabove"] = 7917;
              t2["uhorntilde"] = 7919;
              t2["uhungarumlaut"] = 369;
              t2["uhungarumlautcyrillic"] = 1267;
              t2["uinvertedbreve"] = 535;
              t2["ukatakana"] = 12454;
              t2["ukatakanahalfwidth"] = 65395;
              t2["ukcyrillic"] = 1145;
              t2["ukorean"] = 12636;
              t2["umacron"] = 363;
              t2["umacroncyrillic"] = 1263;
              t2["umacrondieresis"] = 7803;
              t2["umatragurmukhi"] = 2625;
              t2["umonospace"] = 65365;
              t2["underscore"] = 95;
              t2["underscoredbl"] = 8215;
              t2["underscoremonospace"] = 65343;
              t2["underscorevertical"] = 65075;
              t2["underscorewavy"] = 65103;
              t2["union"] = 8746;
              t2["universal"] = 8704;
              t2["uogonek"] = 371;
              t2["uparen"] = 9392;
              t2["upblock"] = 9600;
              t2["upperdothebrew"] = 1476;
              t2["upsilon"] = 965;
              t2["upsilondieresis"] = 971;
              t2["upsilondieresistonos"] = 944;
              t2["upsilonlatin"] = 650;
              t2["upsilontonos"] = 973;
              t2["uptackbelowcmb"] = 797;
              t2["uptackmod"] = 724;
              t2["uragurmukhi"] = 2675;
              t2["uring"] = 367;
              t2["ushortcyrillic"] = 1118;
              t2["usmallhiragana"] = 12357;
              t2["usmallkatakana"] = 12453;
              t2["usmallkatakanahalfwidth"] = 65385;
              t2["ustraightcyrillic"] = 1199;
              t2["ustraightstrokecyrillic"] = 1201;
              t2["utilde"] = 361;
              t2["utildeacute"] = 7801;
              t2["utildebelow"] = 7797;
              t2["uubengali"] = 2442;
              t2["uudeva"] = 2314;
              t2["uugujarati"] = 2698;
              t2["uugurmukhi"] = 2570;
              t2["uumatragurmukhi"] = 2626;
              t2["uuvowelsignbengali"] = 2498;
              t2["uuvowelsigndeva"] = 2370;
              t2["uuvowelsigngujarati"] = 2754;
              t2["uvowelsignbengali"] = 2497;
              t2["uvowelsigndeva"] = 2369;
              t2["uvowelsigngujarati"] = 2753;
              t2["v"] = 118;
              t2["vadeva"] = 2357;
              t2["vagujarati"] = 2741;
              t2["vagurmukhi"] = 2613;
              t2["vakatakana"] = 12535;
              t2["vav"] = 1493;
              t2["vavdagesh"] = 64309;
              t2["vavdagesh65"] = 64309;
              t2["vavdageshhebrew"] = 64309;
              t2["vavhebrew"] = 1493;
              t2["vavholam"] = 64331;
              t2["vavholamhebrew"] = 64331;
              t2["vavvavhebrew"] = 1520;
              t2["vavyodhebrew"] = 1521;
              t2["vcircle"] = 9445;
              t2["vdotbelow"] = 7807;
              t2["vecyrillic"] = 1074;
              t2["veharabic"] = 1700;
              t2["vehfinalarabic"] = 64363;
              t2["vehinitialarabic"] = 64364;
              t2["vehmedialarabic"] = 64365;
              t2["vekatakana"] = 12537;
              t2["venus"] = 9792;
              t2["verticalbar"] = 124;
              t2["verticallineabovecmb"] = 781;
              t2["verticallinebelowcmb"] = 809;
              t2["verticallinelowmod"] = 716;
              t2["verticallinemod"] = 712;
              t2["vewarmenian"] = 1406;
              t2["vhook"] = 651;
              t2["vikatakana"] = 12536;
              t2["viramabengali"] = 2509;
              t2["viramadeva"] = 2381;
              t2["viramagujarati"] = 2765;
              t2["visargabengali"] = 2435;
              t2["visargadeva"] = 2307;
              t2["visargagujarati"] = 2691;
              t2["vmonospace"] = 65366;
              t2["voarmenian"] = 1400;
              t2["voicediterationhiragana"] = 12446;
              t2["voicediterationkatakana"] = 12542;
              t2["voicedmarkkana"] = 12443;
              t2["voicedmarkkanahalfwidth"] = 65438;
              t2["vokatakana"] = 12538;
              t2["vparen"] = 9393;
              t2["vtilde"] = 7805;
              t2["vturned"] = 652;
              t2["vuhiragana"] = 12436;
              t2["vukatakana"] = 12532;
              t2["w"] = 119;
              t2["wacute"] = 7811;
              t2["waekorean"] = 12633;
              t2["wahiragana"] = 12431;
              t2["wakatakana"] = 12527;
              t2["wakatakanahalfwidth"] = 65436;
              t2["wakorean"] = 12632;
              t2["wasmallhiragana"] = 12430;
              t2["wasmallkatakana"] = 12526;
              t2["wattosquare"] = 13143;
              t2["wavedash"] = 12316;
              t2["wavyunderscorevertical"] = 65076;
              t2["wawarabic"] = 1608;
              t2["wawfinalarabic"] = 65262;
              t2["wawhamzaabovearabic"] = 1572;
              t2["wawhamzaabovefinalarabic"] = 65158;
              t2["wbsquare"] = 13277;
              t2["wcircle"] = 9446;
              t2["wcircumflex"] = 373;
              t2["wdieresis"] = 7813;
              t2["wdotaccent"] = 7815;
              t2["wdotbelow"] = 7817;
              t2["wehiragana"] = 12433;
              t2["weierstrass"] = 8472;
              t2["wekatakana"] = 12529;
              t2["wekorean"] = 12638;
              t2["weokorean"] = 12637;
              t2["wgrave"] = 7809;
              t2["whitebullet"] = 9702;
              t2["whitecircle"] = 9675;
              t2["whitecircleinverse"] = 9689;
              t2["whitecornerbracketleft"] = 12302;
              t2["whitecornerbracketleftvertical"] = 65091;
              t2["whitecornerbracketright"] = 12303;
              t2["whitecornerbracketrightvertical"] = 65092;
              t2["whitediamond"] = 9671;
              t2["whitediamondcontainingblacksmalldiamond"] = 9672;
              t2["whitedownpointingsmalltriangle"] = 9663;
              t2["whitedownpointingtriangle"] = 9661;
              t2["whiteleftpointingsmalltriangle"] = 9667;
              t2["whiteleftpointingtriangle"] = 9665;
              t2["whitelenticularbracketleft"] = 12310;
              t2["whitelenticularbracketright"] = 12311;
              t2["whiterightpointingsmalltriangle"] = 9657;
              t2["whiterightpointingtriangle"] = 9655;
              t2["whitesmallsquare"] = 9643;
              t2["whitesmilingface"] = 9786;
              t2["whitesquare"] = 9633;
              t2["whitestar"] = 9734;
              t2["whitetelephone"] = 9743;
              t2["whitetortoiseshellbracketleft"] = 12312;
              t2["whitetortoiseshellbracketright"] = 12313;
              t2["whiteuppointingsmalltriangle"] = 9653;
              t2["whiteuppointingtriangle"] = 9651;
              t2["wihiragana"] = 12432;
              t2["wikatakana"] = 12528;
              t2["wikorean"] = 12639;
              t2["wmonospace"] = 65367;
              t2["wohiragana"] = 12434;
              t2["wokatakana"] = 12530;
              t2["wokatakanahalfwidth"] = 65382;
              t2["won"] = 8361;
              t2["wonmonospace"] = 65510;
              t2["wowaenthai"] = 3623;
              t2["wparen"] = 9394;
              t2["wring"] = 7832;
              t2["wsuperior"] = 695;
              t2["wturned"] = 653;
              t2["wynn"] = 447;
              t2["x"] = 120;
              t2["xabovecmb"] = 829;
              t2["xbopomofo"] = 12562;
              t2["xcircle"] = 9447;
              t2["xdieresis"] = 7821;
              t2["xdotaccent"] = 7819;
              t2["xeharmenian"] = 1389;
              t2["xi"] = 958;
              t2["xmonospace"] = 65368;
              t2["xparen"] = 9395;
              t2["xsuperior"] = 739;
              t2["y"] = 121;
              t2["yaadosquare"] = 13134;
              t2["yabengali"] = 2479;
              t2["yacute"] = 253;
              t2["yadeva"] = 2351;
              t2["yaekorean"] = 12626;
              t2["yagujarati"] = 2735;
              t2["yagurmukhi"] = 2607;
              t2["yahiragana"] = 12420;
              t2["yakatakana"] = 12516;
              t2["yakatakanahalfwidth"] = 65428;
              t2["yakorean"] = 12625;
              t2["yamakkanthai"] = 3662;
              t2["yasmallhiragana"] = 12419;
              t2["yasmallkatakana"] = 12515;
              t2["yasmallkatakanahalfwidth"] = 65388;
              t2["yatcyrillic"] = 1123;
              t2["ycircle"] = 9448;
              t2["ycircumflex"] = 375;
              t2["ydieresis"] = 255;
              t2["ydotaccent"] = 7823;
              t2["ydotbelow"] = 7925;
              t2["yeharabic"] = 1610;
              t2["yehbarreearabic"] = 1746;
              t2["yehbarreefinalarabic"] = 64431;
              t2["yehfinalarabic"] = 65266;
              t2["yehhamzaabovearabic"] = 1574;
              t2["yehhamzaabovefinalarabic"] = 65162;
              t2["yehhamzaaboveinitialarabic"] = 65163;
              t2["yehhamzaabovemedialarabic"] = 65164;
              t2["yehinitialarabic"] = 65267;
              t2["yehmedialarabic"] = 65268;
              t2["yehmeeminitialarabic"] = 64733;
              t2["yehmeemisolatedarabic"] = 64600;
              t2["yehnoonfinalarabic"] = 64660;
              t2["yehthreedotsbelowarabic"] = 1745;
              t2["yekorean"] = 12630;
              t2["yen"] = 165;
              t2["yenmonospace"] = 65509;
              t2["yeokorean"] = 12629;
              t2["yeorinhieuhkorean"] = 12678;
              t2["yerahbenyomohebrew"] = 1450;
              t2["yerahbenyomolefthebrew"] = 1450;
              t2["yericyrillic"] = 1099;
              t2["yerudieresiscyrillic"] = 1273;
              t2["yesieungkorean"] = 12673;
              t2["yesieungpansioskorean"] = 12675;
              t2["yesieungsioskorean"] = 12674;
              t2["yetivhebrew"] = 1434;
              t2["ygrave"] = 7923;
              t2["yhook"] = 436;
              t2["yhookabove"] = 7927;
              t2["yiarmenian"] = 1397;
              t2["yicyrillic"] = 1111;
              t2["yikorean"] = 12642;
              t2["yinyang"] = 9775;
              t2["yiwnarmenian"] = 1410;
              t2["ymonospace"] = 65369;
              t2["yod"] = 1497;
              t2["yoddagesh"] = 64313;
              t2["yoddageshhebrew"] = 64313;
              t2["yodhebrew"] = 1497;
              t2["yodyodhebrew"] = 1522;
              t2["yodyodpatahhebrew"] = 64287;
              t2["yohiragana"] = 12424;
              t2["yoikorean"] = 12681;
              t2["yokatakana"] = 12520;
              t2["yokatakanahalfwidth"] = 65430;
              t2["yokorean"] = 12635;
              t2["yosmallhiragana"] = 12423;
              t2["yosmallkatakana"] = 12519;
              t2["yosmallkatakanahalfwidth"] = 65390;
              t2["yotgreek"] = 1011;
              t2["yoyaekorean"] = 12680;
              t2["yoyakorean"] = 12679;
              t2["yoyakthai"] = 3618;
              t2["yoyingthai"] = 3597;
              t2["yparen"] = 9396;
              t2["ypogegrammeni"] = 890;
              t2["ypogegrammenigreekcmb"] = 837;
              t2["yr"] = 422;
              t2["yring"] = 7833;
              t2["ysuperior"] = 696;
              t2["ytilde"] = 7929;
              t2["yturned"] = 654;
              t2["yuhiragana"] = 12422;
              t2["yuikorean"] = 12684;
              t2["yukatakana"] = 12518;
              t2["yukatakanahalfwidth"] = 65429;
              t2["yukorean"] = 12640;
              t2["yusbigcyrillic"] = 1131;
              t2["yusbigiotifiedcyrillic"] = 1133;
              t2["yuslittlecyrillic"] = 1127;
              t2["yuslittleiotifiedcyrillic"] = 1129;
              t2["yusmallhiragana"] = 12421;
              t2["yusmallkatakana"] = 12517;
              t2["yusmallkatakanahalfwidth"] = 65389;
              t2["yuyekorean"] = 12683;
              t2["yuyeokorean"] = 12682;
              t2["yyabengali"] = 2527;
              t2["yyadeva"] = 2399;
              t2["z"] = 122;
              t2["zaarmenian"] = 1382;
              t2["zacute"] = 378;
              t2["zadeva"] = 2395;
              t2["zagurmukhi"] = 2651;
              t2["zaharabic"] = 1592;
              t2["zahfinalarabic"] = 65222;
              t2["zahinitialarabic"] = 65223;
              t2["zahiragana"] = 12374;
              t2["zahmedialarabic"] = 65224;
              t2["zainarabic"] = 1586;
              t2["zainfinalarabic"] = 65200;
              t2["zakatakana"] = 12470;
              t2["zaqefgadolhebrew"] = 1429;
              t2["zaqefqatanhebrew"] = 1428;
              t2["zarqahebrew"] = 1432;
              t2["zayin"] = 1494;
              t2["zayindagesh"] = 64310;
              t2["zayindageshhebrew"] = 64310;
              t2["zayinhebrew"] = 1494;
              t2["zbopomofo"] = 12567;
              t2["zcaron"] = 382;
              t2["zcircle"] = 9449;
              t2["zcircumflex"] = 7825;
              t2["zcurl"] = 657;
              t2["zdot"] = 380;
              t2["zdotaccent"] = 380;
              t2["zdotbelow"] = 7827;
              t2["zecyrillic"] = 1079;
              t2["zedescendercyrillic"] = 1177;
              t2["zedieresiscyrillic"] = 1247;
              t2["zehiragana"] = 12380;
              t2["zekatakana"] = 12476;
              t2["zero"] = 48;
              t2["zeroarabic"] = 1632;
              t2["zerobengali"] = 2534;
              t2["zerodeva"] = 2406;
              t2["zerogujarati"] = 2790;
              t2["zerogurmukhi"] = 2662;
              t2["zerohackarabic"] = 1632;
              t2["zeroinferior"] = 8320;
              t2["zeromonospace"] = 65296;
              t2["zerooldstyle"] = 63280;
              t2["zeropersian"] = 1776;
              t2["zerosuperior"] = 8304;
              t2["zerothai"] = 3664;
              t2["zerowidthjoiner"] = 65279;
              t2["zerowidthnonjoiner"] = 8204;
              t2["zerowidthspace"] = 8203;
              t2["zeta"] = 950;
              t2["zhbopomofo"] = 12563;
              t2["zhearmenian"] = 1386;
              t2["zhebrevecyrillic"] = 1218;
              t2["zhecyrillic"] = 1078;
              t2["zhedescendercyrillic"] = 1175;
              t2["zhedieresiscyrillic"] = 1245;
              t2["zihiragana"] = 12376;
              t2["zikatakana"] = 12472;
              t2["zinorhebrew"] = 1454;
              t2["zlinebelow"] = 7829;
              t2["zmonospace"] = 65370;
              t2["zohiragana"] = 12382;
              t2["zokatakana"] = 12478;
              t2["zparen"] = 9397;
              t2["zretroflexhook"] = 656;
              t2["zstroke"] = 438;
              t2["zuhiragana"] = 12378;
              t2["zukatakana"] = 12474;
              t2[".notdef"] = 0;
              t2["angbracketleftbig"] = 9001;
              t2["angbracketleftBig"] = 9001;
              t2["angbracketleftbigg"] = 9001;
              t2["angbracketleftBigg"] = 9001;
              t2["angbracketrightBig"] = 9002;
              t2["angbracketrightbig"] = 9002;
              t2["angbracketrightBigg"] = 9002;
              t2["angbracketrightbigg"] = 9002;
              t2["arrowhookleft"] = 8618;
              t2["arrowhookright"] = 8617;
              t2["arrowlefttophalf"] = 8636;
              t2["arrowleftbothalf"] = 8637;
              t2["arrownortheast"] = 8599;
              t2["arrownorthwest"] = 8598;
              t2["arrowrighttophalf"] = 8640;
              t2["arrowrightbothalf"] = 8641;
              t2["arrowsoutheast"] = 8600;
              t2["arrowsouthwest"] = 8601;
              t2["backslashbig"] = 8726;
              t2["backslashBig"] = 8726;
              t2["backslashBigg"] = 8726;
              t2["backslashbigg"] = 8726;
              t2["bardbl"] = 8214;
              t2["bracehtipdownleft"] = 65079;
              t2["bracehtipdownright"] = 65079;
              t2["bracehtipupleft"] = 65080;
              t2["bracehtipupright"] = 65080;
              t2["braceleftBig"] = 123;
              t2["braceleftbig"] = 123;
              t2["braceleftbigg"] = 123;
              t2["braceleftBigg"] = 123;
              t2["bracerightBig"] = 125;
              t2["bracerightbig"] = 125;
              t2["bracerightbigg"] = 125;
              t2["bracerightBigg"] = 125;
              t2["bracketleftbig"] = 91;
              t2["bracketleftBig"] = 91;
              t2["bracketleftbigg"] = 91;
              t2["bracketleftBigg"] = 91;
              t2["bracketrightBig"] = 93;
              t2["bracketrightbig"] = 93;
              t2["bracketrightbigg"] = 93;
              t2["bracketrightBigg"] = 93;
              t2["ceilingleftbig"] = 8968;
              t2["ceilingleftBig"] = 8968;
              t2["ceilingleftBigg"] = 8968;
              t2["ceilingleftbigg"] = 8968;
              t2["ceilingrightbig"] = 8969;
              t2["ceilingrightBig"] = 8969;
              t2["ceilingrightbigg"] = 8969;
              t2["ceilingrightBigg"] = 8969;
              t2["circledotdisplay"] = 8857;
              t2["circledottext"] = 8857;
              t2["circlemultiplydisplay"] = 8855;
              t2["circlemultiplytext"] = 8855;
              t2["circleplusdisplay"] = 8853;
              t2["circleplustext"] = 8853;
              t2["contintegraldisplay"] = 8750;
              t2["contintegraltext"] = 8750;
              t2["coproductdisplay"] = 8720;
              t2["coproducttext"] = 8720;
              t2["floorleftBig"] = 8970;
              t2["floorleftbig"] = 8970;
              t2["floorleftbigg"] = 8970;
              t2["floorleftBigg"] = 8970;
              t2["floorrightbig"] = 8971;
              t2["floorrightBig"] = 8971;
              t2["floorrightBigg"] = 8971;
              t2["floorrightbigg"] = 8971;
              t2["hatwide"] = 770;
              t2["hatwider"] = 770;
              t2["hatwidest"] = 770;
              t2["intercal"] = 7488;
              t2["integraldisplay"] = 8747;
              t2["integraltext"] = 8747;
              t2["intersectiondisplay"] = 8898;
              t2["intersectiontext"] = 8898;
              t2["logicalanddisplay"] = 8743;
              t2["logicalandtext"] = 8743;
              t2["logicalordisplay"] = 8744;
              t2["logicalortext"] = 8744;
              t2["parenleftBig"] = 40;
              t2["parenleftbig"] = 40;
              t2["parenleftBigg"] = 40;
              t2["parenleftbigg"] = 40;
              t2["parenrightBig"] = 41;
              t2["parenrightbig"] = 41;
              t2["parenrightBigg"] = 41;
              t2["parenrightbigg"] = 41;
              t2["prime"] = 8242;
              t2["productdisplay"] = 8719;
              t2["producttext"] = 8719;
              t2["radicalbig"] = 8730;
              t2["radicalBig"] = 8730;
              t2["radicalBigg"] = 8730;
              t2["radicalbigg"] = 8730;
              t2["radicalbt"] = 8730;
              t2["radicaltp"] = 8730;
              t2["radicalvertex"] = 8730;
              t2["slashbig"] = 47;
              t2["slashBig"] = 47;
              t2["slashBigg"] = 47;
              t2["slashbigg"] = 47;
              t2["summationdisplay"] = 8721;
              t2["summationtext"] = 8721;
              t2["tildewide"] = 732;
              t2["tildewider"] = 732;
              t2["tildewidest"] = 732;
              t2["uniondisplay"] = 8899;
              t2["unionmultidisplay"] = 8846;
              t2["unionmultitext"] = 8846;
              t2["unionsqdisplay"] = 8852;
              t2["unionsqtext"] = 8852;
              t2["uniontext"] = 8899;
              t2["vextenddouble"] = 8741;
              t2["vextendsingle"] = 8739;
            });
            var getDingbatsGlyphsUnicode = getLookupTableFactory(function(t2) {
              t2["space"] = 32;
              t2["a1"] = 9985;
              t2["a2"] = 9986;
              t2["a202"] = 9987;
              t2["a3"] = 9988;
              t2["a4"] = 9742;
              t2["a5"] = 9990;
              t2["a119"] = 9991;
              t2["a118"] = 9992;
              t2["a117"] = 9993;
              t2["a11"] = 9755;
              t2["a12"] = 9758;
              t2["a13"] = 9996;
              t2["a14"] = 9997;
              t2["a15"] = 9998;
              t2["a16"] = 9999;
              t2["a105"] = 1e4;
              t2["a17"] = 10001;
              t2["a18"] = 10002;
              t2["a19"] = 10003;
              t2["a20"] = 10004;
              t2["a21"] = 10005;
              t2["a22"] = 10006;
              t2["a23"] = 10007;
              t2["a24"] = 10008;
              t2["a25"] = 10009;
              t2["a26"] = 10010;
              t2["a27"] = 10011;
              t2["a28"] = 10012;
              t2["a6"] = 10013;
              t2["a7"] = 10014;
              t2["a8"] = 10015;
              t2["a9"] = 10016;
              t2["a10"] = 10017;
              t2["a29"] = 10018;
              t2["a30"] = 10019;
              t2["a31"] = 10020;
              t2["a32"] = 10021;
              t2["a33"] = 10022;
              t2["a34"] = 10023;
              t2["a35"] = 9733;
              t2["a36"] = 10025;
              t2["a37"] = 10026;
              t2["a38"] = 10027;
              t2["a39"] = 10028;
              t2["a40"] = 10029;
              t2["a41"] = 10030;
              t2["a42"] = 10031;
              t2["a43"] = 10032;
              t2["a44"] = 10033;
              t2["a45"] = 10034;
              t2["a46"] = 10035;
              t2["a47"] = 10036;
              t2["a48"] = 10037;
              t2["a49"] = 10038;
              t2["a50"] = 10039;
              t2["a51"] = 10040;
              t2["a52"] = 10041;
              t2["a53"] = 10042;
              t2["a54"] = 10043;
              t2["a55"] = 10044;
              t2["a56"] = 10045;
              t2["a57"] = 10046;
              t2["a58"] = 10047;
              t2["a59"] = 10048;
              t2["a60"] = 10049;
              t2["a61"] = 10050;
              t2["a62"] = 10051;
              t2["a63"] = 10052;
              t2["a64"] = 10053;
              t2["a65"] = 10054;
              t2["a66"] = 10055;
              t2["a67"] = 10056;
              t2["a68"] = 10057;
              t2["a69"] = 10058;
              t2["a70"] = 10059;
              t2["a71"] = 9679;
              t2["a72"] = 10061;
              t2["a73"] = 9632;
              t2["a74"] = 10063;
              t2["a203"] = 10064;
              t2["a75"] = 10065;
              t2["a204"] = 10066;
              t2["a76"] = 9650;
              t2["a77"] = 9660;
              t2["a78"] = 9670;
              t2["a79"] = 10070;
              t2["a81"] = 9687;
              t2["a82"] = 10072;
              t2["a83"] = 10073;
              t2["a84"] = 10074;
              t2["a97"] = 10075;
              t2["a98"] = 10076;
              t2["a99"] = 10077;
              t2["a100"] = 10078;
              t2["a101"] = 10081;
              t2["a102"] = 10082;
              t2["a103"] = 10083;
              t2["a104"] = 10084;
              t2["a106"] = 10085;
              t2["a107"] = 10086;
              t2["a108"] = 10087;
              t2["a112"] = 9827;
              t2["a111"] = 9830;
              t2["a110"] = 9829;
              t2["a109"] = 9824;
              t2["a120"] = 9312;
              t2["a121"] = 9313;
              t2["a122"] = 9314;
              t2["a123"] = 9315;
              t2["a124"] = 9316;
              t2["a125"] = 9317;
              t2["a126"] = 9318;
              t2["a127"] = 9319;
              t2["a128"] = 9320;
              t2["a129"] = 9321;
              t2["a130"] = 10102;
              t2["a131"] = 10103;
              t2["a132"] = 10104;
              t2["a133"] = 10105;
              t2["a134"] = 10106;
              t2["a135"] = 10107;
              t2["a136"] = 10108;
              t2["a137"] = 10109;
              t2["a138"] = 10110;
              t2["a139"] = 10111;
              t2["a140"] = 10112;
              t2["a141"] = 10113;
              t2["a142"] = 10114;
              t2["a143"] = 10115;
              t2["a144"] = 10116;
              t2["a145"] = 10117;
              t2["a146"] = 10118;
              t2["a147"] = 10119;
              t2["a148"] = 10120;
              t2["a149"] = 10121;
              t2["a150"] = 10122;
              t2["a151"] = 10123;
              t2["a152"] = 10124;
              t2["a153"] = 10125;
              t2["a154"] = 10126;
              t2["a155"] = 10127;
              t2["a156"] = 10128;
              t2["a157"] = 10129;
              t2["a158"] = 10130;
              t2["a159"] = 10131;
              t2["a160"] = 10132;
              t2["a161"] = 8594;
              t2["a163"] = 8596;
              t2["a164"] = 8597;
              t2["a196"] = 10136;
              t2["a165"] = 10137;
              t2["a192"] = 10138;
              t2["a166"] = 10139;
              t2["a167"] = 10140;
              t2["a168"] = 10141;
              t2["a169"] = 10142;
              t2["a170"] = 10143;
              t2["a171"] = 10144;
              t2["a172"] = 10145;
              t2["a173"] = 10146;
              t2["a162"] = 10147;
              t2["a174"] = 10148;
              t2["a175"] = 10149;
              t2["a176"] = 10150;
              t2["a177"] = 10151;
              t2["a178"] = 10152;
              t2["a179"] = 10153;
              t2["a193"] = 10154;
              t2["a180"] = 10155;
              t2["a199"] = 10156;
              t2["a181"] = 10157;
              t2["a200"] = 10158;
              t2["a182"] = 10159;
              t2["a201"] = 10161;
              t2["a183"] = 10162;
              t2["a184"] = 10163;
              t2["a197"] = 10164;
              t2["a185"] = 10165;
              t2["a194"] = 10166;
              t2["a198"] = 10167;
              t2["a186"] = 10168;
              t2["a195"] = 10169;
              t2["a187"] = 10170;
              t2["a188"] = 10171;
              t2["a189"] = 10172;
              t2["a190"] = 10173;
              t2["a191"] = 10174;
              t2["a89"] = 10088;
              t2["a90"] = 10089;
              t2["a93"] = 10090;
              t2["a94"] = 10091;
              t2["a91"] = 10092;
              t2["a92"] = 10093;
              t2["a205"] = 10094;
              t2["a85"] = 10095;
              t2["a206"] = 10096;
              t2["a86"] = 10097;
              t2["a87"] = 10098;
              t2["a88"] = 10099;
              t2["a95"] = 10100;
              t2["a96"] = 10101;
              t2[".notdef"] = 0;
            });
            exports3.getGlyphsUnicode = getGlyphsUnicode;
            exports3.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
          },
          /* 32 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getSupplementalGlyphMapForCalibri = exports3.getSupplementalGlyphMapForArialBlack = exports3.getGlyphMapForStandardFonts = exports3.getSymbolsFonts = exports3.getSerifFonts = exports3.getNonStdFontMap = exports3.getStdFontMap = void 0;
            var _core_utils = __w_pdfjs_require__2(7);
            const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2["ArialNarrow"] = "Helvetica";
              t2["ArialNarrow-Bold"] = "Helvetica-Bold";
              t2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
              t2["ArialNarrow-Italic"] = "Helvetica-Oblique";
              t2["ArialBlack"] = "Helvetica";
              t2["ArialBlack-Bold"] = "Helvetica-Bold";
              t2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
              t2["ArialBlack-Italic"] = "Helvetica-Oblique";
              t2["Arial-Black"] = "Helvetica";
              t2["Arial-Black-Bold"] = "Helvetica-Bold";
              t2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
              t2["Arial-Black-Italic"] = "Helvetica-Oblique";
              t2["Arial"] = "Helvetica";
              t2["Arial-Bold"] = "Helvetica-Bold";
              t2["Arial-BoldItalic"] = "Helvetica-BoldOblique";
              t2["Arial-Italic"] = "Helvetica-Oblique";
              t2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
              t2["Arial-BoldMT"] = "Helvetica-Bold";
              t2["Arial-ItalicMT"] = "Helvetica-Oblique";
              t2["ArialMT"] = "Helvetica";
              t2["Courier-Bold"] = "Courier-Bold";
              t2["Courier-BoldItalic"] = "Courier-BoldOblique";
              t2["Courier-Italic"] = "Courier-Oblique";
              t2["CourierNew"] = "Courier";
              t2["CourierNew-Bold"] = "Courier-Bold";
              t2["CourierNew-BoldItalic"] = "Courier-BoldOblique";
              t2["CourierNew-Italic"] = "Courier-Oblique";
              t2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
              t2["CourierNewPS-BoldMT"] = "Courier-Bold";
              t2["CourierNewPS-ItalicMT"] = "Courier-Oblique";
              t2["CourierNewPSMT"] = "Courier";
              t2["Helvetica"] = "Helvetica";
              t2["Helvetica-Bold"] = "Helvetica-Bold";
              t2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
              t2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
              t2["Helvetica-Italic"] = "Helvetica-Oblique";
              t2["Helvetica-Oblique"] = "Helvetica-Oblique";
              t2["Symbol-Bold"] = "Symbol";
              t2["Symbol-BoldItalic"] = "Symbol";
              t2["Symbol-Italic"] = "Symbol";
              t2["TimesNewRoman"] = "Times-Roman";
              t2["TimesNewRoman-Bold"] = "Times-Bold";
              t2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
              t2["TimesNewRoman-Italic"] = "Times-Italic";
              t2["TimesNewRomanPS"] = "Times-Roman";
              t2["TimesNewRomanPS-Bold"] = "Times-Bold";
              t2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
              t2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
              t2["TimesNewRomanPS-BoldMT"] = "Times-Bold";
              t2["TimesNewRomanPS-Italic"] = "Times-Italic";
              t2["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
              t2["TimesNewRomanPSMT"] = "Times-Roman";
              t2["TimesNewRomanPSMT-Bold"] = "Times-Bold";
              t2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
              t2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
            });
            exports3.getStdFontMap = getStdFontMap;
            const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2["Calibri"] = "Helvetica";
              t2["Calibri-Bold"] = "Helvetica-Bold";
              t2["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
              t2["Calibri-Italic"] = "Helvetica-Oblique";
              t2["CenturyGothic"] = "Helvetica";
              t2["CenturyGothic-Bold"] = "Helvetica-Bold";
              t2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
              t2["CenturyGothic-Italic"] = "Helvetica-Oblique";
              t2["ComicSansMS"] = "Comic Sans MS";
              t2["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
              t2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
              t2["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
              t2["LucidaConsole"] = "Courier";
              t2["LucidaConsole-Bold"] = "Courier-Bold";
              t2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
              t2["LucidaConsole-Italic"] = "Courier-Oblique";
              t2["LucidaSans-Demi"] = "Helvetica-Bold";
              t2["MS-Gothic"] = "MS Gothic";
              t2["MS-Gothic-Bold"] = "MS Gothic-Bold";
              t2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
              t2["MS-Gothic-Italic"] = "MS Gothic-Italic";
              t2["MS-Mincho"] = "MS Mincho";
              t2["MS-Mincho-Bold"] = "MS Mincho-Bold";
              t2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
              t2["MS-Mincho-Italic"] = "MS Mincho-Italic";
              t2["MS-PGothic"] = "MS PGothic";
              t2["MS-PGothic-Bold"] = "MS PGothic-Bold";
              t2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
              t2["MS-PGothic-Italic"] = "MS PGothic-Italic";
              t2["MS-PMincho"] = "MS PMincho";
              t2["MS-PMincho-Bold"] = "MS PMincho-Bold";
              t2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
              t2["MS-PMincho-Italic"] = "MS PMincho-Italic";
              t2["NuptialScript"] = "Times-Italic";
              t2["SegoeUISymbol"] = "Helvetica";
              t2["Wingdings"] = "ZapfDingbats";
              t2["Wingdings-Regular"] = "ZapfDingbats";
            });
            exports3.getNonStdFontMap = getNonStdFontMap;
            const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2["Adobe Jenson"] = true;
              t2["Adobe Text"] = true;
              t2["Albertus"] = true;
              t2["Aldus"] = true;
              t2["Alexandria"] = true;
              t2["Algerian"] = true;
              t2["American Typewriter"] = true;
              t2["Antiqua"] = true;
              t2["Apex"] = true;
              t2["Arno"] = true;
              t2["Aster"] = true;
              t2["Aurora"] = true;
              t2["Baskerville"] = true;
              t2["Bell"] = true;
              t2["Bembo"] = true;
              t2["Bembo Schoolbook"] = true;
              t2["Benguiat"] = true;
              t2["Berkeley Old Style"] = true;
              t2["Bernhard Modern"] = true;
              t2["Berthold City"] = true;
              t2["Bodoni"] = true;
              t2["Bauer Bodoni"] = true;
              t2["Book Antiqua"] = true;
              t2["Bookman"] = true;
              t2["Bordeaux Roman"] = true;
              t2["Californian FB"] = true;
              t2["Calisto"] = true;
              t2["Calvert"] = true;
              t2["Capitals"] = true;
              t2["Cambria"] = true;
              t2["Cartier"] = true;
              t2["Caslon"] = true;
              t2["Catull"] = true;
              t2["Centaur"] = true;
              t2["Century Old Style"] = true;
              t2["Century Schoolbook"] = true;
              t2["Chaparral"] = true;
              t2["Charis SIL"] = true;
              t2["Cheltenham"] = true;
              t2["Cholla Slab"] = true;
              t2["Clarendon"] = true;
              t2["Clearface"] = true;
              t2["Cochin"] = true;
              t2["Colonna"] = true;
              t2["Computer Modern"] = true;
              t2["Concrete Roman"] = true;
              t2["Constantia"] = true;
              t2["Cooper Black"] = true;
              t2["Corona"] = true;
              t2["Ecotype"] = true;
              t2["Egyptienne"] = true;
              t2["Elephant"] = true;
              t2["Excelsior"] = true;
              t2["Fairfield"] = true;
              t2["FF Scala"] = true;
              t2["Folkard"] = true;
              t2["Footlight"] = true;
              t2["FreeSerif"] = true;
              t2["Friz Quadrata"] = true;
              t2["Garamond"] = true;
              t2["Gentium"] = true;
              t2["Georgia"] = true;
              t2["Gloucester"] = true;
              t2["Goudy Old Style"] = true;
              t2["Goudy Schoolbook"] = true;
              t2["Goudy Pro Font"] = true;
              t2["Granjon"] = true;
              t2["Guardian Egyptian"] = true;
              t2["Heather"] = true;
              t2["Hercules"] = true;
              t2["High Tower Text"] = true;
              t2["Hiroshige"] = true;
              t2["Hoefler Text"] = true;
              t2["Humana Serif"] = true;
              t2["Imprint"] = true;
              t2["Ionic No. 5"] = true;
              t2["Janson"] = true;
              t2["Joanna"] = true;
              t2["Korinna"] = true;
              t2["Lexicon"] = true;
              t2["Liberation Serif"] = true;
              t2["Linux Libertine"] = true;
              t2["Literaturnaya"] = true;
              t2["Lucida"] = true;
              t2["Lucida Bright"] = true;
              t2["Melior"] = true;
              t2["Memphis"] = true;
              t2["Miller"] = true;
              t2["Minion"] = true;
              t2["Modern"] = true;
              t2["Mona Lisa"] = true;
              t2["Mrs Eaves"] = true;
              t2["MS Serif"] = true;
              t2["Museo Slab"] = true;
              t2["New York"] = true;
              t2["Nimbus Roman"] = true;
              t2["NPS Rawlinson Roadway"] = true;
              t2["NuptialScript"] = true;
              t2["Palatino"] = true;
              t2["Perpetua"] = true;
              t2["Plantin"] = true;
              t2["Plantin Schoolbook"] = true;
              t2["Playbill"] = true;
              t2["Poor Richard"] = true;
              t2["Rawlinson Roadway"] = true;
              t2["Renault"] = true;
              t2["Requiem"] = true;
              t2["Rockwell"] = true;
              t2["Roman"] = true;
              t2["Rotis Serif"] = true;
              t2["Sabon"] = true;
              t2["Scala"] = true;
              t2["Seagull"] = true;
              t2["Sistina"] = true;
              t2["Souvenir"] = true;
              t2["STIX"] = true;
              t2["Stone Informal"] = true;
              t2["Stone Serif"] = true;
              t2["Sylfaen"] = true;
              t2["Times"] = true;
              t2["Trajan"] = true;
              t2["Trinité"] = true;
              t2["Trump Mediaeval"] = true;
              t2["Utopia"] = true;
              t2["Vale Type"] = true;
              t2["Bitstream Vera"] = true;
              t2["Vera Serif"] = true;
              t2["Versailles"] = true;
              t2["Wanted"] = true;
              t2["Weiss"] = true;
              t2["Wide Latin"] = true;
              t2["Windsor"] = true;
              t2["XITS"] = true;
            });
            exports3.getSerifFonts = getSerifFonts;
            const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2["Dingbats"] = true;
              t2["Symbol"] = true;
              t2["ZapfDingbats"] = true;
            });
            exports3.getSymbolsFonts = getSymbolsFonts;
            const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2[2] = 10;
              t2[3] = 32;
              t2[4] = 33;
              t2[5] = 34;
              t2[6] = 35;
              t2[7] = 36;
              t2[8] = 37;
              t2[9] = 38;
              t2[10] = 39;
              t2[11] = 40;
              t2[12] = 41;
              t2[13] = 42;
              t2[14] = 43;
              t2[15] = 44;
              t2[16] = 45;
              t2[17] = 46;
              t2[18] = 47;
              t2[19] = 48;
              t2[20] = 49;
              t2[21] = 50;
              t2[22] = 51;
              t2[23] = 52;
              t2[24] = 53;
              t2[25] = 54;
              t2[26] = 55;
              t2[27] = 56;
              t2[28] = 57;
              t2[29] = 58;
              t2[30] = 894;
              t2[31] = 60;
              t2[32] = 61;
              t2[33] = 62;
              t2[34] = 63;
              t2[35] = 64;
              t2[36] = 65;
              t2[37] = 66;
              t2[38] = 67;
              t2[39] = 68;
              t2[40] = 69;
              t2[41] = 70;
              t2[42] = 71;
              t2[43] = 72;
              t2[44] = 73;
              t2[45] = 74;
              t2[46] = 75;
              t2[47] = 76;
              t2[48] = 77;
              t2[49] = 78;
              t2[50] = 79;
              t2[51] = 80;
              t2[52] = 81;
              t2[53] = 82;
              t2[54] = 83;
              t2[55] = 84;
              t2[56] = 85;
              t2[57] = 86;
              t2[58] = 87;
              t2[59] = 88;
              t2[60] = 89;
              t2[61] = 90;
              t2[62] = 91;
              t2[63] = 92;
              t2[64] = 93;
              t2[65] = 94;
              t2[66] = 95;
              t2[67] = 96;
              t2[68] = 97;
              t2[69] = 98;
              t2[70] = 99;
              t2[71] = 100;
              t2[72] = 101;
              t2[73] = 102;
              t2[74] = 103;
              t2[75] = 104;
              t2[76] = 105;
              t2[77] = 106;
              t2[78] = 107;
              t2[79] = 108;
              t2[80] = 109;
              t2[81] = 110;
              t2[82] = 111;
              t2[83] = 112;
              t2[84] = 113;
              t2[85] = 114;
              t2[86] = 115;
              t2[87] = 116;
              t2[88] = 117;
              t2[89] = 118;
              t2[90] = 119;
              t2[91] = 120;
              t2[92] = 121;
              t2[93] = 122;
              t2[94] = 123;
              t2[95] = 124;
              t2[96] = 125;
              t2[97] = 126;
              t2[98] = 196;
              t2[99] = 197;
              t2[100] = 199;
              t2[101] = 201;
              t2[102] = 209;
              t2[103] = 214;
              t2[104] = 220;
              t2[105] = 225;
              t2[106] = 224;
              t2[107] = 226;
              t2[108] = 228;
              t2[109] = 227;
              t2[110] = 229;
              t2[111] = 231;
              t2[112] = 233;
              t2[113] = 232;
              t2[114] = 234;
              t2[115] = 235;
              t2[116] = 237;
              t2[117] = 236;
              t2[118] = 238;
              t2[119] = 239;
              t2[120] = 241;
              t2[121] = 243;
              t2[122] = 242;
              t2[123] = 244;
              t2[124] = 246;
              t2[125] = 245;
              t2[126] = 250;
              t2[127] = 249;
              t2[128] = 251;
              t2[129] = 252;
              t2[130] = 8224;
              t2[131] = 176;
              t2[132] = 162;
              t2[133] = 163;
              t2[134] = 167;
              t2[135] = 8226;
              t2[136] = 182;
              t2[137] = 223;
              t2[138] = 174;
              t2[139] = 169;
              t2[140] = 8482;
              t2[141] = 180;
              t2[142] = 168;
              t2[143] = 8800;
              t2[144] = 198;
              t2[145] = 216;
              t2[146] = 8734;
              t2[147] = 177;
              t2[148] = 8804;
              t2[149] = 8805;
              t2[150] = 165;
              t2[151] = 181;
              t2[152] = 8706;
              t2[153] = 8721;
              t2[154] = 8719;
              t2[156] = 8747;
              t2[157] = 170;
              t2[158] = 186;
              t2[159] = 8486;
              t2[160] = 230;
              t2[161] = 248;
              t2[162] = 191;
              t2[163] = 161;
              t2[164] = 172;
              t2[165] = 8730;
              t2[166] = 402;
              t2[167] = 8776;
              t2[168] = 8710;
              t2[169] = 171;
              t2[170] = 187;
              t2[171] = 8230;
              t2[210] = 218;
              t2[223] = 711;
              t2[224] = 321;
              t2[225] = 322;
              t2[227] = 353;
              t2[229] = 382;
              t2[234] = 253;
              t2[252] = 263;
              t2[253] = 268;
              t2[254] = 269;
              t2[258] = 258;
              t2[260] = 260;
              t2[261] = 261;
              t2[265] = 280;
              t2[266] = 281;
              t2[268] = 283;
              t2[269] = 313;
              t2[275] = 323;
              t2[276] = 324;
              t2[278] = 328;
              t2[284] = 345;
              t2[285] = 346;
              t2[286] = 347;
              t2[292] = 367;
              t2[295] = 377;
              t2[296] = 378;
              t2[298] = 380;
              t2[305] = 963;
              t2[306] = 964;
              t2[307] = 966;
              t2[308] = 8215;
              t2[309] = 8252;
              t2[310] = 8319;
              t2[311] = 8359;
              t2[312] = 8592;
              t2[313] = 8593;
              t2[337] = 9552;
              t2[493] = 1039;
              t2[494] = 1040;
              t2[705] = 1524;
              t2[706] = 8362;
              t2[710] = 64288;
              t2[711] = 64298;
              t2[759] = 1617;
              t2[761] = 1776;
              t2[763] = 1778;
              t2[775] = 1652;
              t2[777] = 1764;
              t2[778] = 1780;
              t2[779] = 1781;
              t2[780] = 1782;
              t2[782] = 771;
              t2[783] = 64726;
              t2[786] = 8363;
              t2[788] = 8532;
              t2[790] = 768;
              t2[791] = 769;
              t2[792] = 768;
              t2[795] = 803;
              t2[797] = 64336;
              t2[798] = 64337;
              t2[799] = 64342;
              t2[800] = 64343;
              t2[801] = 64344;
              t2[802] = 64345;
              t2[803] = 64362;
              t2[804] = 64363;
              t2[805] = 64364;
              t2[2424] = 7821;
              t2[2425] = 7822;
              t2[2426] = 7823;
              t2[2427] = 7824;
              t2[2428] = 7825;
              t2[2429] = 7826;
              t2[2430] = 7827;
              t2[2433] = 7682;
              t2[2678] = 8045;
              t2[2679] = 8046;
              t2[2830] = 1552;
              t2[2838] = 686;
              t2[2840] = 751;
              t2[2842] = 753;
              t2[2843] = 754;
              t2[2844] = 755;
              t2[2846] = 757;
              t2[2856] = 767;
              t2[2857] = 848;
              t2[2858] = 849;
              t2[2862] = 853;
              t2[2863] = 854;
              t2[2864] = 855;
              t2[2865] = 861;
              t2[2866] = 862;
              t2[2906] = 7460;
              t2[2908] = 7462;
              t2[2909] = 7463;
              t2[2910] = 7464;
              t2[2912] = 7466;
              t2[2913] = 7467;
              t2[2914] = 7468;
              t2[2916] = 7470;
              t2[2917] = 7471;
              t2[2918] = 7472;
              t2[2920] = 7474;
              t2[2921] = 7475;
              t2[2922] = 7476;
              t2[2924] = 7478;
              t2[2925] = 7479;
              t2[2926] = 7480;
              t2[2928] = 7482;
              t2[2929] = 7483;
              t2[2930] = 7484;
              t2[2932] = 7486;
              t2[2933] = 7487;
              t2[2934] = 7488;
              t2[2936] = 7490;
              t2[2937] = 7491;
              t2[2938] = 7492;
              t2[2940] = 7494;
              t2[2941] = 7495;
              t2[2942] = 7496;
              t2[2944] = 7498;
              t2[2946] = 7500;
              t2[2948] = 7502;
              t2[2950] = 7504;
              t2[2951] = 7505;
              t2[2952] = 7506;
              t2[2954] = 7508;
              t2[2955] = 7509;
              t2[2956] = 7510;
              t2[2958] = 7512;
              t2[2959] = 7513;
              t2[2960] = 7514;
              t2[2962] = 7516;
              t2[2963] = 7517;
              t2[2964] = 7518;
              t2[2966] = 7520;
              t2[2967] = 7521;
              t2[2968] = 7522;
              t2[2970] = 7524;
              t2[2971] = 7525;
              t2[2972] = 7526;
              t2[2974] = 7528;
              t2[2975] = 7529;
              t2[2976] = 7530;
              t2[2978] = 1537;
              t2[2979] = 1538;
              t2[2980] = 1539;
              t2[2982] = 1549;
              t2[2983] = 1551;
              t2[2984] = 1552;
              t2[2986] = 1554;
              t2[2987] = 1555;
              t2[2988] = 1556;
              t2[2990] = 1623;
              t2[2991] = 1624;
              t2[2995] = 1775;
              t2[2999] = 1791;
              t2[3002] = 64290;
              t2[3003] = 64291;
              t2[3004] = 64292;
              t2[3006] = 64294;
              t2[3007] = 64295;
              t2[3008] = 64296;
              t2[3011] = 1900;
              t2[3014] = 8223;
              t2[3015] = 8244;
              t2[3017] = 7532;
              t2[3018] = 7533;
              t2[3019] = 7534;
              t2[3075] = 7590;
              t2[3076] = 7591;
              t2[3079] = 7594;
              t2[3080] = 7595;
              t2[3083] = 7598;
              t2[3084] = 7599;
              t2[3087] = 7602;
              t2[3088] = 7603;
              t2[3091] = 7606;
              t2[3092] = 7607;
              t2[3095] = 7610;
              t2[3096] = 7611;
              t2[3099] = 7614;
              t2[3100] = 7615;
              t2[3103] = 7618;
              t2[3104] = 7619;
              t2[3107] = 8337;
              t2[3108] = 8338;
              t2[3116] = 1884;
              t2[3119] = 1885;
              t2[3120] = 1885;
              t2[3123] = 1886;
              t2[3124] = 1886;
              t2[3127] = 1887;
              t2[3128] = 1887;
              t2[3131] = 1888;
              t2[3132] = 1888;
              t2[3135] = 1889;
              t2[3136] = 1889;
              t2[3139] = 1890;
              t2[3140] = 1890;
              t2[3143] = 1891;
              t2[3144] = 1891;
              t2[3147] = 1892;
              t2[3148] = 1892;
              t2[3153] = 580;
              t2[3154] = 581;
              t2[3157] = 584;
              t2[3158] = 585;
              t2[3161] = 588;
              t2[3162] = 589;
              t2[3165] = 891;
              t2[3166] = 892;
              t2[3169] = 1274;
              t2[3170] = 1275;
              t2[3173] = 1278;
              t2[3174] = 1279;
              t2[3181] = 7622;
              t2[3182] = 7623;
              t2[3282] = 11799;
              t2[3316] = 578;
              t2[3379] = 42785;
              t2[3393] = 1159;
              t2[3416] = 8377;
            });
            exports3.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
            const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2[227] = 322;
              t2[264] = 261;
              t2[291] = 346;
            });
            exports3.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
            const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2[1] = 32;
              t2[4] = 65;
              t2[17] = 66;
              t2[18] = 67;
              t2[24] = 68;
              t2[28] = 69;
              t2[38] = 70;
              t2[39] = 71;
              t2[44] = 72;
              t2[47] = 73;
              t2[58] = 74;
              t2[60] = 75;
              t2[62] = 76;
              t2[68] = 77;
              t2[69] = 78;
              t2[75] = 79;
              t2[87] = 80;
              t2[89] = 81;
              t2[90] = 82;
              t2[94] = 83;
              t2[100] = 84;
              t2[104] = 85;
              t2[115] = 86;
              t2[116] = 87;
              t2[121] = 88;
              t2[122] = 89;
              t2[127] = 90;
              t2[258] = 97;
              t2[268] = 261;
              t2[271] = 98;
              t2[272] = 99;
              t2[273] = 263;
              t2[282] = 100;
              t2[286] = 101;
              t2[295] = 281;
              t2[296] = 102;
              t2[336] = 103;
              t2[346] = 104;
              t2[349] = 105;
              t2[361] = 106;
              t2[364] = 107;
              t2[367] = 108;
              t2[371] = 322;
              t2[373] = 109;
              t2[374] = 110;
              t2[381] = 111;
              t2[383] = 243;
              t2[393] = 112;
              t2[395] = 113;
              t2[396] = 114;
              t2[400] = 115;
              t2[401] = 347;
              t2[410] = 116;
              t2[437] = 117;
              t2[448] = 118;
              t2[449] = 119;
              t2[454] = 120;
              t2[455] = 121;
              t2[460] = 122;
              t2[463] = 380;
              t2[853] = 44;
              t2[855] = 58;
              t2[856] = 46;
              t2[876] = 47;
              t2[878] = 45;
              t2[882] = 45;
              t2[894] = 40;
              t2[895] = 41;
              t2[896] = 91;
              t2[897] = 93;
              t2[923] = 64;
              t2[1004] = 48;
              t2[1005] = 49;
              t2[1006] = 50;
              t2[1007] = 51;
              t2[1008] = 52;
              t2[1009] = 53;
              t2[1010] = 54;
              t2[1011] = 55;
              t2[1012] = 56;
              t2[1013] = 57;
              t2[1081] = 37;
              t2[1085] = 43;
              t2[1086] = 45;
            });
            exports3.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
          },
          /* 33 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            var getLookupTableFactory = __w_pdfjs_require__2(7).getLookupTableFactory;
            var getSpecialPUASymbols = getLookupTableFactory(function(t2) {
              t2[63721] = 169;
              t2[63193] = 169;
              t2[63720] = 174;
              t2[63194] = 174;
              t2[63722] = 8482;
              t2[63195] = 8482;
              t2[63729] = 9127;
              t2[63730] = 9128;
              t2[63731] = 9129;
              t2[63740] = 9131;
              t2[63741] = 9132;
              t2[63742] = 9133;
              t2[63726] = 9121;
              t2[63727] = 9122;
              t2[63728] = 9123;
              t2[63737] = 9124;
              t2[63738] = 9125;
              t2[63739] = 9126;
              t2[63723] = 9115;
              t2[63724] = 9116;
              t2[63725] = 9117;
              t2[63734] = 9118;
              t2[63735] = 9119;
              t2[63736] = 9120;
            });
            function mapSpecialUnicodeValues(code) {
              if (code >= 65520 && code <= 65535) {
                return 0;
              } else if (code >= 62976 && code <= 63743) {
                return getSpecialPUASymbols()[code] || code;
              } else if (code === 173) {
                return 45;
              }
              return code;
            }
            function getUnicodeForGlyph(name, glyphsUnicodeMap) {
              var unicode = glyphsUnicodeMap[name];
              if (unicode !== void 0) {
                return unicode;
              }
              if (!name) {
                return -1;
              }
              if (name[0] === "u") {
                var nameLen = name.length, hexStr;
                if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
                  hexStr = name.substring(3);
                } else if (nameLen >= 5 && nameLen <= 7) {
                  hexStr = name.substring(1);
                } else {
                  return -1;
                }
                if (hexStr === hexStr.toUpperCase()) {
                  unicode = parseInt(hexStr, 16);
                  if (unicode >= 0) {
                    return unicode;
                  }
                }
              }
              return -1;
            }
            var UnicodeRanges = [
              {
                begin: 0,
                end: 127
              },
              {
                begin: 128,
                end: 255
              },
              {
                begin: 256,
                end: 383
              },
              {
                begin: 384,
                end: 591
              },
              {
                begin: 592,
                end: 687
              },
              {
                begin: 688,
                end: 767
              },
              {
                begin: 768,
                end: 879
              },
              {
                begin: 880,
                end: 1023
              },
              {
                begin: 11392,
                end: 11519
              },
              {
                begin: 1024,
                end: 1279
              },
              {
                begin: 1328,
                end: 1423
              },
              {
                begin: 1424,
                end: 1535
              },
              {
                begin: 42240,
                end: 42559
              },
              {
                begin: 1536,
                end: 1791
              },
              {
                begin: 1984,
                end: 2047
              },
              {
                begin: 2304,
                end: 2431
              },
              {
                begin: 2432,
                end: 2559
              },
              {
                begin: 2560,
                end: 2687
              },
              {
                begin: 2688,
                end: 2815
              },
              {
                begin: 2816,
                end: 2943
              },
              {
                begin: 2944,
                end: 3071
              },
              {
                begin: 3072,
                end: 3199
              },
              {
                begin: 3200,
                end: 3327
              },
              {
                begin: 3328,
                end: 3455
              },
              {
                begin: 3584,
                end: 3711
              },
              {
                begin: 3712,
                end: 3839
              },
              {
                begin: 4256,
                end: 4351
              },
              {
                begin: 6912,
                end: 7039
              },
              {
                begin: 4352,
                end: 4607
              },
              {
                begin: 7680,
                end: 7935
              },
              {
                begin: 7936,
                end: 8191
              },
              {
                begin: 8192,
                end: 8303
              },
              {
                begin: 8304,
                end: 8351
              },
              {
                begin: 8352,
                end: 8399
              },
              {
                begin: 8400,
                end: 8447
              },
              {
                begin: 8448,
                end: 8527
              },
              {
                begin: 8528,
                end: 8591
              },
              {
                begin: 8592,
                end: 8703
              },
              {
                begin: 8704,
                end: 8959
              },
              {
                begin: 8960,
                end: 9215
              },
              {
                begin: 9216,
                end: 9279
              },
              {
                begin: 9280,
                end: 9311
              },
              {
                begin: 9312,
                end: 9471
              },
              {
                begin: 9472,
                end: 9599
              },
              {
                begin: 9600,
                end: 9631
              },
              {
                begin: 9632,
                end: 9727
              },
              {
                begin: 9728,
                end: 9983
              },
              {
                begin: 9984,
                end: 10175
              },
              {
                begin: 12288,
                end: 12351
              },
              {
                begin: 12352,
                end: 12447
              },
              {
                begin: 12448,
                end: 12543
              },
              {
                begin: 12544,
                end: 12591
              },
              {
                begin: 12592,
                end: 12687
              },
              {
                begin: 43072,
                end: 43135
              },
              {
                begin: 12800,
                end: 13055
              },
              {
                begin: 13056,
                end: 13311
              },
              {
                begin: 44032,
                end: 55215
              },
              {
                begin: 55296,
                end: 57343
              },
              {
                begin: 67840,
                end: 67871
              },
              {
                begin: 19968,
                end: 40959
              },
              {
                begin: 57344,
                end: 63743
              },
              {
                begin: 12736,
                end: 12783
              },
              {
                begin: 64256,
                end: 64335
              },
              {
                begin: 64336,
                end: 65023
              },
              {
                begin: 65056,
                end: 65071
              },
              {
                begin: 65040,
                end: 65055
              },
              {
                begin: 65104,
                end: 65135
              },
              {
                begin: 65136,
                end: 65279
              },
              {
                begin: 65280,
                end: 65519
              },
              {
                begin: 65520,
                end: 65535
              },
              {
                begin: 3840,
                end: 4095
              },
              {
                begin: 1792,
                end: 1871
              },
              {
                begin: 1920,
                end: 1983
              },
              {
                begin: 3456,
                end: 3583
              },
              {
                begin: 4096,
                end: 4255
              },
              {
                begin: 4608,
                end: 4991
              },
              {
                begin: 5024,
                end: 5119
              },
              {
                begin: 5120,
                end: 5759
              },
              {
                begin: 5760,
                end: 5791
              },
              {
                begin: 5792,
                end: 5887
              },
              {
                begin: 6016,
                end: 6143
              },
              {
                begin: 6144,
                end: 6319
              },
              {
                begin: 10240,
                end: 10495
              },
              {
                begin: 40960,
                end: 42127
              },
              {
                begin: 5888,
                end: 5919
              },
              {
                begin: 66304,
                end: 66351
              },
              {
                begin: 66352,
                end: 66383
              },
              {
                begin: 66560,
                end: 66639
              },
              {
                begin: 118784,
                end: 119039
              },
              {
                begin: 119808,
                end: 120831
              },
              {
                begin: 1044480,
                end: 1048573
              },
              {
                begin: 65024,
                end: 65039
              },
              {
                begin: 917504,
                end: 917631
              },
              {
                begin: 6400,
                end: 6479
              },
              {
                begin: 6480,
                end: 6527
              },
              {
                begin: 6528,
                end: 6623
              },
              {
                begin: 6656,
                end: 6687
              },
              {
                begin: 11264,
                end: 11359
              },
              {
                begin: 11568,
                end: 11647
              },
              {
                begin: 19904,
                end: 19967
              },
              {
                begin: 43008,
                end: 43055
              },
              {
                begin: 65536,
                end: 65663
              },
              {
                begin: 65856,
                end: 65935
              },
              {
                begin: 66432,
                end: 66463
              },
              {
                begin: 66464,
                end: 66527
              },
              {
                begin: 66640,
                end: 66687
              },
              {
                begin: 66688,
                end: 66735
              },
              {
                begin: 67584,
                end: 67647
              },
              {
                begin: 68096,
                end: 68191
              },
              {
                begin: 119552,
                end: 119647
              },
              {
                begin: 73728,
                end: 74751
              },
              {
                begin: 119648,
                end: 119679
              },
              {
                begin: 7040,
                end: 7103
              },
              {
                begin: 7168,
                end: 7247
              },
              {
                begin: 7248,
                end: 7295
              },
              {
                begin: 43136,
                end: 43231
              },
              {
                begin: 43264,
                end: 43311
              },
              {
                begin: 43312,
                end: 43359
              },
              {
                begin: 43520,
                end: 43615
              },
              {
                begin: 65936,
                end: 65999
              },
              {
                begin: 66e3,
                end: 66047
              },
              {
                begin: 66208,
                end: 66271
              },
              {
                begin: 127024,
                end: 127135
              }
            ];
            function getUnicodeRangeFor(value) {
              for (var i2 = 0, ii = UnicodeRanges.length; i2 < ii; i2++) {
                var range = UnicodeRanges[i2];
                if (value >= range.begin && value < range.end) {
                  return i2;
                }
              }
              return -1;
            }
            function isRTLRangeFor(value) {
              var range = UnicodeRanges[13];
              if (value >= range.begin && value < range.end) {
                return true;
              }
              range = UnicodeRanges[11];
              if (value >= range.begin && value < range.end) {
                return true;
              }
              return false;
            }
            var getNormalizedUnicodes = getLookupTableFactory(function(t2) {
              t2["¨"] = " ̈";
              t2["¯"] = " ̄";
              t2["´"] = " ́";
              t2["µ"] = "μ";
              t2["¸"] = " ̧";
              t2["Ĳ"] = "IJ";
              t2["ĳ"] = "ij";
              t2["Ŀ"] = "L·";
              t2["ŀ"] = "l·";
              t2["ŉ"] = "ʼn";
              t2["ſ"] = "s";
              t2["Ǆ"] = "DŽ";
              t2["ǅ"] = "Dž";
              t2["ǆ"] = "dž";
              t2["Ǉ"] = "LJ";
              t2["ǈ"] = "Lj";
              t2["ǉ"] = "lj";
              t2["Ǌ"] = "NJ";
              t2["ǋ"] = "Nj";
              t2["ǌ"] = "nj";
              t2["Ǳ"] = "DZ";
              t2["ǲ"] = "Dz";
              t2["ǳ"] = "dz";
              t2["˘"] = " ̆";
              t2["˙"] = " ̇";
              t2["˚"] = " ̊";
              t2["˛"] = " ̨";
              t2["˜"] = " ̃";
              t2["˝"] = " ̋";
              t2["ͺ"] = " ͅ";
              t2["΄"] = " ́";
              t2["ϐ"] = "β";
              t2["ϑ"] = "θ";
              t2["ϒ"] = "Υ";
              t2["ϕ"] = "φ";
              t2["ϖ"] = "π";
              t2["ϰ"] = "κ";
              t2["ϱ"] = "ρ";
              t2["ϲ"] = "ς";
              t2["ϴ"] = "Θ";
              t2["ϵ"] = "ε";
              t2["Ϲ"] = "Σ";
              t2["և"] = "եւ";
              t2["ٵ"] = "اٴ";
              t2["ٶ"] = "وٴ";
              t2["ٷ"] = "ۇٴ";
              t2["ٸ"] = "يٴ";
              t2["ำ"] = "ํา";
              t2["ຳ"] = "ໍາ";
              t2["ໜ"] = "ຫນ";
              t2["ໝ"] = "ຫມ";
              t2["ཷ"] = "ྲཱྀ";
              t2["ཹ"] = "ླཱྀ";
              t2["ẚ"] = "aʾ";
              t2["᾽"] = " ̓";
              t2["᾿"] = " ̓";
              t2["῀"] = " ͂";
              t2["῾"] = " ̔";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2[" "] = " ";
              t2["‗"] = " ̳";
              t2["․"] = ".";
              t2["‥"] = "..";
              t2["…"] = "...";
              t2["″"] = "′′";
              t2["‴"] = "′′′";
              t2["‶"] = "‵‵";
              t2["‷"] = "‵‵‵";
              t2["‼"] = "!!";
              t2["‾"] = " ̅";
              t2["⁇"] = "??";
              t2["⁈"] = "?!";
              t2["⁉"] = "!?";
              t2["⁗"] = "′′′′";
              t2[" "] = " ";
              t2["₨"] = "Rs";
              t2["℀"] = "a/c";
              t2["℁"] = "a/s";
              t2["℃"] = "°C";
              t2["℅"] = "c/o";
              t2["℆"] = "c/u";
              t2["ℇ"] = "Ɛ";
              t2["℉"] = "°F";
              t2["№"] = "No";
              t2["℡"] = "TEL";
              t2["ℵ"] = "א";
              t2["ℶ"] = "ב";
              t2["ℷ"] = "ג";
              t2["ℸ"] = "ד";
              t2["℻"] = "FAX";
              t2["Ⅰ"] = "I";
              t2["Ⅱ"] = "II";
              t2["Ⅲ"] = "III";
              t2["Ⅳ"] = "IV";
              t2["Ⅴ"] = "V";
              t2["Ⅵ"] = "VI";
              t2["Ⅶ"] = "VII";
              t2["Ⅷ"] = "VIII";
              t2["Ⅸ"] = "IX";
              t2["Ⅹ"] = "X";
              t2["Ⅺ"] = "XI";
              t2["Ⅻ"] = "XII";
              t2["Ⅼ"] = "L";
              t2["Ⅽ"] = "C";
              t2["Ⅾ"] = "D";
              t2["Ⅿ"] = "M";
              t2["ⅰ"] = "i";
              t2["ⅱ"] = "ii";
              t2["ⅲ"] = "iii";
              t2["ⅳ"] = "iv";
              t2["ⅴ"] = "v";
              t2["ⅵ"] = "vi";
              t2["ⅶ"] = "vii";
              t2["ⅷ"] = "viii";
              t2["ⅸ"] = "ix";
              t2["ⅹ"] = "x";
              t2["ⅺ"] = "xi";
              t2["ⅻ"] = "xii";
              t2["ⅼ"] = "l";
              t2["ⅽ"] = "c";
              t2["ⅾ"] = "d";
              t2["ⅿ"] = "m";
              t2["∬"] = "∫∫";
              t2["∭"] = "∫∫∫";
              t2["∯"] = "∮∮";
              t2["∰"] = "∮∮∮";
              t2["⑴"] = "(1)";
              t2["⑵"] = "(2)";
              t2["⑶"] = "(3)";
              t2["⑷"] = "(4)";
              t2["⑸"] = "(5)";
              t2["⑹"] = "(6)";
              t2["⑺"] = "(7)";
              t2["⑻"] = "(8)";
              t2["⑼"] = "(9)";
              t2["⑽"] = "(10)";
              t2["⑾"] = "(11)";
              t2["⑿"] = "(12)";
              t2["⒀"] = "(13)";
              t2["⒁"] = "(14)";
              t2["⒂"] = "(15)";
              t2["⒃"] = "(16)";
              t2["⒄"] = "(17)";
              t2["⒅"] = "(18)";
              t2["⒆"] = "(19)";
              t2["⒇"] = "(20)";
              t2["⒈"] = "1.";
              t2["⒉"] = "2.";
              t2["⒊"] = "3.";
              t2["⒋"] = "4.";
              t2["⒌"] = "5.";
              t2["⒍"] = "6.";
              t2["⒎"] = "7.";
              t2["⒏"] = "8.";
              t2["⒐"] = "9.";
              t2["⒑"] = "10.";
              t2["⒒"] = "11.";
              t2["⒓"] = "12.";
              t2["⒔"] = "13.";
              t2["⒕"] = "14.";
              t2["⒖"] = "15.";
              t2["⒗"] = "16.";
              t2["⒘"] = "17.";
              t2["⒙"] = "18.";
              t2["⒚"] = "19.";
              t2["⒛"] = "20.";
              t2["⒜"] = "(a)";
              t2["⒝"] = "(b)";
              t2["⒞"] = "(c)";
              t2["⒟"] = "(d)";
              t2["⒠"] = "(e)";
              t2["⒡"] = "(f)";
              t2["⒢"] = "(g)";
              t2["⒣"] = "(h)";
              t2["⒤"] = "(i)";
              t2["⒥"] = "(j)";
              t2["⒦"] = "(k)";
              t2["⒧"] = "(l)";
              t2["⒨"] = "(m)";
              t2["⒩"] = "(n)";
              t2["⒪"] = "(o)";
              t2["⒫"] = "(p)";
              t2["⒬"] = "(q)";
              t2["⒭"] = "(r)";
              t2["⒮"] = "(s)";
              t2["⒯"] = "(t)";
              t2["⒰"] = "(u)";
              t2["⒱"] = "(v)";
              t2["⒲"] = "(w)";
              t2["⒳"] = "(x)";
              t2["⒴"] = "(y)";
              t2["⒵"] = "(z)";
              t2["⨌"] = "∫∫∫∫";
              t2["⩴"] = "::=";
              t2["⩵"] = "==";
              t2["⩶"] = "===";
              t2["⺟"] = "母";
              t2["⻳"] = "龟";
              t2["⼀"] = "一";
              t2["⼁"] = "丨";
              t2["⼂"] = "丶";
              t2["⼃"] = "丿";
              t2["⼄"] = "乙";
              t2["⼅"] = "亅";
              t2["⼆"] = "二";
              t2["⼇"] = "亠";
              t2["⼈"] = "人";
              t2["⼉"] = "儿";
              t2["⼊"] = "入";
              t2["⼋"] = "八";
              t2["⼌"] = "冂";
              t2["⼍"] = "冖";
              t2["⼎"] = "冫";
              t2["⼏"] = "几";
              t2["⼐"] = "凵";
              t2["⼑"] = "刀";
              t2["⼒"] = "力";
              t2["⼓"] = "勹";
              t2["⼔"] = "匕";
              t2["⼕"] = "匚";
              t2["⼖"] = "匸";
              t2["⼗"] = "十";
              t2["⼘"] = "卜";
              t2["⼙"] = "卩";
              t2["⼚"] = "厂";
              t2["⼛"] = "厶";
              t2["⼜"] = "又";
              t2["⼝"] = "口";
              t2["⼞"] = "囗";
              t2["⼟"] = "土";
              t2["⼠"] = "士";
              t2["⼡"] = "夂";
              t2["⼢"] = "夊";
              t2["⼣"] = "夕";
              t2["⼤"] = "大";
              t2["⼥"] = "女";
              t2["⼦"] = "子";
              t2["⼧"] = "宀";
              t2["⼨"] = "寸";
              t2["⼩"] = "小";
              t2["⼪"] = "尢";
              t2["⼫"] = "尸";
              t2["⼬"] = "屮";
              t2["⼭"] = "山";
              t2["⼮"] = "巛";
              t2["⼯"] = "工";
              t2["⼰"] = "己";
              t2["⼱"] = "巾";
              t2["⼲"] = "干";
              t2["⼳"] = "幺";
              t2["⼴"] = "广";
              t2["⼵"] = "廴";
              t2["⼶"] = "廾";
              t2["⼷"] = "弋";
              t2["⼸"] = "弓";
              t2["⼹"] = "彐";
              t2["⼺"] = "彡";
              t2["⼻"] = "彳";
              t2["⼼"] = "心";
              t2["⼽"] = "戈";
              t2["⼾"] = "戶";
              t2["⼿"] = "手";
              t2["⽀"] = "支";
              t2["⽁"] = "攴";
              t2["⽂"] = "文";
              t2["⽃"] = "斗";
              t2["⽄"] = "斤";
              t2["⽅"] = "方";
              t2["⽆"] = "无";
              t2["⽇"] = "日";
              t2["⽈"] = "曰";
              t2["⽉"] = "月";
              t2["⽊"] = "木";
              t2["⽋"] = "欠";
              t2["⽌"] = "止";
              t2["⽍"] = "歹";
              t2["⽎"] = "殳";
              t2["⽏"] = "毋";
              t2["⽐"] = "比";
              t2["⽑"] = "毛";
              t2["⽒"] = "氏";
              t2["⽓"] = "气";
              t2["⽔"] = "水";
              t2["⽕"] = "火";
              t2["⽖"] = "爪";
              t2["⽗"] = "父";
              t2["⽘"] = "爻";
              t2["⽙"] = "爿";
              t2["⽚"] = "片";
              t2["⽛"] = "牙";
              t2["⽜"] = "牛";
              t2["⽝"] = "犬";
              t2["⽞"] = "玄";
              t2["⽟"] = "玉";
              t2["⽠"] = "瓜";
              t2["⽡"] = "瓦";
              t2["⽢"] = "甘";
              t2["⽣"] = "生";
              t2["⽤"] = "用";
              t2["⽥"] = "田";
              t2["⽦"] = "疋";
              t2["⽧"] = "疒";
              t2["⽨"] = "癶";
              t2["⽩"] = "白";
              t2["⽪"] = "皮";
              t2["⽫"] = "皿";
              t2["⽬"] = "目";
              t2["⽭"] = "矛";
              t2["⽮"] = "矢";
              t2["⽯"] = "石";
              t2["⽰"] = "示";
              t2["⽱"] = "禸";
              t2["⽲"] = "禾";
              t2["⽳"] = "穴";
              t2["⽴"] = "立";
              t2["⽵"] = "竹";
              t2["⽶"] = "米";
              t2["⽷"] = "糸";
              t2["⽸"] = "缶";
              t2["⽹"] = "网";
              t2["⽺"] = "羊";
              t2["⽻"] = "羽";
              t2["⽼"] = "老";
              t2["⽽"] = "而";
              t2["⽾"] = "耒";
              t2["⽿"] = "耳";
              t2["⾀"] = "聿";
              t2["⾁"] = "肉";
              t2["⾂"] = "臣";
              t2["⾃"] = "自";
              t2["⾄"] = "至";
              t2["⾅"] = "臼";
              t2["⾆"] = "舌";
              t2["⾇"] = "舛";
              t2["⾈"] = "舟";
              t2["⾉"] = "艮";
              t2["⾊"] = "色";
              t2["⾋"] = "艸";
              t2["⾌"] = "虍";
              t2["⾍"] = "虫";
              t2["⾎"] = "血";
              t2["⾏"] = "行";
              t2["⾐"] = "衣";
              t2["⾑"] = "襾";
              t2["⾒"] = "見";
              t2["⾓"] = "角";
              t2["⾔"] = "言";
              t2["⾕"] = "谷";
              t2["⾖"] = "豆";
              t2["⾗"] = "豕";
              t2["⾘"] = "豸";
              t2["⾙"] = "貝";
              t2["⾚"] = "赤";
              t2["⾛"] = "走";
              t2["⾜"] = "足";
              t2["⾝"] = "身";
              t2["⾞"] = "車";
              t2["⾟"] = "辛";
              t2["⾠"] = "辰";
              t2["⾡"] = "辵";
              t2["⾢"] = "邑";
              t2["⾣"] = "酉";
              t2["⾤"] = "釆";
              t2["⾥"] = "里";
              t2["⾦"] = "金";
              t2["⾧"] = "長";
              t2["⾨"] = "門";
              t2["⾩"] = "阜";
              t2["⾪"] = "隶";
              t2["⾫"] = "隹";
              t2["⾬"] = "雨";
              t2["⾭"] = "靑";
              t2["⾮"] = "非";
              t2["⾯"] = "面";
              t2["⾰"] = "革";
              t2["⾱"] = "韋";
              t2["⾲"] = "韭";
              t2["⾳"] = "音";
              t2["⾴"] = "頁";
              t2["⾵"] = "風";
              t2["⾶"] = "飛";
              t2["⾷"] = "食";
              t2["⾸"] = "首";
              t2["⾹"] = "香";
              t2["⾺"] = "馬";
              t2["⾻"] = "骨";
              t2["⾼"] = "高";
              t2["⾽"] = "髟";
              t2["⾾"] = "鬥";
              t2["⾿"] = "鬯";
              t2["⿀"] = "鬲";
              t2["⿁"] = "鬼";
              t2["⿂"] = "魚";
              t2["⿃"] = "鳥";
              t2["⿄"] = "鹵";
              t2["⿅"] = "鹿";
              t2["⿆"] = "麥";
              t2["⿇"] = "麻";
              t2["⿈"] = "黃";
              t2["⿉"] = "黍";
              t2["⿊"] = "黑";
              t2["⿋"] = "黹";
              t2["⿌"] = "黽";
              t2["⿍"] = "鼎";
              t2["⿎"] = "鼓";
              t2["⿏"] = "鼠";
              t2["⿐"] = "鼻";
              t2["⿑"] = "齊";
              t2["⿒"] = "齒";
              t2["⿓"] = "龍";
              t2["⿔"] = "龜";
              t2["⿕"] = "龠";
              t2["〶"] = "〒";
              t2["〸"] = "十";
              t2["〹"] = "卄";
              t2["〺"] = "卅";
              t2["゛"] = " ゙";
              t2["゜"] = " ゚";
              t2["ㄱ"] = "ᄀ";
              t2["ㄲ"] = "ᄁ";
              t2["ㄳ"] = "ᆪ";
              t2["ㄴ"] = "ᄂ";
              t2["ㄵ"] = "ᆬ";
              t2["ㄶ"] = "ᆭ";
              t2["ㄷ"] = "ᄃ";
              t2["ㄸ"] = "ᄄ";
              t2["ㄹ"] = "ᄅ";
              t2["ㄺ"] = "ᆰ";
              t2["ㄻ"] = "ᆱ";
              t2["ㄼ"] = "ᆲ";
              t2["ㄽ"] = "ᆳ";
              t2["ㄾ"] = "ᆴ";
              t2["ㄿ"] = "ᆵ";
              t2["ㅀ"] = "ᄚ";
              t2["ㅁ"] = "ᄆ";
              t2["ㅂ"] = "ᄇ";
              t2["ㅃ"] = "ᄈ";
              t2["ㅄ"] = "ᄡ";
              t2["ㅅ"] = "ᄉ";
              t2["ㅆ"] = "ᄊ";
              t2["ㅇ"] = "ᄋ";
              t2["ㅈ"] = "ᄌ";
              t2["ㅉ"] = "ᄍ";
              t2["ㅊ"] = "ᄎ";
              t2["ㅋ"] = "ᄏ";
              t2["ㅌ"] = "ᄐ";
              t2["ㅍ"] = "ᄑ";
              t2["ㅎ"] = "ᄒ";
              t2["ㅏ"] = "ᅡ";
              t2["ㅐ"] = "ᅢ";
              t2["ㅑ"] = "ᅣ";
              t2["ㅒ"] = "ᅤ";
              t2["ㅓ"] = "ᅥ";
              t2["ㅔ"] = "ᅦ";
              t2["ㅕ"] = "ᅧ";
              t2["ㅖ"] = "ᅨ";
              t2["ㅗ"] = "ᅩ";
              t2["ㅘ"] = "ᅪ";
              t2["ㅙ"] = "ᅫ";
              t2["ㅚ"] = "ᅬ";
              t2["ㅛ"] = "ᅭ";
              t2["ㅜ"] = "ᅮ";
              t2["ㅝ"] = "ᅯ";
              t2["ㅞ"] = "ᅰ";
              t2["ㅟ"] = "ᅱ";
              t2["ㅠ"] = "ᅲ";
              t2["ㅡ"] = "ᅳ";
              t2["ㅢ"] = "ᅴ";
              t2["ㅣ"] = "ᅵ";
              t2["ㅤ"] = "ᅠ";
              t2["ㅥ"] = "ᄔ";
              t2["ㅦ"] = "ᄕ";
              t2["ㅧ"] = "ᇇ";
              t2["ㅨ"] = "ᇈ";
              t2["ㅩ"] = "ᇌ";
              t2["ㅪ"] = "ᇎ";
              t2["ㅫ"] = "ᇓ";
              t2["ㅬ"] = "ᇗ";
              t2["ㅭ"] = "ᇙ";
              t2["ㅮ"] = "ᄜ";
              t2["ㅯ"] = "ᇝ";
              t2["ㅰ"] = "ᇟ";
              t2["ㅱ"] = "ᄝ";
              t2["ㅲ"] = "ᄞ";
              t2["ㅳ"] = "ᄠ";
              t2["ㅴ"] = "ᄢ";
              t2["ㅵ"] = "ᄣ";
              t2["ㅶ"] = "ᄧ";
              t2["ㅷ"] = "ᄩ";
              t2["ㅸ"] = "ᄫ";
              t2["ㅹ"] = "ᄬ";
              t2["ㅺ"] = "ᄭ";
              t2["ㅻ"] = "ᄮ";
              t2["ㅼ"] = "ᄯ";
              t2["ㅽ"] = "ᄲ";
              t2["ㅾ"] = "ᄶ";
              t2["ㅿ"] = "ᅀ";
              t2["ㆀ"] = "ᅇ";
              t2["ㆁ"] = "ᅌ";
              t2["ㆂ"] = "ᇱ";
              t2["ㆃ"] = "ᇲ";
              t2["ㆄ"] = "ᅗ";
              t2["ㆅ"] = "ᅘ";
              t2["ㆆ"] = "ᅙ";
              t2["ㆇ"] = "ᆄ";
              t2["ㆈ"] = "ᆅ";
              t2["ㆉ"] = "ᆈ";
              t2["ㆊ"] = "ᆑ";
              t2["ㆋ"] = "ᆒ";
              t2["ㆌ"] = "ᆔ";
              t2["ㆍ"] = "ᆞ";
              t2["ㆎ"] = "ᆡ";
              t2["㈀"] = "(ᄀ)";
              t2["㈁"] = "(ᄂ)";
              t2["㈂"] = "(ᄃ)";
              t2["㈃"] = "(ᄅ)";
              t2["㈄"] = "(ᄆ)";
              t2["㈅"] = "(ᄇ)";
              t2["㈆"] = "(ᄉ)";
              t2["㈇"] = "(ᄋ)";
              t2["㈈"] = "(ᄌ)";
              t2["㈉"] = "(ᄎ)";
              t2["㈊"] = "(ᄏ)";
              t2["㈋"] = "(ᄐ)";
              t2["㈌"] = "(ᄑ)";
              t2["㈍"] = "(ᄒ)";
              t2["㈎"] = "(가)";
              t2["㈏"] = "(나)";
              t2["㈐"] = "(다)";
              t2["㈑"] = "(라)";
              t2["㈒"] = "(마)";
              t2["㈓"] = "(바)";
              t2["㈔"] = "(사)";
              t2["㈕"] = "(아)";
              t2["㈖"] = "(자)";
              t2["㈗"] = "(차)";
              t2["㈘"] = "(카)";
              t2["㈙"] = "(타)";
              t2["㈚"] = "(파)";
              t2["㈛"] = "(하)";
              t2["㈜"] = "(주)";
              t2["㈝"] = "(오전)";
              t2["㈞"] = "(오후)";
              t2["㈠"] = "(一)";
              t2["㈡"] = "(二)";
              t2["㈢"] = "(三)";
              t2["㈣"] = "(四)";
              t2["㈤"] = "(五)";
              t2["㈥"] = "(六)";
              t2["㈦"] = "(七)";
              t2["㈧"] = "(八)";
              t2["㈨"] = "(九)";
              t2["㈩"] = "(十)";
              t2["㈪"] = "(月)";
              t2["㈫"] = "(火)";
              t2["㈬"] = "(水)";
              t2["㈭"] = "(木)";
              t2["㈮"] = "(金)";
              t2["㈯"] = "(土)";
              t2["㈰"] = "(日)";
              t2["㈱"] = "(株)";
              t2["㈲"] = "(有)";
              t2["㈳"] = "(社)";
              t2["㈴"] = "(名)";
              t2["㈵"] = "(特)";
              t2["㈶"] = "(財)";
              t2["㈷"] = "(祝)";
              t2["㈸"] = "(労)";
              t2["㈹"] = "(代)";
              t2["㈺"] = "(呼)";
              t2["㈻"] = "(学)";
              t2["㈼"] = "(監)";
              t2["㈽"] = "(企)";
              t2["㈾"] = "(資)";
              t2["㈿"] = "(協)";
              t2["㉀"] = "(祭)";
              t2["㉁"] = "(休)";
              t2["㉂"] = "(自)";
              t2["㉃"] = "(至)";
              t2["㋀"] = "1月";
              t2["㋁"] = "2月";
              t2["㋂"] = "3月";
              t2["㋃"] = "4月";
              t2["㋄"] = "5月";
              t2["㋅"] = "6月";
              t2["㋆"] = "7月";
              t2["㋇"] = "8月";
              t2["㋈"] = "9月";
              t2["㋉"] = "10月";
              t2["㋊"] = "11月";
              t2["㋋"] = "12月";
              t2["㍘"] = "0点";
              t2["㍙"] = "1点";
              t2["㍚"] = "2点";
              t2["㍛"] = "3点";
              t2["㍜"] = "4点";
              t2["㍝"] = "5点";
              t2["㍞"] = "6点";
              t2["㍟"] = "7点";
              t2["㍠"] = "8点";
              t2["㍡"] = "9点";
              t2["㍢"] = "10点";
              t2["㍣"] = "11点";
              t2["㍤"] = "12点";
              t2["㍥"] = "13点";
              t2["㍦"] = "14点";
              t2["㍧"] = "15点";
              t2["㍨"] = "16点";
              t2["㍩"] = "17点";
              t2["㍪"] = "18点";
              t2["㍫"] = "19点";
              t2["㍬"] = "20点";
              t2["㍭"] = "21点";
              t2["㍮"] = "22点";
              t2["㍯"] = "23点";
              t2["㍰"] = "24点";
              t2["㏠"] = "1日";
              t2["㏡"] = "2日";
              t2["㏢"] = "3日";
              t2["㏣"] = "4日";
              t2["㏤"] = "5日";
              t2["㏥"] = "6日";
              t2["㏦"] = "7日";
              t2["㏧"] = "8日";
              t2["㏨"] = "9日";
              t2["㏩"] = "10日";
              t2["㏪"] = "11日";
              t2["㏫"] = "12日";
              t2["㏬"] = "13日";
              t2["㏭"] = "14日";
              t2["㏮"] = "15日";
              t2["㏯"] = "16日";
              t2["㏰"] = "17日";
              t2["㏱"] = "18日";
              t2["㏲"] = "19日";
              t2["㏳"] = "20日";
              t2["㏴"] = "21日";
              t2["㏵"] = "22日";
              t2["㏶"] = "23日";
              t2["㏷"] = "24日";
              t2["㏸"] = "25日";
              t2["㏹"] = "26日";
              t2["㏺"] = "27日";
              t2["㏻"] = "28日";
              t2["㏼"] = "29日";
              t2["㏽"] = "30日";
              t2["㏾"] = "31日";
              t2["ﬀ"] = "ff";
              t2["ﬁ"] = "fi";
              t2["ﬂ"] = "fl";
              t2["ﬃ"] = "ffi";
              t2["ﬄ"] = "ffl";
              t2["ﬅ"] = "ſt";
              t2["ﬆ"] = "st";
              t2["ﬓ"] = "մն";
              t2["ﬔ"] = "մե";
              t2["ﬕ"] = "մի";
              t2["ﬖ"] = "վն";
              t2["ﬗ"] = "մխ";
              t2["ﭏ"] = "אל";
              t2["ﭐ"] = "ٱ";
              t2["ﭑ"] = "ٱ";
              t2["ﭒ"] = "ٻ";
              t2["ﭓ"] = "ٻ";
              t2["ﭔ"] = "ٻ";
              t2["ﭕ"] = "ٻ";
              t2["ﭖ"] = "پ";
              t2["ﭗ"] = "پ";
              t2["ﭘ"] = "پ";
              t2["ﭙ"] = "پ";
              t2["ﭚ"] = "ڀ";
              t2["ﭛ"] = "ڀ";
              t2["ﭜ"] = "ڀ";
              t2["ﭝ"] = "ڀ";
              t2["ﭞ"] = "ٺ";
              t2["ﭟ"] = "ٺ";
              t2["ﭠ"] = "ٺ";
              t2["ﭡ"] = "ٺ";
              t2["ﭢ"] = "ٿ";
              t2["ﭣ"] = "ٿ";
              t2["ﭤ"] = "ٿ";
              t2["ﭥ"] = "ٿ";
              t2["ﭦ"] = "ٹ";
              t2["ﭧ"] = "ٹ";
              t2["ﭨ"] = "ٹ";
              t2["ﭩ"] = "ٹ";
              t2["ﭪ"] = "ڤ";
              t2["ﭫ"] = "ڤ";
              t2["ﭬ"] = "ڤ";
              t2["ﭭ"] = "ڤ";
              t2["ﭮ"] = "ڦ";
              t2["ﭯ"] = "ڦ";
              t2["ﭰ"] = "ڦ";
              t2["ﭱ"] = "ڦ";
              t2["ﭲ"] = "ڄ";
              t2["ﭳ"] = "ڄ";
              t2["ﭴ"] = "ڄ";
              t2["ﭵ"] = "ڄ";
              t2["ﭶ"] = "ڃ";
              t2["ﭷ"] = "ڃ";
              t2["ﭸ"] = "ڃ";
              t2["ﭹ"] = "ڃ";
              t2["ﭺ"] = "چ";
              t2["ﭻ"] = "چ";
              t2["ﭼ"] = "چ";
              t2["ﭽ"] = "چ";
              t2["ﭾ"] = "ڇ";
              t2["ﭿ"] = "ڇ";
              t2["ﮀ"] = "ڇ";
              t2["ﮁ"] = "ڇ";
              t2["ﮂ"] = "ڍ";
              t2["ﮃ"] = "ڍ";
              t2["ﮄ"] = "ڌ";
              t2["ﮅ"] = "ڌ";
              t2["ﮆ"] = "ڎ";
              t2["ﮇ"] = "ڎ";
              t2["ﮈ"] = "ڈ";
              t2["ﮉ"] = "ڈ";
              t2["ﮊ"] = "ژ";
              t2["ﮋ"] = "ژ";
              t2["ﮌ"] = "ڑ";
              t2["ﮍ"] = "ڑ";
              t2["ﮎ"] = "ک";
              t2["ﮏ"] = "ک";
              t2["ﮐ"] = "ک";
              t2["ﮑ"] = "ک";
              t2["ﮒ"] = "گ";
              t2["ﮓ"] = "گ";
              t2["ﮔ"] = "گ";
              t2["ﮕ"] = "گ";
              t2["ﮖ"] = "ڳ";
              t2["ﮗ"] = "ڳ";
              t2["ﮘ"] = "ڳ";
              t2["ﮙ"] = "ڳ";
              t2["ﮚ"] = "ڱ";
              t2["ﮛ"] = "ڱ";
              t2["ﮜ"] = "ڱ";
              t2["ﮝ"] = "ڱ";
              t2["ﮞ"] = "ں";
              t2["ﮟ"] = "ں";
              t2["ﮠ"] = "ڻ";
              t2["ﮡ"] = "ڻ";
              t2["ﮢ"] = "ڻ";
              t2["ﮣ"] = "ڻ";
              t2["ﮤ"] = "ۀ";
              t2["ﮥ"] = "ۀ";
              t2["ﮦ"] = "ہ";
              t2["ﮧ"] = "ہ";
              t2["ﮨ"] = "ہ";
              t2["ﮩ"] = "ہ";
              t2["ﮪ"] = "ھ";
              t2["ﮫ"] = "ھ";
              t2["ﮬ"] = "ھ";
              t2["ﮭ"] = "ھ";
              t2["ﮮ"] = "ے";
              t2["ﮯ"] = "ے";
              t2["ﮰ"] = "ۓ";
              t2["ﮱ"] = "ۓ";
              t2["ﯓ"] = "ڭ";
              t2["ﯔ"] = "ڭ";
              t2["ﯕ"] = "ڭ";
              t2["ﯖ"] = "ڭ";
              t2["ﯗ"] = "ۇ";
              t2["ﯘ"] = "ۇ";
              t2["ﯙ"] = "ۆ";
              t2["ﯚ"] = "ۆ";
              t2["ﯛ"] = "ۈ";
              t2["ﯜ"] = "ۈ";
              t2["ﯝ"] = "ٷ";
              t2["ﯞ"] = "ۋ";
              t2["ﯟ"] = "ۋ";
              t2["ﯠ"] = "ۅ";
              t2["ﯡ"] = "ۅ";
              t2["ﯢ"] = "ۉ";
              t2["ﯣ"] = "ۉ";
              t2["ﯤ"] = "ې";
              t2["ﯥ"] = "ې";
              t2["ﯦ"] = "ې";
              t2["ﯧ"] = "ې";
              t2["ﯨ"] = "ى";
              t2["ﯩ"] = "ى";
              t2["ﯪ"] = "ئا";
              t2["ﯫ"] = "ئا";
              t2["ﯬ"] = "ئە";
              t2["ﯭ"] = "ئە";
              t2["ﯮ"] = "ئو";
              t2["ﯯ"] = "ئو";
              t2["ﯰ"] = "ئۇ";
              t2["ﯱ"] = "ئۇ";
              t2["ﯲ"] = "ئۆ";
              t2["ﯳ"] = "ئۆ";
              t2["ﯴ"] = "ئۈ";
              t2["ﯵ"] = "ئۈ";
              t2["ﯶ"] = "ئې";
              t2["ﯷ"] = "ئې";
              t2["ﯸ"] = "ئې";
              t2["ﯹ"] = "ئى";
              t2["ﯺ"] = "ئى";
              t2["ﯻ"] = "ئى";
              t2["ﯼ"] = "ی";
              t2["ﯽ"] = "ی";
              t2["ﯾ"] = "ی";
              t2["ﯿ"] = "ی";
              t2["ﰀ"] = "ئج";
              t2["ﰁ"] = "ئح";
              t2["ﰂ"] = "ئم";
              t2["ﰃ"] = "ئى";
              t2["ﰄ"] = "ئي";
              t2["ﰅ"] = "بج";
              t2["ﰆ"] = "بح";
              t2["ﰇ"] = "بخ";
              t2["ﰈ"] = "بم";
              t2["ﰉ"] = "بى";
              t2["ﰊ"] = "بي";
              t2["ﰋ"] = "تج";
              t2["ﰌ"] = "تح";
              t2["ﰍ"] = "تخ";
              t2["ﰎ"] = "تم";
              t2["ﰏ"] = "تى";
              t2["ﰐ"] = "تي";
              t2["ﰑ"] = "ثج";
              t2["ﰒ"] = "ثم";
              t2["ﰓ"] = "ثى";
              t2["ﰔ"] = "ثي";
              t2["ﰕ"] = "جح";
              t2["ﰖ"] = "جم";
              t2["ﰗ"] = "حج";
              t2["ﰘ"] = "حم";
              t2["ﰙ"] = "خج";
              t2["ﰚ"] = "خح";
              t2["ﰛ"] = "خم";
              t2["ﰜ"] = "سج";
              t2["ﰝ"] = "سح";
              t2["ﰞ"] = "سخ";
              t2["ﰟ"] = "سم";
              t2["ﰠ"] = "صح";
              t2["ﰡ"] = "صم";
              t2["ﰢ"] = "ضج";
              t2["ﰣ"] = "ضح";
              t2["ﰤ"] = "ضخ";
              t2["ﰥ"] = "ضم";
              t2["ﰦ"] = "طح";
              t2["ﰧ"] = "طم";
              t2["ﰨ"] = "ظم";
              t2["ﰩ"] = "عج";
              t2["ﰪ"] = "عم";
              t2["ﰫ"] = "غج";
              t2["ﰬ"] = "غم";
              t2["ﰭ"] = "فج";
              t2["ﰮ"] = "فح";
              t2["ﰯ"] = "فخ";
              t2["ﰰ"] = "فم";
              t2["ﰱ"] = "فى";
              t2["ﰲ"] = "في";
              t2["ﰳ"] = "قح";
              t2["ﰴ"] = "قم";
              t2["ﰵ"] = "قى";
              t2["ﰶ"] = "قي";
              t2["ﰷ"] = "كا";
              t2["ﰸ"] = "كج";
              t2["ﰹ"] = "كح";
              t2["ﰺ"] = "كخ";
              t2["ﰻ"] = "كل";
              t2["ﰼ"] = "كم";
              t2["ﰽ"] = "كى";
              t2["ﰾ"] = "كي";
              t2["ﰿ"] = "لج";
              t2["ﱀ"] = "لح";
              t2["ﱁ"] = "لخ";
              t2["ﱂ"] = "لم";
              t2["ﱃ"] = "لى";
              t2["ﱄ"] = "لي";
              t2["ﱅ"] = "مج";
              t2["ﱆ"] = "مح";
              t2["ﱇ"] = "مخ";
              t2["ﱈ"] = "مم";
              t2["ﱉ"] = "مى";
              t2["ﱊ"] = "مي";
              t2["ﱋ"] = "نج";
              t2["ﱌ"] = "نح";
              t2["ﱍ"] = "نخ";
              t2["ﱎ"] = "نم";
              t2["ﱏ"] = "نى";
              t2["ﱐ"] = "ني";
              t2["ﱑ"] = "هج";
              t2["ﱒ"] = "هم";
              t2["ﱓ"] = "هى";
              t2["ﱔ"] = "هي";
              t2["ﱕ"] = "يج";
              t2["ﱖ"] = "يح";
              t2["ﱗ"] = "يخ";
              t2["ﱘ"] = "يم";
              t2["ﱙ"] = "يى";
              t2["ﱚ"] = "يي";
              t2["ﱛ"] = "ذٰ";
              t2["ﱜ"] = "رٰ";
              t2["ﱝ"] = "ىٰ";
              t2["ﱞ"] = " ٌّ";
              t2["ﱟ"] = " ٍّ";
              t2["ﱠ"] = " َّ";
              t2["ﱡ"] = " ُّ";
              t2["ﱢ"] = " ِّ";
              t2["ﱣ"] = " ّٰ";
              t2["ﱤ"] = "ئر";
              t2["ﱥ"] = "ئز";
              t2["ﱦ"] = "ئم";
              t2["ﱧ"] = "ئن";
              t2["ﱨ"] = "ئى";
              t2["ﱩ"] = "ئي";
              t2["ﱪ"] = "بر";
              t2["ﱫ"] = "بز";
              t2["ﱬ"] = "بم";
              t2["ﱭ"] = "بن";
              t2["ﱮ"] = "بى";
              t2["ﱯ"] = "بي";
              t2["ﱰ"] = "تر";
              t2["ﱱ"] = "تز";
              t2["ﱲ"] = "تم";
              t2["ﱳ"] = "تن";
              t2["ﱴ"] = "تى";
              t2["ﱵ"] = "تي";
              t2["ﱶ"] = "ثر";
              t2["ﱷ"] = "ثز";
              t2["ﱸ"] = "ثم";
              t2["ﱹ"] = "ثن";
              t2["ﱺ"] = "ثى";
              t2["ﱻ"] = "ثي";
              t2["ﱼ"] = "فى";
              t2["ﱽ"] = "في";
              t2["ﱾ"] = "قى";
              t2["ﱿ"] = "قي";
              t2["ﲀ"] = "كا";
              t2["ﲁ"] = "كل";
              t2["ﲂ"] = "كم";
              t2["ﲃ"] = "كى";
              t2["ﲄ"] = "كي";
              t2["ﲅ"] = "لم";
              t2["ﲆ"] = "لى";
              t2["ﲇ"] = "لي";
              t2["ﲈ"] = "ما";
              t2["ﲉ"] = "مم";
              t2["ﲊ"] = "نر";
              t2["ﲋ"] = "نز";
              t2["ﲌ"] = "نم";
              t2["ﲍ"] = "نن";
              t2["ﲎ"] = "نى";
              t2["ﲏ"] = "ني";
              t2["ﲐ"] = "ىٰ";
              t2["ﲑ"] = "ير";
              t2["ﲒ"] = "يز";
              t2["ﲓ"] = "يم";
              t2["ﲔ"] = "ين";
              t2["ﲕ"] = "يى";
              t2["ﲖ"] = "يي";
              t2["ﲗ"] = "ئج";
              t2["ﲘ"] = "ئح";
              t2["ﲙ"] = "ئخ";
              t2["ﲚ"] = "ئم";
              t2["ﲛ"] = "ئه";
              t2["ﲜ"] = "بج";
              t2["ﲝ"] = "بح";
              t2["ﲞ"] = "بخ";
              t2["ﲟ"] = "بم";
              t2["ﲠ"] = "به";
              t2["ﲡ"] = "تج";
              t2["ﲢ"] = "تح";
              t2["ﲣ"] = "تخ";
              t2["ﲤ"] = "تم";
              t2["ﲥ"] = "ته";
              t2["ﲦ"] = "ثم";
              t2["ﲧ"] = "جح";
              t2["ﲨ"] = "جم";
              t2["ﲩ"] = "حج";
              t2["ﲪ"] = "حم";
              t2["ﲫ"] = "خج";
              t2["ﲬ"] = "خم";
              t2["ﲭ"] = "سج";
              t2["ﲮ"] = "سح";
              t2["ﲯ"] = "سخ";
              t2["ﲰ"] = "سم";
              t2["ﲱ"] = "صح";
              t2["ﲲ"] = "صخ";
              t2["ﲳ"] = "صم";
              t2["ﲴ"] = "ضج";
              t2["ﲵ"] = "ضح";
              t2["ﲶ"] = "ضخ";
              t2["ﲷ"] = "ضم";
              t2["ﲸ"] = "طح";
              t2["ﲹ"] = "ظم";
              t2["ﲺ"] = "عج";
              t2["ﲻ"] = "عم";
              t2["ﲼ"] = "غج";
              t2["ﲽ"] = "غم";
              t2["ﲾ"] = "فج";
              t2["ﲿ"] = "فح";
              t2["ﳀ"] = "فخ";
              t2["ﳁ"] = "فم";
              t2["ﳂ"] = "قح";
              t2["ﳃ"] = "قم";
              t2["ﳄ"] = "كج";
              t2["ﳅ"] = "كح";
              t2["ﳆ"] = "كخ";
              t2["ﳇ"] = "كل";
              t2["ﳈ"] = "كم";
              t2["ﳉ"] = "لج";
              t2["ﳊ"] = "لح";
              t2["ﳋ"] = "لخ";
              t2["ﳌ"] = "لم";
              t2["ﳍ"] = "له";
              t2["ﳎ"] = "مج";
              t2["ﳏ"] = "مح";
              t2["ﳐ"] = "مخ";
              t2["ﳑ"] = "مم";
              t2["ﳒ"] = "نج";
              t2["ﳓ"] = "نح";
              t2["ﳔ"] = "نخ";
              t2["ﳕ"] = "نم";
              t2["ﳖ"] = "نه";
              t2["ﳗ"] = "هج";
              t2["ﳘ"] = "هم";
              t2["ﳙ"] = "هٰ";
              t2["ﳚ"] = "يج";
              t2["ﳛ"] = "يح";
              t2["ﳜ"] = "يخ";
              t2["ﳝ"] = "يم";
              t2["ﳞ"] = "يه";
              t2["ﳟ"] = "ئم";
              t2["ﳠ"] = "ئه";
              t2["ﳡ"] = "بم";
              t2["ﳢ"] = "به";
              t2["ﳣ"] = "تم";
              t2["ﳤ"] = "ته";
              t2["ﳥ"] = "ثم";
              t2["ﳦ"] = "ثه";
              t2["ﳧ"] = "سم";
              t2["ﳨ"] = "سه";
              t2["ﳩ"] = "شم";
              t2["ﳪ"] = "شه";
              t2["ﳫ"] = "كل";
              t2["ﳬ"] = "كم";
              t2["ﳭ"] = "لم";
              t2["ﳮ"] = "نم";
              t2["ﳯ"] = "نه";
              t2["ﳰ"] = "يم";
              t2["ﳱ"] = "يه";
              t2["ﳲ"] = "ـَّ";
              t2["ﳳ"] = "ـُّ";
              t2["ﳴ"] = "ـِّ";
              t2["ﳵ"] = "طى";
              t2["ﳶ"] = "طي";
              t2["ﳷ"] = "عى";
              t2["ﳸ"] = "عي";
              t2["ﳹ"] = "غى";
              t2["ﳺ"] = "غي";
              t2["ﳻ"] = "سى";
              t2["ﳼ"] = "سي";
              t2["ﳽ"] = "شى";
              t2["ﳾ"] = "شي";
              t2["ﳿ"] = "حى";
              t2["ﴀ"] = "حي";
              t2["ﴁ"] = "جى";
              t2["ﴂ"] = "جي";
              t2["ﴃ"] = "خى";
              t2["ﴄ"] = "خي";
              t2["ﴅ"] = "صى";
              t2["ﴆ"] = "صي";
              t2["ﴇ"] = "ضى";
              t2["ﴈ"] = "ضي";
              t2["ﴉ"] = "شج";
              t2["ﴊ"] = "شح";
              t2["ﴋ"] = "شخ";
              t2["ﴌ"] = "شم";
              t2["ﴍ"] = "شر";
              t2["ﴎ"] = "سر";
              t2["ﴏ"] = "صر";
              t2["ﴐ"] = "ضر";
              t2["ﴑ"] = "طى";
              t2["ﴒ"] = "طي";
              t2["ﴓ"] = "عى";
              t2["ﴔ"] = "عي";
              t2["ﴕ"] = "غى";
              t2["ﴖ"] = "غي";
              t2["ﴗ"] = "سى";
              t2["ﴘ"] = "سي";
              t2["ﴙ"] = "شى";
              t2["ﴚ"] = "شي";
              t2["ﴛ"] = "حى";
              t2["ﴜ"] = "حي";
              t2["ﴝ"] = "جى";
              t2["ﴞ"] = "جي";
              t2["ﴟ"] = "خى";
              t2["ﴠ"] = "خي";
              t2["ﴡ"] = "صى";
              t2["ﴢ"] = "صي";
              t2["ﴣ"] = "ضى";
              t2["ﴤ"] = "ضي";
              t2["ﴥ"] = "شج";
              t2["ﴦ"] = "شح";
              t2["ﴧ"] = "شخ";
              t2["ﴨ"] = "شم";
              t2["ﴩ"] = "شر";
              t2["ﴪ"] = "سر";
              t2["ﴫ"] = "صر";
              t2["ﴬ"] = "ضر";
              t2["ﴭ"] = "شج";
              t2["ﴮ"] = "شح";
              t2["ﴯ"] = "شخ";
              t2["ﴰ"] = "شم";
              t2["ﴱ"] = "سه";
              t2["ﴲ"] = "شه";
              t2["ﴳ"] = "طم";
              t2["ﴴ"] = "سج";
              t2["ﴵ"] = "سح";
              t2["ﴶ"] = "سخ";
              t2["ﴷ"] = "شج";
              t2["ﴸ"] = "شح";
              t2["ﴹ"] = "شخ";
              t2["ﴺ"] = "طم";
              t2["ﴻ"] = "ظم";
              t2["ﴼ"] = "اً";
              t2["ﴽ"] = "اً";
              t2["ﵐ"] = "تجم";
              t2["ﵑ"] = "تحج";
              t2["ﵒ"] = "تحج";
              t2["ﵓ"] = "تحم";
              t2["ﵔ"] = "تخم";
              t2["ﵕ"] = "تمج";
              t2["ﵖ"] = "تمح";
              t2["ﵗ"] = "تمخ";
              t2["ﵘ"] = "جمح";
              t2["ﵙ"] = "جمح";
              t2["ﵚ"] = "حمي";
              t2["ﵛ"] = "حمى";
              t2["ﵜ"] = "سحج";
              t2["ﵝ"] = "سجح";
              t2["ﵞ"] = "سجى";
              t2["ﵟ"] = "سمح";
              t2["ﵠ"] = "سمح";
              t2["ﵡ"] = "سمج";
              t2["ﵢ"] = "سمم";
              t2["ﵣ"] = "سمم";
              t2["ﵤ"] = "صحح";
              t2["ﵥ"] = "صحح";
              t2["ﵦ"] = "صمم";
              t2["ﵧ"] = "شحم";
              t2["ﵨ"] = "شحم";
              t2["ﵩ"] = "شجي";
              t2["ﵪ"] = "شمخ";
              t2["ﵫ"] = "شمخ";
              t2["ﵬ"] = "شمم";
              t2["ﵭ"] = "شمم";
              t2["ﵮ"] = "ضحى";
              t2["ﵯ"] = "ضخم";
              t2["ﵰ"] = "ضخم";
              t2["ﵱ"] = "طمح";
              t2["ﵲ"] = "طمح";
              t2["ﵳ"] = "طمم";
              t2["ﵴ"] = "طمي";
              t2["ﵵ"] = "عجم";
              t2["ﵶ"] = "عمم";
              t2["ﵷ"] = "عمم";
              t2["ﵸ"] = "عمى";
              t2["ﵹ"] = "غمم";
              t2["ﵺ"] = "غمي";
              t2["ﵻ"] = "غمى";
              t2["ﵼ"] = "فخم";
              t2["ﵽ"] = "فخم";
              t2["ﵾ"] = "قمح";
              t2["ﵿ"] = "قمم";
              t2["ﶀ"] = "لحم";
              t2["ﶁ"] = "لحي";
              t2["ﶂ"] = "لحى";
              t2["ﶃ"] = "لجج";
              t2["ﶄ"] = "لجج";
              t2["ﶅ"] = "لخم";
              t2["ﶆ"] = "لخم";
              t2["ﶇ"] = "لمح";
              t2["ﶈ"] = "لمح";
              t2["ﶉ"] = "محج";
              t2["ﶊ"] = "محم";
              t2["ﶋ"] = "محي";
              t2["ﶌ"] = "مجح";
              t2["ﶍ"] = "مجم";
              t2["ﶎ"] = "مخج";
              t2["ﶏ"] = "مخم";
              t2["ﶒ"] = "مجخ";
              t2["ﶓ"] = "همج";
              t2["ﶔ"] = "همم";
              t2["ﶕ"] = "نحم";
              t2["ﶖ"] = "نحى";
              t2["ﶗ"] = "نجم";
              t2["ﶘ"] = "نجم";
              t2["ﶙ"] = "نجى";
              t2["ﶚ"] = "نمي";
              t2["ﶛ"] = "نمى";
              t2["ﶜ"] = "يمم";
              t2["ﶝ"] = "يمم";
              t2["ﶞ"] = "بخي";
              t2["ﶟ"] = "تجي";
              t2["ﶠ"] = "تجى";
              t2["ﶡ"] = "تخي";
              t2["ﶢ"] = "تخى";
              t2["ﶣ"] = "تمي";
              t2["ﶤ"] = "تمى";
              t2["ﶥ"] = "جمي";
              t2["ﶦ"] = "جحى";
              t2["ﶧ"] = "جمى";
              t2["ﶨ"] = "سخى";
              t2["ﶩ"] = "صحي";
              t2["ﶪ"] = "شحي";
              t2["ﶫ"] = "ضحي";
              t2["ﶬ"] = "لجي";
              t2["ﶭ"] = "لمي";
              t2["ﶮ"] = "يحي";
              t2["ﶯ"] = "يجي";
              t2["ﶰ"] = "يمي";
              t2["ﶱ"] = "ممي";
              t2["ﶲ"] = "قمي";
              t2["ﶳ"] = "نحي";
              t2["ﶴ"] = "قمح";
              t2["ﶵ"] = "لحم";
              t2["ﶶ"] = "عمي";
              t2["ﶷ"] = "كمي";
              t2["ﶸ"] = "نجح";
              t2["ﶹ"] = "مخي";
              t2["ﶺ"] = "لجم";
              t2["ﶻ"] = "كمم";
              t2["ﶼ"] = "لجم";
              t2["ﶽ"] = "نجح";
              t2["ﶾ"] = "جحي";
              t2["ﶿ"] = "حجي";
              t2["ﷀ"] = "مجي";
              t2["ﷁ"] = "فمي";
              t2["ﷂ"] = "بحي";
              t2["ﷃ"] = "كمم";
              t2["ﷄ"] = "عجم";
              t2["ﷅ"] = "صمم";
              t2["ﷆ"] = "سخي";
              t2["ﷇ"] = "نجي";
              t2["﹉"] = "‾";
              t2["﹊"] = "‾";
              t2["﹋"] = "‾";
              t2["﹌"] = "‾";
              t2["﹍"] = "_";
              t2["﹎"] = "_";
              t2["﹏"] = "_";
              t2["ﺀ"] = "ء";
              t2["ﺁ"] = "آ";
              t2["ﺂ"] = "آ";
              t2["ﺃ"] = "أ";
              t2["ﺄ"] = "أ";
              t2["ﺅ"] = "ؤ";
              t2["ﺆ"] = "ؤ";
              t2["ﺇ"] = "إ";
              t2["ﺈ"] = "إ";
              t2["ﺉ"] = "ئ";
              t2["ﺊ"] = "ئ";
              t2["ﺋ"] = "ئ";
              t2["ﺌ"] = "ئ";
              t2["ﺍ"] = "ا";
              t2["ﺎ"] = "ا";
              t2["ﺏ"] = "ب";
              t2["ﺐ"] = "ب";
              t2["ﺑ"] = "ب";
              t2["ﺒ"] = "ب";
              t2["ﺓ"] = "ة";
              t2["ﺔ"] = "ة";
              t2["ﺕ"] = "ت";
              t2["ﺖ"] = "ت";
              t2["ﺗ"] = "ت";
              t2["ﺘ"] = "ت";
              t2["ﺙ"] = "ث";
              t2["ﺚ"] = "ث";
              t2["ﺛ"] = "ث";
              t2["ﺜ"] = "ث";
              t2["ﺝ"] = "ج";
              t2["ﺞ"] = "ج";
              t2["ﺟ"] = "ج";
              t2["ﺠ"] = "ج";
              t2["ﺡ"] = "ح";
              t2["ﺢ"] = "ح";
              t2["ﺣ"] = "ح";
              t2["ﺤ"] = "ح";
              t2["ﺥ"] = "خ";
              t2["ﺦ"] = "خ";
              t2["ﺧ"] = "خ";
              t2["ﺨ"] = "خ";
              t2["ﺩ"] = "د";
              t2["ﺪ"] = "د";
              t2["ﺫ"] = "ذ";
              t2["ﺬ"] = "ذ";
              t2["ﺭ"] = "ر";
              t2["ﺮ"] = "ر";
              t2["ﺯ"] = "ز";
              t2["ﺰ"] = "ز";
              t2["ﺱ"] = "س";
              t2["ﺲ"] = "س";
              t2["ﺳ"] = "س";
              t2["ﺴ"] = "س";
              t2["ﺵ"] = "ش";
              t2["ﺶ"] = "ش";
              t2["ﺷ"] = "ش";
              t2["ﺸ"] = "ش";
              t2["ﺹ"] = "ص";
              t2["ﺺ"] = "ص";
              t2["ﺻ"] = "ص";
              t2["ﺼ"] = "ص";
              t2["ﺽ"] = "ض";
              t2["ﺾ"] = "ض";
              t2["ﺿ"] = "ض";
              t2["ﻀ"] = "ض";
              t2["ﻁ"] = "ط";
              t2["ﻂ"] = "ط";
              t2["ﻃ"] = "ط";
              t2["ﻄ"] = "ط";
              t2["ﻅ"] = "ظ";
              t2["ﻆ"] = "ظ";
              t2["ﻇ"] = "ظ";
              t2["ﻈ"] = "ظ";
              t2["ﻉ"] = "ع";
              t2["ﻊ"] = "ع";
              t2["ﻋ"] = "ع";
              t2["ﻌ"] = "ع";
              t2["ﻍ"] = "غ";
              t2["ﻎ"] = "غ";
              t2["ﻏ"] = "غ";
              t2["ﻐ"] = "غ";
              t2["ﻑ"] = "ف";
              t2["ﻒ"] = "ف";
              t2["ﻓ"] = "ف";
              t2["ﻔ"] = "ف";
              t2["ﻕ"] = "ق";
              t2["ﻖ"] = "ق";
              t2["ﻗ"] = "ق";
              t2["ﻘ"] = "ق";
              t2["ﻙ"] = "ك";
              t2["ﻚ"] = "ك";
              t2["ﻛ"] = "ك";
              t2["ﻜ"] = "ك";
              t2["ﻝ"] = "ل";
              t2["ﻞ"] = "ل";
              t2["ﻟ"] = "ل";
              t2["ﻠ"] = "ل";
              t2["ﻡ"] = "م";
              t2["ﻢ"] = "م";
              t2["ﻣ"] = "م";
              t2["ﻤ"] = "م";
              t2["ﻥ"] = "ن";
              t2["ﻦ"] = "ن";
              t2["ﻧ"] = "ن";
              t2["ﻨ"] = "ن";
              t2["ﻩ"] = "ه";
              t2["ﻪ"] = "ه";
              t2["ﻫ"] = "ه";
              t2["ﻬ"] = "ه";
              t2["ﻭ"] = "و";
              t2["ﻮ"] = "و";
              t2["ﻯ"] = "ى";
              t2["ﻰ"] = "ى";
              t2["ﻱ"] = "ي";
              t2["ﻲ"] = "ي";
              t2["ﻳ"] = "ي";
              t2["ﻴ"] = "ي";
              t2["ﻵ"] = "لآ";
              t2["ﻶ"] = "لآ";
              t2["ﻷ"] = "لأ";
              t2["ﻸ"] = "لأ";
              t2["ﻹ"] = "لإ";
              t2["ﻺ"] = "لإ";
              t2["ﻻ"] = "لا";
              t2["ﻼ"] = "لا";
            });
            function reverseIfRtl(chars) {
              var charsLength = chars.length;
              if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
                return chars;
              }
              var s2 = "";
              for (var ii = charsLength - 1; ii >= 0; ii--) {
                s2 += chars[ii];
              }
              return s2;
            }
            exports3.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
            exports3.reverseIfRtl = reverseIfRtl;
            exports3.getUnicodeRangeFor = getUnicodeRangeFor;
            exports3.getNormalizedUnicodes = getNormalizedUnicodes;
            exports3.getUnicodeForGlyph = getUnicodeForGlyph;
          },
          /* 34 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.FontRendererFactory = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _cff_parser = __w_pdfjs_require__2(28);
            var _glyphlist = __w_pdfjs_require__2(31);
            var _encodings = __w_pdfjs_require__2(30);
            var _stream = __w_pdfjs_require__2(11);
            var FontRendererFactory = function FontRendererFactoryClosure() {
              function getLong(data, offset) {
                return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
              }
              function getUshort(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              function getSubroutineBias(subrs) {
                const numSubrs = subrs.length;
                let bias = 32768;
                if (numSubrs < 1240) {
                  bias = 107;
                } else if (numSubrs < 33900) {
                  bias = 1131;
                }
                return bias;
              }
              function parseCmap(data, start, end) {
                var offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
                var format = getUshort(data, start + offset);
                var ranges, p, i2;
                if (format === 4) {
                  getUshort(data, start + offset + 2);
                  var segCount = getUshort(data, start + offset + 6) >> 1;
                  p = start + offset + 14;
                  ranges = [];
                  for (i2 = 0; i2 < segCount; i2++, p += 2) {
                    ranges[i2] = {
                      end: getUshort(data, p)
                    };
                  }
                  p += 2;
                  for (i2 = 0; i2 < segCount; i2++, p += 2) {
                    ranges[i2].start = getUshort(data, p);
                  }
                  for (i2 = 0; i2 < segCount; i2++, p += 2) {
                    ranges[i2].idDelta = getUshort(data, p);
                  }
                  for (i2 = 0; i2 < segCount; i2++, p += 2) {
                    var idOffset = getUshort(data, p);
                    if (idOffset === 0) {
                      continue;
                    }
                    ranges[i2].ids = [];
                    for (var j2 = 0, jj = ranges[i2].end - ranges[i2].start + 1; j2 < jj; j2++) {
                      ranges[i2].ids[j2] = getUshort(data, p + idOffset);
                      idOffset += 2;
                    }
                  }
                  return ranges;
                } else if (format === 12) {
                  getLong(data, start + offset + 4);
                  var groups = getLong(data, start + offset + 12);
                  p = start + offset + 16;
                  ranges = [];
                  for (i2 = 0; i2 < groups; i2++) {
                    ranges.push({
                      start: getLong(data, p),
                      end: getLong(data, p + 4),
                      idDelta: getLong(data, p + 8) - getLong(data, p)
                    });
                    p += 12;
                  }
                  return ranges;
                }
                throw new _util2.FormatError(`unsupported cmap: ${format}`);
              }
              function parseCff(data, start, end, seacAnalysisEnabled) {
                var properties = {};
                var parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
                var cff = parser.parse();
                return {
                  glyphs: cff.charStrings.objects,
                  subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
                  gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
                  isCFFCIDFont: cff.isCIDFont,
                  fdSelect: cff.fdSelect,
                  fdArray: cff.fdArray
                };
              }
              function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                var itemSize, itemDecode;
                if (isGlyphLocationsLong) {
                  itemSize = 4;
                  itemDecode = function fontItemDecodeLong(data, offset) {
                    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                  };
                } else {
                  itemSize = 2;
                  itemDecode = function fontItemDecode(data, offset) {
                    return data[offset] << 9 | data[offset + 1] << 1;
                  };
                }
                var glyphs = [];
                var startOffset = itemDecode(loca, 0);
                for (var j2 = itemSize; j2 < loca.length; j2 += itemSize) {
                  var endOffset = itemDecode(loca, j2);
                  glyphs.push(glyf.subarray(startOffset, endOffset));
                  startOffset = endOffset;
                }
                return glyphs;
              }
              function lookupCmap(ranges, unicode) {
                var code = unicode.codePointAt(0), gid = 0;
                var l2 = 0, r2 = ranges.length - 1;
                while (l2 < r2) {
                  var c2 = l2 + r2 + 1 >> 1;
                  if (code < ranges[c2].start) {
                    r2 = c2 - 1;
                  } else {
                    l2 = c2;
                  }
                }
                if (ranges[l2].start <= code && code <= ranges[l2].end) {
                  gid = ranges[l2].idDelta + (ranges[l2].ids ? ranges[l2].ids[code - ranges[l2].start] : code) & 65535;
                }
                return {
                  charCode: code,
                  glyphId: gid
                };
              }
              function compileGlyf(code, cmds, font) {
                function moveTo(x3, y3) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x3, y3]
                  });
                }
                function lineTo(x3, y3) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x3, y3]
                  });
                }
                function quadraticCurveTo(xa, ya, x3, y3) {
                  cmds.push({
                    cmd: "quadraticCurveTo",
                    args: [xa, ya, x3, y3]
                  });
                }
                var i2 = 0;
                var numberOfContours = (code[i2] << 24 | code[i2 + 1] << 16) >> 16;
                var flags;
                var x2 = 0, y2 = 0;
                i2 += 10;
                if (numberOfContours < 0) {
                  do {
                    flags = code[i2] << 8 | code[i2 + 1];
                    var glyphIndex = code[i2 + 2] << 8 | code[i2 + 3];
                    i2 += 4;
                    var arg1, arg2;
                    if (flags & 1) {
                      arg1 = (code[i2] << 24 | code[i2 + 1] << 16) >> 16;
                      arg2 = (code[i2 + 2] << 24 | code[i2 + 3] << 16) >> 16;
                      i2 += 4;
                    } else {
                      arg1 = code[i2++];
                      arg2 = code[i2++];
                    }
                    if (flags & 2) {
                      x2 = arg1;
                      y2 = arg2;
                    } else {
                      x2 = 0;
                      y2 = 0;
                    }
                    var scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
                    if (flags & 8) {
                      scaleX = scaleY = (code[i2] << 24 | code[i2 + 1] << 16) / 1073741824;
                      i2 += 2;
                    } else if (flags & 64) {
                      scaleX = (code[i2] << 24 | code[i2 + 1] << 16) / 1073741824;
                      scaleY = (code[i2 + 2] << 24 | code[i2 + 3] << 16) / 1073741824;
                      i2 += 4;
                    } else if (flags & 128) {
                      scaleX = (code[i2] << 24 | code[i2 + 1] << 16) / 1073741824;
                      scale01 = (code[i2 + 2] << 24 | code[i2 + 3] << 16) / 1073741824;
                      scale10 = (code[i2 + 4] << 24 | code[i2 + 5] << 16) / 1073741824;
                      scaleY = (code[i2 + 6] << 24 | code[i2 + 7] << 16) / 1073741824;
                      i2 += 8;
                    }
                    var subglyph = font.glyphs[glyphIndex];
                    if (subglyph) {
                      cmds.push({
                        cmd: "save"
                      });
                      cmds.push({
                        cmd: "transform",
                        args: [scaleX, scale01, scale10, scaleY, x2, y2]
                      });
                      compileGlyf(subglyph, cmds, font);
                      cmds.push({
                        cmd: "restore"
                      });
                    }
                  } while (flags & 32);
                } else {
                  var endPtsOfContours = [];
                  var j2, jj;
                  for (j2 = 0; j2 < numberOfContours; j2++) {
                    endPtsOfContours.push(code[i2] << 8 | code[i2 + 1]);
                    i2 += 2;
                  }
                  var instructionLength = code[i2] << 8 | code[i2 + 1];
                  i2 += 2 + instructionLength;
                  var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                  var points = [];
                  while (points.length < numberOfPoints) {
                    flags = code[i2++];
                    var repeat = 1;
                    if (flags & 8) {
                      repeat += code[i2++];
                    }
                    while (repeat-- > 0) {
                      points.push({
                        flags
                      });
                    }
                  }
                  for (j2 = 0; j2 < numberOfPoints; j2++) {
                    switch (points[j2].flags & 18) {
                      case 0:
                        x2 += (code[i2] << 24 | code[i2 + 1] << 16) >> 16;
                        i2 += 2;
                        break;
                      case 2:
                        x2 -= code[i2++];
                        break;
                      case 18:
                        x2 += code[i2++];
                        break;
                    }
                    points[j2].x = x2;
                  }
                  for (j2 = 0; j2 < numberOfPoints; j2++) {
                    switch (points[j2].flags & 36) {
                      case 0:
                        y2 += (code[i2] << 24 | code[i2 + 1] << 16) >> 16;
                        i2 += 2;
                        break;
                      case 4:
                        y2 -= code[i2++];
                        break;
                      case 36:
                        y2 += code[i2++];
                        break;
                    }
                    points[j2].y = y2;
                  }
                  var startPoint = 0;
                  for (i2 = 0; i2 < numberOfContours; i2++) {
                    var endPoint = endPtsOfContours[i2];
                    var contour = points.slice(startPoint, endPoint + 1);
                    if (contour[0].flags & 1) {
                      contour.push(contour[0]);
                    } else if (contour[contour.length - 1].flags & 1) {
                      contour.unshift(contour[contour.length - 1]);
                    } else {
                      var p = {
                        flags: 1,
                        x: (contour[0].x + contour[contour.length - 1].x) / 2,
                        y: (contour[0].y + contour[contour.length - 1].y) / 2
                      };
                      contour.unshift(p);
                      contour.push(p);
                    }
                    moveTo(contour[0].x, contour[0].y);
                    for (j2 = 1, jj = contour.length; j2 < jj; j2++) {
                      if (contour[j2].flags & 1) {
                        lineTo(contour[j2].x, contour[j2].y);
                      } else if (contour[j2 + 1].flags & 1) {
                        quadraticCurveTo(contour[j2].x, contour[j2].y, contour[j2 + 1].x, contour[j2 + 1].y);
                        j2++;
                      } else {
                        quadraticCurveTo(contour[j2].x, contour[j2].y, (contour[j2].x + contour[j2 + 1].x) / 2, (contour[j2].y + contour[j2 + 1].y) / 2);
                      }
                    }
                    startPoint = endPoint + 1;
                  }
                }
              }
              function compileCharString(code, cmds, font, glyphId) {
                var stack = [];
                var x2 = 0, y2 = 0;
                var stems = 0;
                function moveTo(x3, y3) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x3, y3]
                  });
                }
                function lineTo(x3, y3) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x3, y3]
                  });
                }
                function bezierCurveTo(x1, y1, x22, y22, x3, y3) {
                  cmds.push({
                    cmd: "bezierCurveTo",
                    args: [x1, y1, x22, y22, x3, y3]
                  });
                }
                function parse(code2) {
                  var i2 = 0;
                  while (i2 < code2.length) {
                    var stackClean = false;
                    var v2 = code2[i2++];
                    var xa, xb, ya, yb, y1, y22, y3, n2, subrCode;
                    switch (v2) {
                      case 1:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 3:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 4:
                        y2 += stack.pop();
                        moveTo(x2, y2);
                        stackClean = true;
                        break;
                      case 5:
                        while (stack.length > 0) {
                          x2 += stack.shift();
                          y2 += stack.shift();
                          lineTo(x2, y2);
                        }
                        break;
                      case 6:
                        while (stack.length > 0) {
                          x2 += stack.shift();
                          lineTo(x2, y2);
                          if (stack.length === 0) {
                            break;
                          }
                          y2 += stack.shift();
                          lineTo(x2, y2);
                        }
                        break;
                      case 7:
                        while (stack.length > 0) {
                          y2 += stack.shift();
                          lineTo(x2, y2);
                          if (stack.length === 0) {
                            break;
                          }
                          x2 += stack.shift();
                          lineTo(x2, y2);
                        }
                        break;
                      case 8:
                        while (stack.length > 0) {
                          xa = x2 + stack.shift();
                          ya = y2 + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb + stack.shift();
                          y2 = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        break;
                      case 10:
                        n2 = stack.pop();
                        subrCode = null;
                        if (font.isCFFCIDFont) {
                          const fdIndex = font.fdSelect.getFDIndex(glyphId);
                          if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                            const fontDict = font.fdArray[fdIndex];
                            let subrs;
                            if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                              subrs = fontDict.privateDict.subrsIndex.objects;
                            }
                            if (subrs) {
                              n2 += getSubroutineBias(subrs);
                              subrCode = subrs[n2];
                            }
                          } else {
                            (0, _util2.warn)("Invalid fd index for glyph index.");
                          }
                        } else {
                          subrCode = font.subrs[n2 + font.subrsBias];
                        }
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 11:
                        return;
                      case 12:
                        v2 = code2[i2++];
                        switch (v2) {
                          case 34:
                            xa = x2 + stack.shift();
                            xb = xa + stack.shift();
                            y1 = y2 + stack.shift();
                            x2 = xb + stack.shift();
                            bezierCurveTo(xa, y2, xb, y1, x2, y1);
                            xa = x2 + stack.shift();
                            xb = xa + stack.shift();
                            x2 = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y2, x2, y2);
                            break;
                          case 35:
                            xa = x2 + stack.shift();
                            ya = y2 + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x2 = xb + stack.shift();
                            y2 = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x2, y2);
                            xa = x2 + stack.shift();
                            ya = y2 + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x2 = xb + stack.shift();
                            y2 = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x2, y2);
                            stack.pop();
                            break;
                          case 36:
                            xa = x2 + stack.shift();
                            y1 = y2 + stack.shift();
                            xb = xa + stack.shift();
                            y22 = y1 + stack.shift();
                            x2 = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y22, x2, y22);
                            xa = x2 + stack.shift();
                            xb = xa + stack.shift();
                            y3 = y22 + stack.shift();
                            x2 = xb + stack.shift();
                            bezierCurveTo(xa, y22, xb, y3, x2, y2);
                            break;
                          case 37:
                            var x0 = x2, y0 = y2;
                            xa = x2 + stack.shift();
                            ya = y2 + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x2 = xb + stack.shift();
                            y2 = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x2, y2);
                            xa = x2 + stack.shift();
                            ya = y2 + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x2 = xb;
                            y2 = yb;
                            if (Math.abs(x2 - x0) > Math.abs(y2 - y0)) {
                              x2 += stack.shift();
                            } else {
                              y2 += stack.shift();
                            }
                            bezierCurveTo(xa, ya, xb, yb, x2, y2);
                            break;
                          default:
                            throw new _util2.FormatError(`unknown operator: 12 ${v2}`);
                        }
                        break;
                      case 14:
                        if (stack.length >= 4) {
                          var achar = stack.pop();
                          var bchar = stack.pop();
                          y2 = stack.pop();
                          x2 = stack.pop();
                          cmds.push({
                            cmd: "save"
                          });
                          cmds.push({
                            cmd: "translate",
                            args: [x2, y2]
                          });
                          var cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                          cmds.push({
                            cmd: "restore"
                          });
                          cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                        }
                        return;
                      case 18:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 19:
                        stems += stack.length >> 1;
                        i2 += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 20:
                        stems += stack.length >> 1;
                        i2 += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 21:
                        y2 += stack.pop();
                        x2 += stack.pop();
                        moveTo(x2, y2);
                        stackClean = true;
                        break;
                      case 22:
                        x2 += stack.pop();
                        moveTo(x2, y2);
                        stackClean = true;
                        break;
                      case 23:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 24:
                        while (stack.length > 2) {
                          xa = x2 + stack.shift();
                          ya = y2 + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb + stack.shift();
                          y2 = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        x2 += stack.shift();
                        y2 += stack.shift();
                        lineTo(x2, y2);
                        break;
                      case 25:
                        while (stack.length > 6) {
                          x2 += stack.shift();
                          y2 += stack.shift();
                          lineTo(x2, y2);
                        }
                        xa = x2 + stack.shift();
                        ya = y2 + stack.shift();
                        xb = xa + stack.shift();
                        yb = ya + stack.shift();
                        x2 = xb + stack.shift();
                        y2 = yb + stack.shift();
                        bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        break;
                      case 26:
                        if (stack.length % 2) {
                          x2 += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x2;
                          ya = y2 + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb;
                          y2 = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        break;
                      case 27:
                        if (stack.length % 2) {
                          y2 += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x2 + stack.shift();
                          ya = y2;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb + stack.shift();
                          y2 = yb;
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        break;
                      case 28:
                        stack.push((code2[i2] << 24 | code2[i2 + 1] << 16) >> 16);
                        i2 += 2;
                        break;
                      case 29:
                        n2 = stack.pop() + font.gsubrsBias;
                        subrCode = font.gsubrs[n2];
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 30:
                        while (stack.length > 0) {
                          xa = x2;
                          ya = y2 + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb + stack.shift();
                          y2 = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x2 + stack.shift();
                          ya = y2;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y2 = yb + stack.shift();
                          x2 = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        break;
                      case 31:
                        while (stack.length > 0) {
                          xa = x2 + stack.shift();
                          ya = y2;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y2 = yb + stack.shift();
                          x2 = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x2;
                          ya = y2 + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x2 = xb + stack.shift();
                          y2 = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x2, y2);
                        }
                        break;
                      default:
                        if (v2 < 32) {
                          throw new _util2.FormatError(`unknown operator: ${v2}`);
                        }
                        if (v2 < 247) {
                          stack.push(v2 - 139);
                        } else if (v2 < 251) {
                          stack.push((v2 - 247) * 256 + code2[i2++] + 108);
                        } else if (v2 < 255) {
                          stack.push(-(v2 - 251) * 256 - code2[i2++] - 108);
                        } else {
                          stack.push((code2[i2] << 24 | code2[i2 + 1] << 16 | code2[i2 + 2] << 8 | code2[i2 + 3]) / 65536);
                          i2 += 4;
                        }
                        break;
                    }
                    if (stackClean) {
                      stack.length = 0;
                    }
                  }
                }
                parse(code);
              }
              const NOOP = [];
              class CompiledFont {
                constructor(fontMatrix) {
                  if (this.constructor === CompiledFont) {
                    (0, _util2.unreachable)("Cannot initialize CompiledFont.");
                  }
                  this.fontMatrix = fontMatrix;
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                }
                getPathJs(unicode) {
                  const cmap = lookupCmap(this.cmap, unicode);
                  let fn = this.compiledGlyphs[cmap.glyphId];
                  if (!fn) {
                    fn = this.compileGlyph(this.glyphs[cmap.glyphId], cmap.glyphId);
                    this.compiledGlyphs[cmap.glyphId] = fn;
                  }
                  if (this.compiledCharCodeToGlyphId[cmap.charCode] === void 0) {
                    this.compiledCharCodeToGlyphId[cmap.charCode] = cmap.glyphId;
                  }
                  return fn;
                }
                compileGlyph(code, glyphId) {
                  if (!code || code.length === 0 || code[0] === 14) {
                    return NOOP;
                  }
                  let fontMatrix = this.fontMatrix;
                  if (this.isCFFCIDFont) {
                    const fdIndex = this.fdSelect.getFDIndex(glyphId);
                    if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
                      const fontDict = this.fdArray[fdIndex];
                      fontMatrix = fontDict.getByName("FontMatrix") || _util2.FONT_IDENTITY_MATRIX;
                    } else {
                      (0, _util2.warn)("Invalid fd index for glyph index.");
                    }
                  }
                  const cmds = [];
                  cmds.push({
                    cmd: "save"
                  });
                  cmds.push({
                    cmd: "transform",
                    args: fontMatrix.slice()
                  });
                  cmds.push({
                    cmd: "scale",
                    args: ["size", "-size"]
                  });
                  this.compileGlyphImpl(code, cmds, glyphId);
                  cmds.push({
                    cmd: "restore"
                  });
                  return cmds;
                }
                compileGlyphImpl() {
                  (0, _util2.unreachable)("Children classes should implement this.");
                }
                hasBuiltPath(unicode) {
                  const cmap = lookupCmap(this.cmap, unicode);
                  return this.compiledGlyphs[cmap.glyphId] !== void 0 && this.compiledCharCodeToGlyphId[cmap.charCode] !== void 0;
                }
              }
              class TrueTypeCompiled extends CompiledFont {
                constructor(glyphs, cmap, fontMatrix) {
                  super(fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0]);
                  this.glyphs = glyphs;
                  this.cmap = cmap;
                }
                compileGlyphImpl(code, cmds) {
                  compileGlyf(code, cmds, this);
                }
              }
              class Type2Compiled extends CompiledFont {
                constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
                  super(fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0]);
                  this.glyphs = cffInfo.glyphs;
                  this.gsubrs = cffInfo.gsubrs || [];
                  this.subrs = cffInfo.subrs || [];
                  this.cmap = cmap;
                  this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
                  this.gsubrsBias = getSubroutineBias(this.gsubrs);
                  this.subrsBias = getSubroutineBias(this.subrs);
                  this.isCFFCIDFont = cffInfo.isCFFCIDFont;
                  this.fdSelect = cffInfo.fdSelect;
                  this.fdArray = cffInfo.fdArray;
                }
                compileGlyphImpl(code, cmds, glyphId) {
                  compileCharString(code, cmds, this, glyphId);
                }
              }
              return {
                create: function FontRendererFactory_create(font, seacAnalysisEnabled) {
                  var data = new Uint8Array(font.data);
                  var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                  var numTables = getUshort(data, 4);
                  for (var i2 = 0, p = 12; i2 < numTables; i2++, p += 16) {
                    var tag = (0, _util2.bytesToString)(data.subarray(p, p + 4));
                    var offset = getLong(data, p + 8);
                    var length = getLong(data, p + 12);
                    switch (tag) {
                      case "cmap":
                        cmap = parseCmap(data, offset, offset + length);
                        break;
                      case "glyf":
                        glyf = data.subarray(offset, offset + length);
                        break;
                      case "loca":
                        loca = data.subarray(offset, offset + length);
                        break;
                      case "head":
                        unitsPerEm = getUshort(data, offset + 18);
                        indexToLocFormat = getUshort(data, offset + 50);
                        break;
                      case "CFF ":
                        cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
                        break;
                    }
                  }
                  if (glyf) {
                    var fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
                    return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                  }
                  return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                }
              };
            }();
            exports3.FontRendererFactory = FontRendererFactory;
          },
          /* 35 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Type1Parser = void 0;
            var _encodings = __w_pdfjs_require__2(30);
            var _core_utils = __w_pdfjs_require__2(7);
            var _stream = __w_pdfjs_require__2(11);
            var _util2 = __w_pdfjs_require__2(2);
            var HINTING_ENABLED = false;
            var Type1CharString = function Type1CharStringClosure() {
              var COMMAND_MAP = {
                hstem: [1],
                vstem: [3],
                vmoveto: [4],
                rlineto: [5],
                hlineto: [6],
                vlineto: [7],
                rrcurveto: [8],
                callsubr: [10],
                flex: [12, 35],
                drop: [12, 18],
                endchar: [14],
                rmoveto: [21],
                hmoveto: [22],
                vhcurveto: [30],
                hvcurveto: [31]
              };
              function Type1CharString2() {
                this.width = 0;
                this.lsb = 0;
                this.flexing = false;
                this.output = [];
                this.stack = [];
              }
              Type1CharString2.prototype = {
                convert: function Type1CharString_convert(encoded, subrs, seacAnalysisEnabled) {
                  var count = encoded.length;
                  var error = false;
                  var wx, sbx, subrNumber;
                  for (var i2 = 0; i2 < count; i2++) {
                    var value = encoded[i2];
                    if (value < 32) {
                      if (value === 12) {
                        value = (value << 8) + encoded[++i2];
                      }
                      switch (value) {
                        case 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case 3:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case 4:
                          if (this.flexing) {
                            if (this.stack.length < 1) {
                              error = true;
                              break;
                            }
                            var dy = this.stack.pop();
                            this.stack.push(0, dy);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                          break;
                        case 5:
                          error = this.executeCommand(2, COMMAND_MAP.rlineto);
                          break;
                        case 6:
                          error = this.executeCommand(1, COMMAND_MAP.hlineto);
                          break;
                        case 7:
                          error = this.executeCommand(1, COMMAND_MAP.vlineto);
                          break;
                        case 8:
                          error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                          break;
                        case 9:
                          this.stack = [];
                          break;
                        case 10:
                          if (this.stack.length < 1) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          if (!subrs[subrNumber]) {
                            error = true;
                            break;
                          }
                          error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
                          break;
                        case 11:
                          return error;
                        case 13:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          wx = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx);
                          error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                          break;
                        case 14:
                          this.output.push(COMMAND_MAP.endchar[0]);
                          break;
                        case 21:
                          if (this.flexing) {
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                          break;
                        case 22:
                          if (this.flexing) {
                            this.stack.push(0);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                          break;
                        case 30:
                          error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                          break;
                        case 31:
                          error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                          break;
                        case (12 << 8) + 0:
                          this.stack = [];
                          break;
                        case (12 << 8) + 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case (12 << 8) + 2:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case (12 << 8) + 6:
                          if (seacAnalysisEnabled) {
                            this.seac = this.stack.splice(-4, 4);
                            error = this.executeCommand(0, COMMAND_MAP.endchar);
                          } else {
                            error = this.executeCommand(4, COMMAND_MAP.endchar);
                          }
                          break;
                        case (12 << 8) + 7:
                          if (this.stack.length < 4) {
                            error = true;
                            break;
                          }
                          this.stack.pop();
                          wx = this.stack.pop();
                          var sby = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx, sby);
                          error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                          break;
                        case (12 << 8) + 12:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          var num2 = this.stack.pop();
                          var num1 = this.stack.pop();
                          this.stack.push(num1 / num2);
                          break;
                        case (12 << 8) + 16:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          var numArgs = this.stack.pop();
                          if (subrNumber === 0 && numArgs === 3) {
                            var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                            this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                            error = this.executeCommand(13, COMMAND_MAP.flex, true);
                            this.flexing = false;
                            this.stack.push(flexArgs[15], flexArgs[16]);
                          } else if (subrNumber === 1 && numArgs === 0) {
                            this.flexing = true;
                          }
                          break;
                        case (12 << 8) + 17:
                          break;
                        case (12 << 8) + 33:
                          this.stack = [];
                          break;
                        default:
                          (0, _util2.warn)('Unknown type 1 charstring command of "' + value + '"');
                          break;
                      }
                      if (error) {
                        break;
                      }
                      continue;
                    } else if (value <= 246) {
                      value = value - 139;
                    } else if (value <= 250) {
                      value = (value - 247) * 256 + encoded[++i2] + 108;
                    } else if (value <= 254) {
                      value = -((value - 251) * 256) - encoded[++i2] - 108;
                    } else {
                      value = (encoded[++i2] & 255) << 24 | (encoded[++i2] & 255) << 16 | (encoded[++i2] & 255) << 8 | (encoded[++i2] & 255) << 0;
                    }
                    this.stack.push(value);
                  }
                  return error;
                },
                executeCommand(howManyArgs, command, keepStack) {
                  var stackLength = this.stack.length;
                  if (howManyArgs > stackLength) {
                    return true;
                  }
                  var start = stackLength - howManyArgs;
                  for (var i2 = start; i2 < stackLength; i2++) {
                    var value = this.stack[i2];
                    if (Number.isInteger(value)) {
                      this.output.push(28, value >> 8 & 255, value & 255);
                    } else {
                      value = 65536 * value | 0;
                      this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                    }
                  }
                  this.output.push.apply(this.output, command);
                  if (keepStack) {
                    this.stack.splice(start, howManyArgs);
                  } else {
                    this.stack.length = 0;
                  }
                  return false;
                }
              };
              return Type1CharString2;
            }();
            var Type1Parser = function Type1ParserClosure() {
              var EEXEC_ENCRYPT_KEY = 55665;
              var CHAR_STRS_ENCRYPT_KEY = 4330;
              function isHexDigit(code) {
                return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
              }
              function decrypt(data, key, discardNumber) {
                if (discardNumber >= data.length) {
                  return new Uint8Array(0);
                }
                var r2 = key | 0, c1 = 52845, c2 = 22719, i2, j2;
                for (i2 = 0; i2 < discardNumber; i2++) {
                  r2 = (data[i2] + r2) * c1 + c2 & (1 << 16) - 1;
                }
                var count = data.length - discardNumber;
                var decrypted = new Uint8Array(count);
                for (i2 = discardNumber, j2 = 0; j2 < count; i2++, j2++) {
                  var value = data[i2];
                  decrypted[j2] = value ^ r2 >> 8;
                  r2 = (value + r2) * c1 + c2 & (1 << 16) - 1;
                }
                return decrypted;
              }
              function decryptAscii(data, key, discardNumber) {
                var r2 = key | 0, c1 = 52845, c2 = 22719;
                var count = data.length, maybeLength = count >>> 1;
                var decrypted = new Uint8Array(maybeLength);
                var i2, j2;
                for (i2 = 0, j2 = 0; i2 < count; i2++) {
                  var digit1 = data[i2];
                  if (!isHexDigit(digit1)) {
                    continue;
                  }
                  i2++;
                  var digit2;
                  while (i2 < count && !isHexDigit(digit2 = data[i2])) {
                    i2++;
                  }
                  if (i2 < count) {
                    var value = parseInt(String.fromCharCode(digit1, digit2), 16);
                    decrypted[j2++] = value ^ r2 >> 8;
                    r2 = (value + r2) * c1 + c2 & (1 << 16) - 1;
                  }
                }
                return Array.prototype.slice.call(decrypted, discardNumber, j2);
              }
              function isSpecial(c2) {
                return c2 === 47 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125 || c2 === 40 || c2 === 41;
              }
              function Type1Parser2(stream, encrypted, seacAnalysisEnabled) {
                if (encrypted) {
                  var data = stream.getBytes();
                  var isBinary = !(isHexDigit(data[0]) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]));
                  stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                }
                this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                this.stream = stream;
                this.nextChar();
              }
              Type1Parser2.prototype = {
                readNumberArray: function Type1Parser_readNumberArray() {
                  this.getToken();
                  var array = [];
                  while (true) {
                    var token = this.getToken();
                    if (token === null || token === "]" || token === "}") {
                      break;
                    }
                    array.push(parseFloat(token || 0));
                  }
                  return array;
                },
                readNumber: function Type1Parser_readNumber() {
                  var token = this.getToken();
                  return parseFloat(token || 0);
                },
                readInt: function Type1Parser_readInt() {
                  var token = this.getToken();
                  return parseInt(token || 0, 10) | 0;
                },
                readBoolean: function Type1Parser_readBoolean() {
                  var token = this.getToken();
                  return token === "true" ? 1 : 0;
                },
                nextChar: function Type1_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                getToken: function Type1Parser_getToken() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch === -1) {
                      return null;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  if (isSpecial(ch)) {
                    this.nextChar();
                    return String.fromCharCode(ch);
                  }
                  var token = "";
                  do {
                    token += String.fromCharCode(ch);
                    ch = this.nextChar();
                  } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
                  return token;
                },
                readCharStrings: function Type1Parser_readCharStrings(bytes, lenIV) {
                  if (lenIV === -1) {
                    return bytes;
                  }
                  return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
                },
                extractFontProgram: function Type1Parser_extractFontProgram(properties) {
                  var stream = this.stream;
                  var subrs = [], charstrings = [];
                  var privateData = /* @__PURE__ */ Object.create(null);
                  privateData["lenIV"] = 4;
                  var program = {
                    subrs: [],
                    charstrings: [],
                    properties: {
                      privateData
                    }
                  };
                  var token, length, data, lenIV, encoded;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "CharStrings":
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        while (true) {
                          token = this.getToken();
                          if (token === null || token === "end") {
                            break;
                          }
                          if (token !== "/") {
                            continue;
                          }
                          var glyph = this.getToken();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData["lenIV"];
                          encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          charstrings.push({
                            glyph,
                            encoded
                          });
                        }
                        break;
                      case "Subrs":
                        this.readInt();
                        this.getToken();
                        while (this.getToken() === "dup") {
                          var index = this.readInt();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData["lenIV"];
                          encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          subrs[index] = encoded;
                        }
                        break;
                      case "BlueValues":
                      case "OtherBlues":
                      case "FamilyBlues":
                      case "FamilyOtherBlues":
                        var blueArray = this.readNumberArray();
                        if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
                          program.properties.privateData[token] = blueArray;
                        }
                        break;
                      case "StemSnapH":
                      case "StemSnapV":
                        program.properties.privateData[token] = this.readNumberArray();
                        break;
                      case "StdHW":
                      case "StdVW":
                        program.properties.privateData[token] = this.readNumberArray()[0];
                        break;
                      case "BlueShift":
                      case "lenIV":
                      case "BlueFuzz":
                      case "BlueScale":
                      case "LanguageGroup":
                      case "ExpansionFactor":
                        program.properties.privateData[token] = this.readNumber();
                        break;
                      case "ForceBold":
                        program.properties.privateData[token] = this.readBoolean();
                        break;
                    }
                  }
                  for (var i2 = 0; i2 < charstrings.length; i2++) {
                    glyph = charstrings[i2].glyph;
                    encoded = charstrings[i2].encoded;
                    var charString = new Type1CharString();
                    var error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
                    var output = charString.output;
                    if (error) {
                      output = [14];
                    }
                    const charStringObject = {
                      glyphName: glyph,
                      charstring: output,
                      width: charString.width,
                      lsb: charString.lsb,
                      seac: charString.seac
                    };
                    if (glyph === ".notdef") {
                      program.charstrings.unshift(charStringObject);
                    } else {
                      program.charstrings.push(charStringObject);
                    }
                    if (properties.builtInEncoding) {
                      const index2 = properties.builtInEncoding.indexOf(glyph);
                      if (index2 > -1 && properties.widths[index2] === void 0 && index2 >= properties.firstChar && index2 <= properties.lastChar) {
                        properties.widths[index2] = charString.width;
                      }
                    }
                  }
                  return program;
                },
                extractFontHeader: function Type1Parser_extractFontHeader(properties) {
                  var token;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "FontMatrix":
                        var matrix = this.readNumberArray();
                        properties.fontMatrix = matrix;
                        break;
                      case "Encoding":
                        var encodingArg = this.getToken();
                        var encoding;
                        if (!/^\d+$/.test(encodingArg)) {
                          encoding = (0, _encodings.getEncoding)(encodingArg);
                        } else {
                          encoding = [];
                          var size = parseInt(encodingArg, 10) | 0;
                          this.getToken();
                          for (var j2 = 0; j2 < size; j2++) {
                            token = this.getToken();
                            while (token !== "dup" && token !== "def") {
                              token = this.getToken();
                              if (token === null) {
                                return;
                              }
                            }
                            if (token === "def") {
                              break;
                            }
                            var index = this.readInt();
                            this.getToken();
                            var glyph = this.getToken();
                            encoding[index] = glyph;
                            this.getToken();
                          }
                        }
                        properties.builtInEncoding = encoding;
                        break;
                      case "FontBBox":
                        var fontBBox = this.readNumberArray();
                        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                        properties.ascentScaled = true;
                        break;
                    }
                  }
                }
              };
              return Type1Parser2;
            }();
            exports3.Type1Parser = Type1Parser;
          },
          /* 36 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getTilingPatternIR = getTilingPatternIR;
            exports3.Pattern = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _colorspace = __w_pdfjs_require__2(22);
            var _primitives = __w_pdfjs_require__2(4);
            var _core_utils = __w_pdfjs_require__2(7);
            var ShadingType = {
              FUNCTION_BASED: 1,
              AXIAL: 2,
              RADIAL: 3,
              FREE_FORM_MESH: 4,
              LATTICE_FORM_MESH: 5,
              COONS_PATCH_MESH: 6,
              TENSOR_PATCH_MESH: 7
            };
            var Pattern = function PatternClosure() {
              function Pattern2() {
                (0, _util2.unreachable)("should not call Pattern constructor");
              }
              Pattern2.prototype = {
                getPattern: function Pattern_getPattern(ctx) {
                  (0, _util2.unreachable)(`Should not call Pattern.getStyle: ${ctx}`);
                }
              };
              Pattern2.parseShading = function(shading, matrix, xref, res, handler, pdfFunctionFactory) {
                var dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
                var type = dict.get("ShadingType");
                try {
                  switch (type) {
                    case ShadingType.AXIAL:
                    case ShadingType.RADIAL:
                      return new Shadings.RadialAxial(dict, matrix, xref, res, pdfFunctionFactory);
                    case ShadingType.FREE_FORM_MESH:
                    case ShadingType.LATTICE_FORM_MESH:
                    case ShadingType.COONS_PATCH_MESH:
                    case ShadingType.TENSOR_PATCH_MESH:
                      return new Shadings.Mesh(shading, matrix, xref, res, pdfFunctionFactory);
                    default:
                      throw new _util2.FormatError("Unsupported ShadingType: " + type);
                  }
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }
                  handler.send("UnsupportedFeature", {
                    featureId: _util2.UNSUPPORTED_FEATURES.shadingPattern
                  });
                  (0, _util2.warn)(ex);
                  return new Shadings.Dummy();
                }
              };
              return Pattern2;
            }();
            exports3.Pattern = Pattern;
            var Shadings = {};
            Shadings.SMALL_NUMBER = 1e-6;
            Shadings.RadialAxial = function RadialAxialClosure() {
              function RadialAxial(dict, matrix, xref, res, pdfFunctionFactory) {
                this.matrix = matrix;
                this.coordsArr = dict.getArray("Coords");
                this.shadingType = dict.get("ShadingType");
                this.type = "Pattern";
                var cs = dict.get("ColorSpace", "CS");
                cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                this.cs = cs;
                const bbox = dict.getArray("BBox");
                if (Array.isArray(bbox) && bbox.length === 4) {
                  this.bbox = _util2.Util.normalizeRect(bbox);
                } else {
                  this.bbox = null;
                }
                var t0 = 0, t1 = 1;
                if (dict.has("Domain")) {
                  var domainArr = dict.getArray("Domain");
                  t0 = domainArr[0];
                  t1 = domainArr[1];
                }
                var extendStart = false, extendEnd = false;
                if (dict.has("Extend")) {
                  var extendArr = dict.getArray("Extend");
                  extendStart = extendArr[0];
                  extendEnd = extendArr[1];
                }
                if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                  var x1 = this.coordsArr[0];
                  var y1 = this.coordsArr[1];
                  var r1 = this.coordsArr[2];
                  var x2 = this.coordsArr[3];
                  var y2 = this.coordsArr[4];
                  var r2 = this.coordsArr[5];
                  var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                  if (r1 <= r2 + distance && r2 <= r1 + distance) {
                    (0, _util2.warn)("Unsupported radial gradient.");
                  }
                }
                this.extendStart = extendStart;
                this.extendEnd = extendEnd;
                var fnObj = dict.get("Function");
                var fn = pdfFunctionFactory.createFromArray(fnObj);
                const NUMBER_OF_SAMPLES = 10;
                const step = (t1 - t0) / NUMBER_OF_SAMPLES;
                var colorStops = this.colorStops = [];
                if (t0 >= t1 || step <= 0) {
                  (0, _util2.info)("Bad shading domain.");
                  return;
                }
                var color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
                var rgbColor;
                for (let i2 = 0; i2 <= NUMBER_OF_SAMPLES; i2++) {
                  ratio[0] = t0 + i2 * step;
                  fn(ratio, 0, color, 0);
                  rgbColor = cs.getRgb(color, 0);
                  var cssColor = _util2.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                  colorStops.push([i2 / NUMBER_OF_SAMPLES, cssColor]);
                }
                var background = "transparent";
                if (dict.has("Background")) {
                  rgbColor = cs.getRgb(dict.get("Background"), 0);
                  background = _util2.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                }
                if (!extendStart) {
                  colorStops.unshift([0, background]);
                  colorStops[1][0] += Shadings.SMALL_NUMBER;
                }
                if (!extendEnd) {
                  colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
                  colorStops.push([1, background]);
                }
                this.colorStops = colorStops;
              }
              RadialAxial.prototype = {
                getIR: function RadialAxial_getIR() {
                  var coordsArr = this.coordsArr;
                  var shadingType = this.shadingType;
                  var type, p0, p1, r0, r1;
                  if (shadingType === ShadingType.AXIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[2], coordsArr[3]];
                    r0 = null;
                    r1 = null;
                    type = "axial";
                  } else if (shadingType === ShadingType.RADIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[3], coordsArr[4]];
                    r0 = coordsArr[2];
                    r1 = coordsArr[5];
                    type = "radial";
                  } else {
                    (0, _util2.unreachable)(`getPattern type unknown: ${shadingType}`);
                  }
                  var matrix = this.matrix;
                  if (matrix) {
                    p0 = _util2.Util.applyTransform(p0, matrix);
                    p1 = _util2.Util.applyTransform(p1, matrix);
                    if (shadingType === ShadingType.RADIAL) {
                      var scale = _util2.Util.singularValueDecompose2dScale(matrix);
                      r0 *= scale[0];
                      r1 *= scale[1];
                    }
                  }
                  return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
                }
              };
              return RadialAxial;
            }();
            Shadings.Mesh = function MeshClosure() {
              function MeshStreamReader(stream, context) {
                this.stream = stream;
                this.context = context;
                this.buffer = 0;
                this.bufferLength = 0;
                var numComps = context.numComps;
                this.tmpCompsBuf = new Float32Array(numComps);
                var csNumComps = context.colorSpace.numComps;
                this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
              }
              MeshStreamReader.prototype = {
                get hasData() {
                  if (this.stream.end) {
                    return this.stream.pos < this.stream.end;
                  }
                  if (this.bufferLength > 0) {
                    return true;
                  }
                  var nextByte = this.stream.getByte();
                  if (nextByte < 0) {
                    return false;
                  }
                  this.buffer = nextByte;
                  this.bufferLength = 8;
                  return true;
                },
                readBits: function MeshStreamReader_readBits(n2) {
                  var buffer = this.buffer;
                  var bufferLength = this.bufferLength;
                  if (n2 === 32) {
                    if (bufferLength === 0) {
                      return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                    }
                    buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                    var nextByte = this.stream.getByte();
                    this.buffer = nextByte & (1 << bufferLength) - 1;
                    return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
                  }
                  if (n2 === 8 && bufferLength === 0) {
                    return this.stream.getByte();
                  }
                  while (bufferLength < n2) {
                    buffer = buffer << 8 | this.stream.getByte();
                    bufferLength += 8;
                  }
                  bufferLength -= n2;
                  this.bufferLength = bufferLength;
                  this.buffer = buffer & (1 << bufferLength) - 1;
                  return buffer >> bufferLength;
                },
                align: function MeshStreamReader_align() {
                  this.buffer = 0;
                  this.bufferLength = 0;
                },
                readFlag: function MeshStreamReader_readFlag() {
                  return this.readBits(this.context.bitsPerFlag);
                },
                readCoordinate: function MeshStreamReader_readCoordinate() {
                  var bitsPerCoordinate = this.context.bitsPerCoordinate;
                  var xi = this.readBits(bitsPerCoordinate);
                  var yi = this.readBits(bitsPerCoordinate);
                  var decode = this.context.decode;
                  var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
                  return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                },
                readComponents: function MeshStreamReader_readComponents() {
                  var numComps = this.context.numComps;
                  var bitsPerComponent = this.context.bitsPerComponent;
                  var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
                  var decode = this.context.decode;
                  var components = this.tmpCompsBuf;
                  for (var i2 = 0, j2 = 4; i2 < numComps; i2++, j2 += 2) {
                    var ci = this.readBits(bitsPerComponent);
                    components[i2] = ci * scale * (decode[j2 + 1] - decode[j2]) + decode[j2];
                  }
                  var color = this.tmpCsCompsBuf;
                  if (this.context.colorFn) {
                    this.context.colorFn(components, 0, color, 0);
                  }
                  return this.context.colorSpace.getRgb(color, 0);
                }
              };
              function decodeType4Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var operators = [];
                var ps = [];
                var verticesLeft = 0;
                while (reader.hasData) {
                  var f = reader.readFlag();
                  var coord = reader.readCoordinate();
                  var color = reader.readComponents();
                  if (verticesLeft === 0) {
                    if (!(0 <= f && f <= 2)) {
                      throw new _util2.FormatError("Unknown type4 flag");
                    }
                    switch (f) {
                      case 0:
                        verticesLeft = 3;
                        break;
                      case 1:
                        ps.push(ps[ps.length - 2], ps[ps.length - 1]);
                        verticesLeft = 1;
                        break;
                      case 2:
                        ps.push(ps[ps.length - 3], ps[ps.length - 1]);
                        verticesLeft = 1;
                        break;
                    }
                    operators.push(f);
                  }
                  ps.push(coords.length);
                  coords.push(coord);
                  colors.push(color);
                  verticesLeft--;
                  reader.align();
                }
                mesh.figures.push({
                  type: "triangles",
                  coords: new Int32Array(ps),
                  colors: new Int32Array(ps)
                });
              }
              function decodeType5Shading(mesh, reader, verticesPerRow) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = [];
                while (reader.hasData) {
                  var coord = reader.readCoordinate();
                  var color = reader.readComponents();
                  ps.push(coords.length);
                  coords.push(coord);
                  colors.push(color);
                }
                mesh.figures.push({
                  type: "lattice",
                  coords: new Int32Array(ps),
                  colors: new Int32Array(ps),
                  verticesPerRow
                });
              }
              var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
              var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
              var TRIANGLE_DENSITY = 20;
              var getB = function getBClosure() {
                function buildB(count) {
                  var lut = [];
                  for (var i2 = 0; i2 <= count; i2++) {
                    var t2 = i2 / count, t_ = 1 - t2;
                    lut.push(new Float32Array([t_ * t_ * t_, 3 * t2 * t_ * t_, 3 * t2 * t2 * t_, t2 * t2 * t2]));
                  }
                  return lut;
                }
                var cache = [];
                return function getB2(count) {
                  if (!cache[count]) {
                    cache[count] = buildB(count);
                  }
                  return cache[count];
                };
              }();
              function buildFigureFromPatch(mesh, index) {
                var figure = mesh.figures[index];
                (0, _util2.assert)(figure.type === "patch", "Unexpected patch mesh figure");
                var coords = mesh.coords, colors = mesh.colors;
                var pi = figure.coords;
                var ci = figure.colors;
                var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
                splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
                splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                var verticesPerRow = splitXBy + 1;
                var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                var k2 = 0;
                var cl = new Uint8Array(3), cr = new Uint8Array(3);
                var c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
                var bRow = getB(splitYBy), bCol = getB(splitXBy);
                for (var row = 0; row <= splitYBy; row++) {
                  cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
                  cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
                  cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
                  cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
                  cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
                  cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
                  for (var col = 0; col <= splitXBy; col++, k2++) {
                    if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                      continue;
                    }
                    var x2 = 0, y2 = 0;
                    var q2 = 0;
                    for (var i2 = 0; i2 <= 3; i2++) {
                      for (var j2 = 0; j2 <= 3; j2++, q2++) {
                        var m = bRow[row][i2] * bCol[col][j2];
                        x2 += coords[pi[q2]][0] * m;
                        y2 += coords[pi[q2]][1] * m;
                      }
                    }
                    figureCoords[k2] = coords.length;
                    coords.push([x2, y2]);
                    figureColors[k2] = colors.length;
                    var newColor = new Uint8Array(3);
                    newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
                    newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
                    newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
                    colors.push(newColor);
                  }
                }
                figureCoords[0] = pi[0];
                figureColors[0] = ci[0];
                figureCoords[splitXBy] = pi[3];
                figureColors[splitXBy] = ci[1];
                figureCoords[verticesPerRow * splitYBy] = pi[12];
                figureColors[verticesPerRow * splitYBy] = ci[2];
                figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                mesh.figures[index] = {
                  type: "lattice",
                  coords: figureCoords,
                  colors: figureColors,
                  verticesPerRow
                };
              }
              function decodeType6Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = new Int32Array(16);
                var cs = new Int32Array(4);
                while (reader.hasData) {
                  var f = reader.readFlag();
                  if (!(0 <= f && f <= 3)) {
                    throw new _util2.FormatError("Unknown type6 flag");
                  }
                  var i2, ii;
                  var pi = coords.length;
                  for (i2 = 0, ii = f !== 0 ? 8 : 12; i2 < ii; i2++) {
                    coords.push(reader.readCoordinate());
                  }
                  var ci = colors.length;
                  for (i2 = 0, ii = f !== 0 ? 2 : 4; i2 < ii; i2++) {
                    colors.push(reader.readComponents());
                  }
                  var tmp1, tmp2, tmp3, tmp4;
                  switch (f) {
                    case 0:
                      ps[12] = pi + 3;
                      ps[13] = pi + 4;
                      ps[14] = pi + 5;
                      ps[15] = pi + 6;
                      ps[8] = pi + 2;
                      ps[11] = pi + 7;
                      ps[4] = pi + 1;
                      ps[7] = pi + 8;
                      ps[0] = pi;
                      ps[1] = pi + 11;
                      ps[2] = pi + 10;
                      ps[3] = pi + 9;
                      cs[2] = ci + 1;
                      cs[3] = ci + 2;
                      cs[0] = ci;
                      cs[1] = ci + 3;
                      break;
                    case 1:
                      tmp1 = ps[12];
                      tmp2 = ps[13];
                      tmp3 = ps[14];
                      tmp4 = ps[15];
                      ps[12] = tmp4;
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = tmp3;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[2];
                      tmp2 = cs[3];
                      cs[2] = tmp2;
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 2:
                      tmp1 = ps[15];
                      tmp2 = ps[11];
                      ps[12] = ps[3];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[7];
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[3];
                      cs[2] = cs[1];
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 3:
                      ps[12] = ps[0];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[1];
                      ps[11] = pi + 3;
                      ps[4] = ps[2];
                      ps[7] = pi + 4;
                      ps[0] = ps[3];
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      cs[2] = cs[0];
                      cs[3] = ci;
                      cs[0] = cs[1];
                      cs[1] = ci + 1;
                      break;
                  }
                  ps[5] = coords.length;
                  coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                  ps[6] = coords.length;
                  coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                  ps[9] = coords.length;
                  coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                  ps[10] = coords.length;
                  coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                  mesh.figures.push({
                    type: "patch",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(cs)
                  });
                }
              }
              function decodeType7Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = new Int32Array(16);
                var cs = new Int32Array(4);
                while (reader.hasData) {
                  var f = reader.readFlag();
                  if (!(0 <= f && f <= 3)) {
                    throw new _util2.FormatError("Unknown type7 flag");
                  }
                  var i2, ii;
                  var pi = coords.length;
                  for (i2 = 0, ii = f !== 0 ? 12 : 16; i2 < ii; i2++) {
                    coords.push(reader.readCoordinate());
                  }
                  var ci = colors.length;
                  for (i2 = 0, ii = f !== 0 ? 2 : 4; i2 < ii; i2++) {
                    colors.push(reader.readComponents());
                  }
                  var tmp1, tmp2, tmp3, tmp4;
                  switch (f) {
                    case 0:
                      ps[12] = pi + 3;
                      ps[13] = pi + 4;
                      ps[14] = pi + 5;
                      ps[15] = pi + 6;
                      ps[8] = pi + 2;
                      ps[9] = pi + 13;
                      ps[10] = pi + 14;
                      ps[11] = pi + 7;
                      ps[4] = pi + 1;
                      ps[5] = pi + 12;
                      ps[6] = pi + 15;
                      ps[7] = pi + 8;
                      ps[0] = pi;
                      ps[1] = pi + 11;
                      ps[2] = pi + 10;
                      ps[3] = pi + 9;
                      cs[2] = ci + 1;
                      cs[3] = ci + 2;
                      cs[0] = ci;
                      cs[1] = ci + 3;
                      break;
                    case 1:
                      tmp1 = ps[12];
                      tmp2 = ps[13];
                      tmp3 = ps[14];
                      tmp4 = ps[15];
                      ps[12] = tmp4;
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = tmp3;
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[2];
                      tmp2 = cs[3];
                      cs[2] = tmp2;
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 2:
                      tmp1 = ps[15];
                      tmp2 = ps[11];
                      ps[12] = ps[3];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[7];
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[3];
                      cs[2] = cs[1];
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 3:
                      ps[12] = ps[0];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[1];
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = ps[2];
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = ps[3];
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      cs[2] = cs[0];
                      cs[3] = ci;
                      cs[0] = cs[1];
                      cs[1] = ci + 1;
                      break;
                  }
                  mesh.figures.push({
                    type: "patch",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(cs)
                  });
                }
              }
              function updateBounds(mesh) {
                var minX = mesh.coords[0][0], minY = mesh.coords[0][1], maxX = minX, maxY = minY;
                for (var i2 = 1, ii = mesh.coords.length; i2 < ii; i2++) {
                  var x2 = mesh.coords[i2][0], y2 = mesh.coords[i2][1];
                  minX = minX > x2 ? x2 : minX;
                  minY = minY > y2 ? y2 : minY;
                  maxX = maxX < x2 ? x2 : maxX;
                  maxY = maxY < y2 ? y2 : maxY;
                }
                mesh.bounds = [minX, minY, maxX, maxY];
              }
              function packData(mesh) {
                var i2, ii, j2, jj;
                var coords = mesh.coords;
                var coordsPacked = new Float32Array(coords.length * 2);
                for (i2 = 0, j2 = 0, ii = coords.length; i2 < ii; i2++) {
                  var xy = coords[i2];
                  coordsPacked[j2++] = xy[0];
                  coordsPacked[j2++] = xy[1];
                }
                mesh.coords = coordsPacked;
                var colors = mesh.colors;
                var colorsPacked = new Uint8Array(colors.length * 3);
                for (i2 = 0, j2 = 0, ii = colors.length; i2 < ii; i2++) {
                  var c2 = colors[i2];
                  colorsPacked[j2++] = c2[0];
                  colorsPacked[j2++] = c2[1];
                  colorsPacked[j2++] = c2[2];
                }
                mesh.colors = colorsPacked;
                var figures = mesh.figures;
                for (i2 = 0, ii = figures.length; i2 < ii; i2++) {
                  var figure = figures[i2], ps = figure.coords, cs = figure.colors;
                  for (j2 = 0, jj = ps.length; j2 < jj; j2++) {
                    ps[j2] *= 2;
                    cs[j2] *= 3;
                  }
                }
              }
              function Mesh(stream, matrix, xref, res, pdfFunctionFactory) {
                if (!(0, _primitives.isStream)(stream)) {
                  throw new _util2.FormatError("Mesh data is not a stream");
                }
                var dict = stream.dict;
                this.matrix = matrix;
                this.shadingType = dict.get("ShadingType");
                this.type = "Pattern";
                const bbox = dict.getArray("BBox");
                if (Array.isArray(bbox) && bbox.length === 4) {
                  this.bbox = _util2.Util.normalizeRect(bbox);
                } else {
                  this.bbox = null;
                }
                var cs = dict.get("ColorSpace", "CS");
                cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                this.cs = cs;
                this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
                var fnObj = dict.get("Function");
                var fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
                this.coords = [];
                this.colors = [];
                this.figures = [];
                var decodeContext = {
                  bitsPerCoordinate: dict.get("BitsPerCoordinate"),
                  bitsPerComponent: dict.get("BitsPerComponent"),
                  bitsPerFlag: dict.get("BitsPerFlag"),
                  decode: dict.getArray("Decode"),
                  colorFn: fn,
                  colorSpace: cs,
                  numComps: fn ? 1 : cs.numComps
                };
                var reader = new MeshStreamReader(stream, decodeContext);
                var patchMesh = false;
                switch (this.shadingType) {
                  case ShadingType.FREE_FORM_MESH:
                    decodeType4Shading(this, reader);
                    break;
                  case ShadingType.LATTICE_FORM_MESH:
                    var verticesPerRow = dict.get("VerticesPerRow") | 0;
                    if (verticesPerRow < 2) {
                      throw new _util2.FormatError("Invalid VerticesPerRow");
                    }
                    decodeType5Shading(this, reader, verticesPerRow);
                    break;
                  case ShadingType.COONS_PATCH_MESH:
                    decodeType6Shading(this, reader);
                    patchMesh = true;
                    break;
                  case ShadingType.TENSOR_PATCH_MESH:
                    decodeType7Shading(this, reader);
                    patchMesh = true;
                    break;
                  default:
                    (0, _util2.unreachable)("Unsupported mesh type.");
                    break;
                }
                if (patchMesh) {
                  updateBounds(this);
                  for (var i2 = 0, ii = this.figures.length; i2 < ii; i2++) {
                    buildFigureFromPatch(this, i2);
                  }
                }
                updateBounds(this);
                packData(this);
              }
              Mesh.prototype = {
                getIR: function Mesh_getIR() {
                  return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
                }
              };
              return Mesh;
            }();
            Shadings.Dummy = function DummyClosure() {
              function Dummy() {
                this.type = "Pattern";
              }
              Dummy.prototype = {
                getIR: function Dummy_getIR() {
                  return ["Dummy"];
                }
              };
              return Dummy;
            }();
            function getTilingPatternIR(operatorList, dict, args) {
              const matrix = dict.getArray("Matrix");
              const bbox = _util2.Util.normalizeRect(dict.getArray("BBox"));
              const xstep = dict.get("XStep");
              const ystep = dict.get("YStep");
              const paintType = dict.get("PaintType");
              const tilingType = dict.get("TilingType");
              if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
                throw new _util2.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
              }
              return ["TilingPattern", args, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
            }
          },
          /* 37 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.bidi = bidi;
            var _util2 = __w_pdfjs_require__2(2);
            var baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
            var arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
            function isOdd(i2) {
              return (i2 & 1) !== 0;
            }
            function isEven(i2) {
              return (i2 & 1) === 0;
            }
            function findUnequal(arr, start, value) {
              for (var j2 = start, jj = arr.length; j2 < jj; ++j2) {
                if (arr[j2] !== value) {
                  return j2;
                }
              }
              return j2;
            }
            function setValues(arr, start, end, value) {
              for (var j2 = start; j2 < end; ++j2) {
                arr[j2] = value;
              }
            }
            function reverseValues(arr, start, end) {
              for (var i2 = start, j2 = end - 1; i2 < j2; ++i2, --j2) {
                var temp = arr[i2];
                arr[i2] = arr[j2];
                arr[j2] = temp;
              }
            }
            function createBidiText(str, isLTR, vertical = false) {
              let dir = "ltr";
              if (vertical) {
                dir = "ttb";
              } else if (!isLTR) {
                dir = "rtl";
              }
              return {
                str,
                dir
              };
            }
            var chars = [];
            var types = [];
            function bidi(str, startLevel, vertical) {
              var isLTR = true;
              var strLength = str.length;
              if (strLength === 0 || vertical) {
                return createBidiText(str, isLTR, vertical);
              }
              chars.length = strLength;
              types.length = strLength;
              var numBidi = 0;
              var i2, ii;
              for (i2 = 0; i2 < strLength; ++i2) {
                chars[i2] = str.charAt(i2);
                var charCode = str.charCodeAt(i2);
                var charType = "L";
                if (charCode <= 255) {
                  charType = baseTypes[charCode];
                } else if (1424 <= charCode && charCode <= 1524) {
                  charType = "R";
                } else if (1536 <= charCode && charCode <= 1791) {
                  charType = arabicTypes[charCode & 255];
                  if (!charType) {
                    (0, _util2.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
                  }
                } else if (1792 <= charCode && charCode <= 2220) {
                  charType = "AL";
                }
                if (charType === "R" || charType === "AL" || charType === "AN") {
                  numBidi++;
                }
                types[i2] = charType;
              }
              if (numBidi === 0) {
                isLTR = true;
                return createBidiText(str, isLTR);
              }
              if (startLevel === -1) {
                if (numBidi / strLength < 0.3) {
                  isLTR = true;
                  startLevel = 0;
                } else {
                  isLTR = false;
                  startLevel = 1;
                }
              }
              var levels = [];
              for (i2 = 0; i2 < strLength; ++i2) {
                levels[i2] = startLevel;
              }
              var e2 = isOdd(startLevel) ? "R" : "L";
              var sor = e2;
              var eor = sor;
              var lastType = sor;
              for (i2 = 0; i2 < strLength; ++i2) {
                if (types[i2] === "NSM") {
                  types[i2] = lastType;
                } else {
                  lastType = types[i2];
                }
              }
              lastType = sor;
              var t2;
              for (i2 = 0; i2 < strLength; ++i2) {
                t2 = types[i2];
                if (t2 === "EN") {
                  types[i2] = lastType === "AL" ? "AN" : "EN";
                } else if (t2 === "R" || t2 === "L" || t2 === "AL") {
                  lastType = t2;
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                t2 = types[i2];
                if (t2 === "AL") {
                  types[i2] = "R";
                }
              }
              for (i2 = 1; i2 < strLength - 1; ++i2) {
                if (types[i2] === "ES" && types[i2 - 1] === "EN" && types[i2 + 1] === "EN") {
                  types[i2] = "EN";
                }
                if (types[i2] === "CS" && (types[i2 - 1] === "EN" || types[i2 - 1] === "AN") && types[i2 + 1] === types[i2 - 1]) {
                  types[i2] = types[i2 - 1];
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                if (types[i2] === "EN") {
                  var j2;
                  for (j2 = i2 - 1; j2 >= 0; --j2) {
                    if (types[j2] !== "ET") {
                      break;
                    }
                    types[j2] = "EN";
                  }
                  for (j2 = i2 + 1; j2 < strLength; ++j2) {
                    if (types[j2] !== "ET") {
                      break;
                    }
                    types[j2] = "EN";
                  }
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                t2 = types[i2];
                if (t2 === "WS" || t2 === "ES" || t2 === "ET" || t2 === "CS") {
                  types[i2] = "ON";
                }
              }
              lastType = sor;
              for (i2 = 0; i2 < strLength; ++i2) {
                t2 = types[i2];
                if (t2 === "EN") {
                  types[i2] = lastType === "L" ? "L" : "EN";
                } else if (t2 === "R" || t2 === "L") {
                  lastType = t2;
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                if (types[i2] === "ON") {
                  var end = findUnequal(types, i2 + 1, "ON");
                  var before = sor;
                  if (i2 > 0) {
                    before = types[i2 - 1];
                  }
                  var after = eor;
                  if (end + 1 < strLength) {
                    after = types[end + 1];
                  }
                  if (before !== "L") {
                    before = "R";
                  }
                  if (after !== "L") {
                    after = "R";
                  }
                  if (before === after) {
                    setValues(types, i2, end, before);
                  }
                  i2 = end - 1;
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                if (types[i2] === "ON") {
                  types[i2] = e2;
                }
              }
              for (i2 = 0; i2 < strLength; ++i2) {
                t2 = types[i2];
                if (isEven(levels[i2])) {
                  if (t2 === "R") {
                    levels[i2] += 1;
                  } else if (t2 === "AN" || t2 === "EN") {
                    levels[i2] += 2;
                  }
                } else {
                  if (t2 === "L" || t2 === "AN" || t2 === "EN") {
                    levels[i2] += 1;
                  }
                }
              }
              var highestLevel = -1;
              var lowestOddLevel = 99;
              var level;
              for (i2 = 0, ii = levels.length; i2 < ii; ++i2) {
                level = levels[i2];
                if (highestLevel < level) {
                  highestLevel = level;
                }
                if (lowestOddLevel > level && isOdd(level)) {
                  lowestOddLevel = level;
                }
              }
              for (level = highestLevel; level >= lowestOddLevel; --level) {
                var start = -1;
                for (i2 = 0, ii = levels.length; i2 < ii; ++i2) {
                  if (levels[i2] < level) {
                    if (start >= 0) {
                      reverseValues(chars, start, i2);
                      start = -1;
                    }
                  } else if (start < 0) {
                    start = i2;
                  }
                }
                if (start >= 0) {
                  reverseValues(chars, start, levels.length);
                }
              }
              for (i2 = 0, ii = chars.length; i2 < ii; ++i2) {
                var ch = chars[i2];
                if (ch === "<" || ch === ">") {
                  chars[i2] = "";
                }
              }
              return createBidiText(chars.join(""), isLTR);
            }
          },
          /* 38 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getMetrics = void 0;
            var _core_utils = __w_pdfjs_require__2(7);
            var getMetrics = (0, _core_utils.getLookupTableFactory)(function(t2) {
              t2["Courier"] = 600;
              t2["Courier-Bold"] = 600;
              t2["Courier-BoldOblique"] = 600;
              t2["Courier-Oblique"] = 600;
              t2["Helvetica"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 278;
                t3["exclam"] = 278;
                t3["quotedbl"] = 355;
                t3["numbersign"] = 556;
                t3["dollar"] = 556;
                t3["percent"] = 889;
                t3["ampersand"] = 667;
                t3["quoteright"] = 222;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 389;
                t3["plus"] = 584;
                t3["comma"] = 278;
                t3["hyphen"] = 333;
                t3["period"] = 278;
                t3["slash"] = 278;
                t3["zero"] = 556;
                t3["one"] = 556;
                t3["two"] = 556;
                t3["three"] = 556;
                t3["four"] = 556;
                t3["five"] = 556;
                t3["six"] = 556;
                t3["seven"] = 556;
                t3["eight"] = 556;
                t3["nine"] = 556;
                t3["colon"] = 278;
                t3["semicolon"] = 278;
                t3["less"] = 584;
                t3["equal"] = 584;
                t3["greater"] = 584;
                t3["question"] = 556;
                t3["at"] = 1015;
                t3["A"] = 667;
                t3["B"] = 667;
                t3["C"] = 722;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 611;
                t3["G"] = 778;
                t3["H"] = 722;
                t3["I"] = 278;
                t3["J"] = 500;
                t3["K"] = 667;
                t3["L"] = 556;
                t3["M"] = 833;
                t3["N"] = 722;
                t3["O"] = 778;
                t3["P"] = 667;
                t3["Q"] = 778;
                t3["R"] = 722;
                t3["S"] = 667;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 667;
                t3["W"] = 944;
                t3["X"] = 667;
                t3["Y"] = 667;
                t3["Z"] = 611;
                t3["bracketleft"] = 278;
                t3["backslash"] = 278;
                t3["bracketright"] = 278;
                t3["asciicircum"] = 469;
                t3["underscore"] = 556;
                t3["quoteleft"] = 222;
                t3["a"] = 556;
                t3["b"] = 556;
                t3["c"] = 500;
                t3["d"] = 556;
                t3["e"] = 556;
                t3["f"] = 278;
                t3["g"] = 556;
                t3["h"] = 556;
                t3["i"] = 222;
                t3["j"] = 222;
                t3["k"] = 500;
                t3["l"] = 222;
                t3["m"] = 833;
                t3["n"] = 556;
                t3["o"] = 556;
                t3["p"] = 556;
                t3["q"] = 556;
                t3["r"] = 333;
                t3["s"] = 500;
                t3["t"] = 278;
                t3["u"] = 556;
                t3["v"] = 500;
                t3["w"] = 722;
                t3["x"] = 500;
                t3["y"] = 500;
                t3["z"] = 500;
                t3["braceleft"] = 334;
                t3["bar"] = 260;
                t3["braceright"] = 334;
                t3["asciitilde"] = 584;
                t3["exclamdown"] = 333;
                t3["cent"] = 556;
                t3["sterling"] = 556;
                t3["fraction"] = 167;
                t3["yen"] = 556;
                t3["florin"] = 556;
                t3["section"] = 556;
                t3["currency"] = 556;
                t3["quotesingle"] = 191;
                t3["quotedblleft"] = 333;
                t3["guillemotleft"] = 556;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 500;
                t3["fl"] = 500;
                t3["endash"] = 556;
                t3["dagger"] = 556;
                t3["daggerdbl"] = 556;
                t3["periodcentered"] = 278;
                t3["paragraph"] = 537;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 222;
                t3["quotedblbase"] = 333;
                t3["quotedblright"] = 333;
                t3["guillemotright"] = 556;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 611;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 1e3;
                t3["ordfeminine"] = 370;
                t3["Lslash"] = 556;
                t3["Oslash"] = 778;
                t3["OE"] = 1e3;
                t3["ordmasculine"] = 365;
                t3["ae"] = 889;
                t3["dotlessi"] = 278;
                t3["lslash"] = 222;
                t3["oslash"] = 611;
                t3["oe"] = 944;
                t3["germandbls"] = 611;
                t3["Idieresis"] = 278;
                t3["eacute"] = 556;
                t3["abreve"] = 556;
                t3["uhungarumlaut"] = 556;
                t3["ecaron"] = 556;
                t3["Ydieresis"] = 667;
                t3["divide"] = 584;
                t3["Yacute"] = 667;
                t3["Acircumflex"] = 667;
                t3["aacute"] = 556;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 500;
                t3["scommaaccent"] = 500;
                t3["ecircumflex"] = 556;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 556;
                t3["Uacute"] = 722;
                t3["uogonek"] = 556;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 737;
                t3["Emacron"] = 667;
                t3["ccaron"] = 500;
                t3["aring"] = 556;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 222;
                t3["agrave"] = 556;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 722;
                t3["atilde"] = 556;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 500;
                t3["scedilla"] = 500;
                t3["iacute"] = 278;
                t3["lozenge"] = 471;
                t3["Rcaron"] = 722;
                t3["Gcommaaccent"] = 778;
                t3["ucircumflex"] = 556;
                t3["acircumflex"] = 556;
                t3["Amacron"] = 667;
                t3["rcaron"] = 333;
                t3["ccedilla"] = 500;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 667;
                t3["Omacron"] = 778;
                t3["Racute"] = 722;
                t3["Sacute"] = 667;
                t3["dcaron"] = 643;
                t3["Umacron"] = 722;
                t3["uring"] = 556;
                t3["threesuperior"] = 333;
                t3["Ograve"] = 778;
                t3["Agrave"] = 667;
                t3["Abreve"] = 667;
                t3["multiply"] = 584;
                t3["uacute"] = 556;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 476;
                t3["ydieresis"] = 500;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 556;
                t3["edieresis"] = 556;
                t3["cacute"] = 500;
                t3["nacute"] = 556;
                t3["umacron"] = 556;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 278;
                t3["plusminus"] = 584;
                t3["brokenbar"] = 260;
                t3["registered"] = 737;
                t3["Gbreve"] = 778;
                t3["Idotaccent"] = 278;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 333;
                t3["omacron"] = 556;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 722;
                t3["lcommaaccent"] = 222;
                t3["tcaron"] = 317;
                t3["eogonek"] = 556;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 667;
                t3["Adieresis"] = 667;
                t3["egrave"] = 556;
                t3["zacute"] = 500;
                t3["iogonek"] = 222;
                t3["Oacute"] = 778;
                t3["oacute"] = 556;
                t3["amacron"] = 556;
                t3["sacute"] = 500;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 778;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 556;
                t3["twosuperior"] = 333;
                t3["Odieresis"] = 778;
                t3["mu"] = 556;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 556;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 556;
                t3["threequarters"] = 834;
                t3["Scedilla"] = 667;
                t3["lcaron"] = 299;
                t3["Kcommaaccent"] = 667;
                t3["Lacute"] = 556;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 556;
                t3["Igrave"] = 278;
                t3["Imacron"] = 278;
                t3["Lcaron"] = 556;
                t3["onehalf"] = 834;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 556;
                t3["ntilde"] = 556;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 556;
                t3["gbreve"] = 556;
                t3["onequarter"] = 834;
                t3["Scaron"] = 667;
                t3["Scommaaccent"] = 667;
                t3["Ohungarumlaut"] = 778;
                t3["degree"] = 400;
                t3["ograve"] = 556;
                t3["Ccaron"] = 722;
                t3["ugrave"] = 556;
                t3["radical"] = 453;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 333;
                t3["Ntilde"] = 722;
                t3["otilde"] = 556;
                t3["Rcommaaccent"] = 722;
                t3["Lcommaaccent"] = 556;
                t3["Atilde"] = 667;
                t3["Aogonek"] = 667;
                t3["Aring"] = 667;
                t3["Otilde"] = 778;
                t3["zdotaccent"] = 500;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 278;
                t3["kcommaaccent"] = 500;
                t3["minus"] = 584;
                t3["Icircumflex"] = 278;
                t3["ncaron"] = 556;
                t3["tcommaaccent"] = 278;
                t3["logicalnot"] = 584;
                t3["odieresis"] = 556;
                t3["udieresis"] = 556;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 556;
                t3["eth"] = 556;
                t3["zcaron"] = 500;
                t3["ncommaaccent"] = 556;
                t3["onesuperior"] = 333;
                t3["imacron"] = 278;
                t3["Euro"] = 556;
              });
              t2["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 278;
                t3["exclam"] = 333;
                t3["quotedbl"] = 474;
                t3["numbersign"] = 556;
                t3["dollar"] = 556;
                t3["percent"] = 889;
                t3["ampersand"] = 722;
                t3["quoteright"] = 278;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 389;
                t3["plus"] = 584;
                t3["comma"] = 278;
                t3["hyphen"] = 333;
                t3["period"] = 278;
                t3["slash"] = 278;
                t3["zero"] = 556;
                t3["one"] = 556;
                t3["two"] = 556;
                t3["three"] = 556;
                t3["four"] = 556;
                t3["five"] = 556;
                t3["six"] = 556;
                t3["seven"] = 556;
                t3["eight"] = 556;
                t3["nine"] = 556;
                t3["colon"] = 333;
                t3["semicolon"] = 333;
                t3["less"] = 584;
                t3["equal"] = 584;
                t3["greater"] = 584;
                t3["question"] = 611;
                t3["at"] = 975;
                t3["A"] = 722;
                t3["B"] = 722;
                t3["C"] = 722;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 611;
                t3["G"] = 778;
                t3["H"] = 722;
                t3["I"] = 278;
                t3["J"] = 556;
                t3["K"] = 722;
                t3["L"] = 611;
                t3["M"] = 833;
                t3["N"] = 722;
                t3["O"] = 778;
                t3["P"] = 667;
                t3["Q"] = 778;
                t3["R"] = 722;
                t3["S"] = 667;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 667;
                t3["W"] = 944;
                t3["X"] = 667;
                t3["Y"] = 667;
                t3["Z"] = 611;
                t3["bracketleft"] = 333;
                t3["backslash"] = 278;
                t3["bracketright"] = 333;
                t3["asciicircum"] = 584;
                t3["underscore"] = 556;
                t3["quoteleft"] = 278;
                t3["a"] = 556;
                t3["b"] = 611;
                t3["c"] = 556;
                t3["d"] = 611;
                t3["e"] = 556;
                t3["f"] = 333;
                t3["g"] = 611;
                t3["h"] = 611;
                t3["i"] = 278;
                t3["j"] = 278;
                t3["k"] = 556;
                t3["l"] = 278;
                t3["m"] = 889;
                t3["n"] = 611;
                t3["o"] = 611;
                t3["p"] = 611;
                t3["q"] = 611;
                t3["r"] = 389;
                t3["s"] = 556;
                t3["t"] = 333;
                t3["u"] = 611;
                t3["v"] = 556;
                t3["w"] = 778;
                t3["x"] = 556;
                t3["y"] = 556;
                t3["z"] = 500;
                t3["braceleft"] = 389;
                t3["bar"] = 280;
                t3["braceright"] = 389;
                t3["asciitilde"] = 584;
                t3["exclamdown"] = 333;
                t3["cent"] = 556;
                t3["sterling"] = 556;
                t3["fraction"] = 167;
                t3["yen"] = 556;
                t3["florin"] = 556;
                t3["section"] = 556;
                t3["currency"] = 556;
                t3["quotesingle"] = 238;
                t3["quotedblleft"] = 500;
                t3["guillemotleft"] = 556;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 611;
                t3["fl"] = 611;
                t3["endash"] = 556;
                t3["dagger"] = 556;
                t3["daggerdbl"] = 556;
                t3["periodcentered"] = 278;
                t3["paragraph"] = 556;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 278;
                t3["quotedblbase"] = 500;
                t3["quotedblright"] = 500;
                t3["guillemotright"] = 556;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 611;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 1e3;
                t3["ordfeminine"] = 370;
                t3["Lslash"] = 611;
                t3["Oslash"] = 778;
                t3["OE"] = 1e3;
                t3["ordmasculine"] = 365;
                t3["ae"] = 889;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 611;
                t3["oe"] = 944;
                t3["germandbls"] = 611;
                t3["Idieresis"] = 278;
                t3["eacute"] = 556;
                t3["abreve"] = 556;
                t3["uhungarumlaut"] = 611;
                t3["ecaron"] = 556;
                t3["Ydieresis"] = 667;
                t3["divide"] = 584;
                t3["Yacute"] = 667;
                t3["Acircumflex"] = 722;
                t3["aacute"] = 556;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 556;
                t3["scommaaccent"] = 556;
                t3["ecircumflex"] = 556;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 556;
                t3["Uacute"] = 722;
                t3["uogonek"] = 611;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 737;
                t3["Emacron"] = 667;
                t3["ccaron"] = 556;
                t3["aring"] = 556;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 278;
                t3["agrave"] = 556;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 722;
                t3["atilde"] = 556;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 556;
                t3["scedilla"] = 556;
                t3["iacute"] = 278;
                t3["lozenge"] = 494;
                t3["Rcaron"] = 722;
                t3["Gcommaaccent"] = 778;
                t3["ucircumflex"] = 611;
                t3["acircumflex"] = 556;
                t3["Amacron"] = 722;
                t3["rcaron"] = 389;
                t3["ccedilla"] = 556;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 667;
                t3["Omacron"] = 778;
                t3["Racute"] = 722;
                t3["Sacute"] = 667;
                t3["dcaron"] = 743;
                t3["Umacron"] = 722;
                t3["uring"] = 611;
                t3["threesuperior"] = 333;
                t3["Ograve"] = 778;
                t3["Agrave"] = 722;
                t3["Abreve"] = 722;
                t3["multiply"] = 584;
                t3["uacute"] = 611;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 494;
                t3["ydieresis"] = 556;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 556;
                t3["edieresis"] = 556;
                t3["cacute"] = 556;
                t3["nacute"] = 611;
                t3["umacron"] = 611;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 278;
                t3["plusminus"] = 584;
                t3["brokenbar"] = 280;
                t3["registered"] = 737;
                t3["Gbreve"] = 778;
                t3["Idotaccent"] = 278;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 389;
                t3["omacron"] = 611;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 722;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 389;
                t3["eogonek"] = 556;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 722;
                t3["Adieresis"] = 722;
                t3["egrave"] = 556;
                t3["zacute"] = 500;
                t3["iogonek"] = 278;
                t3["Oacute"] = 778;
                t3["oacute"] = 611;
                t3["amacron"] = 556;
                t3["sacute"] = 556;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 778;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 611;
                t3["twosuperior"] = 333;
                t3["Odieresis"] = 778;
                t3["mu"] = 611;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 611;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 611;
                t3["threequarters"] = 834;
                t3["Scedilla"] = 667;
                t3["lcaron"] = 400;
                t3["Kcommaaccent"] = 722;
                t3["Lacute"] = 611;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 556;
                t3["Igrave"] = 278;
                t3["Imacron"] = 278;
                t3["Lcaron"] = 611;
                t3["onehalf"] = 834;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 611;
                t3["ntilde"] = 611;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 556;
                t3["gbreve"] = 611;
                t3["onequarter"] = 834;
                t3["Scaron"] = 667;
                t3["Scommaaccent"] = 667;
                t3["Ohungarumlaut"] = 778;
                t3["degree"] = 400;
                t3["ograve"] = 611;
                t3["Ccaron"] = 722;
                t3["ugrave"] = 611;
                t3["radical"] = 549;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 389;
                t3["Ntilde"] = 722;
                t3["otilde"] = 611;
                t3["Rcommaaccent"] = 722;
                t3["Lcommaaccent"] = 611;
                t3["Atilde"] = 722;
                t3["Aogonek"] = 722;
                t3["Aring"] = 722;
                t3["Otilde"] = 778;
                t3["zdotaccent"] = 500;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 278;
                t3["kcommaaccent"] = 556;
                t3["minus"] = 584;
                t3["Icircumflex"] = 278;
                t3["ncaron"] = 611;
                t3["tcommaaccent"] = 333;
                t3["logicalnot"] = 584;
                t3["odieresis"] = 611;
                t3["udieresis"] = 611;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 611;
                t3["eth"] = 611;
                t3["zcaron"] = 500;
                t3["ncommaaccent"] = 611;
                t3["onesuperior"] = 333;
                t3["imacron"] = 278;
                t3["Euro"] = 556;
              });
              t2["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 278;
                t3["exclam"] = 333;
                t3["quotedbl"] = 474;
                t3["numbersign"] = 556;
                t3["dollar"] = 556;
                t3["percent"] = 889;
                t3["ampersand"] = 722;
                t3["quoteright"] = 278;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 389;
                t3["plus"] = 584;
                t3["comma"] = 278;
                t3["hyphen"] = 333;
                t3["period"] = 278;
                t3["slash"] = 278;
                t3["zero"] = 556;
                t3["one"] = 556;
                t3["two"] = 556;
                t3["three"] = 556;
                t3["four"] = 556;
                t3["five"] = 556;
                t3["six"] = 556;
                t3["seven"] = 556;
                t3["eight"] = 556;
                t3["nine"] = 556;
                t3["colon"] = 333;
                t3["semicolon"] = 333;
                t3["less"] = 584;
                t3["equal"] = 584;
                t3["greater"] = 584;
                t3["question"] = 611;
                t3["at"] = 975;
                t3["A"] = 722;
                t3["B"] = 722;
                t3["C"] = 722;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 611;
                t3["G"] = 778;
                t3["H"] = 722;
                t3["I"] = 278;
                t3["J"] = 556;
                t3["K"] = 722;
                t3["L"] = 611;
                t3["M"] = 833;
                t3["N"] = 722;
                t3["O"] = 778;
                t3["P"] = 667;
                t3["Q"] = 778;
                t3["R"] = 722;
                t3["S"] = 667;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 667;
                t3["W"] = 944;
                t3["X"] = 667;
                t3["Y"] = 667;
                t3["Z"] = 611;
                t3["bracketleft"] = 333;
                t3["backslash"] = 278;
                t3["bracketright"] = 333;
                t3["asciicircum"] = 584;
                t3["underscore"] = 556;
                t3["quoteleft"] = 278;
                t3["a"] = 556;
                t3["b"] = 611;
                t3["c"] = 556;
                t3["d"] = 611;
                t3["e"] = 556;
                t3["f"] = 333;
                t3["g"] = 611;
                t3["h"] = 611;
                t3["i"] = 278;
                t3["j"] = 278;
                t3["k"] = 556;
                t3["l"] = 278;
                t3["m"] = 889;
                t3["n"] = 611;
                t3["o"] = 611;
                t3["p"] = 611;
                t3["q"] = 611;
                t3["r"] = 389;
                t3["s"] = 556;
                t3["t"] = 333;
                t3["u"] = 611;
                t3["v"] = 556;
                t3["w"] = 778;
                t3["x"] = 556;
                t3["y"] = 556;
                t3["z"] = 500;
                t3["braceleft"] = 389;
                t3["bar"] = 280;
                t3["braceright"] = 389;
                t3["asciitilde"] = 584;
                t3["exclamdown"] = 333;
                t3["cent"] = 556;
                t3["sterling"] = 556;
                t3["fraction"] = 167;
                t3["yen"] = 556;
                t3["florin"] = 556;
                t3["section"] = 556;
                t3["currency"] = 556;
                t3["quotesingle"] = 238;
                t3["quotedblleft"] = 500;
                t3["guillemotleft"] = 556;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 611;
                t3["fl"] = 611;
                t3["endash"] = 556;
                t3["dagger"] = 556;
                t3["daggerdbl"] = 556;
                t3["periodcentered"] = 278;
                t3["paragraph"] = 556;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 278;
                t3["quotedblbase"] = 500;
                t3["quotedblright"] = 500;
                t3["guillemotright"] = 556;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 611;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 1e3;
                t3["ordfeminine"] = 370;
                t3["Lslash"] = 611;
                t3["Oslash"] = 778;
                t3["OE"] = 1e3;
                t3["ordmasculine"] = 365;
                t3["ae"] = 889;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 611;
                t3["oe"] = 944;
                t3["germandbls"] = 611;
                t3["Idieresis"] = 278;
                t3["eacute"] = 556;
                t3["abreve"] = 556;
                t3["uhungarumlaut"] = 611;
                t3["ecaron"] = 556;
                t3["Ydieresis"] = 667;
                t3["divide"] = 584;
                t3["Yacute"] = 667;
                t3["Acircumflex"] = 722;
                t3["aacute"] = 556;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 556;
                t3["scommaaccent"] = 556;
                t3["ecircumflex"] = 556;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 556;
                t3["Uacute"] = 722;
                t3["uogonek"] = 611;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 737;
                t3["Emacron"] = 667;
                t3["ccaron"] = 556;
                t3["aring"] = 556;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 278;
                t3["agrave"] = 556;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 722;
                t3["atilde"] = 556;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 556;
                t3["scedilla"] = 556;
                t3["iacute"] = 278;
                t3["lozenge"] = 494;
                t3["Rcaron"] = 722;
                t3["Gcommaaccent"] = 778;
                t3["ucircumflex"] = 611;
                t3["acircumflex"] = 556;
                t3["Amacron"] = 722;
                t3["rcaron"] = 389;
                t3["ccedilla"] = 556;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 667;
                t3["Omacron"] = 778;
                t3["Racute"] = 722;
                t3["Sacute"] = 667;
                t3["dcaron"] = 743;
                t3["Umacron"] = 722;
                t3["uring"] = 611;
                t3["threesuperior"] = 333;
                t3["Ograve"] = 778;
                t3["Agrave"] = 722;
                t3["Abreve"] = 722;
                t3["multiply"] = 584;
                t3["uacute"] = 611;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 494;
                t3["ydieresis"] = 556;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 556;
                t3["edieresis"] = 556;
                t3["cacute"] = 556;
                t3["nacute"] = 611;
                t3["umacron"] = 611;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 278;
                t3["plusminus"] = 584;
                t3["brokenbar"] = 280;
                t3["registered"] = 737;
                t3["Gbreve"] = 778;
                t3["Idotaccent"] = 278;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 389;
                t3["omacron"] = 611;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 722;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 389;
                t3["eogonek"] = 556;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 722;
                t3["Adieresis"] = 722;
                t3["egrave"] = 556;
                t3["zacute"] = 500;
                t3["iogonek"] = 278;
                t3["Oacute"] = 778;
                t3["oacute"] = 611;
                t3["amacron"] = 556;
                t3["sacute"] = 556;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 778;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 611;
                t3["twosuperior"] = 333;
                t3["Odieresis"] = 778;
                t3["mu"] = 611;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 611;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 611;
                t3["threequarters"] = 834;
                t3["Scedilla"] = 667;
                t3["lcaron"] = 400;
                t3["Kcommaaccent"] = 722;
                t3["Lacute"] = 611;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 556;
                t3["Igrave"] = 278;
                t3["Imacron"] = 278;
                t3["Lcaron"] = 611;
                t3["onehalf"] = 834;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 611;
                t3["ntilde"] = 611;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 556;
                t3["gbreve"] = 611;
                t3["onequarter"] = 834;
                t3["Scaron"] = 667;
                t3["Scommaaccent"] = 667;
                t3["Ohungarumlaut"] = 778;
                t3["degree"] = 400;
                t3["ograve"] = 611;
                t3["Ccaron"] = 722;
                t3["ugrave"] = 611;
                t3["radical"] = 549;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 389;
                t3["Ntilde"] = 722;
                t3["otilde"] = 611;
                t3["Rcommaaccent"] = 722;
                t3["Lcommaaccent"] = 611;
                t3["Atilde"] = 722;
                t3["Aogonek"] = 722;
                t3["Aring"] = 722;
                t3["Otilde"] = 778;
                t3["zdotaccent"] = 500;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 278;
                t3["kcommaaccent"] = 556;
                t3["minus"] = 584;
                t3["Icircumflex"] = 278;
                t3["ncaron"] = 611;
                t3["tcommaaccent"] = 333;
                t3["logicalnot"] = 584;
                t3["odieresis"] = 611;
                t3["udieresis"] = 611;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 611;
                t3["eth"] = 611;
                t3["zcaron"] = 500;
                t3["ncommaaccent"] = 611;
                t3["onesuperior"] = 333;
                t3["imacron"] = 278;
                t3["Euro"] = 556;
              });
              t2["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 278;
                t3["exclam"] = 278;
                t3["quotedbl"] = 355;
                t3["numbersign"] = 556;
                t3["dollar"] = 556;
                t3["percent"] = 889;
                t3["ampersand"] = 667;
                t3["quoteright"] = 222;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 389;
                t3["plus"] = 584;
                t3["comma"] = 278;
                t3["hyphen"] = 333;
                t3["period"] = 278;
                t3["slash"] = 278;
                t3["zero"] = 556;
                t3["one"] = 556;
                t3["two"] = 556;
                t3["three"] = 556;
                t3["four"] = 556;
                t3["five"] = 556;
                t3["six"] = 556;
                t3["seven"] = 556;
                t3["eight"] = 556;
                t3["nine"] = 556;
                t3["colon"] = 278;
                t3["semicolon"] = 278;
                t3["less"] = 584;
                t3["equal"] = 584;
                t3["greater"] = 584;
                t3["question"] = 556;
                t3["at"] = 1015;
                t3["A"] = 667;
                t3["B"] = 667;
                t3["C"] = 722;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 611;
                t3["G"] = 778;
                t3["H"] = 722;
                t3["I"] = 278;
                t3["J"] = 500;
                t3["K"] = 667;
                t3["L"] = 556;
                t3["M"] = 833;
                t3["N"] = 722;
                t3["O"] = 778;
                t3["P"] = 667;
                t3["Q"] = 778;
                t3["R"] = 722;
                t3["S"] = 667;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 667;
                t3["W"] = 944;
                t3["X"] = 667;
                t3["Y"] = 667;
                t3["Z"] = 611;
                t3["bracketleft"] = 278;
                t3["backslash"] = 278;
                t3["bracketright"] = 278;
                t3["asciicircum"] = 469;
                t3["underscore"] = 556;
                t3["quoteleft"] = 222;
                t3["a"] = 556;
                t3["b"] = 556;
                t3["c"] = 500;
                t3["d"] = 556;
                t3["e"] = 556;
                t3["f"] = 278;
                t3["g"] = 556;
                t3["h"] = 556;
                t3["i"] = 222;
                t3["j"] = 222;
                t3["k"] = 500;
                t3["l"] = 222;
                t3["m"] = 833;
                t3["n"] = 556;
                t3["o"] = 556;
                t3["p"] = 556;
                t3["q"] = 556;
                t3["r"] = 333;
                t3["s"] = 500;
                t3["t"] = 278;
                t3["u"] = 556;
                t3["v"] = 500;
                t3["w"] = 722;
                t3["x"] = 500;
                t3["y"] = 500;
                t3["z"] = 500;
                t3["braceleft"] = 334;
                t3["bar"] = 260;
                t3["braceright"] = 334;
                t3["asciitilde"] = 584;
                t3["exclamdown"] = 333;
                t3["cent"] = 556;
                t3["sterling"] = 556;
                t3["fraction"] = 167;
                t3["yen"] = 556;
                t3["florin"] = 556;
                t3["section"] = 556;
                t3["currency"] = 556;
                t3["quotesingle"] = 191;
                t3["quotedblleft"] = 333;
                t3["guillemotleft"] = 556;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 500;
                t3["fl"] = 500;
                t3["endash"] = 556;
                t3["dagger"] = 556;
                t3["daggerdbl"] = 556;
                t3["periodcentered"] = 278;
                t3["paragraph"] = 537;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 222;
                t3["quotedblbase"] = 333;
                t3["quotedblright"] = 333;
                t3["guillemotright"] = 556;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 611;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 1e3;
                t3["ordfeminine"] = 370;
                t3["Lslash"] = 556;
                t3["Oslash"] = 778;
                t3["OE"] = 1e3;
                t3["ordmasculine"] = 365;
                t3["ae"] = 889;
                t3["dotlessi"] = 278;
                t3["lslash"] = 222;
                t3["oslash"] = 611;
                t3["oe"] = 944;
                t3["germandbls"] = 611;
                t3["Idieresis"] = 278;
                t3["eacute"] = 556;
                t3["abreve"] = 556;
                t3["uhungarumlaut"] = 556;
                t3["ecaron"] = 556;
                t3["Ydieresis"] = 667;
                t3["divide"] = 584;
                t3["Yacute"] = 667;
                t3["Acircumflex"] = 667;
                t3["aacute"] = 556;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 500;
                t3["scommaaccent"] = 500;
                t3["ecircumflex"] = 556;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 556;
                t3["Uacute"] = 722;
                t3["uogonek"] = 556;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 737;
                t3["Emacron"] = 667;
                t3["ccaron"] = 500;
                t3["aring"] = 556;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 222;
                t3["agrave"] = 556;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 722;
                t3["atilde"] = 556;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 500;
                t3["scedilla"] = 500;
                t3["iacute"] = 278;
                t3["lozenge"] = 471;
                t3["Rcaron"] = 722;
                t3["Gcommaaccent"] = 778;
                t3["ucircumflex"] = 556;
                t3["acircumflex"] = 556;
                t3["Amacron"] = 667;
                t3["rcaron"] = 333;
                t3["ccedilla"] = 500;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 667;
                t3["Omacron"] = 778;
                t3["Racute"] = 722;
                t3["Sacute"] = 667;
                t3["dcaron"] = 643;
                t3["Umacron"] = 722;
                t3["uring"] = 556;
                t3["threesuperior"] = 333;
                t3["Ograve"] = 778;
                t3["Agrave"] = 667;
                t3["Abreve"] = 667;
                t3["multiply"] = 584;
                t3["uacute"] = 556;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 476;
                t3["ydieresis"] = 500;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 556;
                t3["edieresis"] = 556;
                t3["cacute"] = 500;
                t3["nacute"] = 556;
                t3["umacron"] = 556;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 278;
                t3["plusminus"] = 584;
                t3["brokenbar"] = 260;
                t3["registered"] = 737;
                t3["Gbreve"] = 778;
                t3["Idotaccent"] = 278;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 333;
                t3["omacron"] = 556;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 722;
                t3["lcommaaccent"] = 222;
                t3["tcaron"] = 317;
                t3["eogonek"] = 556;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 667;
                t3["Adieresis"] = 667;
                t3["egrave"] = 556;
                t3["zacute"] = 500;
                t3["iogonek"] = 222;
                t3["Oacute"] = 778;
                t3["oacute"] = 556;
                t3["amacron"] = 556;
                t3["sacute"] = 500;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 778;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 556;
                t3["twosuperior"] = 333;
                t3["Odieresis"] = 778;
                t3["mu"] = 556;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 556;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 556;
                t3["threequarters"] = 834;
                t3["Scedilla"] = 667;
                t3["lcaron"] = 299;
                t3["Kcommaaccent"] = 667;
                t3["Lacute"] = 556;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 556;
                t3["Igrave"] = 278;
                t3["Imacron"] = 278;
                t3["Lcaron"] = 556;
                t3["onehalf"] = 834;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 556;
                t3["ntilde"] = 556;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 556;
                t3["gbreve"] = 556;
                t3["onequarter"] = 834;
                t3["Scaron"] = 667;
                t3["Scommaaccent"] = 667;
                t3["Ohungarumlaut"] = 778;
                t3["degree"] = 400;
                t3["ograve"] = 556;
                t3["Ccaron"] = 722;
                t3["ugrave"] = 556;
                t3["radical"] = 453;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 333;
                t3["Ntilde"] = 722;
                t3["otilde"] = 556;
                t3["Rcommaaccent"] = 722;
                t3["Lcommaaccent"] = 556;
                t3["Atilde"] = 667;
                t3["Aogonek"] = 667;
                t3["Aring"] = 667;
                t3["Otilde"] = 778;
                t3["zdotaccent"] = 500;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 278;
                t3["kcommaaccent"] = 500;
                t3["minus"] = 584;
                t3["Icircumflex"] = 278;
                t3["ncaron"] = 556;
                t3["tcommaaccent"] = 278;
                t3["logicalnot"] = 584;
                t3["odieresis"] = 556;
                t3["udieresis"] = 556;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 556;
                t3["eth"] = 556;
                t3["zcaron"] = 500;
                t3["ncommaaccent"] = 556;
                t3["onesuperior"] = 333;
                t3["imacron"] = 278;
                t3["Euro"] = 556;
              });
              t2["Symbol"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 250;
                t3["exclam"] = 333;
                t3["universal"] = 713;
                t3["numbersign"] = 500;
                t3["existential"] = 549;
                t3["percent"] = 833;
                t3["ampersand"] = 778;
                t3["suchthat"] = 439;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asteriskmath"] = 500;
                t3["plus"] = 549;
                t3["comma"] = 250;
                t3["minus"] = 549;
                t3["period"] = 250;
                t3["slash"] = 278;
                t3["zero"] = 500;
                t3["one"] = 500;
                t3["two"] = 500;
                t3["three"] = 500;
                t3["four"] = 500;
                t3["five"] = 500;
                t3["six"] = 500;
                t3["seven"] = 500;
                t3["eight"] = 500;
                t3["nine"] = 500;
                t3["colon"] = 278;
                t3["semicolon"] = 278;
                t3["less"] = 549;
                t3["equal"] = 549;
                t3["greater"] = 549;
                t3["question"] = 444;
                t3["congruent"] = 549;
                t3["Alpha"] = 722;
                t3["Beta"] = 667;
                t3["Chi"] = 722;
                t3["Delta"] = 612;
                t3["Epsilon"] = 611;
                t3["Phi"] = 763;
                t3["Gamma"] = 603;
                t3["Eta"] = 722;
                t3["Iota"] = 333;
                t3["theta1"] = 631;
                t3["Kappa"] = 722;
                t3["Lambda"] = 686;
                t3["Mu"] = 889;
                t3["Nu"] = 722;
                t3["Omicron"] = 722;
                t3["Pi"] = 768;
                t3["Theta"] = 741;
                t3["Rho"] = 556;
                t3["Sigma"] = 592;
                t3["Tau"] = 611;
                t3["Upsilon"] = 690;
                t3["sigma1"] = 439;
                t3["Omega"] = 768;
                t3["Xi"] = 645;
                t3["Psi"] = 795;
                t3["Zeta"] = 611;
                t3["bracketleft"] = 333;
                t3["therefore"] = 863;
                t3["bracketright"] = 333;
                t3["perpendicular"] = 658;
                t3["underscore"] = 500;
                t3["radicalex"] = 500;
                t3["alpha"] = 631;
                t3["beta"] = 549;
                t3["chi"] = 549;
                t3["delta"] = 494;
                t3["epsilon"] = 439;
                t3["phi"] = 521;
                t3["gamma"] = 411;
                t3["eta"] = 603;
                t3["iota"] = 329;
                t3["phi1"] = 603;
                t3["kappa"] = 549;
                t3["lambda"] = 549;
                t3["mu"] = 576;
                t3["nu"] = 521;
                t3["omicron"] = 549;
                t3["pi"] = 549;
                t3["theta"] = 521;
                t3["rho"] = 549;
                t3["sigma"] = 603;
                t3["tau"] = 439;
                t3["upsilon"] = 576;
                t3["omega1"] = 713;
                t3["omega"] = 686;
                t3["xi"] = 493;
                t3["psi"] = 686;
                t3["zeta"] = 494;
                t3["braceleft"] = 480;
                t3["bar"] = 200;
                t3["braceright"] = 480;
                t3["similar"] = 549;
                t3["Euro"] = 750;
                t3["Upsilon1"] = 620;
                t3["minute"] = 247;
                t3["lessequal"] = 549;
                t3["fraction"] = 167;
                t3["infinity"] = 713;
                t3["florin"] = 500;
                t3["club"] = 753;
                t3["diamond"] = 753;
                t3["heart"] = 753;
                t3["spade"] = 753;
                t3["arrowboth"] = 1042;
                t3["arrowleft"] = 987;
                t3["arrowup"] = 603;
                t3["arrowright"] = 987;
                t3["arrowdown"] = 603;
                t3["degree"] = 400;
                t3["plusminus"] = 549;
                t3["second"] = 411;
                t3["greaterequal"] = 549;
                t3["multiply"] = 549;
                t3["proportional"] = 713;
                t3["partialdiff"] = 494;
                t3["bullet"] = 460;
                t3["divide"] = 549;
                t3["notequal"] = 549;
                t3["equivalence"] = 549;
                t3["approxequal"] = 549;
                t3["ellipsis"] = 1e3;
                t3["arrowvertex"] = 603;
                t3["arrowhorizex"] = 1e3;
                t3["carriagereturn"] = 658;
                t3["aleph"] = 823;
                t3["Ifraktur"] = 686;
                t3["Rfraktur"] = 795;
                t3["weierstrass"] = 987;
                t3["circlemultiply"] = 768;
                t3["circleplus"] = 768;
                t3["emptyset"] = 823;
                t3["intersection"] = 768;
                t3["union"] = 768;
                t3["propersuperset"] = 713;
                t3["reflexsuperset"] = 713;
                t3["notsubset"] = 713;
                t3["propersubset"] = 713;
                t3["reflexsubset"] = 713;
                t3["element"] = 713;
                t3["notelement"] = 713;
                t3["angle"] = 768;
                t3["gradient"] = 713;
                t3["registerserif"] = 790;
                t3["copyrightserif"] = 790;
                t3["trademarkserif"] = 890;
                t3["product"] = 823;
                t3["radical"] = 549;
                t3["dotmath"] = 250;
                t3["logicalnot"] = 713;
                t3["logicaland"] = 603;
                t3["logicalor"] = 603;
                t3["arrowdblboth"] = 1042;
                t3["arrowdblleft"] = 987;
                t3["arrowdblup"] = 603;
                t3["arrowdblright"] = 987;
                t3["arrowdbldown"] = 603;
                t3["lozenge"] = 494;
                t3["angleleft"] = 329;
                t3["registersans"] = 790;
                t3["copyrightsans"] = 790;
                t3["trademarksans"] = 786;
                t3["summation"] = 713;
                t3["parenlefttp"] = 384;
                t3["parenleftex"] = 384;
                t3["parenleftbt"] = 384;
                t3["bracketlefttp"] = 384;
                t3["bracketleftex"] = 384;
                t3["bracketleftbt"] = 384;
                t3["bracelefttp"] = 494;
                t3["braceleftmid"] = 494;
                t3["braceleftbt"] = 494;
                t3["braceex"] = 494;
                t3["angleright"] = 329;
                t3["integral"] = 274;
                t3["integraltp"] = 686;
                t3["integralex"] = 686;
                t3["integralbt"] = 686;
                t3["parenrighttp"] = 384;
                t3["parenrightex"] = 384;
                t3["parenrightbt"] = 384;
                t3["bracketrighttp"] = 384;
                t3["bracketrightex"] = 384;
                t3["bracketrightbt"] = 384;
                t3["bracerighttp"] = 494;
                t3["bracerightmid"] = 494;
                t3["bracerightbt"] = 494;
                t3["apple"] = 790;
              });
              t2["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 250;
                t3["exclam"] = 333;
                t3["quotedbl"] = 408;
                t3["numbersign"] = 500;
                t3["dollar"] = 500;
                t3["percent"] = 833;
                t3["ampersand"] = 778;
                t3["quoteright"] = 333;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 500;
                t3["plus"] = 564;
                t3["comma"] = 250;
                t3["hyphen"] = 333;
                t3["period"] = 250;
                t3["slash"] = 278;
                t3["zero"] = 500;
                t3["one"] = 500;
                t3["two"] = 500;
                t3["three"] = 500;
                t3["four"] = 500;
                t3["five"] = 500;
                t3["six"] = 500;
                t3["seven"] = 500;
                t3["eight"] = 500;
                t3["nine"] = 500;
                t3["colon"] = 278;
                t3["semicolon"] = 278;
                t3["less"] = 564;
                t3["equal"] = 564;
                t3["greater"] = 564;
                t3["question"] = 444;
                t3["at"] = 921;
                t3["A"] = 722;
                t3["B"] = 667;
                t3["C"] = 667;
                t3["D"] = 722;
                t3["E"] = 611;
                t3["F"] = 556;
                t3["G"] = 722;
                t3["H"] = 722;
                t3["I"] = 333;
                t3["J"] = 389;
                t3["K"] = 722;
                t3["L"] = 611;
                t3["M"] = 889;
                t3["N"] = 722;
                t3["O"] = 722;
                t3["P"] = 556;
                t3["Q"] = 722;
                t3["R"] = 667;
                t3["S"] = 556;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 722;
                t3["W"] = 944;
                t3["X"] = 722;
                t3["Y"] = 722;
                t3["Z"] = 611;
                t3["bracketleft"] = 333;
                t3["backslash"] = 278;
                t3["bracketright"] = 333;
                t3["asciicircum"] = 469;
                t3["underscore"] = 500;
                t3["quoteleft"] = 333;
                t3["a"] = 444;
                t3["b"] = 500;
                t3["c"] = 444;
                t3["d"] = 500;
                t3["e"] = 444;
                t3["f"] = 333;
                t3["g"] = 500;
                t3["h"] = 500;
                t3["i"] = 278;
                t3["j"] = 278;
                t3["k"] = 500;
                t3["l"] = 278;
                t3["m"] = 778;
                t3["n"] = 500;
                t3["o"] = 500;
                t3["p"] = 500;
                t3["q"] = 500;
                t3["r"] = 333;
                t3["s"] = 389;
                t3["t"] = 278;
                t3["u"] = 500;
                t3["v"] = 500;
                t3["w"] = 722;
                t3["x"] = 500;
                t3["y"] = 500;
                t3["z"] = 444;
                t3["braceleft"] = 480;
                t3["bar"] = 200;
                t3["braceright"] = 480;
                t3["asciitilde"] = 541;
                t3["exclamdown"] = 333;
                t3["cent"] = 500;
                t3["sterling"] = 500;
                t3["fraction"] = 167;
                t3["yen"] = 500;
                t3["florin"] = 500;
                t3["section"] = 500;
                t3["currency"] = 500;
                t3["quotesingle"] = 180;
                t3["quotedblleft"] = 444;
                t3["guillemotleft"] = 500;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 556;
                t3["fl"] = 556;
                t3["endash"] = 500;
                t3["dagger"] = 500;
                t3["daggerdbl"] = 500;
                t3["periodcentered"] = 250;
                t3["paragraph"] = 453;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 333;
                t3["quotedblbase"] = 444;
                t3["quotedblright"] = 444;
                t3["guillemotright"] = 500;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 444;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 889;
                t3["ordfeminine"] = 276;
                t3["Lslash"] = 611;
                t3["Oslash"] = 722;
                t3["OE"] = 889;
                t3["ordmasculine"] = 310;
                t3["ae"] = 667;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 500;
                t3["oe"] = 722;
                t3["germandbls"] = 500;
                t3["Idieresis"] = 333;
                t3["eacute"] = 444;
                t3["abreve"] = 444;
                t3["uhungarumlaut"] = 500;
                t3["ecaron"] = 444;
                t3["Ydieresis"] = 722;
                t3["divide"] = 564;
                t3["Yacute"] = 722;
                t3["Acircumflex"] = 722;
                t3["aacute"] = 444;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 500;
                t3["scommaaccent"] = 389;
                t3["ecircumflex"] = 444;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 444;
                t3["Uacute"] = 722;
                t3["uogonek"] = 500;
                t3["Edieresis"] = 611;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 760;
                t3["Emacron"] = 611;
                t3["ccaron"] = 444;
                t3["aring"] = 444;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 278;
                t3["agrave"] = 444;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 667;
                t3["atilde"] = 444;
                t3["Edotaccent"] = 611;
                t3["scaron"] = 389;
                t3["scedilla"] = 389;
                t3["iacute"] = 278;
                t3["lozenge"] = 471;
                t3["Rcaron"] = 667;
                t3["Gcommaaccent"] = 722;
                t3["ucircumflex"] = 500;
                t3["acircumflex"] = 444;
                t3["Amacron"] = 722;
                t3["rcaron"] = 333;
                t3["ccedilla"] = 444;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 556;
                t3["Omacron"] = 722;
                t3["Racute"] = 667;
                t3["Sacute"] = 556;
                t3["dcaron"] = 588;
                t3["Umacron"] = 722;
                t3["uring"] = 500;
                t3["threesuperior"] = 300;
                t3["Ograve"] = 722;
                t3["Agrave"] = 722;
                t3["Abreve"] = 722;
                t3["multiply"] = 564;
                t3["uacute"] = 500;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 476;
                t3["ydieresis"] = 500;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 611;
                t3["adieresis"] = 444;
                t3["edieresis"] = 444;
                t3["cacute"] = 444;
                t3["nacute"] = 500;
                t3["umacron"] = 500;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 333;
                t3["plusminus"] = 564;
                t3["brokenbar"] = 200;
                t3["registered"] = 760;
                t3["Gbreve"] = 722;
                t3["Idotaccent"] = 333;
                t3["summation"] = 600;
                t3["Egrave"] = 611;
                t3["racute"] = 333;
                t3["omacron"] = 500;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 667;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 326;
                t3["eogonek"] = 444;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 722;
                t3["Adieresis"] = 722;
                t3["egrave"] = 444;
                t3["zacute"] = 444;
                t3["iogonek"] = 278;
                t3["Oacute"] = 722;
                t3["oacute"] = 500;
                t3["amacron"] = 444;
                t3["sacute"] = 389;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 722;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 500;
                t3["twosuperior"] = 300;
                t3["Odieresis"] = 722;
                t3["mu"] = 500;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 500;
                t3["Eogonek"] = 611;
                t3["dcroat"] = 500;
                t3["threequarters"] = 750;
                t3["Scedilla"] = 556;
                t3["lcaron"] = 344;
                t3["Kcommaaccent"] = 722;
                t3["Lacute"] = 611;
                t3["trademark"] = 980;
                t3["edotaccent"] = 444;
                t3["Igrave"] = 333;
                t3["Imacron"] = 333;
                t3["Lcaron"] = 611;
                t3["onehalf"] = 750;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 500;
                t3["ntilde"] = 500;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 611;
                t3["emacron"] = 444;
                t3["gbreve"] = 500;
                t3["onequarter"] = 750;
                t3["Scaron"] = 556;
                t3["Scommaaccent"] = 556;
                t3["Ohungarumlaut"] = 722;
                t3["degree"] = 400;
                t3["ograve"] = 500;
                t3["Ccaron"] = 667;
                t3["ugrave"] = 500;
                t3["radical"] = 453;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 333;
                t3["Ntilde"] = 722;
                t3["otilde"] = 500;
                t3["Rcommaaccent"] = 667;
                t3["Lcommaaccent"] = 611;
                t3["Atilde"] = 722;
                t3["Aogonek"] = 722;
                t3["Aring"] = 722;
                t3["Otilde"] = 722;
                t3["zdotaccent"] = 444;
                t3["Ecaron"] = 611;
                t3["Iogonek"] = 333;
                t3["kcommaaccent"] = 500;
                t3["minus"] = 564;
                t3["Icircumflex"] = 333;
                t3["ncaron"] = 500;
                t3["tcommaaccent"] = 278;
                t3["logicalnot"] = 564;
                t3["odieresis"] = 500;
                t3["udieresis"] = 500;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 500;
                t3["eth"] = 500;
                t3["zcaron"] = 444;
                t3["ncommaaccent"] = 500;
                t3["onesuperior"] = 300;
                t3["imacron"] = 278;
                t3["Euro"] = 500;
              });
              t2["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 250;
                t3["exclam"] = 333;
                t3["quotedbl"] = 555;
                t3["numbersign"] = 500;
                t3["dollar"] = 500;
                t3["percent"] = 1e3;
                t3["ampersand"] = 833;
                t3["quoteright"] = 333;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 500;
                t3["plus"] = 570;
                t3["comma"] = 250;
                t3["hyphen"] = 333;
                t3["period"] = 250;
                t3["slash"] = 278;
                t3["zero"] = 500;
                t3["one"] = 500;
                t3["two"] = 500;
                t3["three"] = 500;
                t3["four"] = 500;
                t3["five"] = 500;
                t3["six"] = 500;
                t3["seven"] = 500;
                t3["eight"] = 500;
                t3["nine"] = 500;
                t3["colon"] = 333;
                t3["semicolon"] = 333;
                t3["less"] = 570;
                t3["equal"] = 570;
                t3["greater"] = 570;
                t3["question"] = 500;
                t3["at"] = 930;
                t3["A"] = 722;
                t3["B"] = 667;
                t3["C"] = 722;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 611;
                t3["G"] = 778;
                t3["H"] = 778;
                t3["I"] = 389;
                t3["J"] = 500;
                t3["K"] = 778;
                t3["L"] = 667;
                t3["M"] = 944;
                t3["N"] = 722;
                t3["O"] = 778;
                t3["P"] = 611;
                t3["Q"] = 778;
                t3["R"] = 722;
                t3["S"] = 556;
                t3["T"] = 667;
                t3["U"] = 722;
                t3["V"] = 722;
                t3["W"] = 1e3;
                t3["X"] = 722;
                t3["Y"] = 722;
                t3["Z"] = 667;
                t3["bracketleft"] = 333;
                t3["backslash"] = 278;
                t3["bracketright"] = 333;
                t3["asciicircum"] = 581;
                t3["underscore"] = 500;
                t3["quoteleft"] = 333;
                t3["a"] = 500;
                t3["b"] = 556;
                t3["c"] = 444;
                t3["d"] = 556;
                t3["e"] = 444;
                t3["f"] = 333;
                t3["g"] = 500;
                t3["h"] = 556;
                t3["i"] = 278;
                t3["j"] = 333;
                t3["k"] = 556;
                t3["l"] = 278;
                t3["m"] = 833;
                t3["n"] = 556;
                t3["o"] = 500;
                t3["p"] = 556;
                t3["q"] = 556;
                t3["r"] = 444;
                t3["s"] = 389;
                t3["t"] = 333;
                t3["u"] = 556;
                t3["v"] = 500;
                t3["w"] = 722;
                t3["x"] = 500;
                t3["y"] = 500;
                t3["z"] = 444;
                t3["braceleft"] = 394;
                t3["bar"] = 220;
                t3["braceright"] = 394;
                t3["asciitilde"] = 520;
                t3["exclamdown"] = 333;
                t3["cent"] = 500;
                t3["sterling"] = 500;
                t3["fraction"] = 167;
                t3["yen"] = 500;
                t3["florin"] = 500;
                t3["section"] = 500;
                t3["currency"] = 500;
                t3["quotesingle"] = 278;
                t3["quotedblleft"] = 500;
                t3["guillemotleft"] = 500;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 556;
                t3["fl"] = 556;
                t3["endash"] = 500;
                t3["dagger"] = 500;
                t3["daggerdbl"] = 500;
                t3["periodcentered"] = 250;
                t3["paragraph"] = 540;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 333;
                t3["quotedblbase"] = 500;
                t3["quotedblright"] = 500;
                t3["guillemotright"] = 500;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 500;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 1e3;
                t3["ordfeminine"] = 300;
                t3["Lslash"] = 667;
                t3["Oslash"] = 778;
                t3["OE"] = 1e3;
                t3["ordmasculine"] = 330;
                t3["ae"] = 722;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 500;
                t3["oe"] = 722;
                t3["germandbls"] = 556;
                t3["Idieresis"] = 389;
                t3["eacute"] = 444;
                t3["abreve"] = 500;
                t3["uhungarumlaut"] = 556;
                t3["ecaron"] = 444;
                t3["Ydieresis"] = 722;
                t3["divide"] = 570;
                t3["Yacute"] = 722;
                t3["Acircumflex"] = 722;
                t3["aacute"] = 500;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 500;
                t3["scommaaccent"] = 389;
                t3["ecircumflex"] = 444;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 500;
                t3["Uacute"] = 722;
                t3["uogonek"] = 556;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 747;
                t3["Emacron"] = 667;
                t3["ccaron"] = 444;
                t3["aring"] = 500;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 278;
                t3["agrave"] = 500;
                t3["Tcommaaccent"] = 667;
                t3["Cacute"] = 722;
                t3["atilde"] = 500;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 389;
                t3["scedilla"] = 389;
                t3["iacute"] = 278;
                t3["lozenge"] = 494;
                t3["Rcaron"] = 722;
                t3["Gcommaaccent"] = 778;
                t3["ucircumflex"] = 556;
                t3["acircumflex"] = 500;
                t3["Amacron"] = 722;
                t3["rcaron"] = 444;
                t3["ccedilla"] = 444;
                t3["Zdotaccent"] = 667;
                t3["Thorn"] = 611;
                t3["Omacron"] = 778;
                t3["Racute"] = 722;
                t3["Sacute"] = 556;
                t3["dcaron"] = 672;
                t3["Umacron"] = 722;
                t3["uring"] = 556;
                t3["threesuperior"] = 300;
                t3["Ograve"] = 778;
                t3["Agrave"] = 722;
                t3["Abreve"] = 722;
                t3["multiply"] = 570;
                t3["uacute"] = 556;
                t3["Tcaron"] = 667;
                t3["partialdiff"] = 494;
                t3["ydieresis"] = 500;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 500;
                t3["edieresis"] = 444;
                t3["cacute"] = 444;
                t3["nacute"] = 556;
                t3["umacron"] = 556;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 389;
                t3["plusminus"] = 570;
                t3["brokenbar"] = 220;
                t3["registered"] = 747;
                t3["Gbreve"] = 778;
                t3["Idotaccent"] = 389;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 444;
                t3["omacron"] = 500;
                t3["Zacute"] = 667;
                t3["Zcaron"] = 667;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 722;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 416;
                t3["eogonek"] = 444;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 722;
                t3["Adieresis"] = 722;
                t3["egrave"] = 444;
                t3["zacute"] = 444;
                t3["iogonek"] = 278;
                t3["Oacute"] = 778;
                t3["oacute"] = 500;
                t3["amacron"] = 500;
                t3["sacute"] = 389;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 778;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 556;
                t3["twosuperior"] = 300;
                t3["Odieresis"] = 778;
                t3["mu"] = 556;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 500;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 556;
                t3["threequarters"] = 750;
                t3["Scedilla"] = 556;
                t3["lcaron"] = 394;
                t3["Kcommaaccent"] = 778;
                t3["Lacute"] = 667;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 444;
                t3["Igrave"] = 389;
                t3["Imacron"] = 389;
                t3["Lcaron"] = 667;
                t3["onehalf"] = 750;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 500;
                t3["ntilde"] = 556;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 444;
                t3["gbreve"] = 500;
                t3["onequarter"] = 750;
                t3["Scaron"] = 556;
                t3["Scommaaccent"] = 556;
                t3["Ohungarumlaut"] = 778;
                t3["degree"] = 400;
                t3["ograve"] = 500;
                t3["Ccaron"] = 722;
                t3["ugrave"] = 556;
                t3["radical"] = 549;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 444;
                t3["Ntilde"] = 722;
                t3["otilde"] = 500;
                t3["Rcommaaccent"] = 722;
                t3["Lcommaaccent"] = 667;
                t3["Atilde"] = 722;
                t3["Aogonek"] = 722;
                t3["Aring"] = 722;
                t3["Otilde"] = 778;
                t3["zdotaccent"] = 444;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 389;
                t3["kcommaaccent"] = 556;
                t3["minus"] = 570;
                t3["Icircumflex"] = 389;
                t3["ncaron"] = 556;
                t3["tcommaaccent"] = 333;
                t3["logicalnot"] = 570;
                t3["odieresis"] = 500;
                t3["udieresis"] = 556;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 500;
                t3["eth"] = 500;
                t3["zcaron"] = 444;
                t3["ncommaaccent"] = 556;
                t3["onesuperior"] = 300;
                t3["imacron"] = 278;
                t3["Euro"] = 500;
              });
              t2["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 250;
                t3["exclam"] = 389;
                t3["quotedbl"] = 555;
                t3["numbersign"] = 500;
                t3["dollar"] = 500;
                t3["percent"] = 833;
                t3["ampersand"] = 778;
                t3["quoteright"] = 333;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 500;
                t3["plus"] = 570;
                t3["comma"] = 250;
                t3["hyphen"] = 333;
                t3["period"] = 250;
                t3["slash"] = 278;
                t3["zero"] = 500;
                t3["one"] = 500;
                t3["two"] = 500;
                t3["three"] = 500;
                t3["four"] = 500;
                t3["five"] = 500;
                t3["six"] = 500;
                t3["seven"] = 500;
                t3["eight"] = 500;
                t3["nine"] = 500;
                t3["colon"] = 333;
                t3["semicolon"] = 333;
                t3["less"] = 570;
                t3["equal"] = 570;
                t3["greater"] = 570;
                t3["question"] = 500;
                t3["at"] = 832;
                t3["A"] = 667;
                t3["B"] = 667;
                t3["C"] = 667;
                t3["D"] = 722;
                t3["E"] = 667;
                t3["F"] = 667;
                t3["G"] = 722;
                t3["H"] = 778;
                t3["I"] = 389;
                t3["J"] = 500;
                t3["K"] = 667;
                t3["L"] = 611;
                t3["M"] = 889;
                t3["N"] = 722;
                t3["O"] = 722;
                t3["P"] = 611;
                t3["Q"] = 722;
                t3["R"] = 667;
                t3["S"] = 556;
                t3["T"] = 611;
                t3["U"] = 722;
                t3["V"] = 667;
                t3["W"] = 889;
                t3["X"] = 667;
                t3["Y"] = 611;
                t3["Z"] = 611;
                t3["bracketleft"] = 333;
                t3["backslash"] = 278;
                t3["bracketright"] = 333;
                t3["asciicircum"] = 570;
                t3["underscore"] = 500;
                t3["quoteleft"] = 333;
                t3["a"] = 500;
                t3["b"] = 500;
                t3["c"] = 444;
                t3["d"] = 500;
                t3["e"] = 444;
                t3["f"] = 333;
                t3["g"] = 500;
                t3["h"] = 556;
                t3["i"] = 278;
                t3["j"] = 278;
                t3["k"] = 500;
                t3["l"] = 278;
                t3["m"] = 778;
                t3["n"] = 556;
                t3["o"] = 500;
                t3["p"] = 500;
                t3["q"] = 500;
                t3["r"] = 389;
                t3["s"] = 389;
                t3["t"] = 278;
                t3["u"] = 556;
                t3["v"] = 444;
                t3["w"] = 667;
                t3["x"] = 500;
                t3["y"] = 444;
                t3["z"] = 389;
                t3["braceleft"] = 348;
                t3["bar"] = 220;
                t3["braceright"] = 348;
                t3["asciitilde"] = 570;
                t3["exclamdown"] = 389;
                t3["cent"] = 500;
                t3["sterling"] = 500;
                t3["fraction"] = 167;
                t3["yen"] = 500;
                t3["florin"] = 500;
                t3["section"] = 500;
                t3["currency"] = 500;
                t3["quotesingle"] = 278;
                t3["quotedblleft"] = 500;
                t3["guillemotleft"] = 500;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 556;
                t3["fl"] = 556;
                t3["endash"] = 500;
                t3["dagger"] = 500;
                t3["daggerdbl"] = 500;
                t3["periodcentered"] = 250;
                t3["paragraph"] = 500;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 333;
                t3["quotedblbase"] = 500;
                t3["quotedblright"] = 500;
                t3["guillemotright"] = 500;
                t3["ellipsis"] = 1e3;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 500;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 1e3;
                t3["AE"] = 944;
                t3["ordfeminine"] = 266;
                t3["Lslash"] = 611;
                t3["Oslash"] = 722;
                t3["OE"] = 944;
                t3["ordmasculine"] = 300;
                t3["ae"] = 722;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 500;
                t3["oe"] = 722;
                t3["germandbls"] = 500;
                t3["Idieresis"] = 389;
                t3["eacute"] = 444;
                t3["abreve"] = 500;
                t3["uhungarumlaut"] = 556;
                t3["ecaron"] = 444;
                t3["Ydieresis"] = 611;
                t3["divide"] = 570;
                t3["Yacute"] = 611;
                t3["Acircumflex"] = 667;
                t3["aacute"] = 500;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 444;
                t3["scommaaccent"] = 389;
                t3["ecircumflex"] = 444;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 500;
                t3["Uacute"] = 722;
                t3["uogonek"] = 556;
                t3["Edieresis"] = 667;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 747;
                t3["Emacron"] = 667;
                t3["ccaron"] = 444;
                t3["aring"] = 500;
                t3["Ncommaaccent"] = 722;
                t3["lacute"] = 278;
                t3["agrave"] = 500;
                t3["Tcommaaccent"] = 611;
                t3["Cacute"] = 667;
                t3["atilde"] = 500;
                t3["Edotaccent"] = 667;
                t3["scaron"] = 389;
                t3["scedilla"] = 389;
                t3["iacute"] = 278;
                t3["lozenge"] = 494;
                t3["Rcaron"] = 667;
                t3["Gcommaaccent"] = 722;
                t3["ucircumflex"] = 556;
                t3["acircumflex"] = 500;
                t3["Amacron"] = 667;
                t3["rcaron"] = 389;
                t3["ccedilla"] = 444;
                t3["Zdotaccent"] = 611;
                t3["Thorn"] = 611;
                t3["Omacron"] = 722;
                t3["Racute"] = 667;
                t3["Sacute"] = 556;
                t3["dcaron"] = 608;
                t3["Umacron"] = 722;
                t3["uring"] = 556;
                t3["threesuperior"] = 300;
                t3["Ograve"] = 722;
                t3["Agrave"] = 667;
                t3["Abreve"] = 667;
                t3["multiply"] = 570;
                t3["uacute"] = 556;
                t3["Tcaron"] = 611;
                t3["partialdiff"] = 494;
                t3["ydieresis"] = 444;
                t3["Nacute"] = 722;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 667;
                t3["adieresis"] = 500;
                t3["edieresis"] = 444;
                t3["cacute"] = 444;
                t3["nacute"] = 556;
                t3["umacron"] = 556;
                t3["Ncaron"] = 722;
                t3["Iacute"] = 389;
                t3["plusminus"] = 570;
                t3["brokenbar"] = 220;
                t3["registered"] = 747;
                t3["Gbreve"] = 722;
                t3["Idotaccent"] = 389;
                t3["summation"] = 600;
                t3["Egrave"] = 667;
                t3["racute"] = 389;
                t3["omacron"] = 500;
                t3["Zacute"] = 611;
                t3["Zcaron"] = 611;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 667;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 366;
                t3["eogonek"] = 444;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 667;
                t3["Adieresis"] = 667;
                t3["egrave"] = 444;
                t3["zacute"] = 389;
                t3["iogonek"] = 278;
                t3["Oacute"] = 722;
                t3["oacute"] = 500;
                t3["amacron"] = 500;
                t3["sacute"] = 389;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 722;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 500;
                t3["twosuperior"] = 300;
                t3["Odieresis"] = 722;
                t3["mu"] = 576;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 500;
                t3["Eogonek"] = 667;
                t3["dcroat"] = 500;
                t3["threequarters"] = 750;
                t3["Scedilla"] = 556;
                t3["lcaron"] = 382;
                t3["Kcommaaccent"] = 667;
                t3["Lacute"] = 611;
                t3["trademark"] = 1e3;
                t3["edotaccent"] = 444;
                t3["Igrave"] = 389;
                t3["Imacron"] = 389;
                t3["Lcaron"] = 611;
                t3["onehalf"] = 750;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 500;
                t3["ntilde"] = 556;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 667;
                t3["emacron"] = 444;
                t3["gbreve"] = 500;
                t3["onequarter"] = 750;
                t3["Scaron"] = 556;
                t3["Scommaaccent"] = 556;
                t3["Ohungarumlaut"] = 722;
                t3["degree"] = 400;
                t3["ograve"] = 500;
                t3["Ccaron"] = 667;
                t3["ugrave"] = 556;
                t3["radical"] = 549;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 389;
                t3["Ntilde"] = 722;
                t3["otilde"] = 500;
                t3["Rcommaaccent"] = 667;
                t3["Lcommaaccent"] = 611;
                t3["Atilde"] = 667;
                t3["Aogonek"] = 667;
                t3["Aring"] = 667;
                t3["Otilde"] = 722;
                t3["zdotaccent"] = 389;
                t3["Ecaron"] = 667;
                t3["Iogonek"] = 389;
                t3["kcommaaccent"] = 500;
                t3["minus"] = 606;
                t3["Icircumflex"] = 389;
                t3["ncaron"] = 556;
                t3["tcommaaccent"] = 278;
                t3["logicalnot"] = 606;
                t3["odieresis"] = 500;
                t3["udieresis"] = 556;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 500;
                t3["eth"] = 500;
                t3["zcaron"] = 389;
                t3["ncommaaccent"] = 556;
                t3["onesuperior"] = 300;
                t3["imacron"] = 278;
                t3["Euro"] = 500;
              });
              t2["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 250;
                t3["exclam"] = 333;
                t3["quotedbl"] = 420;
                t3["numbersign"] = 500;
                t3["dollar"] = 500;
                t3["percent"] = 833;
                t3["ampersand"] = 778;
                t3["quoteright"] = 333;
                t3["parenleft"] = 333;
                t3["parenright"] = 333;
                t3["asterisk"] = 500;
                t3["plus"] = 675;
                t3["comma"] = 250;
                t3["hyphen"] = 333;
                t3["period"] = 250;
                t3["slash"] = 278;
                t3["zero"] = 500;
                t3["one"] = 500;
                t3["two"] = 500;
                t3["three"] = 500;
                t3["four"] = 500;
                t3["five"] = 500;
                t3["six"] = 500;
                t3["seven"] = 500;
                t3["eight"] = 500;
                t3["nine"] = 500;
                t3["colon"] = 333;
                t3["semicolon"] = 333;
                t3["less"] = 675;
                t3["equal"] = 675;
                t3["greater"] = 675;
                t3["question"] = 500;
                t3["at"] = 920;
                t3["A"] = 611;
                t3["B"] = 611;
                t3["C"] = 667;
                t3["D"] = 722;
                t3["E"] = 611;
                t3["F"] = 611;
                t3["G"] = 722;
                t3["H"] = 722;
                t3["I"] = 333;
                t3["J"] = 444;
                t3["K"] = 667;
                t3["L"] = 556;
                t3["M"] = 833;
                t3["N"] = 667;
                t3["O"] = 722;
                t3["P"] = 611;
                t3["Q"] = 722;
                t3["R"] = 611;
                t3["S"] = 500;
                t3["T"] = 556;
                t3["U"] = 722;
                t3["V"] = 611;
                t3["W"] = 833;
                t3["X"] = 611;
                t3["Y"] = 556;
                t3["Z"] = 556;
                t3["bracketleft"] = 389;
                t3["backslash"] = 278;
                t3["bracketright"] = 389;
                t3["asciicircum"] = 422;
                t3["underscore"] = 500;
                t3["quoteleft"] = 333;
                t3["a"] = 500;
                t3["b"] = 500;
                t3["c"] = 444;
                t3["d"] = 500;
                t3["e"] = 444;
                t3["f"] = 278;
                t3["g"] = 500;
                t3["h"] = 500;
                t3["i"] = 278;
                t3["j"] = 278;
                t3["k"] = 444;
                t3["l"] = 278;
                t3["m"] = 722;
                t3["n"] = 500;
                t3["o"] = 500;
                t3["p"] = 500;
                t3["q"] = 500;
                t3["r"] = 389;
                t3["s"] = 389;
                t3["t"] = 278;
                t3["u"] = 500;
                t3["v"] = 444;
                t3["w"] = 667;
                t3["x"] = 444;
                t3["y"] = 444;
                t3["z"] = 389;
                t3["braceleft"] = 400;
                t3["bar"] = 275;
                t3["braceright"] = 400;
                t3["asciitilde"] = 541;
                t3["exclamdown"] = 389;
                t3["cent"] = 500;
                t3["sterling"] = 500;
                t3["fraction"] = 167;
                t3["yen"] = 500;
                t3["florin"] = 500;
                t3["section"] = 500;
                t3["currency"] = 500;
                t3["quotesingle"] = 214;
                t3["quotedblleft"] = 556;
                t3["guillemotleft"] = 500;
                t3["guilsinglleft"] = 333;
                t3["guilsinglright"] = 333;
                t3["fi"] = 500;
                t3["fl"] = 500;
                t3["endash"] = 500;
                t3["dagger"] = 500;
                t3["daggerdbl"] = 500;
                t3["periodcentered"] = 250;
                t3["paragraph"] = 523;
                t3["bullet"] = 350;
                t3["quotesinglbase"] = 333;
                t3["quotedblbase"] = 556;
                t3["quotedblright"] = 556;
                t3["guillemotright"] = 500;
                t3["ellipsis"] = 889;
                t3["perthousand"] = 1e3;
                t3["questiondown"] = 500;
                t3["grave"] = 333;
                t3["acute"] = 333;
                t3["circumflex"] = 333;
                t3["tilde"] = 333;
                t3["macron"] = 333;
                t3["breve"] = 333;
                t3["dotaccent"] = 333;
                t3["dieresis"] = 333;
                t3["ring"] = 333;
                t3["cedilla"] = 333;
                t3["hungarumlaut"] = 333;
                t3["ogonek"] = 333;
                t3["caron"] = 333;
                t3["emdash"] = 889;
                t3["AE"] = 889;
                t3["ordfeminine"] = 276;
                t3["Lslash"] = 556;
                t3["Oslash"] = 722;
                t3["OE"] = 944;
                t3["ordmasculine"] = 310;
                t3["ae"] = 667;
                t3["dotlessi"] = 278;
                t3["lslash"] = 278;
                t3["oslash"] = 500;
                t3["oe"] = 667;
                t3["germandbls"] = 500;
                t3["Idieresis"] = 333;
                t3["eacute"] = 444;
                t3["abreve"] = 500;
                t3["uhungarumlaut"] = 500;
                t3["ecaron"] = 444;
                t3["Ydieresis"] = 556;
                t3["divide"] = 675;
                t3["Yacute"] = 556;
                t3["Acircumflex"] = 611;
                t3["aacute"] = 500;
                t3["Ucircumflex"] = 722;
                t3["yacute"] = 444;
                t3["scommaaccent"] = 389;
                t3["ecircumflex"] = 444;
                t3["Uring"] = 722;
                t3["Udieresis"] = 722;
                t3["aogonek"] = 500;
                t3["Uacute"] = 722;
                t3["uogonek"] = 500;
                t3["Edieresis"] = 611;
                t3["Dcroat"] = 722;
                t3["commaaccent"] = 250;
                t3["copyright"] = 760;
                t3["Emacron"] = 611;
                t3["ccaron"] = 444;
                t3["aring"] = 500;
                t3["Ncommaaccent"] = 667;
                t3["lacute"] = 278;
                t3["agrave"] = 500;
                t3["Tcommaaccent"] = 556;
                t3["Cacute"] = 667;
                t3["atilde"] = 500;
                t3["Edotaccent"] = 611;
                t3["scaron"] = 389;
                t3["scedilla"] = 389;
                t3["iacute"] = 278;
                t3["lozenge"] = 471;
                t3["Rcaron"] = 611;
                t3["Gcommaaccent"] = 722;
                t3["ucircumflex"] = 500;
                t3["acircumflex"] = 500;
                t3["Amacron"] = 611;
                t3["rcaron"] = 389;
                t3["ccedilla"] = 444;
                t3["Zdotaccent"] = 556;
                t3["Thorn"] = 611;
                t3["Omacron"] = 722;
                t3["Racute"] = 611;
                t3["Sacute"] = 500;
                t3["dcaron"] = 544;
                t3["Umacron"] = 722;
                t3["uring"] = 500;
                t3["threesuperior"] = 300;
                t3["Ograve"] = 722;
                t3["Agrave"] = 611;
                t3["Abreve"] = 611;
                t3["multiply"] = 675;
                t3["uacute"] = 500;
                t3["Tcaron"] = 556;
                t3["partialdiff"] = 476;
                t3["ydieresis"] = 444;
                t3["Nacute"] = 667;
                t3["icircumflex"] = 278;
                t3["Ecircumflex"] = 611;
                t3["adieresis"] = 500;
                t3["edieresis"] = 444;
                t3["cacute"] = 444;
                t3["nacute"] = 500;
                t3["umacron"] = 500;
                t3["Ncaron"] = 667;
                t3["Iacute"] = 333;
                t3["plusminus"] = 675;
                t3["brokenbar"] = 275;
                t3["registered"] = 760;
                t3["Gbreve"] = 722;
                t3["Idotaccent"] = 333;
                t3["summation"] = 600;
                t3["Egrave"] = 611;
                t3["racute"] = 389;
                t3["omacron"] = 500;
                t3["Zacute"] = 556;
                t3["Zcaron"] = 556;
                t3["greaterequal"] = 549;
                t3["Eth"] = 722;
                t3["Ccedilla"] = 667;
                t3["lcommaaccent"] = 278;
                t3["tcaron"] = 300;
                t3["eogonek"] = 444;
                t3["Uogonek"] = 722;
                t3["Aacute"] = 611;
                t3["Adieresis"] = 611;
                t3["egrave"] = 444;
                t3["zacute"] = 389;
                t3["iogonek"] = 278;
                t3["Oacute"] = 722;
                t3["oacute"] = 500;
                t3["amacron"] = 500;
                t3["sacute"] = 389;
                t3["idieresis"] = 278;
                t3["Ocircumflex"] = 722;
                t3["Ugrave"] = 722;
                t3["Delta"] = 612;
                t3["thorn"] = 500;
                t3["twosuperior"] = 300;
                t3["Odieresis"] = 722;
                t3["mu"] = 500;
                t3["igrave"] = 278;
                t3["ohungarumlaut"] = 500;
                t3["Eogonek"] = 611;
                t3["dcroat"] = 500;
                t3["threequarters"] = 750;
                t3["Scedilla"] = 500;
                t3["lcaron"] = 300;
                t3["Kcommaaccent"] = 667;
                t3["Lacute"] = 556;
                t3["trademark"] = 980;
                t3["edotaccent"] = 444;
                t3["Igrave"] = 333;
                t3["Imacron"] = 333;
                t3["Lcaron"] = 611;
                t3["onehalf"] = 750;
                t3["lessequal"] = 549;
                t3["ocircumflex"] = 500;
                t3["ntilde"] = 500;
                t3["Uhungarumlaut"] = 722;
                t3["Eacute"] = 611;
                t3["emacron"] = 444;
                t3["gbreve"] = 500;
                t3["onequarter"] = 750;
                t3["Scaron"] = 500;
                t3["Scommaaccent"] = 500;
                t3["Ohungarumlaut"] = 722;
                t3["degree"] = 400;
                t3["ograve"] = 500;
                t3["Ccaron"] = 667;
                t3["ugrave"] = 500;
                t3["radical"] = 453;
                t3["Dcaron"] = 722;
                t3["rcommaaccent"] = 389;
                t3["Ntilde"] = 667;
                t3["otilde"] = 500;
                t3["Rcommaaccent"] = 611;
                t3["Lcommaaccent"] = 556;
                t3["Atilde"] = 611;
                t3["Aogonek"] = 611;
                t3["Aring"] = 611;
                t3["Otilde"] = 722;
                t3["zdotaccent"] = 389;
                t3["Ecaron"] = 611;
                t3["Iogonek"] = 333;
                t3["kcommaaccent"] = 444;
                t3["minus"] = 675;
                t3["Icircumflex"] = 333;
                t3["ncaron"] = 500;
                t3["tcommaaccent"] = 278;
                t3["logicalnot"] = 675;
                t3["odieresis"] = 500;
                t3["udieresis"] = 500;
                t3["notequal"] = 549;
                t3["gcommaaccent"] = 500;
                t3["eth"] = 500;
                t3["zcaron"] = 389;
                t3["ncommaaccent"] = 500;
                t3["onesuperior"] = 300;
                t3["imacron"] = 278;
                t3["Euro"] = 500;
              });
              t2["ZapfDingbats"] = (0, _core_utils.getLookupTableFactory)(function(t3) {
                t3["space"] = 278;
                t3["a1"] = 974;
                t3["a2"] = 961;
                t3["a202"] = 974;
                t3["a3"] = 980;
                t3["a4"] = 719;
                t3["a5"] = 789;
                t3["a119"] = 790;
                t3["a118"] = 791;
                t3["a117"] = 690;
                t3["a11"] = 960;
                t3["a12"] = 939;
                t3["a13"] = 549;
                t3["a14"] = 855;
                t3["a15"] = 911;
                t3["a16"] = 933;
                t3["a105"] = 911;
                t3["a17"] = 945;
                t3["a18"] = 974;
                t3["a19"] = 755;
                t3["a20"] = 846;
                t3["a21"] = 762;
                t3["a22"] = 761;
                t3["a23"] = 571;
                t3["a24"] = 677;
                t3["a25"] = 763;
                t3["a26"] = 760;
                t3["a27"] = 759;
                t3["a28"] = 754;
                t3["a6"] = 494;
                t3["a7"] = 552;
                t3["a8"] = 537;
                t3["a9"] = 577;
                t3["a10"] = 692;
                t3["a29"] = 786;
                t3["a30"] = 788;
                t3["a31"] = 788;
                t3["a32"] = 790;
                t3["a33"] = 793;
                t3["a34"] = 794;
                t3["a35"] = 816;
                t3["a36"] = 823;
                t3["a37"] = 789;
                t3["a38"] = 841;
                t3["a39"] = 823;
                t3["a40"] = 833;
                t3["a41"] = 816;
                t3["a42"] = 831;
                t3["a43"] = 923;
                t3["a44"] = 744;
                t3["a45"] = 723;
                t3["a46"] = 749;
                t3["a47"] = 790;
                t3["a48"] = 792;
                t3["a49"] = 695;
                t3["a50"] = 776;
                t3["a51"] = 768;
                t3["a52"] = 792;
                t3["a53"] = 759;
                t3["a54"] = 707;
                t3["a55"] = 708;
                t3["a56"] = 682;
                t3["a57"] = 701;
                t3["a58"] = 826;
                t3["a59"] = 815;
                t3["a60"] = 789;
                t3["a61"] = 789;
                t3["a62"] = 707;
                t3["a63"] = 687;
                t3["a64"] = 696;
                t3["a65"] = 689;
                t3["a66"] = 786;
                t3["a67"] = 787;
                t3["a68"] = 713;
                t3["a69"] = 791;
                t3["a70"] = 785;
                t3["a71"] = 791;
                t3["a72"] = 873;
                t3["a73"] = 761;
                t3["a74"] = 762;
                t3["a203"] = 762;
                t3["a75"] = 759;
                t3["a204"] = 759;
                t3["a76"] = 892;
                t3["a77"] = 892;
                t3["a78"] = 788;
                t3["a79"] = 784;
                t3["a81"] = 438;
                t3["a82"] = 138;
                t3["a83"] = 277;
                t3["a84"] = 415;
                t3["a97"] = 392;
                t3["a98"] = 392;
                t3["a99"] = 668;
                t3["a100"] = 668;
                t3["a89"] = 390;
                t3["a90"] = 390;
                t3["a93"] = 317;
                t3["a94"] = 317;
                t3["a91"] = 276;
                t3["a92"] = 276;
                t3["a205"] = 509;
                t3["a85"] = 509;
                t3["a206"] = 410;
                t3["a86"] = 410;
                t3["a87"] = 234;
                t3["a88"] = 234;
                t3["a95"] = 334;
                t3["a96"] = 334;
                t3["a101"] = 732;
                t3["a102"] = 544;
                t3["a103"] = 544;
                t3["a104"] = 910;
                t3["a106"] = 667;
                t3["a107"] = 760;
                t3["a108"] = 760;
                t3["a112"] = 776;
                t3["a111"] = 595;
                t3["a110"] = 694;
                t3["a109"] = 626;
                t3["a120"] = 788;
                t3["a121"] = 788;
                t3["a122"] = 788;
                t3["a123"] = 788;
                t3["a124"] = 788;
                t3["a125"] = 788;
                t3["a126"] = 788;
                t3["a127"] = 788;
                t3["a128"] = 788;
                t3["a129"] = 788;
                t3["a130"] = 788;
                t3["a131"] = 788;
                t3["a132"] = 788;
                t3["a133"] = 788;
                t3["a134"] = 788;
                t3["a135"] = 788;
                t3["a136"] = 788;
                t3["a137"] = 788;
                t3["a138"] = 788;
                t3["a139"] = 788;
                t3["a140"] = 788;
                t3["a141"] = 788;
                t3["a142"] = 788;
                t3["a143"] = 788;
                t3["a144"] = 788;
                t3["a145"] = 788;
                t3["a146"] = 788;
                t3["a147"] = 788;
                t3["a148"] = 788;
                t3["a149"] = 788;
                t3["a150"] = 788;
                t3["a151"] = 788;
                t3["a152"] = 788;
                t3["a153"] = 788;
                t3["a154"] = 788;
                t3["a155"] = 788;
                t3["a156"] = 788;
                t3["a157"] = 788;
                t3["a158"] = 788;
                t3["a159"] = 788;
                t3["a160"] = 894;
                t3["a161"] = 838;
                t3["a163"] = 1016;
                t3["a164"] = 458;
                t3["a196"] = 748;
                t3["a165"] = 924;
                t3["a192"] = 748;
                t3["a166"] = 918;
                t3["a167"] = 927;
                t3["a168"] = 928;
                t3["a169"] = 928;
                t3["a170"] = 834;
                t3["a171"] = 873;
                t3["a172"] = 828;
                t3["a173"] = 924;
                t3["a162"] = 924;
                t3["a174"] = 917;
                t3["a175"] = 930;
                t3["a176"] = 931;
                t3["a177"] = 463;
                t3["a178"] = 883;
                t3["a179"] = 836;
                t3["a193"] = 836;
                t3["a180"] = 867;
                t3["a199"] = 867;
                t3["a181"] = 696;
                t3["a200"] = 696;
                t3["a182"] = 874;
                t3["a201"] = 874;
                t3["a183"] = 760;
                t3["a184"] = 946;
                t3["a197"] = 771;
                t3["a185"] = 865;
                t3["a194"] = 771;
                t3["a198"] = 888;
                t3["a186"] = 967;
                t3["a195"] = 888;
                t3["a187"] = 831;
                t3["a188"] = 873;
                t3["a189"] = 927;
                t3["a190"] = 970;
                t3["a191"] = 918;
              });
            });
            exports3.getMetrics = getMetrics;
          },
          /* 39 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.isPDFFunction = isPDFFunction;
            exports3.PostScriptCompiler = exports3.PostScriptEvaluator = exports3.PDFFunctionFactory = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _ps_parser = __w_pdfjs_require__2(40);
            class PDFFunctionFactory {
              constructor({
                xref,
                isEvalSupported = true
              }) {
                this.xref = xref;
                this.isEvalSupported = isEvalSupported !== false;
              }
              create(fn) {
                return PDFFunction.parse({
                  xref: this.xref,
                  isEvalSupported: this.isEvalSupported,
                  fn
                });
              }
              createFromArray(fnObj) {
                return PDFFunction.parseArray({
                  xref: this.xref,
                  isEvalSupported: this.isEvalSupported,
                  fnObj
                });
              }
            }
            exports3.PDFFunctionFactory = PDFFunctionFactory;
            function toNumberArray(arr) {
              if (!Array.isArray(arr)) {
                return null;
              }
              const length = arr.length;
              for (let i2 = 0; i2 < length; i2++) {
                if (typeof arr[i2] !== "number") {
                  const result = new Array(length);
                  for (let i3 = 0; i3 < length; i3++) {
                    result[i3] = +arr[i3];
                  }
                  return result;
                }
              }
              return arr;
            }
            var PDFFunction = function PDFFunctionClosure() {
              const CONSTRUCT_SAMPLED = 0;
              const CONSTRUCT_INTERPOLATED = 2;
              const CONSTRUCT_STICHED = 3;
              const CONSTRUCT_POSTSCRIPT = 4;
              return {
                getSampleArray(size, outputSize, bps, stream) {
                  var i2, ii;
                  var length = 1;
                  for (i2 = 0, ii = size.length; i2 < ii; i2++) {
                    length *= size[i2];
                  }
                  length *= outputSize;
                  var array = new Array(length);
                  var codeSize = 0;
                  var codeBuf = 0;
                  var sampleMul = 1 / (2 ** bps - 1);
                  var strBytes = stream.getBytes((length * bps + 7) / 8);
                  var strIdx = 0;
                  for (i2 = 0; i2 < length; i2++) {
                    while (codeSize < bps) {
                      codeBuf <<= 8;
                      codeBuf |= strBytes[strIdx++];
                      codeSize += 8;
                    }
                    codeSize -= bps;
                    array[i2] = (codeBuf >> codeSize) * sampleMul;
                    codeBuf &= (1 << codeSize) - 1;
                  }
                  return array;
                },
                getIR({
                  xref,
                  isEvalSupported,
                  fn
                }) {
                  var dict = fn.dict;
                  if (!dict) {
                    dict = fn;
                  }
                  var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
                  var typeNum = dict.get("FunctionType");
                  var typeFn = types[typeNum];
                  if (!typeFn) {
                    throw new _util2.FormatError("Unknown type of function");
                  }
                  return typeFn.call(this, {
                    xref,
                    isEvalSupported,
                    fn,
                    dict
                  });
                },
                fromIR({
                  xref,
                  isEvalSupported,
                  IR
                }) {
                  var type = IR[0];
                  switch (type) {
                    case CONSTRUCT_SAMPLED:
                      return this.constructSampledFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    case CONSTRUCT_INTERPOLATED:
                      return this.constructInterpolatedFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    case CONSTRUCT_STICHED:
                      return this.constructStichedFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    default:
                      return this.constructPostScriptFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                  }
                },
                parse({
                  xref,
                  isEvalSupported,
                  fn
                }) {
                  const IR = this.getIR({
                    xref,
                    isEvalSupported,
                    fn
                  });
                  return this.fromIR({
                    xref,
                    isEvalSupported,
                    IR
                  });
                },
                parseArray({
                  xref,
                  isEvalSupported,
                  fnObj
                }) {
                  if (!Array.isArray(fnObj)) {
                    return this.parse({
                      xref,
                      isEvalSupported,
                      fn: fnObj
                    });
                  }
                  var fnArray = [];
                  for (var j2 = 0, jj = fnObj.length; j2 < jj; j2++) {
                    fnArray.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnObj[j2])
                    }));
                  }
                  return function(src, srcOffset, dest, destOffset) {
                    for (var i2 = 0, ii = fnArray.length; i2 < ii; i2++) {
                      fnArray[i2](src, srcOffset, dest, destOffset + i2);
                    }
                  };
                },
                constructSampled({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  function toMultiArray(arr) {
                    var inputLength = arr.length;
                    var out = [];
                    var index = 0;
                    for (var i3 = 0; i3 < inputLength; i3 += 2) {
                      out[index] = [arr[i3], arr[i3 + 1]];
                      ++index;
                    }
                    return out;
                  }
                  var domain = toNumberArray(dict.getArray("Domain"));
                  var range = toNumberArray(dict.getArray("Range"));
                  if (!domain || !range) {
                    throw new _util2.FormatError("No domain or range");
                  }
                  var inputSize = domain.length / 2;
                  var outputSize = range.length / 2;
                  domain = toMultiArray(domain);
                  range = toMultiArray(range);
                  var size = toNumberArray(dict.getArray("Size"));
                  var bps = dict.get("BitsPerSample");
                  var order = dict.get("Order") || 1;
                  if (order !== 1) {
                    (0, _util2.info)("No support for cubic spline interpolation: " + order);
                  }
                  var encode = toNumberArray(dict.getArray("Encode"));
                  if (!encode) {
                    encode = [];
                    for (var i2 = 0; i2 < inputSize; ++i2) {
                      encode.push([0, size[i2] - 1]);
                    }
                  } else {
                    encode = toMultiArray(encode);
                  }
                  var decode = toNumberArray(dict.getArray("Decode"));
                  if (!decode) {
                    decode = range;
                  } else {
                    decode = toMultiArray(decode);
                  }
                  var samples = this.getSampleArray(size, outputSize, bps, fn);
                  return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, 2 ** bps - 1, range];
                },
                constructSampledFromIR({
                  xref,
                  isEvalSupported,
                  IR
                }) {
                  function interpolate(x2, xmin, xmax, ymin, ymax) {
                    return ymin + (x2 - xmin) * ((ymax - ymin) / (xmax - xmin));
                  }
                  return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
                    var m = IR[1];
                    var domain = IR[2];
                    var encode = IR[3];
                    var decode = IR[4];
                    var samples = IR[5];
                    var size = IR[6];
                    var n2 = IR[7];
                    var range = IR[9];
                    var cubeVertices = 1 << m;
                    var cubeN = new Float64Array(cubeVertices);
                    var cubeVertex = new Uint32Array(cubeVertices);
                    var i2, j2;
                    for (j2 = 0; j2 < cubeVertices; j2++) {
                      cubeN[j2] = 1;
                    }
                    var k2 = n2, pos = 1;
                    for (i2 = 0; i2 < m; ++i2) {
                      var domain_2i = domain[i2][0];
                      var domain_2i_1 = domain[i2][1];
                      var xi = Math.min(Math.max(src[srcOffset + i2], domain_2i), domain_2i_1);
                      var e2 = interpolate(xi, domain_2i, domain_2i_1, encode[i2][0], encode[i2][1]);
                      var size_i = size[i2];
                      e2 = Math.min(Math.max(e2, 0), size_i - 1);
                      var e0 = e2 < size_i - 1 ? Math.floor(e2) : e2 - 1;
                      var n0 = e0 + 1 - e2;
                      var n1 = e2 - e0;
                      var offset0 = e0 * k2;
                      var offset1 = offset0 + k2;
                      for (j2 = 0; j2 < cubeVertices; j2++) {
                        if (j2 & pos) {
                          cubeN[j2] *= n1;
                          cubeVertex[j2] += offset1;
                        } else {
                          cubeN[j2] *= n0;
                          cubeVertex[j2] += offset0;
                        }
                      }
                      k2 *= size_i;
                      pos <<= 1;
                    }
                    for (j2 = 0; j2 < n2; ++j2) {
                      var rj = 0;
                      for (i2 = 0; i2 < cubeVertices; i2++) {
                        rj += samples[cubeVertex[i2] + j2] * cubeN[i2];
                      }
                      rj = interpolate(rj, 0, 1, decode[j2][0], decode[j2][1]);
                      dest[destOffset + j2] = Math.min(Math.max(rj, range[j2][0]), range[j2][1]);
                    }
                  };
                },
                constructInterpolated({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  var c0 = toNumberArray(dict.getArray("C0")) || [0];
                  var c1 = toNumberArray(dict.getArray("C1")) || [1];
                  var n2 = dict.get("N");
                  var length = c0.length;
                  var diff = [];
                  for (var i2 = 0; i2 < length; ++i2) {
                    diff.push(c1[i2] - c0[i2]);
                  }
                  return [CONSTRUCT_INTERPOLATED, c0, diff, n2];
                },
                constructInterpolatedFromIR({
                  xref,
                  isEvalSupported,
                  IR
                }) {
                  var c0 = IR[1];
                  var diff = IR[2];
                  var n2 = IR[3];
                  var length = diff.length;
                  return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
                    var x2 = n2 === 1 ? src[srcOffset] : src[srcOffset] ** n2;
                    for (var j2 = 0; j2 < length; ++j2) {
                      dest[destOffset + j2] = c0[j2] + x2 * diff[j2];
                    }
                  };
                },
                constructStiched({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  var domain = toNumberArray(dict.getArray("Domain"));
                  if (!domain) {
                    throw new _util2.FormatError("No domain");
                  }
                  var inputSize = domain.length / 2;
                  if (inputSize !== 1) {
                    throw new _util2.FormatError("Bad domain for stiched function");
                  }
                  var fnRefs = dict.get("Functions");
                  var fns = [];
                  for (var i2 = 0, ii = fnRefs.length; i2 < ii; ++i2) {
                    fns.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnRefs[i2])
                    }));
                  }
                  var bounds = toNumberArray(dict.getArray("Bounds"));
                  var encode = toNumberArray(dict.getArray("Encode"));
                  return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
                },
                constructStichedFromIR({
                  xref,
                  isEvalSupported,
                  IR
                }) {
                  var domain = IR[1];
                  var bounds = IR[2];
                  var encode = IR[3];
                  var fns = IR[4];
                  var tmpBuf = new Float32Array(1);
                  return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
                    var clip = function constructStichedFromIRClip(v3, min, max) {
                      if (v3 > max) {
                        v3 = max;
                      } else if (v3 < min) {
                        v3 = min;
                      }
                      return v3;
                    };
                    var v2 = clip(src[srcOffset], domain[0], domain[1]);
                    for (var i2 = 0, ii = bounds.length; i2 < ii; ++i2) {
                      if (v2 < bounds[i2]) {
                        break;
                      }
                    }
                    var dmin = domain[0];
                    if (i2 > 0) {
                      dmin = bounds[i2 - 1];
                    }
                    var dmax = domain[1];
                    if (i2 < bounds.length) {
                      dmax = bounds[i2];
                    }
                    var rmin = encode[2 * i2];
                    var rmax = encode[2 * i2 + 1];
                    tmpBuf[0] = dmin === dmax ? rmin : rmin + (v2 - dmin) * (rmax - rmin) / (dmax - dmin);
                    fns[i2](tmpBuf, 0, dest, destOffset);
                  };
                },
                constructPostScript({
                  xref,
                  isEvalSupported,
                  fn,
                  dict
                }) {
                  var domain = toNumberArray(dict.getArray("Domain"));
                  var range = toNumberArray(dict.getArray("Range"));
                  if (!domain) {
                    throw new _util2.FormatError("No domain.");
                  }
                  if (!range) {
                    throw new _util2.FormatError("No range.");
                  }
                  var lexer = new _ps_parser.PostScriptLexer(fn);
                  var parser = new _ps_parser.PostScriptParser(lexer);
                  var code = parser.parse();
                  return [CONSTRUCT_POSTSCRIPT, domain, range, code];
                },
                constructPostScriptFromIR({
                  xref,
                  isEvalSupported,
                  IR
                }) {
                  var domain = IR[1];
                  var range = IR[2];
                  var code = IR[3];
                  if (isEvalSupported && _util2.IsEvalSupportedCached.value) {
                    const compiled = new PostScriptCompiler().compile(code, domain, range);
                    if (compiled) {
                      return new Function("src", "srcOffset", "dest", "destOffset", compiled);
                    }
                  }
                  (0, _util2.info)("Unable to compile PS function");
                  var numOutputs = range.length >> 1;
                  var numInputs = domain.length >> 1;
                  var evaluator = new PostScriptEvaluator(code);
                  var cache = /* @__PURE__ */ Object.create(null);
                  var MAX_CACHE_SIZE = 2048 * 4;
                  var cache_available = MAX_CACHE_SIZE;
                  var tmpBuf = new Float32Array(numInputs);
                  return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
                    var i2, value;
                    var key = "";
                    var input = tmpBuf;
                    for (i2 = 0; i2 < numInputs; i2++) {
                      value = src[srcOffset + i2];
                      input[i2] = value;
                      key += value + "_";
                    }
                    var cachedValue = cache[key];
                    if (cachedValue !== void 0) {
                      dest.set(cachedValue, destOffset);
                      return;
                    }
                    var output = new Float32Array(numOutputs);
                    var stack = evaluator.execute(input);
                    var stackIndex = stack.length - numOutputs;
                    for (i2 = 0; i2 < numOutputs; i2++) {
                      value = stack[stackIndex + i2];
                      var bound = range[i2 * 2];
                      if (value < bound) {
                        value = bound;
                      } else {
                        bound = range[i2 * 2 + 1];
                        if (value > bound) {
                          value = bound;
                        }
                      }
                      output[i2] = value;
                    }
                    if (cache_available > 0) {
                      cache_available--;
                      cache[key] = output;
                    }
                    dest.set(output, destOffset);
                  };
                }
              };
            }();
            function isPDFFunction(v2) {
              var fnDict;
              if (typeof v2 !== "object") {
                return false;
              } else if ((0, _primitives.isDict)(v2)) {
                fnDict = v2;
              } else if ((0, _primitives.isStream)(v2)) {
                fnDict = v2.dict;
              } else {
                return false;
              }
              return fnDict.has("FunctionType");
            }
            var PostScriptStack = function PostScriptStackClosure() {
              var MAX_STACK_SIZE = 100;
              function PostScriptStack2(initialStack) {
                this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
              }
              PostScriptStack2.prototype = {
                push: function PostScriptStack_push(value) {
                  if (this.stack.length >= MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  this.stack.push(value);
                },
                pop: function PostScriptStack_pop() {
                  if (this.stack.length <= 0) {
                    throw new Error("PostScript function stack underflow.");
                  }
                  return this.stack.pop();
                },
                copy: function PostScriptStack_copy(n2) {
                  if (this.stack.length + n2 >= MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  var stack = this.stack;
                  for (var i2 = stack.length - n2, j2 = n2 - 1; j2 >= 0; j2--, i2++) {
                    stack.push(stack[i2]);
                  }
                },
                index: function PostScriptStack_index(n2) {
                  this.push(this.stack[this.stack.length - n2 - 1]);
                },
                roll: function PostScriptStack_roll(n2, p) {
                  var stack = this.stack;
                  var l2 = stack.length - n2;
                  var r2 = stack.length - 1, c2 = l2 + (p - Math.floor(p / n2) * n2), i2, j2, t2;
                  for (i2 = l2, j2 = r2; i2 < j2; i2++, j2--) {
                    t2 = stack[i2];
                    stack[i2] = stack[j2];
                    stack[j2] = t2;
                  }
                  for (i2 = l2, j2 = c2 - 1; i2 < j2; i2++, j2--) {
                    t2 = stack[i2];
                    stack[i2] = stack[j2];
                    stack[j2] = t2;
                  }
                  for (i2 = c2, j2 = r2; i2 < j2; i2++, j2--) {
                    t2 = stack[i2];
                    stack[i2] = stack[j2];
                    stack[j2] = t2;
                  }
                }
              };
              return PostScriptStack2;
            }();
            var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
              function PostScriptEvaluator2(operators) {
                this.operators = operators;
              }
              PostScriptEvaluator2.prototype = {
                execute: function PostScriptEvaluator_execute(initialStack) {
                  var stack = new PostScriptStack(initialStack);
                  var counter = 0;
                  var operators = this.operators;
                  var length = operators.length;
                  var operator, a2, b2;
                  while (counter < length) {
                    operator = operators[counter++];
                    if (typeof operator === "number") {
                      stack.push(operator);
                      continue;
                    }
                    switch (operator) {
                      case "jz":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        if (!a2) {
                          counter = b2;
                        }
                        break;
                      case "j":
                        a2 = stack.pop();
                        counter = a2;
                        break;
                      case "abs":
                        a2 = stack.pop();
                        stack.push(Math.abs(a2));
                        break;
                      case "add":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 + b2);
                        break;
                      case "and":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        if ((0, _util2.isBool)(a2) && (0, _util2.isBool)(b2)) {
                          stack.push(a2 && b2);
                        } else {
                          stack.push(a2 & b2);
                        }
                        break;
                      case "atan":
                        a2 = stack.pop();
                        stack.push(Math.atan(a2));
                        break;
                      case "bitshift":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        if (a2 > 0) {
                          stack.push(a2 << b2);
                        } else {
                          stack.push(a2 >> b2);
                        }
                        break;
                      case "ceiling":
                        a2 = stack.pop();
                        stack.push(Math.ceil(a2));
                        break;
                      case "copy":
                        a2 = stack.pop();
                        stack.copy(a2);
                        break;
                      case "cos":
                        a2 = stack.pop();
                        stack.push(Math.cos(a2));
                        break;
                      case "cvi":
                        a2 = stack.pop() | 0;
                        stack.push(a2);
                        break;
                      case "cvr":
                        break;
                      case "div":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 / b2);
                        break;
                      case "dup":
                        stack.copy(1);
                        break;
                      case "eq":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 === b2);
                        break;
                      case "exch":
                        stack.roll(2, 1);
                        break;
                      case "exp":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 ** b2);
                        break;
                      case "false":
                        stack.push(false);
                        break;
                      case "floor":
                        a2 = stack.pop();
                        stack.push(Math.floor(a2));
                        break;
                      case "ge":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 >= b2);
                        break;
                      case "gt":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 > b2);
                        break;
                      case "idiv":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 / b2 | 0);
                        break;
                      case "index":
                        a2 = stack.pop();
                        stack.index(a2);
                        break;
                      case "le":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 <= b2);
                        break;
                      case "ln":
                        a2 = stack.pop();
                        stack.push(Math.log(a2));
                        break;
                      case "log":
                        a2 = stack.pop();
                        stack.push(Math.log(a2) / Math.LN10);
                        break;
                      case "lt":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 < b2);
                        break;
                      case "mod":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 % b2);
                        break;
                      case "mul":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 * b2);
                        break;
                      case "ne":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 !== b2);
                        break;
                      case "neg":
                        a2 = stack.pop();
                        stack.push(-a2);
                        break;
                      case "not":
                        a2 = stack.pop();
                        if ((0, _util2.isBool)(a2)) {
                          stack.push(!a2);
                        } else {
                          stack.push(~a2);
                        }
                        break;
                      case "or":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        if ((0, _util2.isBool)(a2) && (0, _util2.isBool)(b2)) {
                          stack.push(a2 || b2);
                        } else {
                          stack.push(a2 | b2);
                        }
                        break;
                      case "pop":
                        stack.pop();
                        break;
                      case "roll":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.roll(a2, b2);
                        break;
                      case "round":
                        a2 = stack.pop();
                        stack.push(Math.round(a2));
                        break;
                      case "sin":
                        a2 = stack.pop();
                        stack.push(Math.sin(a2));
                        break;
                      case "sqrt":
                        a2 = stack.pop();
                        stack.push(Math.sqrt(a2));
                        break;
                      case "sub":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        stack.push(a2 - b2);
                        break;
                      case "true":
                        stack.push(true);
                        break;
                      case "truncate":
                        a2 = stack.pop();
                        a2 = a2 < 0 ? Math.ceil(a2) : Math.floor(a2);
                        stack.push(a2);
                        break;
                      case "xor":
                        b2 = stack.pop();
                        a2 = stack.pop();
                        if ((0, _util2.isBool)(a2) && (0, _util2.isBool)(b2)) {
                          stack.push(a2 !== b2);
                        } else {
                          stack.push(a2 ^ b2);
                        }
                        break;
                      default:
                        throw new _util2.FormatError(`Unknown operator ${operator}`);
                    }
                  }
                  return stack.stack;
                }
              };
              return PostScriptEvaluator2;
            }();
            exports3.PostScriptEvaluator = PostScriptEvaluator;
            var PostScriptCompiler = function PostScriptCompilerClosure() {
              function AstNode(type) {
                this.type = type;
              }
              AstNode.prototype.visit = function(visitor) {
                (0, _util2.unreachable)("abstract method");
              };
              function AstArgument(index, min, max) {
                AstNode.call(this, "args");
                this.index = index;
                this.min = min;
                this.max = max;
              }
              AstArgument.prototype = Object.create(AstNode.prototype);
              AstArgument.prototype.visit = function(visitor) {
                visitor.visitArgument(this);
              };
              function AstLiteral(number) {
                AstNode.call(this, "literal");
                this.number = number;
                this.min = number;
                this.max = number;
              }
              AstLiteral.prototype = Object.create(AstNode.prototype);
              AstLiteral.prototype.visit = function(visitor) {
                visitor.visitLiteral(this);
              };
              function AstBinaryOperation(op, arg1, arg2, min, max) {
                AstNode.call(this, "binary");
                this.op = op;
                this.arg1 = arg1;
                this.arg2 = arg2;
                this.min = min;
                this.max = max;
              }
              AstBinaryOperation.prototype = Object.create(AstNode.prototype);
              AstBinaryOperation.prototype.visit = function(visitor) {
                visitor.visitBinaryOperation(this);
              };
              function AstMin(arg, max) {
                AstNode.call(this, "max");
                this.arg = arg;
                this.min = arg.min;
                this.max = max;
              }
              AstMin.prototype = Object.create(AstNode.prototype);
              AstMin.prototype.visit = function(visitor) {
                visitor.visitMin(this);
              };
              function AstVariable(index, min, max) {
                AstNode.call(this, "var");
                this.index = index;
                this.min = min;
                this.max = max;
              }
              AstVariable.prototype = Object.create(AstNode.prototype);
              AstVariable.prototype.visit = function(visitor) {
                visitor.visitVariable(this);
              };
              function AstVariableDefinition(variable, arg) {
                AstNode.call(this, "definition");
                this.variable = variable;
                this.arg = arg;
              }
              AstVariableDefinition.prototype = Object.create(AstNode.prototype);
              AstVariableDefinition.prototype.visit = function(visitor) {
                visitor.visitVariableDefinition(this);
              };
              function ExpressionBuilderVisitor() {
                this.parts = [];
              }
              ExpressionBuilderVisitor.prototype = {
                visitArgument(arg) {
                  this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
                },
                visitVariable(variable) {
                  this.parts.push("v", variable.index);
                },
                visitLiteral(literal) {
                  this.parts.push(literal.number);
                },
                visitBinaryOperation(operation) {
                  this.parts.push("(");
                  operation.arg1.visit(this);
                  this.parts.push(" ", operation.op, " ");
                  operation.arg2.visit(this);
                  this.parts.push(")");
                },
                visitVariableDefinition(definition) {
                  this.parts.push("var ");
                  definition.variable.visit(this);
                  this.parts.push(" = ");
                  definition.arg.visit(this);
                  this.parts.push(";");
                },
                visitMin(max) {
                  this.parts.push("Math.min(");
                  max.arg.visit(this);
                  this.parts.push(", ", max.max, ")");
                },
                toString() {
                  return this.parts.join("");
                }
              };
              function buildAddOperation(num1, num2) {
                if (num2.type === "literal" && num2.number === 0) {
                  return num1;
                }
                if (num1.type === "literal" && num1.number === 0) {
                  return num2;
                }
                if (num2.type === "literal" && num1.type === "literal") {
                  return new AstLiteral(num1.number + num2.number);
                }
                return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
              }
              function buildMulOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return new AstLiteral(0);
                  } else if (num2.number === 1) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number * num2.number);
                  }
                }
                if (num1.type === "literal") {
                  if (num1.number === 0) {
                    return new AstLiteral(0);
                  } else if (num1.number === 1) {
                    return num2;
                  }
                }
                var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                return new AstBinaryOperation("*", num1, num2, min, max);
              }
              function buildSubOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number - num2.number);
                  }
                }
                if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
                  return num2.arg2;
                }
                return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
              }
              function buildMinOperation(num1, max) {
                if (num1.min >= max) {
                  return new AstLiteral(max);
                } else if (num1.max <= max) {
                  return num1;
                }
                return new AstMin(num1, max);
              }
              function PostScriptCompiler2() {
              }
              PostScriptCompiler2.prototype = {
                compile: function PostScriptCompiler_compile(code, domain, range) {
                  var stack = [];
                  var i2, ii;
                  var instructions = [];
                  var inputSize = domain.length >> 1, outputSize = range.length >> 1;
                  var lastRegister = 0;
                  var n2, j2;
                  var num1, num2, ast1, ast2, tmpVar, item;
                  for (i2 = 0; i2 < inputSize; i2++) {
                    stack.push(new AstArgument(i2, domain[i2 * 2], domain[i2 * 2 + 1]));
                  }
                  for (i2 = 0, ii = code.length; i2 < ii; i2++) {
                    item = code[i2];
                    if (typeof item === "number") {
                      stack.push(new AstLiteral(item));
                      continue;
                    }
                    switch (item) {
                      case "add":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildAddOperation(num1, num2));
                        break;
                      case "cvr":
                        if (stack.length < 1) {
                          return null;
                        }
                        break;
                      case "mul":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildMulOperation(num1, num2));
                        break;
                      case "sub":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildSubOperation(num1, num2));
                        break;
                      case "exch":
                        if (stack.length < 2) {
                          return null;
                        }
                        ast1 = stack.pop();
                        ast2 = stack.pop();
                        stack.push(ast1, ast2);
                        break;
                      case "pop":
                        if (stack.length < 1) {
                          return null;
                        }
                        stack.pop();
                        break;
                      case "index":
                        if (stack.length < 1) {
                          return null;
                        }
                        num1 = stack.pop();
                        if (num1.type !== "literal") {
                          return null;
                        }
                        n2 = num1.number;
                        if (n2 < 0 || !Number.isInteger(n2) || stack.length < n2) {
                          return null;
                        }
                        ast1 = stack[stack.length - n2 - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - n2 - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "dup":
                        if (stack.length < 1) {
                          return null;
                        }
                        if (typeof code[i2 + 1] === "number" && code[i2 + 2] === "gt" && code[i2 + 3] === i2 + 7 && code[i2 + 4] === "jz" && code[i2 + 5] === "pop" && code[i2 + 6] === code[i2 + 1]) {
                          num1 = stack.pop();
                          stack.push(buildMinOperation(num1, code[i2 + 1]));
                          i2 += 6;
                          break;
                        }
                        ast1 = stack[stack.length - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "roll":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        if (num2.type !== "literal" || num1.type !== "literal") {
                          return null;
                        }
                        j2 = num2.number;
                        n2 = num1.number;
                        if (n2 <= 0 || !Number.isInteger(n2) || !Number.isInteger(j2) || stack.length < n2) {
                          return null;
                        }
                        j2 = (j2 % n2 + n2) % n2;
                        if (j2 === 0) {
                          break;
                        }
                        Array.prototype.push.apply(stack, stack.splice(stack.length - n2, n2 - j2));
                        break;
                      default:
                        return null;
                    }
                  }
                  if (stack.length !== outputSize) {
                    return null;
                  }
                  var result = [];
                  instructions.forEach(function(instruction) {
                    var statementBuilder = new ExpressionBuilderVisitor();
                    instruction.visit(statementBuilder);
                    result.push(statementBuilder.toString());
                  });
                  stack.forEach(function(expr, i3) {
                    var statementBuilder = new ExpressionBuilderVisitor();
                    expr.visit(statementBuilder);
                    var min = range[i3 * 2], max = range[i3 * 2 + 1];
                    var out = [statementBuilder.toString()];
                    if (min > expr.min) {
                      out.unshift("Math.max(", min, ", ");
                      out.push(")");
                    }
                    if (max < expr.max) {
                      out.unshift("Math.min(", max, ", ");
                      out.push(")");
                    }
                    out.unshift("dest[destOffset + ", i3, "] = ");
                    out.push(";");
                    result.push(out.join(""));
                  });
                  return result.join("\n");
                }
              };
              return PostScriptCompiler2;
            }();
            exports3.PostScriptCompiler = PostScriptCompiler;
          },
          /* 40 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PostScriptParser = exports3.PostScriptLexer = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _core_utils = __w_pdfjs_require__2(7);
            class PostScriptParser {
              constructor(lexer) {
                this.lexer = lexer;
                this.operators = [];
                this.token = null;
                this.prev = null;
              }
              nextToken() {
                this.prev = this.token;
                this.token = this.lexer.getToken();
              }
              accept(type) {
                if (this.token.type === type) {
                  this.nextToken();
                  return true;
                }
                return false;
              }
              expect(type) {
                if (this.accept(type)) {
                  return true;
                }
                throw new _util2.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
              }
              parse() {
                this.nextToken();
                this.expect(PostScriptTokenTypes.LBRACE);
                this.parseBlock();
                this.expect(PostScriptTokenTypes.RBRACE);
                return this.operators;
              }
              parseBlock() {
                while (true) {
                  if (this.accept(PostScriptTokenTypes.NUMBER)) {
                    this.operators.push(this.prev.value);
                  } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                    this.operators.push(this.prev.value);
                  } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                    this.parseCondition();
                  } else {
                    return;
                  }
                }
              }
              parseCondition() {
                const conditionLocation = this.operators.length;
                this.operators.push(null, null);
                this.parseBlock();
                this.expect(PostScriptTokenTypes.RBRACE);
                if (this.accept(PostScriptTokenTypes.IF)) {
                  this.operators[conditionLocation] = this.operators.length;
                  this.operators[conditionLocation + 1] = "jz";
                } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                  const jumpLocation = this.operators.length;
                  this.operators.push(null, null);
                  const endOfTrue = this.operators.length;
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  this.expect(PostScriptTokenTypes.IFELSE);
                  this.operators[jumpLocation] = this.operators.length;
                  this.operators[jumpLocation + 1] = "j";
                  this.operators[conditionLocation] = endOfTrue;
                  this.operators[conditionLocation + 1] = "jz";
                } else {
                  throw new _util2.FormatError("PS Function: error parsing conditional.");
                }
              }
            }
            exports3.PostScriptParser = PostScriptParser;
            const PostScriptTokenTypes = {
              LBRACE: 0,
              RBRACE: 1,
              NUMBER: 2,
              OPERATOR: 3,
              IF: 4,
              IFELSE: 5
            };
            const PostScriptToken = function PostScriptTokenClosure() {
              const opCache = /* @__PURE__ */ Object.create(null);
              class PostScriptToken2 {
                constructor(type, value) {
                  this.type = type;
                  this.value = value;
                }
                static getOperator(op) {
                  const opValue = opCache[op];
                  if (opValue) {
                    return opValue;
                  }
                  return opCache[op] = new PostScriptToken2(PostScriptTokenTypes.OPERATOR, op);
                }
                static get LBRACE() {
                  return (0, _util2.shadow)(this, "LBRACE", new PostScriptToken2(PostScriptTokenTypes.LBRACE, "{"));
                }
                static get RBRACE() {
                  return (0, _util2.shadow)(this, "RBRACE", new PostScriptToken2(PostScriptTokenTypes.RBRACE, "}"));
                }
                static get IF() {
                  return (0, _util2.shadow)(this, "IF", new PostScriptToken2(PostScriptTokenTypes.IF, "IF"));
                }
                static get IFELSE() {
                  return (0, _util2.shadow)(this, "IFELSE", new PostScriptToken2(PostScriptTokenTypes.IFELSE, "IFELSE"));
                }
              }
              return PostScriptToken2;
            }();
            class PostScriptLexer {
              constructor(stream) {
                this.stream = stream;
                this.nextChar();
                this.strBuf = [];
              }
              nextChar() {
                return this.currentChar = this.stream.getByte();
              }
              getToken() {
                let comment = false;
                let ch = this.currentChar;
                while (true) {
                  if (ch < 0) {
                    return _primitives.EOF;
                  }
                  if (comment) {
                    if (ch === 10 || ch === 13) {
                      comment = false;
                    }
                  } else if (ch === 37) {
                    comment = true;
                  } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                    break;
                  }
                  ch = this.nextChar();
                }
                switch (ch | 0) {
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                  case 43:
                  case 45:
                  case 46:
                    return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                  case 123:
                    this.nextChar();
                    return PostScriptToken.LBRACE;
                  case 125:
                    this.nextChar();
                    return PostScriptToken.RBRACE;
                }
                const strBuf = this.strBuf;
                strBuf.length = 0;
                strBuf[0] = String.fromCharCode(ch);
                while ((ch = this.nextChar()) >= 0 && (ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122)) {
                  strBuf.push(String.fromCharCode(ch));
                }
                const str = strBuf.join("");
                switch (str.toLowerCase()) {
                  case "if":
                    return PostScriptToken.IF;
                  case "ifelse":
                    return PostScriptToken.IFELSE;
                  default:
                    return PostScriptToken.getOperator(str);
                }
              }
              getNumber() {
                let ch = this.currentChar;
                const strBuf = this.strBuf;
                strBuf.length = 0;
                strBuf[0] = String.fromCharCode(ch);
                while ((ch = this.nextChar()) >= 0) {
                  if (ch >= 48 && ch <= 57 || ch === 45 || ch === 46) {
                    strBuf.push(String.fromCharCode(ch));
                  } else {
                    break;
                  }
                }
                const value = parseFloat(strBuf.join(""));
                if (isNaN(value)) {
                  throw new _util2.FormatError(`Invalid floating point number: ${value}`);
                }
                return value;
              }
            }
            exports3.PostScriptLexer = PostScriptLexer;
          },
          /* 41 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.MurmurHash3_64 = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const SEED = 3285377520;
            const MASK_HIGH = 4294901760;
            const MASK_LOW = 65535;
            class MurmurHash3_64 {
              constructor(seed) {
                this.h1 = seed ? seed & 4294967295 : SEED;
                this.h2 = seed ? seed & 4294967295 : SEED;
              }
              update(input) {
                let data, length;
                if ((0, _util2.isString)(input)) {
                  data = new Uint8Array(input.length * 2);
                  length = 0;
                  for (let i2 = 0, ii = input.length; i2 < ii; i2++) {
                    const code = input.charCodeAt(i2);
                    if (code <= 255) {
                      data[length++] = code;
                    } else {
                      data[length++] = code >>> 8;
                      data[length++] = code & 255;
                    }
                  }
                } else if ((0, _util2.isArrayBuffer)(input)) {
                  data = input;
                  length = data.byteLength;
                } else {
                  throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                }
                const blockCounts = length >> 2;
                const tailLength = length - blockCounts * 4;
                const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                let k1 = 0, k2 = 0;
                let h1 = this.h1, h2 = this.h2;
                const C1 = 3432918353, C2 = 461845907;
                const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                for (let i2 = 0; i2 < blockCounts; i2++) {
                  if (i2 & 1) {
                    k1 = dataUint32[i2];
                    k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                    k1 = k1 << 15 | k1 >>> 17;
                    k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                    h1 ^= k1;
                    h1 = h1 << 13 | h1 >>> 19;
                    h1 = h1 * 5 + 3864292196;
                  } else {
                    k2 = dataUint32[i2];
                    k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                    k2 = k2 << 15 | k2 >>> 17;
                    k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                    h2 ^= k2;
                    h2 = h2 << 13 | h2 >>> 19;
                    h2 = h2 * 5 + 3864292196;
                  }
                }
                k1 = 0;
                switch (tailLength) {
                  case 3:
                    k1 ^= data[blockCounts * 4 + 2] << 16;
                  case 2:
                    k1 ^= data[blockCounts * 4 + 1] << 8;
                  case 1:
                    k1 ^= data[blockCounts * 4];
                    k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                    k1 = k1 << 15 | k1 >>> 17;
                    k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                    if (blockCounts & 1) {
                      h1 ^= k1;
                    } else {
                      h2 ^= k1;
                    }
                }
                this.h1 = h1;
                this.h2 = h2;
              }
              hexdigest() {
                let h1 = this.h1, h2 = this.h2;
                h1 ^= h2 >>> 1;
                h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                h1 ^= h2 >>> 1;
                h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                h1 ^= h2 >>> 1;
                const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                return hex1.padStart(8, "0") + hex2.padStart(8, "0");
              }
            }
            exports3.MurmurHash3_64 = MurmurHash3_64;
          },
          /* 42 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.NativeImageDecoder = void 0;
            var _colorspace = __w_pdfjs_require__2(22);
            var _jpeg_stream = __w_pdfjs_require__2(17);
            var _stream = __w_pdfjs_require__2(11);
            class NativeImageDecoder {
              constructor({
                xref,
                resources,
                handler,
                forceDataSchema = false,
                pdfFunctionFactory
              }) {
                this.xref = xref;
                this.resources = resources;
                this.handler = handler;
                this.forceDataSchema = forceDataSchema;
                this.pdfFunctionFactory = pdfFunctionFactory;
              }
              canDecode(image) {
                return image instanceof _jpeg_stream.JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources, this.pdfFunctionFactory) && image.maybeValidDimensions;
              }
              decode(image) {
                const dict = image.dict;
                let colorSpace = dict.get("ColorSpace", "CS");
                colorSpace = _colorspace.ColorSpace.parse(colorSpace, this.xref, this.resources, this.pdfFunctionFactory);
                return this.handler.sendWithPromise("JpegDecode", [image.getIR(this.forceDataSchema), colorSpace.numComps]).then(function({
                  data,
                  width,
                  height
                }) {
                  return new _stream.Stream(data, 0, data.length, dict);
                });
              }
              static isSupported(image, xref, res, pdfFunctionFactory) {
                const dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                const cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                return (cs.name === "DeviceGray" || cs.name === "DeviceRGB") && cs.isDefaultDecode(dict.getArray("Decode", "D"));
              }
              static isDecodable(image, xref, res, pdfFunctionFactory) {
                const dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                const cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                const bpc = dict.get("BitsPerComponent", "BPC") || 1;
                return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray("Decode", "D"), bpc);
              }
            }
            exports3.NativeImageDecoder = NativeImageDecoder;
          },
          /* 43 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFImage = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _primitives = __w_pdfjs_require__2(4);
            var _colorspace = __w_pdfjs_require__2(22);
            var _stream = __w_pdfjs_require__2(11);
            var _jpeg_stream = __w_pdfjs_require__2(17);
            var _jpx = __w_pdfjs_require__2(20);
            var PDFImage = function PDFImageClosure() {
              function handleImageData(image, nativeDecoder) {
                if (nativeDecoder && nativeDecoder.canDecode(image)) {
                  return nativeDecoder.decode(image).catch((reason) => {
                    (0, _util2.warn)("Native image decoding failed -- trying to recover: " + (reason && reason.message));
                    return image;
                  });
                }
                return Promise.resolve(image);
              }
              function decodeAndClamp(value, addend, coefficient, max) {
                value = addend + value * coefficient;
                if (value < 0) {
                  value = 0;
                } else if (value > max) {
                  value = max;
                }
                return value;
              }
              function resizeImageMask(src, bpc, w1, h1, w2, h2) {
                var length = w2 * h2;
                let dest;
                if (bpc <= 8) {
                  dest = new Uint8Array(length);
                } else if (bpc <= 16) {
                  dest = new Uint16Array(length);
                } else {
                  dest = new Uint32Array(length);
                }
                var xRatio = w1 / w2;
                var yRatio = h1 / h2;
                var i2, j2, py, newIndex = 0, oldIndex;
                var xScaled = new Uint16Array(w2);
                var w1Scanline = w1;
                for (i2 = 0; i2 < w2; i2++) {
                  xScaled[i2] = Math.floor(i2 * xRatio);
                }
                for (i2 = 0; i2 < h2; i2++) {
                  py = Math.floor(i2 * yRatio) * w1Scanline;
                  for (j2 = 0; j2 < w2; j2++) {
                    oldIndex = py + xScaled[j2];
                    dest[newIndex++] = src[oldIndex];
                  }
                }
                return dest;
              }
              function PDFImage2({
                xref,
                res,
                image,
                isInline = false,
                smask = null,
                mask = null,
                isMask = false,
                pdfFunctionFactory
              }) {
                this.image = image;
                var dict = image.dict;
                const filter = dict.get("Filter");
                if ((0, _primitives.isName)(filter)) {
                  switch (filter.name) {
                    case "JPXDecode":
                      var jpxImage = new _jpx.JpxImage();
                      jpxImage.parseImageProperties(image.stream);
                      image.stream.reset();
                      image.width = jpxImage.width;
                      image.height = jpxImage.height;
                      image.bitsPerComponent = jpxImage.bitsPerComponent;
                      image.numComps = jpxImage.componentsCount;
                      break;
                    case "JBIG2Decode":
                      image.bitsPerComponent = 1;
                      image.numComps = 1;
                      break;
                  }
                }
                let width = dict.get("Width", "W");
                let height = dict.get("Height", "H");
                if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
                  (0, _util2.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
                  width = image.width;
                  height = image.height;
                }
                if (width < 1 || height < 1) {
                  throw new _util2.FormatError(`Invalid image width: ${width} or height: ${height}`);
                }
                this.width = width;
                this.height = height;
                this.interpolate = dict.get("Interpolate", "I") || false;
                this.imageMask = dict.get("ImageMask", "IM") || false;
                this.matte = dict.get("Matte") || false;
                var bitsPerComponent = image.bitsPerComponent;
                if (!bitsPerComponent) {
                  bitsPerComponent = dict.get("BitsPerComponent", "BPC");
                  if (!bitsPerComponent) {
                    if (this.imageMask) {
                      bitsPerComponent = 1;
                    } else {
                      throw new _util2.FormatError(`Bits per component missing in image: ${this.imageMask}`);
                    }
                  }
                }
                this.bpc = bitsPerComponent;
                if (!this.imageMask) {
                  var colorSpace = dict.get("ColorSpace", "CS");
                  if (!colorSpace) {
                    (0, _util2.info)("JPX images (which do not require color spaces)");
                    switch (image.numComps) {
                      case 1:
                        colorSpace = _primitives.Name.get("DeviceGray");
                        break;
                      case 3:
                        colorSpace = _primitives.Name.get("DeviceRGB");
                        break;
                      case 4:
                        colorSpace = _primitives.Name.get("DeviceCMYK");
                        break;
                      default:
                        throw new Error(`JPX images with ${image.numComps} color components not supported.`);
                    }
                  }
                  const resources = isInline ? res : null;
                  this.colorSpace = _colorspace.ColorSpace.parse(colorSpace, xref, resources, pdfFunctionFactory);
                  this.numComps = this.colorSpace.numComps;
                }
                this.decode = dict.getArray("Decode", "D");
                this.needsDecode = false;
                if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
                  this.needsDecode = true;
                  var max = (1 << bitsPerComponent) - 1;
                  this.decodeCoefficients = [];
                  this.decodeAddends = [];
                  const isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";
                  for (var i2 = 0, j2 = 0; i2 < this.decode.length; i2 += 2, ++j2) {
                    var dmin = this.decode[i2];
                    var dmax = this.decode[i2 + 1];
                    this.decodeCoefficients[j2] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
                    this.decodeAddends[j2] = isIndexed ? dmin : max * dmin;
                  }
                }
                if (smask) {
                  this.smask = new PDFImage2({
                    xref,
                    res,
                    image: smask,
                    isInline,
                    pdfFunctionFactory
                  });
                } else if (mask) {
                  if ((0, _primitives.isStream)(mask)) {
                    var maskDict = mask.dict, imageMask = maskDict.get("ImageMask", "IM");
                    if (!imageMask) {
                      (0, _util2.warn)("Ignoring /Mask in image without /ImageMask.");
                    } else {
                      this.mask = new PDFImage2({
                        xref,
                        res,
                        image: mask,
                        isInline,
                        isMask: true,
                        pdfFunctionFactory
                      });
                    }
                  } else {
                    this.mask = mask;
                  }
                }
              }
              PDFImage2.buildImage = function({
                handler,
                xref,
                res,
                image,
                isInline = false,
                nativeDecoder = null,
                pdfFunctionFactory
              }) {
                var imagePromise = handleImageData(image, nativeDecoder);
                var smaskPromise;
                var maskPromise;
                var smask = image.dict.get("SMask");
                var mask = image.dict.get("Mask");
                if (smask) {
                  smaskPromise = handleImageData(smask, nativeDecoder);
                  maskPromise = Promise.resolve(null);
                } else {
                  smaskPromise = Promise.resolve(null);
                  if (mask) {
                    if ((0, _primitives.isStream)(mask)) {
                      maskPromise = handleImageData(mask, nativeDecoder);
                    } else if (Array.isArray(mask)) {
                      maskPromise = Promise.resolve(mask);
                    } else {
                      (0, _util2.warn)("Unsupported mask format.");
                      maskPromise = Promise.resolve(null);
                    }
                  } else {
                    maskPromise = Promise.resolve(null);
                  }
                }
                return Promise.all([imagePromise, smaskPromise, maskPromise]).then(function([imageData, smaskData, maskData]) {
                  return new PDFImage2({
                    xref,
                    res,
                    image: imageData,
                    isInline,
                    smask: smaskData,
                    mask: maskData,
                    pdfFunctionFactory
                  });
                });
              };
              PDFImage2.createMask = function({
                imgArray,
                width,
                height,
                imageIsFromDecodeStream,
                inverseDecode
              }) {
                var computedLength = (width + 7 >> 3) * height;
                var actualLength = imgArray.byteLength;
                var haveFullData = computedLength === actualLength;
                var data, i2;
                if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                  data = imgArray;
                } else if (!inverseDecode) {
                  data = new Uint8ClampedArray(actualLength);
                  data.set(imgArray);
                } else {
                  data = new Uint8ClampedArray(computedLength);
                  data.set(imgArray);
                  for (i2 = actualLength; i2 < computedLength; i2++) {
                    data[i2] = 255;
                  }
                }
                if (inverseDecode) {
                  for (i2 = 0; i2 < actualLength; i2++) {
                    data[i2] ^= 255;
                  }
                }
                return {
                  data,
                  width,
                  height
                };
              };
              PDFImage2.prototype = {
                get drawWidth() {
                  return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
                },
                get drawHeight() {
                  return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
                },
                decodeBuffer(buffer) {
                  var bpc = this.bpc;
                  var numComps = this.numComps;
                  var decodeAddends = this.decodeAddends;
                  var decodeCoefficients = this.decodeCoefficients;
                  var max = (1 << bpc) - 1;
                  var i2, ii;
                  if (bpc === 1) {
                    for (i2 = 0, ii = buffer.length; i2 < ii; i2++) {
                      buffer[i2] = +!buffer[i2];
                    }
                    return;
                  }
                  var index = 0;
                  for (i2 = 0, ii = this.width * this.height; i2 < ii; i2++) {
                    for (var j2 = 0; j2 < numComps; j2++) {
                      buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j2], decodeCoefficients[j2], max);
                      index++;
                    }
                  }
                },
                getComponents(buffer) {
                  var bpc = this.bpc;
                  if (bpc === 8) {
                    return buffer;
                  }
                  var width = this.width;
                  var height = this.height;
                  var numComps = this.numComps;
                  var length = width * height * numComps;
                  var bufferPos = 0;
                  let output;
                  if (bpc <= 8) {
                    output = new Uint8Array(length);
                  } else if (bpc <= 16) {
                    output = new Uint16Array(length);
                  } else {
                    output = new Uint32Array(length);
                  }
                  var rowComps = width * numComps;
                  var max = (1 << bpc) - 1;
                  var i2 = 0, ii, buf;
                  if (bpc === 1) {
                    var mask, loop1End, loop2End;
                    for (var j2 = 0; j2 < height; j2++) {
                      loop1End = i2 + (rowComps & ~7);
                      loop2End = i2 + rowComps;
                      while (i2 < loop1End) {
                        buf = buffer[bufferPos++];
                        output[i2] = buf >> 7 & 1;
                        output[i2 + 1] = buf >> 6 & 1;
                        output[i2 + 2] = buf >> 5 & 1;
                        output[i2 + 3] = buf >> 4 & 1;
                        output[i2 + 4] = buf >> 3 & 1;
                        output[i2 + 5] = buf >> 2 & 1;
                        output[i2 + 6] = buf >> 1 & 1;
                        output[i2 + 7] = buf & 1;
                        i2 += 8;
                      }
                      if (i2 < loop2End) {
                        buf = buffer[bufferPos++];
                        mask = 128;
                        while (i2 < loop2End) {
                          output[i2++] = +!!(buf & mask);
                          mask >>= 1;
                        }
                      }
                    }
                  } else {
                    var bits = 0;
                    buf = 0;
                    for (i2 = 0, ii = length; i2 < ii; ++i2) {
                      if (i2 % rowComps === 0) {
                        buf = 0;
                        bits = 0;
                      }
                      while (bits < bpc) {
                        buf = buf << 8 | buffer[bufferPos++];
                        bits += 8;
                      }
                      var remainingBits = bits - bpc;
                      let value = buf >> remainingBits;
                      if (value < 0) {
                        value = 0;
                      } else if (value > max) {
                        value = max;
                      }
                      output[i2] = value;
                      buf = buf & (1 << remainingBits) - 1;
                      bits = remainingBits;
                    }
                  }
                  return output;
                },
                fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                  var smask = this.smask;
                  var mask = this.mask;
                  var alphaBuf, sw, sh, i2, ii, j2;
                  if (smask) {
                    sw = smask.width;
                    sh = smask.height;
                    alphaBuf = new Uint8ClampedArray(sw * sh);
                    smask.fillGrayBuffer(alphaBuf);
                    if (sw !== width || sh !== height) {
                      alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
                    }
                  } else if (mask) {
                    if (mask instanceof PDFImage2) {
                      sw = mask.width;
                      sh = mask.height;
                      alphaBuf = new Uint8ClampedArray(sw * sh);
                      mask.numComps = 1;
                      mask.fillGrayBuffer(alphaBuf);
                      for (i2 = 0, ii = sw * sh; i2 < ii; ++i2) {
                        alphaBuf[i2] = 255 - alphaBuf[i2];
                      }
                      if (sw !== width || sh !== height) {
                        alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
                      }
                    } else if (Array.isArray(mask)) {
                      alphaBuf = new Uint8ClampedArray(width * height);
                      var numComps = this.numComps;
                      for (i2 = 0, ii = width * height; i2 < ii; ++i2) {
                        var opacity = 0;
                        var imageOffset = i2 * numComps;
                        for (j2 = 0; j2 < numComps; ++j2) {
                          var color = image[imageOffset + j2];
                          var maskOffset = j2 * 2;
                          if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                            opacity = 255;
                            break;
                          }
                        }
                        alphaBuf[i2] = opacity;
                      }
                    } else {
                      throw new _util2.FormatError("Unknown mask format.");
                    }
                  }
                  if (alphaBuf) {
                    for (i2 = 0, j2 = 3, ii = width * actualHeight; i2 < ii; ++i2, j2 += 4) {
                      rgbaBuf[j2] = alphaBuf[i2];
                    }
                  } else {
                    for (i2 = 0, j2 = 3, ii = width * actualHeight; i2 < ii; ++i2, j2 += 4) {
                      rgbaBuf[j2] = 255;
                    }
                  }
                },
                undoPreblend(buffer, width, height) {
                  var matte = this.smask && this.smask.matte;
                  if (!matte) {
                    return;
                  }
                  var matteRgb = this.colorSpace.getRgb(matte, 0);
                  var matteR = matteRgb[0];
                  var matteG = matteRgb[1];
                  var matteB = matteRgb[2];
                  var length = width * height * 4;
                  for (var i2 = 0; i2 < length; i2 += 4) {
                    var alpha = buffer[i2 + 3];
                    if (alpha === 0) {
                      buffer[i2] = 255;
                      buffer[i2 + 1] = 255;
                      buffer[i2 + 2] = 255;
                      continue;
                    }
                    var k2 = 255 / alpha;
                    buffer[i2] = (buffer[i2] - matteR) * k2 + matteR;
                    buffer[i2 + 1] = (buffer[i2 + 1] - matteG) * k2 + matteG;
                    buffer[i2 + 2] = (buffer[i2 + 2] - matteB) * k2 + matteB;
                  }
                },
                createImageData(forceRGBA = false) {
                  var drawWidth = this.drawWidth;
                  var drawHeight = this.drawHeight;
                  var imgData = {
                    width: drawWidth,
                    height: drawHeight,
                    kind: 0,
                    data: null
                  };
                  var numComps = this.numComps;
                  var originalWidth = this.width;
                  var originalHeight = this.height;
                  var bpc = this.bpc;
                  var rowBytes = originalWidth * numComps * bpc + 7 >> 3;
                  var imgArray;
                  if (!forceRGBA) {
                    var kind;
                    if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
                      kind = _util2.ImageKind.GRAYSCALE_1BPP;
                    } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
                      kind = _util2.ImageKind.RGB_24BPP;
                    }
                    if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                      imgData.kind = kind;
                      imgArray = this.getImageBytes(originalHeight * rowBytes);
                      if (this.image instanceof _stream.DecodeStream) {
                        imgData.data = imgArray;
                      } else {
                        var newArray = new Uint8ClampedArray(imgArray.length);
                        newArray.set(imgArray);
                        imgData.data = newArray;
                      }
                      if (this.needsDecode) {
                        (0, _util2.assert)(kind === _util2.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                        var buffer = imgData.data;
                        for (var i2 = 0, ii = buffer.length; i2 < ii; i2++) {
                          buffer[i2] ^= 255;
                        }
                      }
                      return imgData;
                    }
                    if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
                      let imageLength = originalHeight * rowBytes;
                      switch (this.colorSpace.name) {
                        case "DeviceGray":
                          imageLength *= 3;
                        case "DeviceRGB":
                        case "DeviceCMYK":
                          imgData.kind = _util2.ImageKind.RGB_24BPP;
                          imgData.data = this.getImageBytes(imageLength, drawWidth, drawHeight, true);
                          return imgData;
                      }
                    }
                  }
                  imgArray = this.getImageBytes(originalHeight * rowBytes);
                  var actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
                  var comps = this.getComponents(imgArray);
                  var alpha01, maybeUndoPreblend;
                  if (!forceRGBA && !this.smask && !this.mask) {
                    imgData.kind = _util2.ImageKind.RGB_24BPP;
                    imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
                    alpha01 = 0;
                    maybeUndoPreblend = false;
                  } else {
                    imgData.kind = _util2.ImageKind.RGBA_32BPP;
                    imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
                    alpha01 = 1;
                    maybeUndoPreblend = true;
                    this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                  if (maybeUndoPreblend) {
                    this.undoPreblend(imgData.data, drawWidth, actualHeight);
                  }
                  return imgData;
                },
                fillGrayBuffer(buffer) {
                  var numComps = this.numComps;
                  if (numComps !== 1) {
                    throw new _util2.FormatError(`Reading gray scale from a color image: ${numComps}`);
                  }
                  var width = this.width;
                  var height = this.height;
                  var bpc = this.bpc;
                  var rowBytes = width * numComps * bpc + 7 >> 3;
                  var imgArray = this.getImageBytes(height * rowBytes);
                  var comps = this.getComponents(imgArray);
                  var i2, length;
                  if (bpc === 1) {
                    length = width * height;
                    if (this.needsDecode) {
                      for (i2 = 0; i2 < length; ++i2) {
                        buffer[i2] = comps[i2] - 1 & 255;
                      }
                    } else {
                      for (i2 = 0; i2 < length; ++i2) {
                        buffer[i2] = -comps[i2] & 255;
                      }
                    }
                    return;
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  length = width * height;
                  var scale = 255 / ((1 << bpc) - 1);
                  for (i2 = 0; i2 < length; ++i2) {
                    buffer[i2] = scale * comps[i2];
                  }
                },
                getImageBytes(length, drawWidth, drawHeight, forceRGB = false) {
                  this.image.reset();
                  this.image.drawWidth = drawWidth || this.width;
                  this.image.drawHeight = drawHeight || this.height;
                  this.image.forceRGB = !!forceRGB;
                  return this.image.getBytes(length, true);
                }
              };
              return PDFImage2;
            }();
            exports3.PDFImage = PDFImage;
          },
          /* 44 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.isNodeJS = void 0;
            const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
            exports3.isNodeJS = isNodeJS;
          },
          /* 45 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.MessageHandler = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            const StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (typeof reason !== "object" || reason === null) {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            class MessageHandler {
              constructor(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.postMessageTransfers = true;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = (event) => {
                  const data = event.data;
                  if (data.targetName !== this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    this._processStreamMessage(data);
                    return;
                  }
                  if (data.callback) {
                    const callbackId = data.callbackId;
                    const capability = this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error(`Cannot resolve callback ${callbackId}`);
                    }
                    delete this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  const action = this.actionHandler[data.action];
                  if (!action) {
                    throw new Error(`Unknown action from worker: ${data.action}`);
                  }
                  if (data.callbackId) {
                    const sourceName2 = this.sourceName;
                    const targetName2 = data.sourceName;
                    new Promise(function(resolve) {
                      resolve(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    this._createStreamSink(data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              on(actionName, handler) {
                const ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error(`There is already an actionName called "${actionName}"`);
                }
                ah[actionName] = handler;
              }
              send(actionName, data, transfers) {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                }, transfers);
              }
              sendWithPromise(actionName, data, transfers) {
                const callbackId = this.callbackId++;
                const capability = (0, _util2.createPromiseCapability)();
                this.callbackCapabilities[callbackId] = capability;
                try {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId,
                    data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }
                return capability.promise;
              }
              sendWithStream(actionName, data, queueingStrategy, transfers) {
                const streamId = this.streamId++;
                const sourceName = this.sourceName;
                const targetName = this.targetName;
                const comObj = this.comObj;
                return new ReadableStream({
                  start: (controller) => {
                    const startCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };
                    this._postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    }, transfers);
                    return startCapability.promise;
                  },
                  pull: (controller) => {
                    const pullCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL,
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: (reason) => {
                    (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                    const cancelCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].cancelCall = cancelCapability;
                    this.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL,
                      streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
              _createStreamSink(data) {
                const self2 = this;
                const action = this.actionHandler[data.action];
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util2.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    self2._postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: (0, _util2.createPromiseCapability)(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              }
              _processStreamMessage(data) {
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].startCall.resolve();
                    } else {
                      this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].pullCall.resolve();
                    } else {
                      this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!this.streamSinks[streamId]) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[streamId].desiredSize = data.desiredSize;
                    const {
                      onPull
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onPull && onPull());
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].isClosed = true;
                    this.streamControllers[streamId].controller.close();
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                    this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].cancelCall.resolve();
                    } else {
                      this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                    }
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!this.streamSinks[streamId]) {
                      break;
                    }
                    const {
                      onCancel
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onCancel && onCancel(wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[streamId].isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              }
              async _deleteStreamController(streamId) {
                await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                  return capability && capability.promise;
                }));
                delete this.streamControllers[streamId];
              }
              _postMessage(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }
            exports3.MessageHandler = MessageHandler;
          },
          /* 46 */
          /***/
          function(module3, exports3, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFWorkerStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            class PDFWorkerStream {
              constructor(msgHandler) {
                this._msgHandler = msgHandler;
                this._contentLength = null;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports3.PDFWorkerStream = PDFWorkerStream;
            class PDFWorkerStreamReader {
              constructor(msgHandler) {
                this._msgHandler = msgHandler;
                this.onProgress = null;
                this._contentLength = null;
                this._isRangeSupported = false;
                this._isStreamingSupported = false;
                const readableStream = this._msgHandler.sendWithStream("GetReader");
                this._reader = readableStream.getReader();
                this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((data) => {
                  this._isStreamingSupported = data.isStreamingSupported;
                  this._isRangeSupported = data.isRangeSupported;
                  this._contentLength = data.contentLength;
                });
              }
              get headersReady() {
                return this._headersReady;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              async read() {
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                return {
                  value: value.buffer,
                  done: false
                };
              }
              cancel(reason) {
                this._reader.cancel(reason);
              }
            }
            class PDFWorkerStreamRangeReader {
              constructor(begin, end, msgHandler) {
                this._msgHandler = msgHandler;
                this.onProgress = null;
                const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
                  begin,
                  end
                });
                this._reader = readableStream.getReader();
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                return {
                  value: value.buffer,
                  done: false
                };
              }
              cancel(reason) {
                this._reader.cancel(reason);
              }
            }
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/pdfjs-dist/build/pdf.worker.entry.js
var require_pdf_worker_entry = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.worker.entry.js"() {
    (typeof window !== "undefined" ? window : {}).pdfjsWorker = require_pdf_worker();
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__2(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __w_pdfjs_require__2);
            module2.l = true;
            return module2.exports;
          }
          __w_pdfjs_require__2.m = modules;
          __w_pdfjs_require__2.c = installedModules;
          __w_pdfjs_require__2.d = function(exports2, name, getter) {
            if (!__w_pdfjs_require__2.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __w_pdfjs_require__2.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __w_pdfjs_require__2.t = function(value, mode) {
            if (mode & 1)
              value = __w_pdfjs_require__2(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __w_pdfjs_require__2.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __w_pdfjs_require__2.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __w_pdfjs_require__2.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __w_pdfjs_require__2.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__2.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__2.p = "";
          return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 0);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            var pdfjsVersion = "2.4.456";
            var pdfjsBuild = "228a591c";
            var pdfjsSharedUtil = __w_pdfjs_require__2(1);
            var pdfjsDisplayAPI = __w_pdfjs_require__2(3);
            var pdfjsDisplayTextLayer = __w_pdfjs_require__2(16);
            var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__2(17);
            var pdfjsDisplayDisplayUtils = __w_pdfjs_require__2(4);
            var pdfjsDisplaySVG = __w_pdfjs_require__2(18);
            const pdfjsDisplayWorkerOptions = __w_pdfjs_require__2(10);
            const pdfjsDisplayAPICompatibility = __w_pdfjs_require__2(6);
            {
              const {
                isNodeJS
              } = __w_pdfjs_require__2(7);
              if (isNodeJS) {
                const PDFNodeStream = __w_pdfjs_require__2(19).PDFNodeStream;
                pdfjsDisplayAPI.setPDFNetworkStreamFactory((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const PDFNetworkStream = __w_pdfjs_require__2(22).PDFNetworkStream;
                let PDFFetchStream;
                if (pdfjsDisplayDisplayUtils.isFetchSupported()) {
                  PDFFetchStream = __w_pdfjs_require__2(23).PDFFetchStream;
                }
                pdfjsDisplayAPI.setPDFNetworkStreamFactory((params) => {
                  if (PDFFetchStream && pdfjsDisplayDisplayUtils.isValidFetchUrl(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
            exports2.build = pdfjsDisplayAPI.build;
            exports2.version = pdfjsDisplayAPI.version;
            exports2.getDocument = pdfjsDisplayAPI.getDocument;
            exports2.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
            exports2.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
            exports2.PDFWorker = pdfjsDisplayAPI.PDFWorker;
            exports2.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
            exports2.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
            exports2.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
            exports2.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
            exports2.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
            exports2.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
            exports2.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
            exports2.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
            exports2.CMapCompressionType = pdfjsSharedUtil.CMapCompressionType;
            exports2.PermissionFlag = pdfjsSharedUtil.PermissionFlag;
            exports2.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
            exports2.OPS = pdfjsSharedUtil.OPS;
            exports2.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
            exports2.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
            exports2.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
            exports2.createObjectURL = pdfjsSharedUtil.createObjectURL;
            exports2.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
            exports2.shadow = pdfjsSharedUtil.shadow;
            exports2.Util = pdfjsSharedUtil.Util;
            exports2.RenderingCancelledException = pdfjsDisplayDisplayUtils.RenderingCancelledException;
            exports2.getFilenameFromUrl = pdfjsDisplayDisplayUtils.getFilenameFromUrl;
            exports2.LinkTarget = pdfjsDisplayDisplayUtils.LinkTarget;
            exports2.addLinkAttributes = pdfjsDisplayDisplayUtils.addLinkAttributes;
            exports2.loadScript = pdfjsDisplayDisplayUtils.loadScript;
            exports2.PDFDateString = pdfjsDisplayDisplayUtils.PDFDateString;
            exports2.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
            exports2.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;
          },
          /* 1 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer3;
            exports2.isArrayEqual = isArrayEqual;
            exports2.isBool = isBool;
            exports2.isEmptyObj = isEmptyObj;
            exports2.isNum = isNum;
            exports2.isString = isString3;
            exports2.isSameOrigin = isSameOrigin;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.unreachable = unreachable;
            exports2.IsEvalSupportedCached = exports2.IsLittleEndianCached = exports2.createObjectURL = exports2.FormatError = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VerbosityLevel = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = exports2.BaseException = void 0;
            __w_pdfjs_require__2(2);
            const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            const NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            exports2.NativeImageDecoding = NativeImageDecoding;
            const PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports2.PermissionFlag = PermissionFlag;
            const TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports2.TextRenderingMode = TextRenderingMode;
            const ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports2.ImageKind = ImageKind;
            const AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports2.AnnotationType = AnnotationType;
            const AnnotationStateModelType = {
              MARKED: "Marked",
              REVIEW: "Review"
            };
            exports2.AnnotationStateModelType = AnnotationStateModelType;
            const AnnotationMarkedState = {
              MARKED: "Marked",
              UNMARKED: "Unmarked"
            };
            exports2.AnnotationMarkedState = AnnotationMarkedState;
            const AnnotationReviewState = {
              ACCEPTED: "Accepted",
              REJECTED: "Rejected",
              CANCELLED: "Cancelled",
              COMPLETED: "Completed",
              NONE: "None"
            };
            exports2.AnnotationReviewState = AnnotationReviewState;
            const AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports2.AnnotationReplyType = AnnotationReplyType;
            const AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports2.AnnotationFlag = AnnotationFlag;
            const AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            const AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            const StreamType = {
              UNKNOWN: "UNKNOWN",
              FLATE: "FLATE",
              LZW: "LZW",
              DCT: "DCT",
              JPX: "JPX",
              JBIG: "JBIG",
              A85: "A85",
              AHX: "AHX",
              CCF: "CCF",
              RLX: "RLX"
            };
            exports2.StreamType = StreamType;
            const FontType = {
              UNKNOWN: "UNKNOWN",
              TYPE1: "TYPE1",
              TYPE1C: "TYPE1C",
              CIDFONTTYPE0: "CIDFONTTYPE0",
              CIDFONTTYPE0C: "CIDFONTTYPE0C",
              TRUETYPE: "TRUETYPE",
              CIDFONTTYPE2: "CIDFONTTYPE2",
              TYPE3: "TYPE3",
              OPENTYPE: "OPENTYPE",
              TYPE0: "TYPE0",
              MMTYPE1: "MMTYPE1"
            };
            exports2.FontType = FontType;
            const VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports2.VerbosityLevel = VerbosityLevel;
            const CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            exports2.CMapCompressionType = CMapCompressionType;
            const OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports2.OPS = OPS;
            const UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            const PasswordResponses2 = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports2.PasswordResponses = PasswordResponses2;
            let verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log(`Info: ${msg}`);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log(`Warning: ${msg}`);
              }
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            function isSameOrigin(baseUrl, otherUrl) {
              let base;
              try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e2) {
                return false;
              }
              const other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function _isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            const BaseException = function BaseExceptionClosure() {
              function BaseException2(message) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = this.constructor.name;
              }
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }();
            exports2.BaseException = BaseException;
            class PasswordException extends BaseException {
              constructor(msg, code) {
                super(msg);
                this.code = code;
              }
            }
            exports2.PasswordException = PasswordException;
            class UnknownErrorException extends BaseException {
              constructor(msg, details) {
                super(msg);
                this.details = details;
              }
            }
            exports2.UnknownErrorException = UnknownErrorException;
            class InvalidPDFException extends BaseException {
            }
            exports2.InvalidPDFException = InvalidPDFException;
            class MissingPDFException extends BaseException {
            }
            exports2.MissingPDFException = MissingPDFException;
            class UnexpectedResponseException extends BaseException {
              constructor(msg, status) {
                super(msg);
                this.status = status;
              }
            }
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            class FormatError extends BaseException {
            }
            exports2.FormatError = FormatError;
            class AbortException extends BaseException {
            }
            exports2.AbortException = AbortException;
            const NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && typeof bytes === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              const length = bytes.length;
              const MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              const strBuf = [];
              for (let i2 = 0; i2 < length; i2 += MAX_ARGUMENT_COUNT) {
                const chunkEnd = Math.min(i2 + MAX_ARGUMENT_COUNT, length);
                const chunk = bytes.subarray(i2, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              const length = str.length;
              const bytes = new Uint8Array(length);
              for (let i2 = 0; i2 < length; ++i2) {
                bytes[i2] = str.charCodeAt(i2) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              const length = arr.length;
              if (length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              let resultLength = 0;
              for (let i2 = 0; i2 < length; i2++) {
                resultLength += arrayByteLength(arr[i2]);
              }
              let pos = 0;
              const data = new Uint8Array(resultLength);
              for (let i2 = 0; i2 < length; i2++) {
                let item = arr[i2];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                const itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function isLittleEndian() {
              const buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              const view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            const IsLittleEndianCached = {
              get value() {
                return shadow(this, "value", isLittleEndian());
              }
            };
            exports2.IsLittleEndianCached = IsLittleEndianCached;
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e2) {
                return false;
              }
            }
            const IsEvalSupportedCached = {
              get value() {
                return shadow(this, "value", isEvalSupported());
              }
            };
            exports2.IsEvalSupportedCached = IsEvalSupportedCached;
            const rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
            class Util {
              static makeCssRgb(r2, g2, b2) {
                rgbBuf[1] = r2;
                rgbBuf[3] = g2;
                rgbBuf[5] = b2;
                return rgbBuf.join("");
              }
              static transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
              static applyTransform(p, m) {
                const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              }
              static applyInverseTransform(p, m) {
                const d2 = m[0] * m[3] - m[1] * m[2];
                const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d2;
                const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d2;
                return [xt, yt];
              }
              static getAxialAlignedBoundingBox(r2, m) {
                const p1 = Util.applyTransform(r2, m);
                const p2 = Util.applyTransform(r2.slice(2, 4), m);
                const p3 = Util.applyTransform([r2[0], r2[3]], m);
                const p4 = Util.applyTransform([r2[2], r2[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
              static inverseTransform(m) {
                const d2 = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d2, -m[1] / d2, -m[2] / d2, m[0] / d2, (m[2] * m[5] - m[4] * m[3]) / d2, (m[4] * m[1] - m[5] * m[0]) / d2];
              }
              static apply3dTransform(m, v2) {
                return [m[0] * v2[0] + m[1] * v2[1] + m[2] * v2[2], m[3] * v2[0] + m[4] * v2[1] + m[5] * v2[2], m[6] * v2[0] + m[7] * v2[1] + m[8] * v2[2]];
              }
              static singularValueDecompose2dScale(m) {
                const transpose = [m[0], m[2], m[1], m[3]];
                const a2 = m[0] * transpose[0] + m[1] * transpose[2];
                const b2 = m[0] * transpose[1] + m[1] * transpose[3];
                const c2 = m[2] * transpose[0] + m[3] * transpose[2];
                const d2 = m[2] * transpose[1] + m[3] * transpose[3];
                const first = (a2 + d2) / 2;
                const second = Math.sqrt((a2 + d2) * (a2 + d2) - 4 * (a2 * d2 - c2 * b2)) / 2;
                const sx = first + second || 1;
                const sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
              static normalizeRect(rect) {
                const r2 = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r2[0] = rect[2];
                  r2[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r2[1] = rect[3];
                  r2[3] = rect[1];
                }
                return r2;
              }
              static intersect(rect1, rect2) {
                function compare(a2, b2) {
                  return a2 - b2;
                }
                const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                const result = [];
                rect1 = Util.normalizeRect(rect1);
                rect2 = Util.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return null;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return null;
                }
                return result;
              }
            }
            exports2.Util = Util;
            const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              const length = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (let i2 = 2; i2 < length; i2 += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i2) << 8 | str.charCodeAt(i2 + 1)));
                }
              } else if (str[0] === "ÿ" && str[1] === "þ") {
                for (let i2 = 2; i2 < length; i2 += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i2 + 1) << 8 | str.charCodeAt(i2)));
                }
              } else {
                for (let i2 = 0; i2 < length; ++i2) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i2)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i2));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (const key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v2) {
              return typeof v2 === "boolean";
            }
            function isNum(v2) {
              return typeof v2 === "number";
            }
            function isString3(v2) {
              return typeof v2 === "string";
            }
            function isArrayBuffer3(v2) {
              return typeof v2 === "object" && v2 !== null && v2.byteLength !== void 0;
            }
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              return arr1.every(function(element, index) {
                return element === arr2[index];
              });
            }
            function createPromiseCapability() {
              const capability = /* @__PURE__ */ Object.create(null);
              let isSettled = false;
              Object.defineProperty(capability, "settled", {
                get() {
                  return isSettled;
                }
              });
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = function(data) {
                  isSettled = true;
                  resolve(data);
                };
                capability.reject = function(reason) {
                  isSettled = true;
                  reject(reason);
                };
              });
              return capability;
            }
            const createObjectURL = function createObjectURLClosure() {
              const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType, forceDataSchema = false) {
                if (!forceDataSchema && URL.createObjectURL) {
                  const blob = new Blob([data], {
                    type: contentType
                  });
                  return URL.createObjectURL(blob);
                }
                let buffer = `data:${contentType};base64,`;
                for (let i2 = 0, ii = data.length; i2 < ii; i2 += 3) {
                  const b1 = data[i2] & 255;
                  const b2 = data[i2 + 1] & 255;
                  const b3 = data[i2 + 2] & 255;
                  const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  const d3 = i2 + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  const d4 = i2 + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            exports2.createObjectURL = createObjectURL;
          },
          /* 2 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            ;
          },
          /* 3 */
          /***/
          function(module, exports, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getDocument = getDocument;
            exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
            exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;
            var _util = __w_pdfjs_require__(1);
            var _display_utils = __w_pdfjs_require__(4);
            var _font_loader = __w_pdfjs_require__(5);
            var _api_compatibility = __w_pdfjs_require__(6);
            var _canvas = __w_pdfjs_require__(8);
            var _worker_options = __w_pdfjs_require__(10);
            var _is_node = __w_pdfjs_require__(7);
            var _message_handler = __w_pdfjs_require__(11);
            var _metadata = __w_pdfjs_require__(12);
            var _transport_stream = __w_pdfjs_require__(14);
            var _webgl = __w_pdfjs_require__(15);
            const DEFAULT_RANGE_CHUNK_SIZE = 65536;
            const RENDERING_CANCELLED_TIMEOUT = 100;
            let createPDFNetworkStream;
            function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
              createPDFNetworkStream = pdfNetworkStreamFactory;
            }
            function getDocument(src) {
              const task = new PDFDocumentLoadingTask();
              let source;
              if (typeof src === "string") {
                source = {
                  url: src
                };
              } else if ((0, _util.isArrayBuffer)(src)) {
                source = {
                  data: src
                };
              } else if (src instanceof PDFDataRangeTransport) {
                source = {
                  range: src
                };
              } else {
                if (typeof src !== "object") {
                  throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                source = src;
              }
              const params = /* @__PURE__ */ Object.create(null);
              let rangeTransport = null, worker2 = null;
              for (const key in source) {
                if (key === "url" && typeof window !== "undefined") {
                  params[key] = new URL(source[key], window.location).href;
                  continue;
                } else if (key === "range") {
                  rangeTransport = source[key];
                  continue;
                } else if (key === "worker") {
                  worker2 = source[key];
                  continue;
                } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
                  const pdfBytes = source[key];
                  if (typeof pdfBytes === "string") {
                    params[key] = (0, _util.stringToBytes)(pdfBytes);
                  } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else {
                    throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                  }
                  continue;
                }
                params[key] = source[key];
              }
              params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
              params.CMapReaderFactory = params.CMapReaderFactory || _display_utils.DOMCMapReaderFactory;
              params.ignoreErrors = params.stopAtErrors !== true;
              params.pdfBug = params.pdfBug === true;
              const NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);
              if (params.nativeImageDecoderSupport === void 0 || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
                params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
              }
              if (!Number.isInteger(params.maxImageSize)) {
                params.maxImageSize = -1;
              }
              if (typeof params.isEvalSupported !== "boolean") {
                params.isEvalSupported = true;
              }
              if (typeof params.disableFontFace !== "boolean") {
                params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
              }
              if (typeof params.disableRange !== "boolean") {
                params.disableRange = false;
              }
              if (typeof params.disableStream !== "boolean") {
                params.disableStream = false;
              }
              if (typeof params.disableAutoFetch !== "boolean") {
                params.disableAutoFetch = false;
              }
              if (typeof params.disableCreateObjectURL !== "boolean") {
                params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
              }
              (0, _util.setVerbosityLevel)(params.verbosity);
              if (!worker2) {
                const workerParams = {
                  verbosity: params.verbosity,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                task._worker = worker2;
              }
              const docId = task.docId;
              worker2.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                return _fetchDocument(worker2, params, rangeTransport, docId).then(function(workerId) {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  let networkStream;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length: params.length,
                      initialData: params.initialData,
                      progressiveDone: params.progressiveDone,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    }, rangeTransport);
                  } else if (!params.data) {
                    networkStream = createPDFNetworkStream({
                      url: params.url,
                      length: params.length,
                      httpHeaders: params.httpHeaders,
                      withCredentials: params.withCredentials,
                      rangeChunkSize: params.rangeChunkSize,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    });
                  }
                  const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                  messageHandler.postMessageTransfers = worker2.postMessageTransfers;
                  const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              }).catch(task._capability.reject);
              return task;
            }
            function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
              if (worker2.destroyed) {
                return Promise.reject(new Error("Worker was destroyed"));
              }
              if (pdfDataRangeTransport) {
                source.length = pdfDataRangeTransport.length;
                source.initialData = pdfDataRangeTransport.initialData;
                source.progressiveDone = pdfDataRangeTransport.progressiveDone;
              }
              return worker2.messageHandler.sendWithPromise("GetDocRequest", {
                docId,
                apiVersion: "2.4.456",
                source: {
                  data: source.data,
                  url: source.url,
                  password: source.password,
                  disableAutoFetch: source.disableAutoFetch,
                  rangeChunkSize: source.rangeChunkSize,
                  length: source.length
                },
                maxImageSize: source.maxImageSize,
                disableFontFace: source.disableFontFace,
                disableCreateObjectURL: source.disableCreateObjectURL,
                postMessageTransfers: worker2.postMessageTransfers,
                docBaseUrl: source.docBaseUrl,
                nativeImageDecoderSupport: source.nativeImageDecoderSupport,
                ignoreErrors: source.ignoreErrors,
                isEvalSupported: source.isEvalSupported
              }).then(function(workerId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              });
            }
            const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
              let nextDocumentId = 0;
              class PDFDocumentLoadingTask2 {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = "d" + nextDocumentId++;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                destroy() {
                  this.destroyed = true;
                  const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                  return transportDestroyed.then(() => {
                    this._transport = null;
                    if (this._worker) {
                      this._worker.destroy();
                      this._worker = null;
                    }
                  });
                }
                then(onFulfilled, onRejected) {
                  throw new Error("Removed API method: PDFDocumentLoadingTask.then, use the `promise` getter instead.");
                }
              }
              return PDFDocumentLoadingTask2;
            }();
            class PDFDataRangeTransport {
              constructor(length, initialData, progressiveDone = false) {
                this.length = length;
                this.initialData = initialData;
                this.progressiveDone = progressiveDone;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._progressiveDoneListeners = [];
                this._readyCapability = (0, _util.createPromiseCapability)();
              }
              addRangeListener(listener) {
                this._rangeListeners.push(listener);
              }
              addProgressListener(listener) {
                this._progressListeners.push(listener);
              }
              addProgressiveReadListener(listener) {
                this._progressiveReadListeners.push(listener);
              }
              addProgressiveDoneListener(listener) {
                this._progressiveDoneListeners.push(listener);
              }
              onDataRange(begin, chunk) {
                for (const listener of this._rangeListeners) {
                  listener(begin, chunk);
                }
              }
              onDataProgress(loaded, total) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressListeners) {
                    listener(loaded, total);
                  }
                });
              }
              onDataProgressiveRead(chunk) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveReadListeners) {
                    listener(chunk);
                  }
                });
              }
              onDataProgressiveDone() {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveDoneListeners) {
                    listener();
                  }
                });
              }
              transportReady() {
                this._readyCapability.resolve();
              }
              requestDataRange(begin, end) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
              abort() {
              }
            }
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            class PDFDocumentProxy {
              constructor(pdfInfo, transport) {
                this._pdfInfo = pdfInfo;
                this._transport = transport;
              }
              get numPages() {
                return this._pdfInfo.numPages;
              }
              get fingerprint() {
                return this._pdfInfo.fingerprint;
              }
              getPage(pageNumber) {
                return this._transport.getPage(pageNumber);
              }
              getPageIndex(ref) {
                return this._transport.getPageIndex(ref);
              }
              getDestinations() {
                return this._transport.getDestinations();
              }
              getDestination(id) {
                return this._transport.getDestination(id);
              }
              getPageLabels() {
                return this._transport.getPageLabels();
              }
              getPageLayout() {
                return this._transport.getPageLayout();
              }
              getPageMode() {
                return this._transport.getPageMode();
              }
              getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
              getOpenAction() {
                return this._transport.getOpenAction();
              }
              getOpenActionDestination() {
                (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead.");
                return this.getOpenAction().then(function(openAction) {
                  return openAction && openAction.dest ? openAction.dest : null;
                });
              }
              getAttachments() {
                return this._transport.getAttachments();
              }
              getJavaScript() {
                return this._transport.getJavaScript();
              }
              getOutline() {
                return this._transport.getOutline();
              }
              getPermissions() {
                return this._transport.getPermissions();
              }
              getMetadata() {
                return this._transport.getMetadata();
              }
              getData() {
                return this._transport.getData();
              }
              getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
              getStats() {
                return this._transport.getStats();
              }
              cleanup() {
                return this._transport.startCleanup();
              }
              destroy() {
                return this.loadingTask.destroy();
              }
              get loadingParams() {
                return this._transport.loadingParams;
              }
              get loadingTask() {
                return this._transport.loadingTask;
              }
            }
            exports.PDFDocumentProxy = PDFDocumentProxy;
            class PDFPageProxy {
              constructor(pageIndex, pageInfo, transport, pdfBug = false) {
                this._pageIndex = pageIndex;
                this._pageInfo = pageInfo;
                this._transport = transport;
                this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this.cleanupAfterRender = false;
                this.pendingCleanup = false;
                this.intentStates = /* @__PURE__ */ Object.create(null);
                this.destroyed = false;
              }
              get pageNumber() {
                return this._pageIndex + 1;
              }
              get rotate() {
                return this._pageInfo.rotate;
              }
              get ref() {
                return this._pageInfo.ref;
              }
              get userUnit() {
                return this._pageInfo.userUnit;
              }
              get view() {
                return this._pageInfo.view;
              }
              getViewport({
                scale,
                rotation = this.rotate,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              } = {}) {
                if (arguments.length > 1 || typeof arguments[0] === "number") {
                  throw new Error("PDFPageProxy.getViewport is called with obsolete arguments.");
                }
                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              getAnnotations({
                intent = null
              } = {}) {
                if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                  this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                  this.annotationsIntent = intent;
                }
                return this.annotationsPromise;
              }
              render({
                canvasContext,
                viewport,
                intent = "display",
                enableWebGL = false,
                renderInteractiveForms = false,
                transform = null,
                imageLayer = null,
                canvasFactory = null,
                background = null
              }) {
                if (this._stats) {
                  this._stats.time("Overall");
                }
                const renderingIntent = intent === "print" ? "print" : "display";
                this.pendingCleanup = false;
                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                }
                const intentState = this.intentStates[renderingIntent];
                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }
                const canvasFactoryInstance = canvasFactory || new _display_utils.DOMCanvasFactory();
                const webGLContext = new _webgl.WebGLContext({
                  enable: enableWebGL
                });
                if (!intentState.displayReadyCapability) {
                  intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    renderInteractiveForms: renderInteractiveForms === true
                  });
                }
                const complete = (error) => {
                  const i2 = intentState.renderTasks.indexOf(internalRenderTask);
                  if (i2 >= 0) {
                    intentState.renderTasks.splice(i2, 1);
                  }
                  if (this.cleanupAfterRender || renderingIntent === "print") {
                    this.pendingCleanup = true;
                  }
                  this._tryCleanup();
                  if (error) {
                    internalRenderTask.capability.reject(error);
                    this._abortOperatorList({
                      intentState,
                      reason: error
                    });
                  } else {
                    internalRenderTask.capability.resolve();
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Rendering");
                    this._stats.timeEnd("Overall");
                  }
                };
                const internalRenderTask = new InternalRenderTask({
                  callback: complete,
                  params: {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  operatorList: intentState.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: canvasFactoryInstance,
                  webGLContext,
                  useRequestAnimationFrame: renderingIntent !== "print",
                  pdfBug: this._pdfBug
                });
                if (!intentState.renderTasks) {
                  intentState.renderTasks = [];
                }
                intentState.renderTasks.push(internalRenderTask);
                const renderTask = internalRenderTask.task;
                intentState.displayReadyCapability.promise.then((transparency) => {
                  if (this.pendingCleanup) {
                    complete();
                    return;
                  }
                  if (this._stats) {
                    this._stats.time("Rendering");
                  }
                  internalRenderTask.initializeGraphics(transparency);
                  internalRenderTask.operatorListChanged();
                }).catch(complete);
                return renderTask;
              }
              getOperatorList() {
                function operatorListChanged() {
                  if (intentState.operatorList.lastChunk) {
                    intentState.opListReadCapability.resolve(intentState.operatorList);
                    const i2 = intentState.renderTasks.indexOf(opListTask);
                    if (i2 >= 0) {
                      intentState.renderTasks.splice(i2, 1);
                    }
                  }
                }
                const renderingIntent = "oplist";
                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                }
                const intentState = this.intentStates[renderingIntent];
                let opListTask;
                if (!intentState.opListReadCapability) {
                  opListTask = {};
                  opListTask.operatorListChanged = operatorListChanged;
                  intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                  intentState.renderTasks = [];
                  intentState.renderTasks.push(opListTask);
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent
                  });
                }
                return intentState.opListReadCapability.promise;
              }
              streamTextContent({
                normalizeWhitespace = false,
                disableCombineTextItems = false
              } = {}) {
                const TEXT_CONTENT_CHUNK_SIZE = 100;
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  normalizeWhitespace: normalizeWhitespace === true,
                  combineTextItems: disableCombineTextItems !== true
                }, {
                  highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                  size(textContent) {
                    return textContent.items.length;
                  }
                });
              }
              getTextContent(params = {}) {
                const readableStream = this.streamTextContent(params);
                return new Promise(function(resolve, reject) {
                  function pump() {
                    reader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        resolve(textContent);
                        return;
                      }
                      Object.assign(textContent.styles, value.styles);
                      textContent.items.push(...value.items);
                      pump();
                    }, reject);
                  }
                  const reader = readableStream.getReader();
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  pump();
                });
              }
              _destroy() {
                this.destroyed = true;
                this._transport.pageCache[this._pageIndex] = null;
                const waitOn = [];
                Object.keys(this.intentStates).forEach((intent) => {
                  const intentState = this.intentStates[intent];
                  this._abortOperatorList({
                    intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });
                  if (intent === "oplist") {
                    return;
                  }
                  intentState.renderTasks.forEach(function(renderTask) {
                    const renderCompleted = renderTask.capability.promise.catch(function() {
                    });
                    waitOn.push(renderCompleted);
                    renderTask.cancel();
                  });
                });
                this.objs.clear();
                this.annotationsPromise = null;
                this.pendingCleanup = false;
                return Promise.all(waitOn);
              }
              cleanup(resetStats = false) {
                this.pendingCleanup = true;
                return this._tryCleanup(resetStats);
              }
              _tryCleanup(resetStats = false) {
                if (!this.pendingCleanup || Object.keys(this.intentStates).some((intent) => {
                  const intentState = this.intentStates[intent];
                  return intentState.renderTasks.length !== 0 || !intentState.operatorList.lastChunk;
                })) {
                  return false;
                }
                Object.keys(this.intentStates).forEach((intent) => {
                  delete this.intentStates[intent];
                });
                this.objs.clear();
                this.annotationsPromise = null;
                if (resetStats && this._stats) {
                  this._stats = new _display_utils.StatTimer();
                }
                this.pendingCleanup = false;
                return true;
              }
              _startRenderPage(transparency, intent) {
                const intentState = this.intentStates[intent];
                if (!intentState) {
                  return;
                }
                if (this._stats) {
                  this._stats.timeEnd("Page Request");
                }
                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.resolve(transparency);
                }
              }
              _renderPageChunk(operatorListChunk, intentState) {
                for (let i2 = 0, ii = operatorListChunk.length; i2 < ii; i2++) {
                  intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i2]);
                  intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i2]);
                }
                intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                for (let i2 = 0; i2 < intentState.renderTasks.length; i2++) {
                  intentState.renderTasks[i2].operatorListChanged();
                }
                if (operatorListChunk.lastChunk) {
                  this._tryCleanup();
                }
              }
              _pumpOperatorList(args) {
                (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);
                const reader = readableStream.getReader();
                const intentState = this.intentStates[args.intent];
                intentState.streamReader = reader;
                const pump = () => {
                  reader.read().then(({
                    value,
                    done
                  }) => {
                    if (done) {
                      intentState.streamReader = null;
                      return;
                    }
                    if (this._transport.destroyed) {
                      return;
                    }
                    this._renderPageChunk(value, intentState);
                    pump();
                  }, (reason) => {
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;
                      for (let i2 = 0; i2 < intentState.renderTasks.length; i2++) {
                        intentState.renderTasks[i2].operatorListChanged();
                      }
                      this._tryCleanup();
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(reason);
                    } else if (intentState.opListReadCapability) {
                      intentState.opListReadCapability.reject(reason);
                    } else {
                      throw reason;
                    }
                  });
                };
                pump();
              }
              _abortOperatorList({
                intentState,
                reason,
                force = false
              }) {
                (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');
                if (!intentState.streamReader) {
                  return;
                }
                if (!force) {
                  if (intentState.renderTasks.length !== 0) {
                    return;
                  }
                  if (reason instanceof _display_utils.RenderingCancelledException) {
                    intentState.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState,
                        reason,
                        force: true
                      });
                      intentState.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));
                intentState.streamReader = null;
                if (this._transport.destroyed) {
                  return;
                }
                Object.keys(this.intentStates).some((intent) => {
                  if (this.intentStates[intent] === intentState) {
                    delete this.intentStates[intent];
                    return true;
                  }
                  return false;
                });
                this.cleanup();
              }
              get stats() {
                return this._stats;
              }
            }
            exports.PDFPageProxy = PDFPageProxy;
            class LoopbackPort {
              constructor(defer = true) {
                this._listeners = [];
                this._defer = defer;
                this._deferred = Promise.resolve(void 0);
              }
              postMessage(obj, transfers) {
                function cloneValue(value) {
                  if (typeof value !== "object" || value === null) {
                    return value;
                  }
                  if (cloned.has(value)) {
                    return cloned.get(value);
                  }
                  let buffer, result;
                  if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                    const transferable = transfers && transfers.includes(buffer);
                    if (transferable) {
                      result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                    } else {
                      result = new value.constructor(value);
                    }
                    cloned.set(value, result);
                    return result;
                  }
                  result = Array.isArray(value) ? [] : {};
                  cloned.set(value, result);
                  for (const i2 in value) {
                    let desc, p = value;
                    while (!(desc = Object.getOwnPropertyDescriptor(p, i2))) {
                      p = Object.getPrototypeOf(p);
                    }
                    if (typeof desc.value === "undefined") {
                      continue;
                    }
                    if (typeof desc.value === "function") {
                      if (value.hasOwnProperty && value.hasOwnProperty(i2)) {
                        throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i2]}`);
                      }
                      continue;
                    }
                    result[i2] = cloneValue(desc.value);
                  }
                  return result;
                }
                if (!this._defer) {
                  this._listeners.forEach((listener) => {
                    listener.call(this, {
                      data: obj
                    });
                  });
                  return;
                }
                const cloned = /* @__PURE__ */ new WeakMap();
                const e2 = {
                  data: cloneValue(obj)
                };
                this._deferred.then(() => {
                  this._listeners.forEach((listener) => {
                    listener.call(this, e2);
                  });
                });
              }
              addEventListener(name, listener) {
                this._listeners.push(listener);
              }
              removeEventListener(name, listener) {
                const i2 = this._listeners.indexOf(listener);
                this._listeners.splice(i2, 1);
              }
              terminate() {
                this._listeners.length = 0;
              }
            }
            exports.LoopbackPort = LoopbackPort;
            const PDFWorker = function PDFWorkerClosure() {
              const pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
              let isWorkerDisabled = false;
              let fallbackWorkerSrc;
              let nextFakeWorkerId = 0;
              let fakeWorkerCapability;
              if (_is_node.isNodeJS && typeof __require === "function") {
                isWorkerDisabled = true;
                fallbackWorkerSrc = "./pdf.worker.js";
              } else if (typeof document === "object" && "currentScript" in document) {
                const pdfjsFilePath = document.currentScript && document.currentScript.src;
                if (pdfjsFilePath) {
                  fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
              }
              function getWorkerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (typeof fallbackWorkerSrc !== "undefined") {
                  if (!_is_node.isNodeJS) {
                    (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  return fallbackWorkerSrc;
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              function getMainThreadWorkerMessageHandler() {
                let mainWorkerMessageHandler2;
                try {
                  mainWorkerMessageHandler2 = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;
                } catch (ex) {
                }
                return mainWorkerMessageHandler2 || null;
              }
              function setupFakeWorkerGlobal() {
                if (fakeWorkerCapability) {
                  return fakeWorkerCapability.promise;
                }
                fakeWorkerCapability = (0, _util.createPromiseCapability)();
                const loader = async function() {
                  const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                  if (mainWorkerMessageHandler) {
                    return mainWorkerMessageHandler;
                  }
                  if (_is_node.isNodeJS && typeof __require === "function") {
                    const worker = eval("require")(getWorkerSrc());
                    return worker.WorkerMessageHandler;
                  }
                  await (0, _display_utils.loadScript)(getWorkerSrc());
                  return window.pdfjsWorker.WorkerMessageHandler;
                };
                loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
                return fakeWorkerCapability.promise;
              }
              function createCDNWrapper(url) {
                const wrapper = "importScripts('" + url + "');";
                return URL.createObjectURL(new Blob([wrapper]));
              }
              class PDFWorker {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && pdfWorkerPorts.has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.postMessageTransfers = true;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    pdfWorkerPorts.set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                    let workerSrc = getWorkerSrc();
                    try {
                      if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                        workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          if (!data.supportTransfers) {
                            this.postMessageTransfers = false;
                          }
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e2) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);
                        try {
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        } catch (ex) {
                          (0, _util.warn)("Cannot use postMessage transfers.");
                          testObj[0] = 0;
                          messageHandler.send("test", testObj);
                        }
                      };
                      sendTest();
                      return;
                    } catch (e2) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    isWorkerDisabled = true;
                  }
                  setupFakeWorkerGlobal().then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = "fake" + nextFakeWorkerId++;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  pdfWorkerPorts.delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params || !params.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (pdfWorkerPorts.has(params.port)) {
                    return pdfWorkerPorts.get(params.port);
                  }
                  return new PDFWorker(params);
                }
                static getWorkerSrc() {
                  return getWorkerSrc();
                }
              }
              return PDFWorker;
            }();
            exports.PDFWorker = PDFWorker;
            class WorkerTransport {
              constructor(messageHandler, loadingTask, networkStream, params) {
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader({
                  docId: loadingTask.docId,
                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
                });
                this._params = params;
                this.CMapReaderFactory = new params.CMapReaderFactory({
                  baseUrl: params.cMapUrl,
                  isCompressed: params.cMapPacked
                });
                this.destroyed = false;
                this.destroyCapability = null;
                this._passwordCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.pageCache = [];
                this.pagePromises = [];
                this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                this.setupMessageHandler();
              }
              destroy() {
                if (this.destroyCapability) {
                  return this.destroyCapability.promise;
                }
                this.destroyed = true;
                this.destroyCapability = (0, _util.createPromiseCapability)();
                if (this._passwordCapability) {
                  this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                }
                const waitOn = [];
                this.pageCache.forEach(function(page) {
                  if (page) {
                    waitOn.push(page._destroy());
                  }
                });
                this.pageCache.length = 0;
                this.pagePromises.length = 0;
                const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                waitOn.push(terminated);
                Promise.all(waitOn).then(() => {
                  this.fontLoader.clear();
                  if (this._networkStream) {
                    this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                  }
                  if (this.messageHandler) {
                    this.messageHandler.destroy();
                    this.messageHandler = null;
                  }
                  this.destroyCapability.resolve();
                }, this.destroyCapability.reject);
                return this.destroyCapability.promise;
              }
              setupMessageHandler() {
                const {
                  messageHandler,
                  loadingTask
                } = this;
                messageHandler.on("GetReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream);
                  this._fullReader = this._networkStream.getFullReader();
                  this._fullReader.onProgress = (evt) => {
                    this._lastProgress = {
                      loaded: evt.loaded,
                      total: evt.total
                    };
                  };
                  sink.onPull = () => {
                    this._fullReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    this._fullReader.cancel(reason);
                  };
                });
                messageHandler.on("ReaderHeadersReady", (data) => {
                  const headersCapability = (0, _util.createPromiseCapability)();
                  const fullReader = this._fullReader;
                  fullReader.headersReady.then(() => {
                    if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                      if (this._lastProgress && loadingTask.onProgress) {
                        loadingTask.onProgress(this._lastProgress);
                      }
                      fullReader.onProgress = (evt) => {
                        if (loadingTask.onProgress) {
                          loadingTask.onProgress({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        }
                      };
                    }
                    headersCapability.resolve({
                      isStreamingSupported: fullReader.isStreamingSupported,
                      isRangeSupported: fullReader.isRangeSupported,
                      contentLength: fullReader.contentLength
                    });
                  }, headersCapability.reject);
                  return headersCapability.promise;
                });
                messageHandler.on("GetRangeReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream);
                  const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                  if (!rangeReader) {
                    sink.close();
                    return;
                  }
                  sink.onPull = () => {
                    rangeReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    rangeReader.cancel(reason);
                  };
                });
                messageHandler.on("GetDoc", ({
                  pdfInfo
                }) => {
                  this._numPages = pdfInfo.numPages;
                  loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                });
                messageHandler.on("DocException", function(ex) {
                  let reason;
                  switch (ex.name) {
                    case "PasswordException":
                      reason = new _util.PasswordException(ex.message, ex.code);
                      break;
                    case "InvalidPDFException":
                      reason = new _util.InvalidPDFException(ex.message);
                      break;
                    case "MissingPDFException":
                      reason = new _util.MissingPDFException(ex.message);
                      break;
                    case "UnexpectedResponseException":
                      reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                      break;
                    case "UnknownErrorException":
                      reason = new _util.UnknownErrorException(ex.message, ex.details);
                      break;
                  }
                  loadingTask._capability.reject(reason);
                });
                messageHandler.on("PasswordRequest", (exception) => {
                  this._passwordCapability = (0, _util.createPromiseCapability)();
                  if (loadingTask.onPassword) {
                    const updatePassword = (password) => {
                      this._passwordCapability.resolve({
                        password
                      });
                    };
                    try {
                      loadingTask.onPassword(updatePassword, exception.code);
                    } catch (ex) {
                      this._passwordCapability.reject(ex);
                    }
                  } else {
                    this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                  }
                  return this._passwordCapability.promise;
                });
                messageHandler.on("DataLoaded", (data) => {
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.length,
                      total: data.length
                    });
                  }
                  this.downloadInfoCapability.resolve(data);
                });
                messageHandler.on("StartRenderPage", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const page = this.pageCache[data.pageIndex];
                  page._startRenderPage(data.transparency, data.intent);
                });
                messageHandler.on("commonobj", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const [id, type, exportedData] = data;
                  if (this.commonObjs.has(id)) {
                    return;
                  }
                  switch (type) {
                    case "Font":
                      const params = this._params;
                      if ("error" in exportedData) {
                        const exportedError = exportedData.error;
                        (0, _util.warn)(`Error during font loading: ${exportedError}`);
                        this.commonObjs.resolve(id, exportedError);
                        break;
                      }
                      let fontRegistry = null;
                      if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {
                        fontRegistry = {
                          registerFont(font2, url) {
                            globalThis.FontInspector.fontAdded(font2, url);
                          }
                        };
                      }
                      const font = new _font_loader.FontFaceObject(exportedData, {
                        isEvalSupported: params.isEvalSupported,
                        disableFontFace: params.disableFontFace,
                        ignoreErrors: params.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry
                      });
                      this.fontLoader.bind(font).then(() => {
                        this.commonObjs.resolve(id, font);
                      }, (reason) => {
                        messageHandler.sendWithPromise("FontFallback", {
                          id
                        }).finally(() => {
                          this.commonObjs.resolve(id, font);
                        });
                      });
                      break;
                    case "FontPath":
                    case "FontType3Res":
                      this.commonObjs.resolve(id, exportedData);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${type}`);
                  }
                });
                messageHandler.on("obj", (data) => {
                  if (this.destroyed) {
                    return void 0;
                  }
                  const [id, pageIndex, type, imageData] = data;
                  const pageProxy = this.pageCache[pageIndex];
                  if (pageProxy.objs.has(id)) {
                    return void 0;
                  }
                  switch (type) {
                    case "JpegStream":
                      return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = function() {
                          resolve(img);
                        };
                        img.onerror = function() {
                          reject(new Error("Error during JPEG image loading"));
                          (0, _display_utils.releaseImageResources)(img);
                        };
                        img.src = imageData;
                      }).then((img) => {
                        pageProxy.objs.resolve(id, img);
                      });
                    case "Image":
                      pageProxy.objs.resolve(id, imageData);
                      const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                      if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                        pageProxy.cleanupAfterRender = true;
                      }
                      break;
                    default:
                      throw new Error(`Got unknown object type ${type}`);
                  }
                  return void 0;
                });
                messageHandler.on("DocProgress", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.loaded,
                      total: data.total
                    });
                  }
                });
                messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                messageHandler.on("JpegDecode", (data) => {
                  if (this.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed"));
                  }
                  if (typeof document === "undefined") {
                    return Promise.reject(new Error('"document" is not defined.'));
                  }
                  const [imageUrl, components] = data;
                  if (components !== 3 && components !== 1) {
                    return Promise.reject(new Error("Only 3 components or 1 component can be returned"));
                  }
                  return new Promise(function(resolve, reject) {
                    const img = new Image();
                    img.onload = function() {
                      const {
                        width,
                        height
                      } = img;
                      const size = width * height;
                      const rgbaLength = size * 4;
                      const buf = new Uint8ClampedArray(size * components);
                      let tmpCanvas = document.createElement("canvas");
                      tmpCanvas.width = width;
                      tmpCanvas.height = height;
                      let tmpCtx = tmpCanvas.getContext("2d");
                      tmpCtx.drawImage(img, 0, 0);
                      const data2 = tmpCtx.getImageData(0, 0, width, height).data;
                      if (components === 3) {
                        for (let i2 = 0, j2 = 0; i2 < rgbaLength; i2 += 4, j2 += 3) {
                          buf[j2] = data2[i2];
                          buf[j2 + 1] = data2[i2 + 1];
                          buf[j2 + 2] = data2[i2 + 2];
                        }
                      } else if (components === 1) {
                        for (let i2 = 0, j2 = 0; i2 < rgbaLength; i2 += 4, j2++) {
                          buf[j2] = data2[i2];
                        }
                      }
                      resolve({
                        data: buf,
                        width,
                        height
                      });
                      (0, _display_utils.releaseImageResources)(img);
                      tmpCanvas.width = 0;
                      tmpCanvas.height = 0;
                      tmpCanvas = null;
                      tmpCtx = null;
                    };
                    img.onerror = function() {
                      reject(new Error("JpegDecode failed to load image"));
                      (0, _display_utils.releaseImageResources)(img);
                    };
                    img.src = imageUrl;
                  });
                });
                messageHandler.on("FetchBuiltInCMap", (data, sink) => {
                  if (this.destroyed) {
                    sink.error(new Error("Worker was destroyed"));
                    return;
                  }
                  let fetched = false;
                  sink.onPull = () => {
                    if (fetched) {
                      sink.close();
                      return;
                    }
                    fetched = true;
                    this.CMapReaderFactory.fetch(data).then(function(builtInCMap) {
                      sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                    }).catch(function(reason) {
                      sink.error(reason);
                    });
                  };
                });
              }
              _onUnsupportedFeature({
                featureId
              }) {
                if (this.destroyed) {
                  return;
                }
                if (this.loadingTask.onUnsupportedFeature) {
                  this.loadingTask.onUnsupportedFeature(featureId);
                }
              }
              getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
              getPage(pageNumber) {
                if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                  return Promise.reject(new Error("Invalid page request"));
                }
                const pageIndex = pageNumber - 1;
                if (pageIndex in this.pagePromises) {
                  return this.pagePromises[pageIndex];
                }
                const promise = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex
                }).then((pageInfo) => {
                  if (this.destroyed) {
                    throw new Error("Transport destroyed");
                  }
                  const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
                  this.pageCache[pageIndex] = page;
                  return page;
                });
                this.pagePromises[pageIndex] = promise;
                return promise;
              }
              getPageIndex(ref) {
                return this.messageHandler.sendWithPromise("GetPageIndex", {
                  ref
                }).catch(function(reason) {
                  return Promise.reject(new Error(reason));
                });
              }
              getAnnotations(pageIndex, intent) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex,
                  intent
                });
              }
              getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
              getDestination(id) {
                if (typeof id !== "string") {
                  return Promise.reject(new Error("Invalid destination request."));
                }
                return this.messageHandler.sendWithPromise("GetDestination", {
                  id
                });
              }
              getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
              getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
              getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
              getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
              getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
              getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
              getJavaScript() {
                return this.messageHandler.sendWithPromise("GetJavaScript", null);
              }
              getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
              getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
              getMetadata() {
                return this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                  return {
                    info: results[0],
                    metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                    contentDispositionFilename: this._fullReader ? this._fullReader.filename : null
                  };
                });
              }
              getStats() {
                return this.messageHandler.sendWithPromise("GetStats", null);
              }
              startCleanup() {
                return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {
                  for (let i2 = 0, ii = this.pageCache.length; i2 < ii; i2++) {
                    const page = this.pageCache[i2];
                    if (page) {
                      const cleanupSuccessful = page.cleanup();
                      if (!cleanupSuccessful) {
                        throw new Error(`startCleanup: Page ${i2 + 1} is currently rendering.`);
                      }
                    }
                  }
                  this.commonObjs.clear();
                  this.fontLoader.clear();
                });
              }
              get loadingParams() {
                const params = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch: params.disableAutoFetch,
                  disableCreateObjectURL: params.disableCreateObjectURL,
                  disableFontFace: params.disableFontFace,
                  nativeImageDecoderSupport: params.nativeImageDecoderSupport
                });
              }
            }
            class PDFObjects {
              constructor() {
                this._objs = /* @__PURE__ */ Object.create(null);
              }
              _ensureObj(objId) {
                if (this._objs[objId]) {
                  return this._objs[objId];
                }
                return this._objs[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null,
                  resolved: false
                };
              }
              get(objId, callback = null) {
                if (callback) {
                  this._ensureObj(objId).capability.promise.then(callback);
                  return null;
                }
                const obj = this._objs[objId];
                if (!obj || !obj.resolved) {
                  throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                }
                return obj.data;
              }
              has(objId) {
                const obj = this._objs[objId];
                return obj ? obj.resolved : false;
              }
              resolve(objId, data) {
                const obj = this._ensureObj(objId);
                obj.resolved = true;
                obj.data = data;
                obj.capability.resolve(data);
              }
              clear() {
                for (const objId in this._objs) {
                  const {
                    data
                  } = this._objs[objId];
                  if (typeof Image !== "undefined" && data instanceof Image) {
                    (0, _display_utils.releaseImageResources)(data);
                  }
                }
                this._objs = /* @__PURE__ */ Object.create(null);
              }
            }
            class RenderTask {
              constructor(internalRenderTask) {
                this._internalRenderTask = internalRenderTask;
                this.onContinue = null;
              }
              get promise() {
                return this._internalRenderTask.capability.promise;
              }
              cancel() {
                this._internalRenderTask.cancel();
              }
              then(onFulfilled, onRejected) {
                throw new Error("Removed API method: RenderTask.then, use the `promise` getter instead.");
              }
            }
            const InternalRenderTask = function InternalRenderTaskClosure() {
              const canvasInRendering = /* @__PURE__ */ new WeakSet();
              class InternalRenderTask2 {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  webGLContext,
                  useRequestAnimationFrame = false,
                  pdfBug = false
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.webGLContext = webGLContext;
                  this._pdfBug = pdfBug;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                initializeGraphics(transparency = false) {
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (canvasInRendering.has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    canvasInRendering.add(this._canvas);
                  }
                  if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    canvasInRendering.delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this.cancel.bind(this));
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        canvasInRendering.delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              }
              return InternalRenderTask2;
            }();
            const version = "2.4.456";
            exports.version = version;
            const build = "228a591c";
            exports.build = build;
          },
          /* 4 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.addLinkAttributes = addLinkAttributes;
            exports2.getFilenameFromUrl = getFilenameFromUrl;
            exports2.isFetchSupported = isFetchSupported;
            exports2.isValidFetchUrl = isValidFetchUrl;
            exports2.loadScript = loadScript;
            exports2.deprecated = deprecated;
            exports2.releaseImageResources = releaseImageResources;
            exports2.PDFDateString = exports2.StatTimer = exports2.DOMSVGFactory = exports2.DOMCMapReaderFactory = exports2.DOMCanvasFactory = exports2.DEFAULT_LINK_REL = exports2.LinkTarget = exports2.RenderingCancelledException = exports2.PageViewport = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
            exports2.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
            const SVG_NS = "http://www.w3.org/2000/svg";
            class DOMCanvasFactory {
              create(width, height) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                const canvas = document.createElement("canvas");
                const context = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                return {
                  canvas,
                  context
                };
              }
              reset(canvasAndContext, width, height) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                canvasAndContext.canvas.width = width;
                canvasAndContext.canvas.height = height;
              }
              destroy(canvasAndContext) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                canvasAndContext.canvas.width = 0;
                canvasAndContext.canvas.height = 0;
                canvasAndContext.canvas = null;
                canvasAndContext.context = null;
              }
            }
            exports2.DOMCanvasFactory = DOMCanvasFactory;
            class DOMCMapReaderFactory {
              constructor({
                baseUrl = null,
                isCompressed = false
              }) {
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              async fetch({
                name
              }) {
                if (!this.baseUrl) {
                  throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                }
                if (!name) {
                  throw new Error("CMap name must be specified.");
                }
                const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
                  return fetch(url).then(async (response) => {
                    if (!response.ok) {
                      throw new Error(response.statusText);
                    }
                    let cMapData;
                    if (this.isCompressed) {
                      cMapData = new Uint8Array(await response.arrayBuffer());
                    } else {
                      cMapData = (0, _util2.stringToBytes)(await response.text());
                    }
                    return {
                      cMapData,
                      compressionType
                    };
                  }).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (this.isCompressed) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let cMapData;
                      if (this.isCompressed && request.response) {
                        cMapData = new Uint8Array(request.response);
                      } else if (!this.isCompressed && request.responseText) {
                        cMapData = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (cMapData) {
                        resolve({
                          cMapData,
                          compressionType
                        });
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                }).catch((reason) => {
                  throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                });
              }
            }
            exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
            class DOMSVGFactory {
              create(width, height) {
                (0, _util2.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                const svg = document.createElementNS(SVG_NS, "svg:svg");
                svg.setAttribute("version", "1.1");
                svg.setAttribute("width", width + "px");
                svg.setAttribute("height", height + "px");
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                return svg;
              }
              createElement(type) {
                (0, _util2.assert)(typeof type === "string", "Invalid SVG element type");
                return document.createElementNS(SVG_NS, type);
              }
            }
            exports2.DOMSVGFactory = DOMSVGFactory;
            class PageViewport {
              constructor({
                viewBox,
                scale,
                rotation,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              }) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                const centerX = (viewBox[2] + viewBox[0]) / 2;
                const centerY = (viewBox[3] + viewBox[1]) / 2;
                let rotateA, rotateB, rotateC, rotateD;
                rotation = rotation % 360;
                rotation = rotation < 0 ? rotation + 360 : rotation;
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  default:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                let offsetCanvasX, offsetCanvasY;
                let width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              clone({
                scale = this.scale,
                rotation = this.rotation,
                offsetX = this.offsetX,
                offsetY = this.offsetY,
                dontFlip = false
              } = {}) {
                return new PageViewport({
                  viewBox: this.viewBox.slice(),
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              convertToViewportPoint(x2, y2) {
                return _util2.Util.applyTransform([x2, y2], this.transform);
              }
              convertToViewportRectangle(rect) {
                const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
              }
              convertToPdfPoint(x2, y2) {
                return _util2.Util.applyInverseTransform([x2, y2], this.transform);
              }
            }
            exports2.PageViewport = PageViewport;
            class RenderingCancelledException extends _util2.BaseException {
              constructor(msg, type) {
                super(msg);
                this.type = type;
              }
            }
            exports2.RenderingCancelledException = RenderingCancelledException;
            const LinkTarget = {
              NONE: 0,
              SELF: 1,
              BLANK: 2,
              PARENT: 3,
              TOP: 4
            };
            exports2.LinkTarget = LinkTarget;
            function addLinkAttributes(link, {
              url,
              target,
              rel,
              enabled = true
            } = {}) {
              (0, _util2.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
              const urlNullRemoved = (0, _util2.removeNullCharacters)(url);
              if (enabled) {
                link.href = link.title = urlNullRemoved;
              } else {
                link.href = "";
                link.title = `Disabled: ${urlNullRemoved}`;
                link.onclick = () => {
                  return false;
                };
              }
              let targetStr = "";
              switch (target) {
                case LinkTarget.NONE:
                  break;
                case LinkTarget.SELF:
                  targetStr = "_self";
                  break;
                case LinkTarget.BLANK:
                  targetStr = "_blank";
                  break;
                case LinkTarget.PARENT:
                  targetStr = "_parent";
                  break;
                case LinkTarget.TOP:
                  targetStr = "_top";
                  break;
              }
              link.target = targetStr;
              link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
            }
            function getFilenameFromUrl(url) {
              const anchor = url.indexOf("#");
              const query = url.indexOf("?");
              const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
              return url.substring(url.lastIndexOf("/", end) + 1, end);
            }
            class StatTimer {
              constructor() {
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
              }
              time(name) {
                if (name in this.started) {
                  (0, _util2.warn)(`Timer is already running for ${name}`);
                }
                this.started[name] = Date.now();
              }
              timeEnd(name) {
                if (!(name in this.started)) {
                  (0, _util2.warn)(`Timer has not been started for ${name}`);
                }
                this.times.push({
                  name,
                  start: this.started[name],
                  end: Date.now()
                });
                delete this.started[name];
              }
              toString() {
                const outBuf = [];
                let longest = 0;
                for (const time of this.times) {
                  const name = time.name;
                  if (name.length > longest) {
                    longest = name.length;
                  }
                }
                for (const time of this.times) {
                  const duration = time.end - time.start;
                  outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                }
                return outBuf.join("");
              }
            }
            exports2.StatTimer = StatTimer;
            function isFetchSupported() {
              return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
            }
            function isValidFetchUrl(url, baseUrl) {
              try {
                const {
                  protocol
                } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                return protocol === "http:" || protocol === "https:";
              } catch (ex) {
                return false;
              }
            }
            function loadScript(src) {
              return new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.src = src;
                script.onload = resolve;
                script.onerror = function() {
                  reject(new Error(`Cannot load script at: ${script.src}`));
                };
                (document.head || document.documentElement).appendChild(script);
              });
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function releaseImageResources(img) {
              (0, _util2.assert)(img instanceof Image, "Invalid `img` parameter.");
              const url = img.src;
              if (typeof url === "string" && url.startsWith("blob:") && URL.revokeObjectURL) {
                URL.revokeObjectURL(url);
              }
              img.removeAttribute("src");
            }
            let pdfDateStringRegex;
            class PDFDateString {
              static toDateObject(input) {
                if (!input || !(0, _util2.isString)(input)) {
                  return null;
                }
                if (!pdfDateStringRegex) {
                  pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                }
                const matches = pdfDateStringRegex.exec(input);
                if (!matches) {
                  return null;
                }
                const year = parseInt(matches[1], 10);
                let month = parseInt(matches[2], 10);
                month = month >= 1 && month <= 12 ? month - 1 : 0;
                let day = parseInt(matches[3], 10);
                day = day >= 1 && day <= 31 ? day : 1;
                let hour = parseInt(matches[4], 10);
                hour = hour >= 0 && hour <= 23 ? hour : 0;
                let minute = parseInt(matches[5], 10);
                minute = minute >= 0 && minute <= 59 ? minute : 0;
                let second = parseInt(matches[6], 10);
                second = second >= 0 && second <= 59 ? second : 0;
                const universalTimeRelation = matches[7] || "Z";
                let offsetHour = parseInt(matches[8], 10);
                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                let offsetMinute = parseInt(matches[9], 10) || 0;
                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                if (universalTimeRelation === "-") {
                  hour += offsetHour;
                  minute += offsetMinute;
                } else if (universalTimeRelation === "+") {
                  hour -= offsetHour;
                  minute -= offsetMinute;
                }
                return new Date(Date.UTC(year, month, day, hour, minute, second));
              }
            }
            exports2.PDFDateString = PDFDateString;
          },
          /* 5 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontLoader = exports2.FontFaceObject = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            class BaseFontLoader {
              constructor({
                docId,
                onUnsupportedFeature
              }) {
                if (this.constructor === BaseFontLoader) {
                  (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                }
                this.docId = docId;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.nativeFontFaces = [];
                this.styleElement = null;
              }
              addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.push(nativeFontFace);
                document.fonts.add(nativeFontFace);
              }
              insertRule(rule) {
                let styleElement = this.styleElement;
                if (!styleElement) {
                  styleElement = this.styleElement = document.createElement("style");
                  styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                  document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                }
                const styleSheet = styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              }
              clear() {
                this.nativeFontFaces.forEach(function(nativeFontFace) {
                  document.fonts.delete(nativeFontFace);
                });
                this.nativeFontFaces.length = 0;
                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
              }
              async bind(font) {
                if (font.attached || font.missingFile) {
                  return;
                }
                font.attached = true;
                if (this.isFontLoadingAPISupported) {
                  const nativeFontFace = font.createNativeFontFace();
                  if (nativeFontFace) {
                    this.addNativeFontFace(nativeFontFace);
                    try {
                      await nativeFontFace.loaded;
                    } catch (ex) {
                      this._onUnsupportedFeature({
                        featureId: _util2.UNSUPPORTED_FEATURES.font
                      });
                      (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                      font.disableFontFace = true;
                      throw ex;
                    }
                  }
                  return;
                }
                const rule = font.createFontFaceRule();
                if (rule) {
                  this.insertRule(rule);
                  if (this.isSyncFontLoadingSupported) {
                    return;
                  }
                  await new Promise((resolve) => {
                    const request = this._queueLoadingCallback(resolve);
                    this._prepareFontLoadEvent([rule], [font], request);
                  });
                }
              }
              _queueLoadingCallback(callback) {
                (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
              }
              get isFontLoadingAPISupported() {
                const supported = typeof document !== "undefined" && !!document.fonts;
                return (0, _util2.shadow)(this, "isFontLoadingAPISupported", supported);
              }
              get isSyncFontLoadingSupported() {
                (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
              }
              get _loadTestFont() {
                (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
              }
              _prepareFontLoadEvent(rules, fontsToLoad, request) {
                (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
              }
            }
            let FontLoader;
            exports2.FontLoader = FontLoader;
            {
              exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                constructor(docId) {
                  super(docId);
                  this.loadingContext = {
                    requests: [],
                    nextRequestId: 0
                  };
                  this.loadTestFontId = 0;
                }
                get isSyncFontLoadingSupported() {
                  let supported = false;
                  if (typeof navigator === "undefined") {
                    supported = true;
                  } else {
                    const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                    if (m && m[1] >= 14) {
                      supported = true;
                    }
                  }
                  return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
                _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;
                    while (context.requests.length > 0 && context.requests[0].done) {
                      const otherRequest = context.requests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }
                  const context = this.loadingContext;
                  const request = {
                    id: `pdfjs-font-loading-${context.nextRequestId++}`,
                    done: false,
                    complete: completeRequest,
                    callback
                  };
                  context.requests.push(request);
                  return request;
                }
                get _loadTestFont() {
                  const getLoadTestFont = function() {
                    return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  };
                  return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                }
                _prepareFontLoadEvent(rules, fonts, request) {
                  function int32(data2, offset) {
                    return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                  }
                  function spliceString(s2, offset, remove, insert) {
                    const chunk1 = s2.substring(0, offset);
                    const chunk2 = s2.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }
                  let i2, ii;
                  const canvas = document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext("2d");
                  let called = 0;
                  function isFontReady(name, callback) {
                    called++;
                    if (called > 30) {
                      (0, _util2.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }
                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }
                    setTimeout(isFontReady.bind(null, name, callback));
                  }
                  const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                  let data = this._loadTestFont;
                  const COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  const CFF_CHECKSUM_OFFSET = 16;
                  const XXXX_VALUE = 1482184792;
                  let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                  for (i2 = 0, ii = loadTestFontId.length - 3; i2 < ii; i2 += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i2) | 0;
                  }
                  if (i2 < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i2) | 0;
                  }
                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                  const url = `url(data:font/opentype;base64,${btoa(data)});`;
                  const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                  this.insertRule(rule);
                  const names = [];
                  for (i2 = 0, ii = fonts.length; i2 < ii; i2++) {
                    names.push(fonts[i2].loadedName);
                  }
                  names.push(loadTestFontId);
                  const div = document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";
                  for (i2 = 0, ii = names.length; i2 < ii; ++i2) {
                    const span = document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = names[i2];
                    div.appendChild(span);
                  }
                  document.body.appendChild(div);
                  isFontReady(loadTestFontId, function() {
                    document.body.removeChild(div);
                    request.complete();
                  });
                }
              };
            }
            class FontFaceObject {
              constructor(translatedData, {
                isEvalSupported = true,
                disableFontFace = false,
                ignoreErrors = false,
                onUnsupportedFeature = null,
                fontRegistry = null
              }) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (const i2 in translatedData) {
                  this[i2] = translatedData[i2];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.ignoreErrors = ignoreErrors === true;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.fontRegistry = fontRegistry;
              }
              createNativeFontFace() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const nativeFontFace = new FontFace(this.loadedName, this.data, {});
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this);
                }
                return nativeFontFace;
              }
              createFontFaceRule() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const data = (0, _util2.bytesToString)(new Uint8Array(this.data));
                const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this, url);
                }
                return rule;
              }
              getPathGenerator(objs, character) {
                if (this.compiledGlyphs[character] !== void 0) {
                  return this.compiledGlyphs[character];
                }
                let cmds, current;
                try {
                  cmds = objs.get(this.loadedName + "_path_" + character);
                } catch (ex) {
                  if (!this.ignoreErrors) {
                    throw ex;
                  }
                  if (this._onUnsupportedFeature) {
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.font
                    });
                  }
                  (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                  return this.compiledGlyphs[character] = function(c2, size) {
                  };
                }
                if (this.isEvalSupported && _util2.IsEvalSupportedCached.value) {
                  let args, js = "";
                  for (let i2 = 0, ii = cmds.length; i2 < ii; i2++) {
                    current = cmds[i2];
                    if (current.args !== void 0) {
                      args = current.args.join(",");
                    } else {
                      args = "";
                    }
                    js += "c." + current.cmd + "(" + args + ");\n";
                  }
                  return this.compiledGlyphs[character] = new Function("c", "size", js);
                }
                return this.compiledGlyphs[character] = function(c2, size) {
                  for (let i2 = 0, ii = cmds.length; i2 < ii; i2++) {
                    current = cmds[i2];
                    if (current.cmd === "scale") {
                      current.args = [size, -size];
                    }
                    c2[current.cmd].apply(c2, current.args);
                  }
                };
              }
            }
            exports2.FontFaceObject = FontFaceObject;
          },
          /* 6 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            const compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              const {
                isNodeJS
              } = __w_pdfjs_require__2(7);
              const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
              const isIE = /Trident/.test(userAgent);
              const isIOSChrome = /CriOS/.test(userAgent);
              (function checkOnBlobSupport() {
                if (isIE || isIOSChrome) {
                  compatibilityParams.disableCreateObjectURL = true;
                }
              })();
              (function checkFontFaceAndImage() {
                if (isNodeJS) {
                  compatibilityParams.disableFontFace = true;
                  compatibilityParams.nativeImageDecoderSupport = "none";
                }
              })();
            }
            exports2.apiCompatibilityParams = Object.freeze(compatibilityParams);
          },
          /* 7 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isNodeJS = void 0;
            const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
            exports2.isNodeJS = isNodeJS;
          },
          /* 8 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CanvasGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _pattern_helper = __w_pdfjs_require__2(9);
            var MIN_FONT_SIZE = 16;
            var MAX_FONT_SIZE = 100;
            var MAX_GROUP_SIZE = 4096;
            var MIN_WIDTH_FACTOR = 0.65;
            var COMPILE_TYPE3_GLYPHS = true;
            var MAX_SIZE_TO_COMPILE = 1e3;
            var FULL_CHUNK_HEIGHT = 16;
            function addContextCurrentTransform(ctx) {
              if (!ctx.mozCurrentTransform) {
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    var m = this._transformMatrix;
                    var a2 = m[0], b2 = m[1], c2 = m[2], d2 = m[3], e2 = m[4], f = m[5];
                    var ad_bc = a2 * d2 - b2 * c2;
                    var bc_ad = b2 * c2 - a2 * d2;
                    return [d2 / ad_bc, b2 / bc_ad, c2 / bc_ad, a2 / ad_bc, (d2 * e2 - c2 * f) / bc_ad, (b2 * e2 - a2 * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  var old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  var prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x2, y2) {
                  var m = this._transformMatrix;
                  m[4] = m[0] * x2 + m[2] * y2 + m[4];
                  m[5] = m[1] * x2 + m[3] * y2 + m[5];
                  this._originalTranslate(x2, y2);
                };
                ctx.scale = function ctxScale(x2, y2) {
                  var m = this._transformMatrix;
                  m[0] = m[0] * x2;
                  m[1] = m[1] * x2;
                  m[2] = m[2] * y2;
                  m[3] = m[3] * y2;
                  this._originalScale(x2, y2);
                };
                ctx.transform = function ctxTransform(a2, b2, c2, d2, e2, f) {
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a2 + m[2] * b2, m[1] * a2 + m[3] * b2, m[0] * c2 + m[2] * d2, m[1] * c2 + m[3] * d2, m[0] * e2 + m[2] * f + m[4], m[1] * e2 + m[3] * f + m[5]];
                  ctx._originalTransform(a2, b2, c2, d2, e2, f);
                };
                ctx.setTransform = function ctxSetTransform(a2, b2, c2, d2, e2, f) {
                  this._transformMatrix = [a2, b2, c2, d2, e2, f];
                  ctx._originalSetTransform(a2, b2, c2, d2, e2, f);
                };
                ctx.rotate = function ctxRotate(angle) {
                  var cosValue = Math.cos(angle);
                  var sinValue = Math.sin(angle);
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
            }
            var CachedCanvases = function CachedCanvasesClosure() {
              function CachedCanvases2(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              CachedCanvases2.prototype = {
                getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                  var canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                    canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  if (trackTransform) {
                    addContextCurrentTransform(canvasEntry.context);
                  }
                  return canvasEntry;
                },
                clear() {
                  for (var id in this.cache) {
                    var canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              };
              return CachedCanvases2;
            }();
            function compileType3Glyph(imgData) {
              var POINT_TO_PROCESS_LIMIT = 1e3;
              var width = imgData.width, height = imgData.height;
              var i2, j2, j0, width1 = width + 1;
              var points = new Uint8Array(width1 * (height + 1));
              var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              var lineSize = width + 7 & ~7, data0 = imgData.data;
              var data = new Uint8Array(lineSize * height), pos = 0, ii;
              for (i2 = 0, ii = data0.length; i2 < ii; i2++) {
                var mask = 128, elem = data0[i2];
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              var count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j2 = 1; j2 < width; j2++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j2] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j2] = 2;
                ++count;
              }
              for (i2 = 1; i2 < height; i2++) {
                pos = i2 * lineSize;
                j0 = i2 * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j2 = 1; j2 < width; j2++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j2] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j2] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i2 * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j2 = 1; j2 < width; j2++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j2] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j2] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              var outlines = [];
              for (i2 = 0; count && i2 <= height; i2++) {
                var p = i2 * width1;
                var end = p + width;
                while (p < end && !points[p]) {
                  p++;
                }
                if (p === end) {
                  continue;
                }
                var coords = [p % width1, i2];
                var type = points[p], p0 = p, pp;
                do {
                  var step = steps[type];
                  do {
                    p += step;
                  } while (!points[p]);
                  pp = points[p];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p] &= type >> 2 | type << 2;
                  }
                  coords.push(p % width1);
                  coords.push(p / width1 | 0);
                  if (!points[p]) {
                    --count;
                  }
                } while (p0 !== p);
                outlines.push(coords);
                --i2;
              }
              var drawOutline = function(c2) {
                c2.save();
                c2.scale(1 / width, -1 / height);
                c2.translate(0, -height);
                c2.beginPath();
                for (var i3 = 0, ii2 = outlines.length; i3 < ii2; i3++) {
                  var o2 = outlines[i3];
                  c2.moveTo(o2[0], o2[1]);
                  for (var j3 = 2, jj = o2.length; j3 < jj; j3 += 2) {
                    c2.lineTo(o2[j3], o2[j3 + 1]);
                  }
                }
                c2.fill();
                c2.beginPath();
                c2.restore();
              };
              return drawOutline;
            }
            var CanvasExtraState = function CanvasExtraStateClosure() {
              function CanvasExtraState2() {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.resumeSMaskCtx = null;
              }
              CanvasExtraState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                },
                setCurrentPoint: function CanvasExtraState_setCurrentPoint(x2, y2) {
                  this.x = x2;
                  this.y = y2;
                }
              };
              return CanvasExtraState2;
            }();
            var CanvasGraphics = function CanvasGraphicsClosure() {
              var EXECUTION_TIME = 15;
              var EXECUTION_STEPS = 10;
              function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState();
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this.imageLayer = imageLayer;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                if (canvasCtx) {
                  addContextCurrentTransform(canvasCtx);
                }
                this._cachedGetSinglePixelWidth = null;
              }
              function putBinaryImageData(ctx, imgData) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0, destPos;
                var src = imgData.data;
                var dest = chunkImgData.data;
                var i2, j2, thisChunkHeight, elemsInThisChunk;
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  var srcLength = src.byteLength;
                  var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  var dest32DataLength = dest32.length;
                  var fullSrcDiff = width + 7 >> 3;
                  var white = 4294967295;
                  var black = _util2.IsLittleEndianCached.value ? 4278190080 : 255;
                  for (i2 = 0; i2 < totalChunks; i2++) {
                    thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j2 = 0; j2 < thisChunkHeight; j2++) {
                      var srcDiff = srcLength - srcPos;
                      var k2 = 0;
                      var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      var kEndUnrolled = kEnd & ~7;
                      var mask = 0;
                      var srcByte = 0;
                      for (; k2 < kEndUnrolled; k2 += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k2 < kEnd; k2++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  j2 = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i2 = 0; i2 < fullChunks; i2++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    ctx.putImageData(chunkImgData, 0, j2);
                    j2 += FULL_CHUNK_HEIGHT;
                  }
                  if (i2 < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    ctx.putImageData(chunkImgData, 0, j2);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i2 = 0; i2 < totalChunks; i2++) {
                    if (i2 >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j2 = elemsInThisChunk; j2--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0;
                var src = imgData.data;
                var dest = chunkImgData.data;
                for (var i2 = 0; i2 < totalChunks; i2++) {
                  var thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  var destPos = 3;
                  for (var j2 = 0; j2 < thisChunkHeight; j2++) {
                    var mask = 0;
                    for (var k2 = 0; k2 < width; k2++) {
                      if (!mask) {
                        var elem = src[srcPos++];
                        mask = 128;
                      }
                      dest[destPos] = elem & mask ? 0 : 255;
                      destPos += 4;
                      mask >>= 1;
                    }
                  }
                  ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (var i2 = 0, ii = properties.length; i2 < ii; i2++) {
                  var property = properties[i2];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = "#000000";
                ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                var length = bytes.length;
                for (var i2 = 3; i2 < length; i2 += 4) {
                  var alpha = bytes[i2];
                  if (alpha === 0) {
                    bytes[i2 - 3] = r0;
                    bytes[i2 - 2] = g0;
                    bytes[i2 - 1] = b0;
                  } else if (alpha < 255) {
                    var alpha_ = 255 - alpha;
                    bytes[i2 - 3] = bytes[i2 - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i2 - 2] = bytes[i2 - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i2 - 1] = bytes[i2 - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                var length = maskData.length;
                var scale = 1 / 255;
                for (var i2 = 3; i2 < length; i2 += 4) {
                  var alpha = transferMap ? transferMap[maskData[i2]] : maskData[i2];
                  layerData[i2] = layerData[i2] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                var length = maskData.length;
                for (var i2 = 3; i2 < length; i2 += 4) {
                  var y2 = maskData[i2 - 3] * 77 + maskData[i2 - 2] * 152 + maskData[i2 - 1] * 28;
                  layerData[i2] = transferMap ? layerData[i2] * transferMap[y2 >> 8] >> 8 : layerData[i2] * y2 >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                var hasBackdrop = !!backdrop;
                var r0 = hasBackdrop ? backdrop[0] : 0;
                var g0 = hasBackdrop ? backdrop[1] : 0;
                var b0 = hasBackdrop ? backdrop[2] : 0;
                var composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                var PIXELS_TO_PROCESS = 1048576;
                var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (var row = 0; row < height; row += chunkSize) {
                  var chunkHeight = Math.min(chunkSize, height - row);
                  var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                  var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  maskCtx.putImageData(layerData, 0, row);
                }
              }
              function composeSMask(ctx, smask, layerCtx, webGLContext) {
                var mask = smask.canvas;
                var maskCtx = smask.context;
                ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                var backdrop = smask.backdrop || null;
                if (!smask.transferMap && webGLContext.isEnabled) {
                  const composed = webGLContext.composeSMask({
                    layer: layerCtx.canvas,
                    mask,
                    properties: {
                      subtype: smask.subtype,
                      backdrop
                    }
                  });
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                  return;
                }
                genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                ctx.drawImage(mask, 0, 0);
              }
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var NORMAL_CLIP = {};
              var EO_CLIP = {};
              CanvasGraphics2.prototype = {
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  var width = this.ctx.canvas.width;
                  var height = this.ctx.canvas.height;
                  this.ctx.save();
                  this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform.apply(this.ctx, transform);
                  }
                  this.ctx.transform.apply(this.ctx, viewport.transform);
                  this.baseTransform = this.ctx.mozCurrentTransform.slice();
                  if (this.imageLayer) {
                    this.imageLayer.beginLayout();
                  }
                },
                executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  var argsArray = operatorList.argsArray;
                  var fnArray = operatorList.fnArray;
                  var i2 = executionStartIdx || 0;
                  var argsArrayLen = argsArray.length;
                  if (argsArrayLen === i2) {
                    return i2;
                  }
                  var chunkOperations = argsArrayLen - i2 > EXECUTION_STEPS && typeof continueCallback === "function";
                  var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  var steps = 0;
                  var commonObjs = this.commonObjs;
                  var objs = this.objs;
                  var fnId;
                  while (true) {
                    if (stepper !== void 0 && i2 === stepper.nextBreakPoint) {
                      stepper.breakIt(i2, continueCallback);
                      return i2;
                    }
                    fnId = fnArray[i2];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i2]);
                    } else {
                      for (const depObjId of argsArray[i2]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i2;
                        }
                      }
                    }
                    i2++;
                    if (i2 === argsArrayLen) {
                      return i2;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i2;
                      }
                      steps = 0;
                    }
                  }
                },
                endDrawing: function CanvasGraphics_endDrawing() {
                  if (this.current.activeSMask !== null) {
                    this.endSMaskGroup();
                  }
                  this.ctx.restore();
                  if (this.transparentCanvas) {
                    this.ctx = this.compositeCtx;
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.drawImage(this.transparentCanvas, 0, 0);
                    this.ctx.restore();
                    this.transparentCanvas = null;
                  }
                  this.cachedCanvases.clear();
                  this.webGLContext.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                },
                setLineWidth: function CanvasGraphics_setLineWidth(width) {
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                },
                setLineCap: function CanvasGraphics_setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                },
                setLineJoin: function CanvasGraphics_setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                },
                setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                },
                setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                  var ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                },
                setRenderingIntent(intent) {
                },
                setFlatness(flatness) {
                },
                setGState: function CanvasGraphics_setGState(states) {
                  for (var i2 = 0, ii = states.length; i2 < ii; i2++) {
                    var state = states[i2];
                    var key = state[0];
                    var value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        if (this.current.activeSMask) {
                          if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                            this.suspendSMaskGroup();
                          } else {
                            this.endSMaskGroup();
                          }
                        }
                        this.current.activeSMask = value ? this.tempSMask : null;
                        if (this.current.activeSMask) {
                          this.beginSMaskGroup();
                        }
                        this.tempSMask = null;
                        break;
                    }
                  }
                },
                beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                  var activeSMask = this.current.activeSMask;
                  var drawnWidth = activeSMask.canvas.width;
                  var drawnHeight = activeSMask.canvas.height;
                  var cacheId = "smaskGroupAt" + this.groupLevel;
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var currentCtx = this.ctx;
                  var currentTransform = currentCtx.mozCurrentTransform;
                  this.ctx.save();
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                  groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  this.ctx.save();
                  copyCtxState(groupCtx, this.ctx);
                  this.current.resumeSMaskCtx = groupCtx;
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                  groupCtx.save();
                  groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                  groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                  groupCtx.restore();
                },
                resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.current.resumeSMaskCtx;
                  var currentCtx = this.ctx;
                  this.ctx = groupCtx;
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  copyCtxState(groupCtx, this.ctx);
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                },
                save: function CanvasGraphics_save() {
                  this.ctx.save();
                  var old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                  this.current.resumeSMaskCtx = null;
                },
                restore: function CanvasGraphics_restore() {
                  if (this.current.resumeSMaskCtx) {
                    this.resumeSMaskGroup();
                  }
                  if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                    this.endSMaskGroup();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    this.ctx.restore();
                    this.pendingClip = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                },
                transform: function CanvasGraphics_transform(a2, b2, c2, d2, e2, f) {
                  this.ctx.transform(a2, b2, c2, d2, e2, f);
                  this._cachedGetSinglePixelWidth = null;
                },
                constructPath: function CanvasGraphics_constructPath(ops, args) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var x2 = current.x, y2 = current.y;
                  for (var i2 = 0, j2 = 0, ii = ops.length; i2 < ii; i2++) {
                    switch (ops[i2] | 0) {
                      case _util2.OPS.rectangle:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        var width = args[j2++];
                        var height = args[j2++];
                        if (width === 0) {
                          width = this.getSinglePixelWidth();
                        }
                        if (height === 0) {
                          height = this.getSinglePixelWidth();
                        }
                        var xw = x2 + width;
                        var yh = y2 + height;
                        this.ctx.moveTo(x2, y2);
                        this.ctx.lineTo(xw, y2);
                        this.ctx.lineTo(xw, yh);
                        this.ctx.lineTo(x2, yh);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        ctx.moveTo(x2, y2);
                        break;
                      case _util2.OPS.lineTo:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        ctx.lineTo(x2, y2);
                        break;
                      case _util2.OPS.curveTo:
                        x2 = args[j2 + 4];
                        y2 = args[j2 + 5];
                        ctx.bezierCurveTo(args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3], x2, y2);
                        j2 += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        ctx.bezierCurveTo(x2, y2, args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3]);
                        x2 = args[j2 + 2];
                        y2 = args[j2 + 3];
                        j2 += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x2 = args[j2 + 2];
                        y2 = args[j2 + 3];
                        ctx.bezierCurveTo(args[j2], args[j2 + 1], x2, y2, x2, y2);
                        j2 += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  current.setCurrentPoint(x2, y2);
                },
                closePath: function CanvasGraphics_closePath() {
                  this.ctx.closePath();
                },
                stroke: function CanvasGraphics_stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {
                    ctx.save();
                    const transform = ctx.mozCurrentTransform;
                    const scale = _util2.Util.singularValueDecompose2dScale(transform)[0];
                    ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                    ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);
                    ctx.stroke();
                    ctx.restore();
                  } else {
                    ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                    ctx.stroke();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                },
                closeStroke: function CanvasGraphics_closeStroke() {
                  this.closePath();
                  this.stroke();
                },
                fill: function CanvasGraphics_fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    if (this.baseTransform) {
                      ctx.setTransform.apply(ctx, this.baseTransform);
                    }
                    ctx.fillStyle = fillColor.getPattern(ctx, this);
                    needRestore = true;
                  }
                  if (this.pendingEOFill) {
                    ctx.fill("evenodd");
                    this.pendingEOFill = false;
                  } else {
                    ctx.fill();
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                },
                eoFill: function CanvasGraphics_eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                },
                fillStroke: function CanvasGraphics_fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                },
                eoFillStroke: function CanvasGraphics_eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                },
                closeFillStroke: function CanvasGraphics_closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                },
                closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                },
                endPath: function CanvasGraphics_endPath() {
                  this.consumePath();
                },
                clip: function CanvasGraphics_clip() {
                  this.pendingClip = NORMAL_CLIP;
                },
                eoClip: function CanvasGraphics_eoClip() {
                  this.pendingClip = EO_CLIP;
                },
                beginText: function CanvasGraphics_beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                endText: function CanvasGraphics_endText() {
                  var paths = this.pendingTextPaths;
                  var ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (var i2 = 0; i2 < paths.length; i2++) {
                    var path = paths[i2];
                    ctx.setTransform.apply(ctx, path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                },
                setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                },
                setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                },
                setHScale: function CanvasGraphics_setHScale(scale) {
                  this.current.textHScale = scale / 100;
                },
                setLeading: function CanvasGraphics_setLeading(leading) {
                  this.current.leading = -leading;
                },
                setFont: function CanvasGraphics_setFont(fontRefName, size) {
                  var fontObj = this.commonObjs.get(fontRefName);
                  var current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  var name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  var italic = fontObj.italic ? "italic" : "normal";
                  var typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                },
                setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                },
                setTextRise: function CanvasGraphics_setTextRise(rise) {
                  this.current.textRise = rise;
                },
                moveText: function CanvasGraphics_moveText(x2, y2) {
                  this.current.x = this.current.lineX += x2;
                  this.current.y = this.current.lineY += y2;
                },
                setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x2, y2) {
                  this.setLeading(-y2);
                  this.moveText(x2, y2);
                },
                setTextMatrix: function CanvasGraphics_setTextMatrix(a2, b2, c2, d2, e2, f) {
                  this.current.textMatrix = [a2, b2, c2, d2, e2, f];
                  this.current.textMatrixScale = Math.sqrt(a2 * a2 + b2 * b2);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                nextLine: function CanvasGraphics_nextLine() {
                  this.moveText(0, this.current.leading);
                },
                paintChar(character, x2, y2, patternTransform) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var textRenderingMode = current.textRenderingMode;
                  var fontSize = current.fontSize / current.fontSizeScale;
                  var fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  var isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && font.data;
                  var addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x2, y2);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform.apply(ctx, patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x2, y2);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x2, y2);
                    }
                  }
                  if (isAddToPathSet) {
                    var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: ctx.mozCurrentTransform,
                      x: x2,
                      y: y2,
                      fontSize,
                      addToPath
                    });
                  }
                },
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  var data = ctx.getImageData(0, 0, 10, 10).data;
                  var enabled = false;
                  for (var i2 = 3; i2 < data.length; i2 += 4) {
                    if (data[i2] > 0 && data[i2] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                },
                showText: function CanvasGraphics_showText(glyphs) {
                  var current = this.current;
                  var font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  var fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  var ctx = this.ctx;
                  var fontSizeScale = current.fontSizeScale;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var fontDirection = current.fontDirection;
                  var textHScale = current.textHScale * fontDirection;
                  var glyphsLength = glyphs.length;
                  var vertical = font.vertical;
                  var spacingDir = vertical ? 1 : -1;
                  var defaultVMetrics = font.defaultVMetrics;
                  var widthAdvanceScale = fontSize * current.fontMatrix[0];
                  var simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this);
                    patternTransform = ctx.mozCurrentTransform;
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  var lineWidth = current.lineWidth;
                  var scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      this._cachedGetSinglePixelWidth = null;
                      lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  var x2 = 0, i2;
                  for (i2 = 0; i2 < glyphsLength; ++i2) {
                    var glyph = glyphs[i2];
                    if ((0, _util2.isNum)(glyph)) {
                      x2 += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    var restoreNeeded = false;
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var character = glyph.fontChar;
                    var accent = glyph.accent;
                    var scaledX, scaledY, scaledAccentX, scaledAccentY;
                    var width = glyph.width;
                    if (vertical) {
                      var vmetric, vx, vy;
                      vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x2 + vy) / fontSizeScale;
                    } else {
                      scaledX = x2 / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        var characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (glyph.isInFont || font.missingFile) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                          scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    var charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x2 += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x2;
                  } else {
                    current.x += x2 * textHScale;
                  }
                  ctx.restore();
                },
                showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var fontSize = current.fontSize;
                  var fontDirection = current.fontDirection;
                  var spacingDir = font.vertical ? 1 : -1;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var textHScale = current.textHScale * fontDirection;
                  var fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  var glyphsLength = glyphs.length;
                  var isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  var i2, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i2 = 0; i2 < glyphsLength; ++i2) {
                    glyph = glyphs[i2];
                    if ((0, _util2.isNum)(glyph)) {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    this.processingType3 = glyph;
                    this.save();
                    ctx.scale(fontSize, fontSize);
                    ctx.transform.apply(ctx, fontMatrix);
                    this.executeOperatorList(operatorList);
                    this.restore();
                    var transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                },
                setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                },
                setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.clip();
                  this.endPath();
                },
                getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                  var pattern;
                  if (IR[0] === "TilingPattern") {
                    var color = IR[1];
                    var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                    var canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new CanvasGraphics2(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                  }
                  return pattern;
                },
                setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                },
                setFillColorN: function CanvasGraphics_setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                },
                setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r2, g2, b2) {
                  var color = _util2.Util.makeCssRgb(r2, g2, b2);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                },
                setFillRGBColor: function CanvasGraphics_setFillRGBColor(r2, g2, b2) {
                  var color = _util2.Util.makeCssRgb(r2, g2, b2);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                },
                shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                  var ctx = this.ctx;
                  this.save();
                  var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                  ctx.fillStyle = pattern.getPattern(ctx, this, true);
                  var inv = ctx.mozCurrentTransformInverse;
                  if (inv) {
                    var canvas = ctx.canvas;
                    var width = canvas.width;
                    var height = canvas.height;
                    var bl = _util2.Util.applyTransform([0, 0], inv);
                    var br = _util2.Util.applyTransform([0, height], inv);
                    var ul = _util2.Util.applyTransform([width, 0], inv);
                    var ur = _util2.Util.applyTransform([width, height], inv);
                    var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.restore();
                },
                beginInlineImage: function CanvasGraphics_beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                },
                beginImageData: function CanvasGraphics_beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                },
                paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform.apply(this, matrix);
                  }
                  this.baseTransform = this.ctx.mozCurrentTransform;
                  if (bbox) {
                    var width = bbox[2] - bbox[0];
                    var height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                },
                paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                },
                beginGroup: function CanvasGraphics_beginGroup(group) {
                  this.save();
                  var currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  var currentTransform = currentCtx.mozCurrentTransform;
                  if (group.matrix) {
                    currentCtx.transform.apply(currentCtx, group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  var bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                  var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  var offsetX = Math.floor(bounds[0]);
                  var offsetY = Math.floor(bounds[1]);
                  var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  var scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  var cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                  this.current.activeSMask = null;
                },
                endGroup: function CanvasGraphics_endGroup(group) {
                  this.groupLevel--;
                  var groupCtx = this.ctx;
                  this.ctx = this.groupStack.pop();
                  if (this.ctx.imageSmoothingEnabled !== void 0) {
                    this.ctx.imageSmoothingEnabled = false;
                  } else {
                    this.ctx.mozImageSmoothingEnabled = false;
                  }
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                  } else {
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  }
                  this.restore();
                },
                beginAnnotations: function CanvasGraphics_beginAnnotations() {
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                  }
                },
                endAnnotations: function CanvasGraphics_endAnnotations() {
                  this.restore();
                },
                beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                  this.save();
                  resetCtxToDefault(this.ctx);
                  this.current = new CanvasExtraState();
                  if (Array.isArray(rect) && rect.length === 4) {
                    var width = rect[2] - rect[0];
                    var height = rect[3] - rect[1];
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                  this.transform.apply(this, transform);
                  this.transform.apply(this, matrix);
                },
                endAnnotation: function CanvasGraphics_endAnnotation() {
                  this.restore();
                },
                paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w2, h2) {
                  const domImage = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!domImage) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.save();
                  var ctx = this.ctx;
                  ctx.scale(1 / w2, -1 / h2);
                  ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h2, w2, h2);
                  if (this.imageLayer) {
                    var currentTransform = ctx.mozCurrentTransformInverse;
                    var position = this.getCanvasPosition(0, 0);
                    this.imageLayer.appendImage({
                      objId,
                      left: position[0],
                      top: position[1],
                      width: w2 / currentTransform[0],
                      height: h2 / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                  var ctx = this.ctx;
                  var width = img.width, height = img.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var glyph = this.processingType3;
                  if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                    if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                      glyph.compiled = compileType3Glyph({
                        data: img.data,
                        width,
                        height
                      });
                    } else {
                      glyph.compiled = null;
                    }
                  }
                  if (glyph && glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  this.paintInlineImageXObject(maskCanvas.canvas);
                },
                paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, imgData);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  var ctx = this.ctx;
                  for (var i2 = 0, ii = positions.length; i2 < ii; i2 += 2) {
                    ctx.save();
                    ctx.transform(scaleX, 0, 0, scaleY, positions[i2], positions[i2 + 1]);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  for (var i2 = 0, ii = images.length; i2 < ii; i2++) {
                    var image = images[i2];
                    var width = image.width, height = image.height;
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, image);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform.apply(ctx, image.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                  const imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                },
                paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  const imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var map = [];
                  for (var i2 = 0, ii = positions.length; i2 < ii; i2 += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i2], positions[i2 + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                },
                paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  var currentTransform = ctx.mozCurrentTransformInverse;
                  var a2 = currentTransform[0], b2 = currentTransform[1];
                  var widthScale = Math.max(Math.sqrt(a2 * a2 + b2 * b2), 1);
                  var c2 = currentTransform[2], d2 = currentTransform[3];
                  var heightScale = Math.max(Math.sqrt(c2 * c2 + d2 * d2), 1);
                  var imgToPaint, tmpCanvas;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    var tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  var paintWidth = width, paintHeight = height;
                  var tmpCanvasId = "prescale1";
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    var newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    imgToPaint = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    var position = this.getCanvasPosition(0, -height);
                    this.imageLayer.appendImage({
                      imgData,
                      left: position[0],
                      top: position[1],
                      width: width / currentTransform[0],
                      height: height / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                  var ctx = this.ctx;
                  var w2 = imgData.width;
                  var h2 = imgData.height;
                  var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w2, h2);
                  var tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  for (var i2 = 0, ii = map.length; i2 < ii; i2++) {
                    var entry = map[i2];
                    ctx.save();
                    ctx.transform.apply(ctx, entry.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(entry.x, entry.y);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: w2,
                        height: h2
                      });
                    }
                    ctx.restore();
                  }
                },
                paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                  this.ctx.fillRect(0, 0, 1, 1);
                },
                paintXObject: function CanvasGraphics_paintXObject() {
                  (0, _util2.warn)("Unsupported 'paintXObject' command.");
                },
                markPoint: function CanvasGraphics_markPoint(tag) {
                },
                markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                },
                beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                },
                beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                },
                endMarkedContent: function CanvasGraphics_endMarkedContent() {
                },
                beginCompat: function CanvasGraphics_beginCompat() {
                },
                endCompat: function CanvasGraphics_endCompat() {
                },
                consumePath: function CanvasGraphics_consumePath() {
                  var ctx = this.ctx;
                  if (this.pendingClip) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                    this.pendingClip = null;
                  }
                  ctx.beginPath();
                },
                getSinglePixelWidth(scale) {
                  if (this._cachedGetSinglePixelWidth === null) {
                    const inverse = this.ctx.mozCurrentTransformInverse;
                    this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
                  }
                  return this._cachedGetSinglePixelWidth;
                },
                getCanvasPosition: function CanvasGraphics_getCanvasPosition(x2, y2) {
                  var transform = this.ctx.mozCurrentTransform;
                  return [transform[0] * x2 + transform[2] * y2 + transform[4], transform[1] * x2 + transform[3] * y2 + transform[5]];
                }
              };
              for (var op in _util2.OPS) {
                CanvasGraphics2.prototype[_util2.OPS[op]] = CanvasGraphics2.prototype[op];
              }
              return CanvasGraphics2;
            }();
            exports2.CanvasGraphics = CanvasGraphics;
          },
          /* 9 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getShadingPatternFromIR = getShadingPatternFromIR;
            exports2.TilingPattern = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var ShadingIRs = {};
            function applyBoundingBox(ctx, bbox) {
              if (!bbox || typeof Path2D === "undefined") {
                return;
              }
              const width = bbox[2] - bbox[0];
              const height = bbox[3] - bbox[1];
              const region = new Path2D();
              region.rect(bbox[0], bbox[1], width, height);
              ctx.clip(region);
            }
            ShadingIRs.RadialAxial = {
              fromIR: function RadialAxial_fromIR(raw) {
                var type = raw[1];
                var bbox = raw[2];
                var colorStops = raw[3];
                var p0 = raw[4];
                var p1 = raw[5];
                var r0 = raw[6];
                var r1 = raw[7];
                return {
                  type: "Pattern",
                  getPattern: function RadialAxial_getPattern(ctx) {
                    applyBoundingBox(ctx, bbox);
                    var grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (var i2 = 0, ii = colorStops.length; i2 < ii; ++i2) {
                      var c2 = colorStops[i2];
                      grad.addColorStop(c2[0], c2[1]);
                    }
                    return grad;
                  }
                };
              }
            };
            var createMeshCanvas = function createMeshCanvasClosure() {
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                var coords = context.coords, colors = context.colors;
                var bytes = data.data, rowSize = data.width * 4;
                var tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                var minY = Math.round(y1), maxY = Math.round(y3);
                var xa, car, cag, cab;
                var xb, cbr, cbg, cbb;
                for (var y4 = minY; y4 <= maxY; y4++) {
                  if (y4 < y2) {
                    let k3;
                    if (y4 < y1) {
                      k3 = 0;
                    } else if (y1 === y2) {
                      k3 = 1;
                    } else {
                      k3 = (y1 - y4) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k3;
                    car = c1r - (c1r - c2r) * k3;
                    cag = c1g - (c1g - c2g) * k3;
                    cab = c1b - (c1b - c2b) * k3;
                  } else {
                    let k3;
                    if (y4 > y3) {
                      k3 = 1;
                    } else if (y2 === y3) {
                      k3 = 0;
                    } else {
                      k3 = (y2 - y4) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k3;
                    car = c2r - (c2r - c3r) * k3;
                    cag = c2g - (c2g - c3g) * k3;
                    cab = c2b - (c2b - c3b) * k3;
                  }
                  let k2;
                  if (y4 < y1) {
                    k2 = 0;
                  } else if (y4 > y3) {
                    k2 = 1;
                  } else {
                    k2 = (y1 - y4) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k2;
                  cbr = c1r - (c1r - c3r) * k2;
                  cbg = c1g - (c1g - c3g) * k2;
                  cbb = c1b - (c1b - c3b) * k2;
                  var x1_ = Math.round(Math.min(xa, xb));
                  var x2_ = Math.round(Math.max(xa, xb));
                  var j2 = rowSize * y4 + x1_ * 4;
                  for (var x4 = x1_; x4 <= x2_; x4++) {
                    let k3 = (xa - x4) / (xa - xb);
                    if (k3 < 0) {
                      k3 = 0;
                    } else if (k3 > 1) {
                      k3 = 1;
                    }
                    bytes[j2++] = car - (car - cbr) * k3 | 0;
                    bytes[j2++] = cag - (cag - cbg) * k3 | 0;
                    bytes[j2++] = cab - (cab - cbb) * k3 | 0;
                    bytes[j2++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                var ps = figure.coords;
                var cs = figure.colors;
                var i2, ii;
                switch (figure.type) {
                  case "lattice":
                    var verticesPerRow = figure.verticesPerRow;
                    var rows = Math.floor(ps.length / verticesPerRow) - 1;
                    var cols = verticesPerRow - 1;
                    for (i2 = 0; i2 < rows; i2++) {
                      var q2 = i2 * verticesPerRow;
                      for (var j2 = 0; j2 < cols; j2++, q2++) {
                        drawTriangle(data, context, ps[q2], ps[q2 + 1], ps[q2 + verticesPerRow], cs[q2], cs[q2 + 1], cs[q2 + verticesPerRow]);
                        drawTriangle(data, context, ps[q2 + verticesPerRow + 1], ps[q2 + 1], ps[q2 + verticesPerRow], cs[q2 + verticesPerRow + 1], cs[q2 + 1], cs[q2 + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i2 = 0, ii = ps.length; i2 < ii; i2 += 3) {
                      drawTriangle(data, context, ps[i2], ps[i2 + 1], ps[i2 + 2], cs[i2], cs[i2 + 1], cs[i2 + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                var EXPECTED_SCALE = 1.1;
                var MAX_PATTERN_SIZE = 3e3;
                var BORDER_SIZE = 2;
                var offsetX = Math.floor(bounds[0]);
                var offsetY = Math.floor(bounds[1]);
                var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var scaleX = boundsWidth / width;
                var scaleY = boundsHeight / height;
                var context = {
                  coords,
                  colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                var paddedWidth = width + BORDER_SIZE * 2;
                var paddedHeight = height + BORDER_SIZE * 2;
                var canvas, tmpCanvas, i2, ii;
                if (webGLContext.isEnabled) {
                  canvas = webGLContext.drawFigures({
                    width,
                    height,
                    backgroundColor,
                    figures,
                    context
                  });
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                } else {
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  var tmpCtx = tmpCanvas.context;
                  var data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    var bytes = data.data;
                    for (i2 = 0, ii = bytes.length; i2 < ii; i2 += 4) {
                      bytes[i2] = backgroundColor[0];
                      bytes[i2 + 1] = backgroundColor[1];
                      bytes[i2 + 2] = backgroundColor[2];
                      bytes[i2 + 3] = 255;
                    }
                  }
                  for (i2 = 0; i2 < figures.length; i2++) {
                    drawFigure(data, figures[i2], context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                }
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              return createMeshCanvas2;
            }();
            ShadingIRs.Mesh = {
              fromIR: function Mesh_fromIR(raw) {
                var coords = raw[2];
                var colors = raw[3];
                var figures = raw[4];
                var bounds = raw[5];
                var matrix = raw[6];
                var bbox = raw[7];
                var background = raw[8];
                return {
                  type: "Pattern",
                  getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    applyBoundingBox(ctx, bbox);
                    var scale;
                    if (shadingFill) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        var matrixScale = _util2.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                };
              }
            };
            ShadingIRs.Dummy = {
              fromIR: function Dummy_fromIR() {
                return {
                  type: "Pattern",
                  getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  }
                };
              }
            };
            function getShadingPatternFromIR(raw) {
              var shadingIR = ShadingIRs[raw[0]];
              if (!shadingIR) {
                throw new Error(`Unknown IR type: ${raw[0]}`);
              }
              return shadingIR.fromIR(raw);
            }
            var TilingPattern = function TilingPatternClosure() {
              var PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              var MAX_PATTERN_SIZE = 3e3;
              function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
                this.type = "Pattern";
                this.ctx = ctx;
              }
              TilingPattern2.prototype = {
                createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                  var operatorList = this.operatorList;
                  var bbox = this.bbox;
                  var xstep = this.xstep;
                  var ystep = this.ystep;
                  var paintType = this.paintType;
                  var tilingType = this.tilingType;
                  var color = this.color;
                  var canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  var curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  var tmpCtx = tmpCanvas.context;
                  var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  graphics.transform(1, 0, 0, 1, -x0, -y0);
                  this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                  graphics.executeOperatorList(operatorList);
                  this.ctx.transform(1, 0, 0, 1, x0, y0);
                  this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                  return tmpCanvas.canvas;
                },
                getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                  var size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                },
                clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    var bboxWidth = x1 - x0;
                    var bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.clip();
                    graphics.endPath();
                  }
                },
                setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      var ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      var cssColor = _util2.Util.makeCssRgb(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                },
                getPattern: function TilingPattern_getPattern(ctx, owner) {
                  ctx = this.ctx;
                  ctx.setTransform.apply(ctx, this.baseTransform);
                  ctx.transform.apply(ctx, this.matrix);
                  var temporaryPatternCanvas = this.createPatternCanvas(owner);
                  return ctx.createPattern(temporaryPatternCanvas, "repeat");
                }
              };
              return TilingPattern2;
            }();
            exports2.TilingPattern = TilingPattern;
          },
          /* 10 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GlobalWorkerOptions = void 0;
            const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
            exports2.GlobalWorkerOptions = GlobalWorkerOptions;
            GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
            GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
          },
          /* 11 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MessageHandler = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            const StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (typeof reason !== "object" || reason === null) {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            class MessageHandler {
              constructor(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.postMessageTransfers = true;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = (event) => {
                  const data = event.data;
                  if (data.targetName !== this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    this._processStreamMessage(data);
                    return;
                  }
                  if (data.callback) {
                    const callbackId = data.callbackId;
                    const capability = this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error(`Cannot resolve callback ${callbackId}`);
                    }
                    delete this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  const action = this.actionHandler[data.action];
                  if (!action) {
                    throw new Error(`Unknown action from worker: ${data.action}`);
                  }
                  if (data.callbackId) {
                    const sourceName2 = this.sourceName;
                    const targetName2 = data.sourceName;
                    new Promise(function(resolve) {
                      resolve(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    this._createStreamSink(data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              on(actionName, handler) {
                const ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error(`There is already an actionName called "${actionName}"`);
                }
                ah[actionName] = handler;
              }
              send(actionName, data, transfers) {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                }, transfers);
              }
              sendWithPromise(actionName, data, transfers) {
                const callbackId = this.callbackId++;
                const capability = (0, _util2.createPromiseCapability)();
                this.callbackCapabilities[callbackId] = capability;
                try {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId,
                    data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }
                return capability.promise;
              }
              sendWithStream(actionName, data, queueingStrategy, transfers) {
                const streamId = this.streamId++;
                const sourceName = this.sourceName;
                const targetName = this.targetName;
                const comObj = this.comObj;
                return new ReadableStream({
                  start: (controller) => {
                    const startCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };
                    this._postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    }, transfers);
                    return startCapability.promise;
                  },
                  pull: (controller) => {
                    const pullCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL,
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: (reason) => {
                    (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                    const cancelCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].cancelCall = cancelCapability;
                    this.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL,
                      streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
              _createStreamSink(data) {
                const self2 = this;
                const action = this.actionHandler[data.action];
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util2.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    self2._postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: (0, _util2.createPromiseCapability)(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              }
              _processStreamMessage(data) {
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].startCall.resolve();
                    } else {
                      this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].pullCall.resolve();
                    } else {
                      this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!this.streamSinks[streamId]) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[streamId].desiredSize = data.desiredSize;
                    const {
                      onPull
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onPull && onPull());
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].isClosed = true;
                    this.streamControllers[streamId].controller.close();
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                    this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].cancelCall.resolve();
                    } else {
                      this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                    }
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!this.streamSinks[streamId]) {
                      break;
                    }
                    const {
                      onCancel
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onCancel && onCancel(wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[streamId].isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              }
              async _deleteStreamController(streamId) {
                await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                  return capability && capability.promise;
                }));
                delete this.streamControllers[streamId];
              }
              _postMessage(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }
            exports2.MessageHandler = MessageHandler;
          },
          /* 12 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Metadata = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _xml_parser = __w_pdfjs_require__2(13);
            class Metadata {
              constructor(data) {
                (0, _util2.assert)(typeof data === "string", "Metadata: input is not a string");
                data = this._repair(data);
                const parser = new _xml_parser.SimpleXMLParser();
                const xmlDocument = parser.parseFromString(data);
                this._metadataMap = /* @__PURE__ */ new Map();
                if (xmlDocument) {
                  this._parse(xmlDocument);
                }
              }
              _repair(data) {
                return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                  const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
                    return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                  }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                    switch (name) {
                      case "amp":
                        return "&";
                      case "apos":
                        return "'";
                      case "gt":
                        return ">";
                      case "lt":
                        return "<";
                      case "quot":
                        return '"';
                    }
                    throw new Error(`_repair: ${name} isn't defined.`);
                  });
                  let chars = "";
                  for (let i2 = 0, ii = bytes.length; i2 < ii; i2 += 2) {
                    const code = bytes.charCodeAt(i2) * 256 + bytes.charCodeAt(i2 + 1);
                    if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                      chars += String.fromCharCode(code);
                    } else {
                      chars += "&#x" + (65536 + code).toString(16).substring(1) + ";";
                    }
                  }
                  return ">" + chars;
                });
              }
              _parse(xmlDocument) {
                let rdf = xmlDocument.documentElement;
                if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                  rdf = rdf.firstChild;
                  while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                    rdf = rdf.nextSibling;
                  }
                }
                const nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
                if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                  return;
                }
                const children = rdf.childNodes;
                for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
                  const desc = children[i2];
                  if (desc.nodeName.toLowerCase() !== "rdf:description") {
                    continue;
                  }
                  for (let j2 = 0, jj = desc.childNodes.length; j2 < jj; j2++) {
                    if (desc.childNodes[j2].nodeName.toLowerCase() !== "#text") {
                      const entry = desc.childNodes[j2];
                      const name = entry.nodeName.toLowerCase();
                      this._metadataMap.set(name, entry.textContent.trim());
                    }
                  }
                }
              }
              get(name) {
                return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;
              }
              getAll() {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of this._metadataMap) {
                  obj[key] = value;
                }
                return obj;
              }
              has(name) {
                return this._metadataMap.has(name);
              }
            }
            exports2.Metadata = Metadata;
          },
          /* 13 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SimpleXMLParser = void 0;
            const XMLParserErrorCode = {
              NoError: 0,
              EndOfDocument: -1,
              UnterminatedCdat: -2,
              UnterminatedXmlDeclaration: -3,
              UnterminatedDoctypeDeclaration: -4,
              UnterminatedComment: -5,
              MalformedElement: -6,
              OutOfMemory: -7,
              UnterminatedAttributeValue: -8,
              UnterminatedElement: -9,
              ElementNeverBegun: -10
            };
            function isWhitespace(s2, index) {
              const ch = s2[index];
              return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
            }
            function isWhitespaceString(s2) {
              for (let i2 = 0, ii = s2.length; i2 < ii; i2++) {
                if (!isWhitespace(s2, i2)) {
                  return false;
                }
              }
              return true;
            }
            class XMLParserBase {
              _resolveEntities(s2) {
                return s2.replace(/&([^;]+);/g, (all, entity) => {
                  if (entity.substring(0, 2) === "#x") {
                    return String.fromCharCode(parseInt(entity.substring(2), 16));
                  } else if (entity.substring(0, 1) === "#") {
                    return String.fromCharCode(parseInt(entity.substring(1), 10));
                  }
                  switch (entity) {
                    case "lt":
                      return "<";
                    case "gt":
                      return ">";
                    case "amp":
                      return "&";
                    case "quot":
                      return '"';
                  }
                  return this.onResolveEntity(entity);
                });
              }
              _parseContent(s2, start) {
                const attributes = [];
                let pos = start;
                function skipWs() {
                  while (pos < s2.length && isWhitespace(s2, pos)) {
                    ++pos;
                  }
                }
                while (pos < s2.length && !isWhitespace(s2, pos) && s2[pos] !== ">" && s2[pos] !== "/") {
                  ++pos;
                }
                const name = s2.substring(start, pos);
                skipWs();
                while (pos < s2.length && s2[pos] !== ">" && s2[pos] !== "/" && s2[pos] !== "?") {
                  skipWs();
                  let attrName = "", attrValue = "";
                  while (pos < s2.length && !isWhitespace(s2, pos) && s2[pos] !== "=") {
                    attrName += s2[pos];
                    ++pos;
                  }
                  skipWs();
                  if (s2[pos] !== "=") {
                    return null;
                  }
                  ++pos;
                  skipWs();
                  const attrEndChar = s2[pos];
                  if (attrEndChar !== '"' && attrEndChar !== "'") {
                    return null;
                  }
                  const attrEndIndex = s2.indexOf(attrEndChar, ++pos);
                  if (attrEndIndex < 0) {
                    return null;
                  }
                  attrValue = s2.substring(pos, attrEndIndex);
                  attributes.push({
                    name: attrName,
                    value: this._resolveEntities(attrValue)
                  });
                  pos = attrEndIndex + 1;
                  skipWs();
                }
                return {
                  name,
                  attributes,
                  parsed: pos - start
                };
              }
              _parseProcessingInstruction(s2, start) {
                let pos = start;
                function skipWs() {
                  while (pos < s2.length && isWhitespace(s2, pos)) {
                    ++pos;
                  }
                }
                while (pos < s2.length && !isWhitespace(s2, pos) && s2[pos] !== ">" && s2[pos] !== "/") {
                  ++pos;
                }
                const name = s2.substring(start, pos);
                skipWs();
                const attrStart = pos;
                while (pos < s2.length && (s2[pos] !== "?" || s2[pos + 1] !== ">")) {
                  ++pos;
                }
                const value = s2.substring(attrStart, pos);
                return {
                  name,
                  value,
                  parsed: pos - start
                };
              }
              parseXml(s2) {
                let i2 = 0;
                while (i2 < s2.length) {
                  const ch = s2[i2];
                  let j2 = i2;
                  if (ch === "<") {
                    ++j2;
                    const ch2 = s2[j2];
                    let q2;
                    switch (ch2) {
                      case "/":
                        ++j2;
                        q2 = s2.indexOf(">", j2);
                        if (q2 < 0) {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }
                        this.onEndElement(s2.substring(j2, q2));
                        j2 = q2 + 1;
                        break;
                      case "?":
                        ++j2;
                        const pi = this._parseProcessingInstruction(s2, j2);
                        if (s2.substring(j2 + pi.parsed, j2 + pi.parsed + 2) !== "?>") {
                          this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                          return;
                        }
                        this.onPi(pi.name, pi.value);
                        j2 += pi.parsed + 2;
                        break;
                      case "!":
                        if (s2.substring(j2 + 1, j2 + 3) === "--") {
                          q2 = s2.indexOf("-->", j2 + 3);
                          if (q2 < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedComment);
                            return;
                          }
                          this.onComment(s2.substring(j2 + 3, q2));
                          j2 = q2 + 3;
                        } else if (s2.substring(j2 + 1, j2 + 8) === "[CDATA[") {
                          q2 = s2.indexOf("]]>", j2 + 8);
                          if (q2 < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedCdat);
                            return;
                          }
                          this.onCdata(s2.substring(j2 + 8, q2));
                          j2 = q2 + 3;
                        } else if (s2.substring(j2 + 1, j2 + 8) === "DOCTYPE") {
                          const q22 = s2.indexOf("[", j2 + 8);
                          let complexDoctype = false;
                          q2 = s2.indexOf(">", j2 + 8);
                          if (q2 < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          if (q22 > 0 && q2 > q22) {
                            q2 = s2.indexOf("]>", j2 + 8);
                            if (q2 < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }
                            complexDoctype = true;
                          }
                          const doctypeContent = s2.substring(j2 + 8, q2 + (complexDoctype ? 1 : 0));
                          this.onDoctype(doctypeContent);
                          j2 = q2 + (complexDoctype ? 2 : 1);
                        } else {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }
                        break;
                      default:
                        const content = this._parseContent(s2, j2);
                        if (content === null) {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }
                        let isClosed = false;
                        if (s2.substring(j2 + content.parsed, j2 + content.parsed + 2) === "/>") {
                          isClosed = true;
                        } else if (s2.substring(j2 + content.parsed, j2 + content.parsed + 1) !== ">") {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }
                        this.onBeginElement(content.name, content.attributes, isClosed);
                        j2 += content.parsed + (isClosed ? 2 : 1);
                        break;
                    }
                  } else {
                    while (j2 < s2.length && s2[j2] !== "<") {
                      j2++;
                    }
                    const text = s2.substring(i2, j2);
                    this.onText(this._resolveEntities(text));
                  }
                  i2 = j2;
                }
              }
              onResolveEntity(name) {
                return `&${name};`;
              }
              onPi(name, value) {
              }
              onComment(text) {
              }
              onCdata(text) {
              }
              onDoctype(doctypeContent) {
              }
              onText(text) {
              }
              onBeginElement(name, attributes, isEmpty) {
              }
              onEndElement(name) {
              }
              onError(code) {
              }
            }
            class SimpleDOMNode {
              constructor(nodeName, nodeValue) {
                this.nodeName = nodeName;
                this.nodeValue = nodeValue;
                Object.defineProperty(this, "parentNode", {
                  value: null,
                  writable: true
                });
              }
              get firstChild() {
                return this.childNodes && this.childNodes[0];
              }
              get nextSibling() {
                const childNodes = this.parentNode.childNodes;
                if (!childNodes) {
                  return void 0;
                }
                const index = childNodes.indexOf(this);
                if (index === -1) {
                  return void 0;
                }
                return childNodes[index + 1];
              }
              get textContent() {
                if (!this.childNodes) {
                  return this.nodeValue || "";
                }
                return this.childNodes.map(function(child) {
                  return child.textContent;
                }).join("");
              }
              hasChildNodes() {
                return this.childNodes && this.childNodes.length > 0;
              }
            }
            class SimpleXMLParser extends XMLParserBase {
              constructor() {
                super();
                this._currentFragment = null;
                this._stack = null;
                this._errorCode = XMLParserErrorCode.NoError;
              }
              parseFromString(data) {
                this._currentFragment = [];
                this._stack = [];
                this._errorCode = XMLParserErrorCode.NoError;
                this.parseXml(data);
                if (this._errorCode !== XMLParserErrorCode.NoError) {
                  return void 0;
                }
                const [documentElement] = this._currentFragment;
                if (!documentElement) {
                  return void 0;
                }
                return {
                  documentElement
                };
              }
              onResolveEntity(name) {
                switch (name) {
                  case "apos":
                    return "'";
                }
                return super.onResolveEntity(name);
              }
              onText(text) {
                if (isWhitespaceString(text)) {
                  return;
                }
                const node = new SimpleDOMNode("#text", text);
                this._currentFragment.push(node);
              }
              onCdata(text) {
                const node = new SimpleDOMNode("#text", text);
                this._currentFragment.push(node);
              }
              onBeginElement(name, attributes, isEmpty) {
                const node = new SimpleDOMNode(name);
                node.childNodes = [];
                this._currentFragment.push(node);
                if (isEmpty) {
                  return;
                }
                this._stack.push(this._currentFragment);
                this._currentFragment = node.childNodes;
              }
              onEndElement(name) {
                this._currentFragment = this._stack.pop() || [];
                const lastElement = this._currentFragment[this._currentFragment.length - 1];
                if (!lastElement) {
                  return;
                }
                for (let i2 = 0, ii = lastElement.childNodes.length; i2 < ii; i2++) {
                  lastElement.childNodes[i2].parentNode = lastElement;
                }
              }
              onError(code) {
                this._errorCode = code;
              }
            }
            exports2.SimpleXMLParser = SimpleXMLParser;
          },
          /* 14 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDataTransportStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            class PDFDataTransportStream {
              constructor(params, pdfDataRangeTransport) {
                (0, _util2.assert)(pdfDataRangeTransport);
                this._queuedChunks = [];
                this._progressiveDone = params.progressiveDone || false;
                const initialData = params.initialData;
                if (initialData && initialData.length > 0) {
                  const buffer = new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !params.disableStream;
                this._isRangeSupported = !params.disableRange;
                this._contentLength = params.length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                  this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                  this._onProgress({
                    loaded,
                    total
                  });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                  this._onReceiveData({
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                  this._onProgressiveDone();
                });
                this._pdfDataRangeTransport.transportReady();
              }
              _onReceiveData(args) {
                const buffer = new Uint8Array(args.chunk).buffer;
                if (args.begin === void 0) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader._enqueue(buffer);
                  } else {
                    this._queuedChunks.push(buffer);
                  }
                } else {
                  const found = this._rangeReaders.some(function(rangeReader) {
                    if (rangeReader._begin !== args.begin) {
                      return false;
                    }
                    rangeReader._enqueue(buffer);
                    return true;
                  });
                  (0, _util2.assert)(found);
                }
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              _onProgress(evt) {
                if (evt.total === void 0) {
                  const firstReader = this._rangeReaders[0];
                  if (firstReader && firstReader.onProgress) {
                    firstReader.onProgress({
                      loaded: evt.loaded
                    });
                  }
                } else {
                  const fullReader = this._fullRequestReader;
                  if (fullReader && fullReader.onProgress) {
                    fullReader.onProgress({
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
              }
              _onProgressiveDone() {
                if (this._fullRequestReader) {
                  this._fullRequestReader.progressiveDone();
                }
                this._progressiveDone = true;
              }
              _removeRangeReader(reader) {
                const i2 = this._rangeReaders.indexOf(reader);
                if (i2 >= 0) {
                  this._rangeReaders.splice(i2, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                const queuedChunks = this._queuedChunks;
                this._queuedChunks = null;
                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                this._pdfDataRangeTransport.requestDataRange(begin, end);
                this._rangeReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeReaders.slice(0);
                readers.forEach(function(rangeReader) {
                  rangeReader.cancel(reason);
                });
                this._pdfDataRangeTransport.abort();
              }
            }
            exports2.PDFDataTransportStream = PDFDataTransportStream;
            class PDFDataTransportStreamReader {
              constructor(stream, queuedChunks, progressiveDone = false) {
                this._stream = stream;
                this._done = progressiveDone || false;
                this._filename = null;
                this._queuedChunks = queuedChunks || [];
                this._loaded = 0;
                for (const chunk of this._queuedChunks) {
                  this._loaded += chunk.byteLength;
                }
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream._fullRequestReader = this;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunks.push(chunk);
                }
                this._loaded += chunk.byteLength;
              }
              get headersReady() {
                return this._headersReady;
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._stream._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._stream._isStreamingSupported;
              }
              get contentLength() {
                return this._stream._contentLength;
              }
              async read() {
                if (this._queuedChunks.length > 0) {
                  const chunk = this._queuedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              progressiveDone() {
                if (this._done) {
                  return;
                }
                this._done = true;
              }
            }
            class PDFDataTransportStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length === 0) {
                  this._queuedChunk = chunk;
                } else {
                  const requestsCapability = this._requests.shift();
                  requestsCapability.resolve({
                    value: chunk,
                    done: false
                  });
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
                this._done = true;
                this._stream._removeRangeReader(this);
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._queuedChunk) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._stream._removeRangeReader(this);
              }
            }
          },
          /* 15 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.WebGLContext = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            class WebGLContext {
              constructor({
                enable = false
              }) {
                this._enabled = enable === true;
              }
              get isEnabled() {
                let enabled = this._enabled;
                if (enabled) {
                  enabled = WebGLUtils.tryInitGL();
                }
                return (0, _util2.shadow)(this, "isEnabled", enabled);
              }
              composeSMask({
                layer,
                mask,
                properties
              }) {
                return WebGLUtils.composeSMask(layer, mask, properties);
              }
              drawFigures({
                width,
                height,
                backgroundColor,
                figures,
                context
              }) {
                return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
              }
              clear() {
                WebGLUtils.cleanup();
              }
            }
            exports2.WebGLContext = WebGLContext;
            var WebGLUtils = function WebGLUtilsClosure() {
              function loadShader(gl, code, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                  var errorMsg = gl.getShaderInfoLog(shader);
                  throw new Error("Error during shader compilation: " + errorMsg);
                }
                return shader;
              }
              function createVertexShader(gl, code) {
                return loadShader(gl, code, gl.VERTEX_SHADER);
              }
              function createFragmentShader(gl, code) {
                return loadShader(gl, code, gl.FRAGMENT_SHADER);
              }
              function createProgram(gl, shaders) {
                var program = gl.createProgram();
                for (var i2 = 0, ii = shaders.length; i2 < ii; ++i2) {
                  gl.attachShader(program, shaders[i2]);
                }
                gl.linkProgram(program);
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                  var errorMsg = gl.getProgramInfoLog(program);
                  throw new Error("Error during program linking: " + errorMsg);
                }
                return program;
              }
              function createTexture(gl, image, textureId) {
                gl.activeTexture(textureId);
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
              }
              var currentGL, currentCanvas;
              function generateGL() {
                if (currentGL) {
                  return;
                }
                currentCanvas = document.createElement("canvas");
                currentGL = currentCanvas.getContext("webgl", {
                  premultipliedalpha: false
                });
              }
              var smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
              var smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
              var smaskCache = null;
              function initSmaskGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                var texLayerLocation = gl.getUniformLocation(program, "u_image");
                var texMaskLocation = gl.getUniformLocation(program, "u_mask");
                var texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform1i(texLayerLocation, 0);
                gl.uniform1i(texMaskLocation, 1);
                smaskCache = cache;
              }
              function composeSMask(layer, mask, properties) {
                var width = layer.width, height = layer.height;
                if (!smaskCache) {
                  initSmaskGL();
                }
                var cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                if (properties.backdrop) {
                  gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                } else {
                  gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                }
                gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                var texture = createTexture(gl, layer, gl.TEXTURE0);
                var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.flush();
                gl.deleteTexture(texture);
                gl.deleteTexture(maskTexture);
                gl.deleteBuffer(buffer);
                return canvas;
              }
              var figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
              var figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
              var figuresCache = null;
              function initFiguresGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.colorLocation = gl.getAttribLocation(program, "a_color");
                figuresCache = cache;
              }
              function drawFigures(width, height, backgroundColor, figures, context) {
                if (!figuresCache) {
                  initFiguresGL();
                }
                var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                var count = 0;
                var i2, ii, rows;
                for (i2 = 0, ii = figures.length; i2 < ii; i2++) {
                  switch (figures[i2].type) {
                    case "lattice":
                      rows = figures[i2].coords.length / figures[i2].verticesPerRow | 0;
                      count += (rows - 1) * (figures[i2].verticesPerRow - 1) * 6;
                      break;
                    case "triangles":
                      count += figures[i2].coords.length;
                      break;
                  }
                }
                var coords = new Float32Array(count * 2);
                var colors = new Uint8Array(count * 3);
                var coordsMap = context.coords, colorsMap = context.colors;
                var pIndex = 0, cIndex = 0;
                for (i2 = 0, ii = figures.length; i2 < ii; i2++) {
                  var figure = figures[i2], ps = figure.coords, cs = figure.colors;
                  switch (figure.type) {
                    case "lattice":
                      var cols = figure.verticesPerRow;
                      rows = ps.length / cols | 0;
                      for (var row = 1; row < rows; row++) {
                        var offset = row * cols + 1;
                        for (var col = 1; col < cols; col++, offset++) {
                          coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                          coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                          coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                          coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                          coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                          coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                          colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                          colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                          colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                          colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                          colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                          colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                          colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                          colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                          colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                          coords[pIndex + 6] = coords[pIndex + 2];
                          coords[pIndex + 7] = coords[pIndex + 3];
                          coords[pIndex + 8] = coords[pIndex + 4];
                          coords[pIndex + 9] = coords[pIndex + 5];
                          coords[pIndex + 10] = coordsMap[ps[offset]];
                          coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                          colors[cIndex + 9] = colors[cIndex + 3];
                          colors[cIndex + 10] = colors[cIndex + 4];
                          colors[cIndex + 11] = colors[cIndex + 5];
                          colors[cIndex + 12] = colors[cIndex + 6];
                          colors[cIndex + 13] = colors[cIndex + 7];
                          colors[cIndex + 14] = colors[cIndex + 8];
                          colors[cIndex + 15] = colorsMap[cs[offset]];
                          colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                          colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                          pIndex += 12;
                          cIndex += 18;
                        }
                      }
                      break;
                    case "triangles":
                      for (var j2 = 0, jj = ps.length; j2 < jj; j2++) {
                        coords[pIndex] = coordsMap[ps[j2]];
                        coords[pIndex + 1] = coordsMap[ps[j2] + 1];
                        colors[cIndex] = colorsMap[cs[j2]];
                        colors[cIndex + 1] = colorsMap[cs[j2] + 1];
                        colors[cIndex + 2] = colorsMap[cs[j2] + 2];
                        pIndex += 2;
                        cIndex += 3;
                      }
                      break;
                  }
                }
                if (backgroundColor) {
                  gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                } else {
                  gl.clearColor(0, 0, 0, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                var coordsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                var colorsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.colorLocation);
                gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                gl.drawArrays(gl.TRIANGLES, 0, count);
                gl.flush();
                gl.deleteBuffer(coordsBuffer);
                gl.deleteBuffer(colorsBuffer);
                return canvas;
              }
              return {
                tryInitGL() {
                  try {
                    generateGL();
                    return !!currentGL;
                  } catch (ex) {
                  }
                  return false;
                },
                composeSMask,
                drawFigures,
                cleanup() {
                  if (smaskCache && smaskCache.canvas) {
                    smaskCache.canvas.width = 0;
                    smaskCache.canvas.height = 0;
                  }
                  if (figuresCache && figuresCache.canvas) {
                    figuresCache.canvas.width = 0;
                    figuresCache.canvas.height = 0;
                  }
                  smaskCache = null;
                  figuresCache = null;
                }
              };
            }();
          },
          /* 16 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.renderTextLayer = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var renderTextLayer = function renderTextLayerClosure() {
              var MAX_TEXT_DIVS_TO_RENDER = 1e5;
              var NonWhitespaceRegexp = /\S/;
              function isAllWhitespace(str) {
                return !NonWhitespaceRegexp.test(str);
              }
              function appendText(task, geom, styles) {
                var textDiv = document.createElement("span");
                var textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  isWhitespace: false,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                };
                task._textDivs.push(textDiv);
                if (isAllWhitespace(geom.str)) {
                  textDivProperties.isWhitespace = true;
                  task._textDivProperties.set(textDiv, textDivProperties);
                  return;
                }
                var tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                var angle = Math.atan2(tx[1], tx[0]);
                var style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
                var fontAscent = fontHeight;
                if (style.ascent) {
                  fontAscent = style.ascent * fontAscent;
                } else if (style.descent) {
                  fontAscent = (1 + style.descent) * fontAscent;
                }
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDiv.textContent = geom.str;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                if (geom.str.length > 1) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection) {
                  var angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  var divHeight = fontHeight;
                  var m, b2;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b2 = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b2 = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b2[0],
                    top: b2[1],
                    right: b2[2],
                    bottom: b2[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                var textDivs = task._textDivs;
                var capability = task._capability;
                var textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (var i2 = 0; i2 < textDivsLength; i2++) {
                    task._layoutText(textDivs[i2]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function expand(task) {
                var bounds = task._bounds;
                var viewport = task._viewport;
                var expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (var i2 = 0; i2 < expanded.length; i2++) {
                  var div = bounds[i2].div;
                  var divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i2].left - expanded[i2].left;
                    divProperties.paddingTop = bounds[i2].top - expanded[i2].top;
                    divProperties.paddingRight = expanded[i2].right - bounds[i2].right;
                    divProperties.paddingBottom = expanded[i2].bottom - bounds[i2].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  var e2 = expanded[i2], b2 = bounds[i2];
                  var m = b2.m, c2 = m[0], s2 = m[1];
                  var points = [[0, 0], [0, b2.size[1]], [b2.size[0], 0], b2.size];
                  var ts = new Float64Array(64);
                  points.forEach(function(p, i3) {
                    var t2 = _util2.Util.applyTransform(p, m);
                    ts[i3 + 0] = c2 && (e2.left - t2[0]) / c2;
                    ts[i3 + 4] = s2 && (e2.top - t2[1]) / s2;
                    ts[i3 + 8] = c2 && (e2.right - t2[0]) / c2;
                    ts[i3 + 12] = s2 && (e2.bottom - t2[1]) / s2;
                    ts[i3 + 16] = s2 && (e2.left - t2[0]) / -s2;
                    ts[i3 + 20] = c2 && (e2.top - t2[1]) / c2;
                    ts[i3 + 24] = s2 && (e2.right - t2[0]) / -s2;
                    ts[i3 + 28] = c2 && (e2.bottom - t2[1]) / c2;
                    ts[i3 + 32] = c2 && (e2.left - t2[0]) / -c2;
                    ts[i3 + 36] = s2 && (e2.top - t2[1]) / -s2;
                    ts[i3 + 40] = c2 && (e2.right - t2[0]) / -c2;
                    ts[i3 + 44] = s2 && (e2.bottom - t2[1]) / -s2;
                    ts[i3 + 48] = s2 && (e2.left - t2[0]) / s2;
                    ts[i3 + 52] = c2 && (e2.top - t2[1]) / -c2;
                    ts[i3 + 56] = s2 && (e2.right - t2[0]) / s2;
                    ts[i3 + 60] = c2 && (e2.bottom - t2[1]) / -c2;
                  });
                  var findPositiveMin = function(ts2, offset, count) {
                    var result = 0;
                    for (var i3 = 0; i3 < count; i3++) {
                      var t2 = ts2[offset++];
                      if (t2 > 0) {
                        result = result ? Math.min(t2, result) : t2;
                      }
                    }
                    return result;
                  };
                  var boxScale = 1 + Math.min(Math.abs(c2), Math.abs(s2));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                var bounds = boxes.map(function(box, i2) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i2,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                var expanded = new Array(boxes.length);
                bounds.forEach(function(b2) {
                  var i2 = b2.index;
                  expanded[i2] = {
                    left: b2.x1New,
                    top: 0,
                    right: b2.x2New,
                    bottom: 0
                  };
                });
                boxes.map(function(box, i2) {
                  var e2 = expanded[i2], b2 = bounds[i2];
                  b2.x1 = box.top;
                  b2.y1 = width - e2.right;
                  b2.x2 = box.bottom;
                  b2.y2 = width - e2.left;
                  b2.index = i2;
                  b2.x1New = void 0;
                  b2.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                bounds.forEach(function(b2) {
                  var i2 = b2.index;
                  expanded[i2].top = b2.x1New;
                  expanded[i2].bottom = b2.x2New;
                });
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a2, b2) {
                  return a2.x1 - b2.x1 || a2.index - b2.index;
                });
                var fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                var horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                bounds.forEach(function(boundary) {
                  var i2 = 0;
                  while (i2 < horizon.length && horizon[i2].end <= boundary.y1) {
                    i2++;
                  }
                  var j2 = horizon.length - 1;
                  while (j2 >= 0 && horizon[j2].start >= boundary.y2) {
                    j2--;
                  }
                  var horizonPart, affectedBoundary;
                  var q2, k2, maxXNew = -Infinity;
                  for (q2 = i2; q2 <= j2; q2++) {
                    horizonPart = horizon[q2];
                    affectedBoundary = horizonPart.boundary;
                    var xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q2 = i2; q2 <= j2; q2++) {
                    horizonPart = horizon[q2];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  var changedHorizon = [], lastBoundary = null;
                  for (q2 = i2; q2 <= j2; q2++) {
                    horizonPart = horizon[q2];
                    affectedBoundary = horizonPart.boundary;
                    var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i2].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i2].start,
                      end: boundary.y1,
                      boundary: horizon[i2].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j2].end) {
                    changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j2].end,
                      boundary: horizon[j2].boundary
                    });
                  }
                  for (q2 = i2; q2 <= j2; q2++) {
                    horizonPart = horizon[q2];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    var used = false;
                    for (k2 = i2 - 1; !used && k2 >= 0 && horizon[k2].start >= affectedBoundary.y1; k2--) {
                      used = horizon[k2].boundary === affectedBoundary;
                    }
                    for (k2 = j2 + 1; !used && k2 < horizon.length && horizon[k2].end <= affectedBoundary.y2; k2++) {
                      used = horizon[k2].boundary === affectedBoundary;
                    }
                    for (k2 = 0; !used && k2 < changedHorizon.length; k2++) {
                      used = changedHorizon[k2].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i2, j2 - i2 + 1].concat(changedHorizon));
                });
                horizon.forEach(function(horizonPart) {
                  var affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                });
              }
              function TextLayerRenderTask({
                textContent,
                textContentStream,
                container,
                viewport,
                textDivs,
                textContentItemsStr,
                enhanceTextSelection
              }) {
                this._textContent = textContent;
                this._textContentStream = textContentStream;
                this._container = container;
                this._viewport = viewport;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._enhanceTextSelection = !!enhanceTextSelection;
                this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);
                this._reader = null;
                this._layoutTextLastFontSize = null;
                this._layoutTextLastFontFamily = null;
                this._layoutTextCtx = null;
                this._textDivProperties = /* @__PURE__ */ new WeakMap();
                this._renderingDone = false;
                this._canceled = false;
                this._capability = (0, _util2.createPromiseCapability)();
                this._renderTimer = null;
                this._bounds = [];
                this._capability.promise.finally(() => {
                  if (this._layoutTextCtx) {
                    this._layoutTextCtx.canvas.width = 0;
                    this._layoutTextCtx.canvas.height = 0;
                    this._layoutTextCtx = null;
                  }
                }).catch(() => {
                });
              }
              TextLayerRenderTask.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                cancel: function TextLayer_cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."));
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                },
                _processItems(items, styleCache) {
                  for (let i2 = 0, len = items.length; i2 < len; i2++) {
                    this._textContentItemsStr.push(items[i2].str);
                    appendText(this, items[i2], styleCache);
                  }
                },
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  if (textDivProperties.isWhitespace) {
                    return;
                  }
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0) {
                    const {
                      fontSize,
                      fontFamily
                    } = textDiv.style;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width > 0) {
                      textDivProperties.scale = textDivProperties.canvasWidth / width;
                      transform = `scaleX(${textDivProperties.scale})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  this._textDivProperties.set(textDiv, textDivProperties);
                  this._container.appendChild(textDiv);
                },
                _render: function TextLayer_render(timeout) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = document.createElement("canvas");
                  canvas.mozOpaque = true;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                },
                expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (var i2 = 0, ii = this._textDivs.length; i2 < ii; i2++) {
                    const div = this._textDivs[i2];
                    const divProps = this._textDivProperties.get(div);
                    if (divProps.isWhitespace) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div.style.padding = null;
                      div.style.transform = divProps.originalTransform;
                    }
                  }
                }
              };
              function renderTextLayer2(renderParameters) {
                var task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
              return renderTextLayer2;
            }();
            exports2.renderTextLayer = renderTextLayer;
          },
          /* 17 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationLayer = void 0;
            var _display_utils2 = __w_pdfjs_require__2(4);
            var _util2 = __w_pdfjs_require__2(1);
            class AnnotationElementFactory {
              static create(parameters) {
                const subtype = parameters.data.annotationType;
                switch (subtype) {
                  case _util2.AnnotationType.LINK:
                    return new LinkAnnotationElement(parameters);
                  case _util2.AnnotationType.TEXT:
                    return new TextAnnotationElement(parameters);
                  case _util2.AnnotationType.WIDGET:
                    const fieldType = parameters.data.fieldType;
                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotationElement(parameters);
                      case "Btn":
                        if (parameters.data.radioButton) {
                          return new RadioButtonWidgetAnnotationElement(parameters);
                        } else if (parameters.data.checkBox) {
                          return new CheckboxWidgetAnnotationElement(parameters);
                        }
                        return new PushButtonWidgetAnnotationElement(parameters);
                      case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                    }
                    return new WidgetAnnotationElement(parameters);
                  case _util2.AnnotationType.POPUP:
                    return new PopupAnnotationElement(parameters);
                  case _util2.AnnotationType.FREETEXT:
                    return new FreeTextAnnotationElement(parameters);
                  case _util2.AnnotationType.LINE:
                    return new LineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUARE:
                    return new SquareAnnotationElement(parameters);
                  case _util2.AnnotationType.CIRCLE:
                    return new CircleAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYLINE:
                    return new PolylineAnnotationElement(parameters);
                  case _util2.AnnotationType.CARET:
                    return new CaretAnnotationElement(parameters);
                  case _util2.AnnotationType.INK:
                    return new InkAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYGON:
                    return new PolygonAnnotationElement(parameters);
                  case _util2.AnnotationType.HIGHLIGHT:
                    return new HighlightAnnotationElement(parameters);
                  case _util2.AnnotationType.UNDERLINE:
                    return new UnderlineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUIGGLY:
                    return new SquigglyAnnotationElement(parameters);
                  case _util2.AnnotationType.STRIKEOUT:
                    return new StrikeOutAnnotationElement(parameters);
                  case _util2.AnnotationType.STAMP:
                    return new StampAnnotationElement(parameters);
                  case _util2.AnnotationType.FILEATTACHMENT:
                    return new FileAttachmentAnnotationElement(parameters);
                  default:
                    return new AnnotationElement(parameters);
                }
              }
            }
            class AnnotationElement {
              constructor(parameters, isRenderable = false, ignoreBorder = false) {
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.page = parameters.page;
                this.viewport = parameters.viewport;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderInteractiveForms = parameters.renderInteractiveForms;
                this.svgFactory = parameters.svgFactory;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
              }
              _createContainer(ignoreBorder = false) {
                const data = this.data, page = this.page, viewport = this.viewport;
                const container = document.createElement("section");
                let width = data.rect[2] - data.rect[0];
                let height = data.rect[3] - data.rect[1];
                container.setAttribute("data-annotation-id", data.id);
                const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                container.style.transform = `matrix(${viewport.transform.join(",")})`;
                container.style.transformOrigin = `-${rect[0]}px -${rect[1]}px`;
                if (!ignoreBorder && data.borderStyle.width > 0) {
                  container.style.borderWidth = `${data.borderStyle.width}px`;
                  if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                    width = width - 2 * data.borderStyle.width;
                    height = height - 2 * data.borderStyle.width;
                  }
                  const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                  const verticalRadius = data.borderStyle.verticalCornerRadius;
                  if (horizontalRadius > 0 || verticalRadius > 0) {
                    const radius = `${horizontalRadius}px / ${verticalRadius}px`;
                    container.style.borderRadius = radius;
                  }
                  switch (data.borderStyle.style) {
                    case _util2.AnnotationBorderStyleType.SOLID:
                      container.style.borderStyle = "solid";
                      break;
                    case _util2.AnnotationBorderStyleType.DASHED:
                      container.style.borderStyle = "dashed";
                      break;
                    case _util2.AnnotationBorderStyleType.BEVELED:
                      (0, _util2.warn)("Unimplemented border style: beveled");
                      break;
                    case _util2.AnnotationBorderStyleType.INSET:
                      (0, _util2.warn)("Unimplemented border style: inset");
                      break;
                    case _util2.AnnotationBorderStyleType.UNDERLINE:
                      container.style.borderBottomStyle = "solid";
                      break;
                    default:
                      break;
                  }
                  if (data.color) {
                    container.style.borderColor = _util2.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                  } else {
                    container.style.borderWidth = 0;
                  }
                }
                container.style.left = `${rect[0]}px`;
                container.style.top = `${rect[1]}px`;
                container.style.width = `${width}px`;
                container.style.height = `${height}px`;
                return container;
              }
              _createPopup(container, trigger, data) {
                if (!trigger) {
                  trigger = document.createElement("div");
                  trigger.style.height = container.style.height;
                  trigger.style.width = container.style.width;
                  container.appendChild(trigger);
                }
                const popupElement = new PopupElement({
                  container,
                  trigger,
                  color: data.color,
                  title: data.title,
                  modificationDate: data.modificationDate,
                  contents: data.contents,
                  hideWrapper: true
                });
                const popup = popupElement.render();
                popup.style.left = container.style.width;
                container.appendChild(popup);
              }
              render() {
                (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
              }
            }
            class LinkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
                super(parameters, isRenderable);
              }
              render() {
                this.container.className = "linkAnnotation";
                const {
                  data,
                  linkService
                } = this;
                const link = document.createElement("a");
                if (data.url) {
                  (0, _display_utils2.addLinkAttributes)(link, {
                    url: data.url,
                    target: data.newWindow ? _display_utils2.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel,
                    enabled: linkService.externalLinkEnabled
                  });
                } else if (data.action) {
                  this._bindNamedAction(link, data.action);
                } else {
                  this._bindLink(link, data.dest);
                }
                this.container.appendChild(link);
                return this.container;
              }
              _bindLink(link, destination) {
                link.href = this.linkService.getDestinationHash(destination);
                link.onclick = () => {
                  if (destination) {
                    this.linkService.navigateTo(destination);
                  }
                  return false;
                };
                if (destination) {
                  link.className = "internalLink";
                }
              }
              _bindNamedAction(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeNamedAction(action);
                  return false;
                };
                link.className = "internalLink";
              }
            }
            class TextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable);
              }
              render() {
                this.container.className = "textAnnotation";
                const image = document.createElement("img");
                image.style.height = this.container.style.height;
                image.style.width = this.container.style.width;
                image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                image.alt = "[{{type}} Annotation]";
                image.dataset.l10nId = "text_annotation_type";
                image.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                });
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, image, this.data);
                }
                this.container.appendChild(image);
                return this.container;
              }
            }
            class WidgetAnnotationElement extends AnnotationElement {
              render() {
                return this.container;
              }
            }
            class TextWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                super(parameters, isRenderable);
              }
              render() {
                const TEXT_ALIGNMENT = ["left", "center", "right"];
                this.container.className = "textWidgetAnnotation";
                let element = null;
                if (this.renderInteractiveForms) {
                  if (this.data.multiLine) {
                    element = document.createElement("textarea");
                    element.textContent = this.data.fieldValue;
                  } else {
                    element = document.createElement("input");
                    element.type = "text";
                    element.setAttribute("value", this.data.fieldValue);
                  }
                  element.disabled = this.data.readOnly;
                  if (this.data.maxLen !== null) {
                    element.maxLength = this.data.maxLen;
                  }
                  if (this.data.comb) {
                    const fieldWidth = this.data.rect[2] - this.data.rect[0];
                    const combWidth = fieldWidth / this.data.maxLen;
                    element.classList.add("comb");
                    element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
                  }
                } else {
                  element = document.createElement("div");
                  element.textContent = this.data.fieldValue;
                  element.style.verticalAlign = "middle";
                  element.style.display = "table-cell";
                  let font = null;
                  if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {
                    font = this.page.commonObjs.get(this.data.fontRefName);
                  }
                  this._setTextStyle(element, font);
                }
                if (this.data.textAlignment !== null) {
                  element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                }
                this.container.appendChild(element);
                return this.container;
              }
              _setTextStyle(element, font) {
                const style = element.style;
                style.fontSize = `${this.data.fontSize}px`;
                style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";
                if (!font) {
                  return;
                }
                let bold = "normal";
                if (font.black) {
                  bold = "900";
                } else if (font.bold) {
                  bold = "bold";
                }
                style.fontWeight = bold;
                style.fontStyle = font.italic ? "italic" : "normal";
                const fontFamily = font.loadedName ? `"${font.loadedName}", ` : "";
                const fallbackName = font.fallbackName || "Helvetica, sans-serif";
                style.fontFamily = fontFamily + fallbackName;
              }
            }
            class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "buttonWidgetAnnotation checkBox";
                const element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "checkbox";
                if (this.data.fieldValue && this.data.fieldValue !== "Off") {
                  element.setAttribute("checked", true);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "buttonWidgetAnnotation radioButton";
                const element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "radio";
                element.name = this.data.fieldName;
                if (this.data.fieldValue === this.data.buttonValue) {
                  element.setAttribute("checked", true);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
              render() {
                const container = super.render();
                container.className = "buttonWidgetAnnotation pushButton";
                return container;
              }
            }
            class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "choiceWidgetAnnotation";
                const selectElement = document.createElement("select");
                selectElement.disabled = this.data.readOnly;
                if (!this.data.combo) {
                  selectElement.size = this.data.options.length;
                  if (this.data.multiSelect) {
                    selectElement.multiple = true;
                  }
                }
                for (const option of this.data.options) {
                  const optionElement = document.createElement("option");
                  optionElement.textContent = option.displayValue;
                  optionElement.value = option.exportValue;
                  if (this.data.fieldValue.includes(option.displayValue)) {
                    optionElement.setAttribute("selected", true);
                  }
                  selectElement.appendChild(optionElement);
                }
                this.container.appendChild(selectElement);
                return this.container;
              }
            }
            class PopupAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable);
              }
              render() {
                const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                this.container.className = "popupAnnotation";
                if (IGNORE_TYPES.includes(this.data.parentType)) {
                  return this.container;
                }
                const selector = `[data-annotation-id="${this.data.parentId}"]`;
                const parentElement = this.layer.querySelector(selector);
                if (!parentElement) {
                  return this.container;
                }
                const popup = new PopupElement({
                  container: this.container,
                  trigger: parentElement,
                  color: this.data.color,
                  title: this.data.title,
                  modificationDate: this.data.modificationDate,
                  contents: this.data.contents
                });
                const parentLeft = parseFloat(parentElement.style.left);
                const parentWidth = parseFloat(parentElement.style.width);
                this.container.style.transformOrigin = `-${parentLeft + parentWidth}px -${parentElement.style.top}`;
                this.container.style.left = `${parentLeft + parentWidth}px`;
                this.container.appendChild(popup.render());
                return this.container;
              }
            }
            class PopupElement {
              constructor(parameters) {
                this.container = parameters.container;
                this.trigger = parameters.trigger;
                this.color = parameters.color;
                this.title = parameters.title;
                this.modificationDate = parameters.modificationDate;
                this.contents = parameters.contents;
                this.hideWrapper = parameters.hideWrapper || false;
                this.pinned = false;
              }
              render() {
                const BACKGROUND_ENLIGHT = 0.7;
                const wrapper = document.createElement("div");
                wrapper.className = "popupWrapper";
                this.hideElement = this.hideWrapper ? wrapper : this.container;
                this.hideElement.setAttribute("hidden", true);
                const popup = document.createElement("div");
                popup.className = "popup";
                const color = this.color;
                if (color) {
                  const r2 = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                  const g2 = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                  const b2 = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                  popup.style.backgroundColor = _util2.Util.makeCssRgb(r2 | 0, g2 | 0, b2 | 0);
                }
                const title = document.createElement("h1");
                title.textContent = this.title;
                popup.appendChild(title);
                const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                if (dateObject) {
                  const modificationDate = document.createElement("span");
                  modificationDate.textContent = "{{date}}, {{time}}";
                  modificationDate.dataset.l10nId = "annotation_date_string";
                  modificationDate.dataset.l10nArgs = JSON.stringify({
                    date: dateObject.toLocaleDateString(),
                    time: dateObject.toLocaleTimeString()
                  });
                  popup.appendChild(modificationDate);
                }
                const contents = this._formatContents(this.contents);
                popup.appendChild(contents);
                this.trigger.addEventListener("click", this._toggle.bind(this));
                this.trigger.addEventListener("mouseover", this._show.bind(this, false));
                this.trigger.addEventListener("mouseout", this._hide.bind(this, false));
                popup.addEventListener("click", this._hide.bind(this, true));
                wrapper.appendChild(popup);
                return wrapper;
              }
              _formatContents(contents) {
                const p = document.createElement("p");
                const lines = contents.split(/(?:\r\n?|\n)/);
                for (let i2 = 0, ii = lines.length; i2 < ii; ++i2) {
                  const line = lines[i2];
                  p.appendChild(document.createTextNode(line));
                  if (i2 < ii - 1) {
                    p.appendChild(document.createElement("br"));
                  }
                }
                return p;
              }
              _toggle() {
                if (this.pinned) {
                  this._hide(true);
                } else {
                  this._show(true);
                }
              }
              _show(pin = false) {
                if (pin) {
                  this.pinned = true;
                }
                if (this.hideElement.hasAttribute("hidden")) {
                  this.hideElement.removeAttribute("hidden");
                  this.container.style.zIndex += 1;
                }
              }
              _hide(unpin = true) {
                if (unpin) {
                  this.pinned = false;
                }
                if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
                  this.hideElement.setAttribute("hidden", true);
                  this.container.style.zIndex -= 1;
                }
              }
            }
            class FreeTextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "freeTextAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class LineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "lineAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const line = this.svgFactory.createElement("svg:line");
                line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                line.setAttribute("stroke-width", data.borderStyle.width || 1);
                line.setAttribute("stroke", "transparent");
                svg.appendChild(line);
                this.container.append(svg);
                this._createPopup(this.container, line, data);
                return this.container;
              }
            }
            class SquareAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "squareAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const square = this.svgFactory.createElement("svg:rect");
                square.setAttribute("x", borderWidth / 2);
                square.setAttribute("y", borderWidth / 2);
                square.setAttribute("width", width - borderWidth);
                square.setAttribute("height", height - borderWidth);
                square.setAttribute("stroke-width", borderWidth || 1);
                square.setAttribute("stroke", "transparent");
                square.setAttribute("fill", "none");
                svg.appendChild(square);
                this.container.append(svg);
                this._createPopup(this.container, square, data);
                return this.container;
              }
            }
            class CircleAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "circleAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const circle = this.svgFactory.createElement("svg:ellipse");
                circle.setAttribute("cx", width / 2);
                circle.setAttribute("cy", height / 2);
                circle.setAttribute("rx", width / 2 - borderWidth / 2);
                circle.setAttribute("ry", height / 2 - borderWidth / 2);
                circle.setAttribute("stroke-width", borderWidth || 1);
                circle.setAttribute("stroke", "transparent");
                circle.setAttribute("fill", "none");
                svg.appendChild(circle);
                this.container.append(svg);
                this._createPopup(this.container, circle, data);
                return this.container;
              }
            }
            class PolylineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
                this.containerClassName = "polylineAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                let points = [];
                for (const coordinate of data.vertices) {
                  const x2 = coordinate.x - data.rect[0];
                  const y2 = data.rect[3] - coordinate.y;
                  points.push(x2 + "," + y2);
                }
                points = points.join(" ");
                const polyline = this.svgFactory.createElement(this.svgElementName);
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "none");
                svg.appendChild(polyline);
                this.container.append(svg);
                this._createPopup(this.container, polyline, data);
                return this.container;
              }
            }
            class PolygonAnnotationElement extends PolylineAnnotationElement {
              constructor(parameters) {
                super(parameters);
                this.containerClassName = "polygonAnnotation";
                this.svgElementName = "svg:polygon";
              }
            }
            class CaretAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "caretAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class InkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
                this.containerClassName = "inkAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                for (const inkList of data.inkLists) {
                  let points = [];
                  for (const coordinate of inkList) {
                    const x2 = coordinate.x - data.rect[0];
                    const y2 = data.rect[3] - coordinate.y;
                    points.push(`${x2},${y2}`);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");
                  this._createPopup(this.container, polyline, data);
                  svg.appendChild(polyline);
                }
                this.container.append(svg);
                return this.container;
              }
            }
            class HighlightAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "highlightAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class UnderlineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "underlineAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class SquigglyAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "squigglyAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class StrikeOutAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "strikeoutAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class StampAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "stampAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class FileAttachmentAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, true);
                const {
                  filename,
                  content
                } = this.data.file;
                this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                this.content = content;
                if (this.linkService.eventBus) {
                  this.linkService.eventBus.dispatch("fileattachmentannotation", {
                    source: this,
                    id: (0, _util2.stringToPDFString)(filename),
                    filename,
                    content
                  });
                }
              }
              render() {
                this.container.className = "fileAttachmentAnnotation";
                const trigger = document.createElement("div");
                trigger.style.height = this.container.style.height;
                trigger.style.width = this.container.style.width;
                trigger.addEventListener("dblclick", this._download.bind(this));
                if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                  this._createPopup(this.container, trigger, this.data);
                }
                this.container.appendChild(trigger);
                return this.container;
              }
              _download() {
                if (!this.downloadManager) {
                  (0, _util2.warn)("Download cannot be started due to unavailable download manager");
                  return;
                }
                this.downloadManager.downloadData(this.content, this.filename, "");
              }
            }
            class AnnotationLayer3 {
              static render(parameters) {
                const sortedAnnotations = [], popupAnnotations = [];
                for (const data of parameters.annotations) {
                  if (!data) {
                    continue;
                  }
                  if (data.annotationType === _util2.AnnotationType.POPUP) {
                    popupAnnotations.push(data);
                    continue;
                  }
                  sortedAnnotations.push(data);
                }
                if (popupAnnotations.length) {
                  sortedAnnotations.push(...popupAnnotations);
                }
                for (const data of sortedAnnotations) {
                  const element = AnnotationElementFactory.create({
                    data,
                    layer: parameters.div,
                    page: parameters.page,
                    viewport: parameters.viewport,
                    linkService: parameters.linkService,
                    downloadManager: parameters.downloadManager,
                    imageResourcesPath: parameters.imageResourcesPath || "",
                    renderInteractiveForms: parameters.renderInteractiveForms || false,
                    svgFactory: new _display_utils2.DOMSVGFactory()
                  });
                  if (element.isRenderable) {
                    parameters.div.appendChild(element.render());
                  }
                }
              }
              static update(parameters) {
                for (const data of parameters.annotations) {
                  const element = parameters.div.querySelector(`[data-annotation-id="${data.id}"]`);
                  if (element) {
                    element.style.transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  }
                }
                parameters.div.removeAttribute("hidden");
              }
            }
            exports2.AnnotationLayer = AnnotationLayer3;
          },
          /* 18 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SVGGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(4);
            var _is_node2 = __w_pdfjs_require__2(7);
            let SVGGraphics = function() {
              throw new Error("Not implemented: SVGGraphics");
            };
            exports2.SVGGraphics = SVGGraphics;
            {
              let opListToTree = function(opList) {
                let opTree = [];
                const tmp = [];
                for (const opListElement of opList) {
                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree[opTree.length - 1].items;
                    continue;
                  }
                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
                return opTree;
              }, pf = function(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const s2 = value.toFixed(10);
                let i2 = s2.length - 1;
                if (s2[i2] !== "0") {
                  return s2;
                }
                do {
                  i2--;
                } while (s2[i2] === "0");
                return s2.substring(0, s2[i2] === "." ? i2 : i2 + 1);
              }, pm = function(m) {
                if (m[4] === 0 && m[5] === 0) {
                  if (m[1] === 0 && m[2] === 0) {
                    if (m[0] === 1 && m[3] === 1) {
                      return "";
                    }
                    return `scale(${pf(m[0])} ${pf(m[3])})`;
                  }
                  if (m[0] === m[3] && m[1] === -m[2]) {
                    const a2 = Math.acos(m[0]) * 180 / Math.PI;
                    return `rotate(${pf(a2)})`;
                  }
                } else {
                  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                    return `translate(${pf(m[4])} ${pf(m[5])})`;
                  }
                }
                return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
              };
              const SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              const XML_NS = "http://www.w3.org/XML/1998/namespace";
              const XLINK_NS = "http://www.w3.org/1999/xlink";
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const convertImgDataToPng = function() {
                const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                const CHUNK_WRAPPER_SIZE = 12;
                const crcTable = new Int32Array(256);
                for (let i2 = 0; i2 < 256; i2++) {
                  let c2 = i2;
                  for (let h2 = 0; h2 < 8; h2++) {
                    if (c2 & 1) {
                      c2 = 3988292384 ^ c2 >> 1 & 2147483647;
                    } else {
                      c2 = c2 >> 1 & 2147483647;
                    }
                  }
                  crcTable[i2] = c2;
                }
                function crc32(data, start, end) {
                  let crc = -1;
                  for (let i2 = start; i2 < end; i2++) {
                    const a2 = (crc ^ data[i2]) & 255;
                    const b2 = crcTable[a2];
                    crc = crc >>> 8 ^ b2;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  let p = offset;
                  const len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  const crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  let a2 = 1;
                  let b2 = 0;
                  for (let i2 = start; i2 < end; ++i2) {
                    a2 = (a2 + (data[i2] & 255)) % 65521;
                    b2 = (b2 + a2) % 65521;
                  }
                  return b2 << 16 | a2;
                }
                function deflateSync(literals) {
                  if (!_is_node2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    let input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = Buffer.from(literals);
                    }
                    const output = require_zlib().deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e2) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e2);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  let len = literals.length;
                  const maxBlockLength = 65535;
                  const deflateBlocks = Math.ceil(len / maxBlockLength);
                  const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  let pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  let pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  const adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  let bitDepth, colorType, lineSize;
                  const bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  const literals = new Uint8Array((1 + lineSize) * height);
                  let offsetLiterals = 0, offsetBytes = 0;
                  for (let y2 = 0; y2 < height; ++y2) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (let y2 = 0; y2 < height; y2++) {
                      offsetLiterals++;
                      for (let i2 = 0; i2 < lineSize; i2++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  const idat = deflateSync(literals);
                  const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  const data = new Uint8Array(pngLength);
                  let offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return (0, _util2.createObjectURL)(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              class SVGExtraState {
                constructor() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                clone() {
                  return Object.create(this);
                }
                setCurrentPoint(x2, y2) {
                  this.x = x2;
                  this.y = y2;
                }
              }
              let clipCount = 0;
              let maskCount = 0;
              let shadingCount = 0;
              exports2.SVGGraphics = SVGGraphics = class SVGGraphics {
                constructor(commonObjs, objs, forceDataSchema) {
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (const op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                save() {
                  this.transformStack.push(this.transformMatrix);
                  const old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
                group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
                loadDependencies(operatorList) {
                  const fnArray = operatorList.fnArray;
                  const argsArray = operatorList.argsArray;
                  for (let i2 = 0, ii = fnArray.length; i2 < ii; i2++) {
                    if (fnArray[i2] !== _util2.OPS.dependency) {
                      continue;
                    }
                    for (const obj of argsArray[i2]) {
                      const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                      const promise = new Promise((resolve) => {
                        objsPool.get(obj, resolve);
                      });
                      this.current.dependencies.push(promise);
                    }
                  }
                  return Promise.all(this.current.dependencies);
                }
                transform(a2, b2, c2, d2, e2, f) {
                  const transformMatrix = [a2, b2, c2, d2, e2, f];
                  this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
                getSVG(operatorList, viewport) {
                  this.viewport = viewport;
                  const svgElement = this._initialize(viewport);
                  return this.loadDependencies(operatorList).then(() => {
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.executeOpTree(this.convertOpList(operatorList));
                    return svgElement;
                  });
                }
                convertOpList(operatorList) {
                  const operatorIdMapping = this._operatorIdMapping;
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  const opList = [];
                  for (let i2 = 0, ii = fnArray.length; i2 < ii; i2++) {
                    const fnId = fnArray[i2];
                    opList.push({
                      fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i2]
                    });
                  }
                  return opListToTree(opList);
                }
                executeOpTree(opTree) {
                  for (const opTreeElement of opTree) {
                    const fn = opTreeElement.fn;
                    const fnId = opTreeElement.fnId;
                    const args = opTreeElement.args;
                    switch (fnId | 0) {
                      case _util2.OPS.beginText:
                        this.beginText();
                        break;
                      case _util2.OPS.dependency:
                        break;
                      case _util2.OPS.setLeading:
                        this.setLeading(args);
                        break;
                      case _util2.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setFont:
                        this.setFont(args);
                        break;
                      case _util2.OPS.showText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.endText:
                        this.endText();
                        break;
                      case _util2.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;
                      case _util2.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;
                      case _util2.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;
                      case _util2.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;
                      case _util2.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;
                      case _util2.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;
                      case _util2.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;
                      case _util2.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;
                      case _util2.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;
                      case _util2.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;
                      case _util2.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;
                      case _util2.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;
                      case _util2.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;
                      case _util2.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;
                      case _util2.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;
                      case _util2.OPS.setGState:
                        this.setGState(args[0]);
                        break;
                      case _util2.OPS.fill:
                        this.fill();
                        break;
                      case _util2.OPS.eoFill:
                        this.eoFill();
                        break;
                      case _util2.OPS.stroke:
                        this.stroke();
                        break;
                      case _util2.OPS.fillStroke:
                        this.fillStroke();
                        break;
                      case _util2.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;
                      case _util2.OPS.clip:
                        this.clip("nonzero");
                        break;
                      case _util2.OPS.eoClip:
                        this.clip("evenodd");
                        break;
                      case _util2.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;
                      case _util2.OPS.paintJpegXObject:
                        this.paintJpegXObject(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;
                      case _util2.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;
                      case _util2.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;
                      case _util2.OPS.closePath:
                        this.closePath();
                        break;
                      case _util2.OPS.closeStroke:
                        this.closeStroke();
                        break;
                      case _util2.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;
                      case _util2.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;
                      case _util2.OPS.nextLine:
                        this.nextLine();
                        break;
                      case _util2.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;
                      case _util2.OPS.endPath:
                        this.endPath();
                        break;
                      case 92:
                        this.group(opTreeElement.items);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented operator ${fn}`);
                        break;
                    }
                  }
                }
                setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
                setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                setTextMatrix(a2, b2, c2, d2, e2, f) {
                  const current = this.current;
                  current.textMatrix = current.lineMatrix = [a2, b2, c2, d2, e2, f];
                  current.textMatrixScale = Math.sqrt(a2 * a2 + b2 * b2);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.appendChild(current.tspan);
                }
                beginText() {
                  const current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util2.IDENTITY_MATRIX;
                  current.lineMatrix = _util2.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                }
                moveText(x2, y2) {
                  const current = this.current;
                  current.x = current.lineX += x2;
                  current.y = current.lineY += y2;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const vertical = font.vertical;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  let x2 = 0;
                  for (const glyph of glyphs) {
                    if (glyph === null) {
                      x2 += fontDirection * wordSpacing;
                      continue;
                    } else if ((0, _util2.isNum)(glyph)) {
                      x2 += -glyph * fontSize * 1e-3;
                      continue;
                    }
                    const width = glyph.width;
                    const character = glyph.fontChar;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    if (!glyph.isInFont && !font.missingFile) {
                      x2 += charWidth;
                      continue;
                    }
                    current.xcoords.push(current.x + x2);
                    current.tspan.textContent += character;
                    x2 += charWidth;
                  }
                  if (vertical) {
                    current.y -= x2 * textHScale;
                  } else {
                    current.x += x2 * textHScale;
                  }
                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }
                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    const lineWidthScale = 1 / (current.textMatrixScale || 1);
                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }
                  let textMatrix = current.textMatrix;
                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }
                  current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.appendChild(current.tspan);
                  current.txtgrp.appendChild(current.txtElement);
                  this._ensureTransformGroup().appendChild(current.txtElement);
                }
                setLeadingMoveText(x2, y2) {
                  this.setLeading(-y2);
                  this.moveText(x2, y2);
                }
                addFontStyle(fontObj) {
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.appendChild(this.cssStyle);
                  }
                  const url = (0, _util2.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                }
                setFont(details) {
                  const current = this.current;
                  const fontObj = this.commonObjs.get(details[0]);
                  let size = details[1];
                  current.font = fontObj;
                  if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }
                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                }
                endText() {
                  const current = this.current;
                  if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
                setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
                setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
                setStrokeRGBColor(r2, g2, b2) {
                  this.current.strokeColor = _util2.Util.makeCssRgb(r2, g2, b2);
                }
                setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
                setFillRGBColor(r2, g2, b2) {
                  this.current.fillColor = _util2.Util.makeCssRgb(r2, g2, b2);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                }
                setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
                setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
                shadingFill(args) {
                  const width = this.viewport.width;
                  const height = this.viewport.height;
                  const inv = _util2.Util.inverseTransform(this.transformMatrix);
                  const bl = _util2.Util.applyTransform([0, 0], inv);
                  const br = _util2.Util.applyTransform([0, height], inv);
                  const ul = _util2.Util.applyTransform([width, 0], inv);
                  const ur = _util2.Util.applyTransform([width, height], inv);
                  const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                  const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                  const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                  const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                  this._ensureTransformGroup().appendChild(rect);
                }
                _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }
                  return this._makeShadingPattern(args);
                }
                _makeTilingPattern(args) {
                  const color = args[1];
                  const operatorList = args[2];
                  const matrix = args[3] || _util2.IDENTITY_MATRIX;
                  const [x0, y0, x1, y1] = args[4];
                  const xstep = args[5];
                  const ystep = args[6];
                  const paintType = args[7];
                  const tilingId = `shading${shadingCount++}`;
                  const [tx0, ty0] = _util2.Util.applyTransform([x0, y0], matrix);
                  const [tx1, ty1] = _util2.Util.applyTransform([x1, y1], matrix);
                  const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                  const txstep = xstep * xscale;
                  const tystep = ystep * yscale;
                  const tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", `${tx0}`);
                  tiling.setAttributeNS(null, "y", `${ty0}`);
                  const svg = this.svg;
                  const transformMatrix = this.transformMatrix;
                  const fillColor = this.current.fillColor;
                  const strokeColor = this.current.strokeColor;
                  const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;
                  if (paintType === 2) {
                    const cssColor = _util2.Util.makeCssRgb(...color);
                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }
                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.appendChild(bbox.childNodes[0]);
                  this.defs.appendChild(tiling);
                  return `url(#${tilingId})`;
                }
                _makeShadingPattern(args) {
                  switch (args[0]) {
                    case "RadialAxial":
                      const shadingId = `shading${shadingCount++}`;
                      const colorStops = args[3];
                      let gradient;
                      switch (args[1]) {
                        case "axial":
                          const point0 = args[4];
                          const point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;
                        case "radial":
                          const focalPoint = args[4];
                          const circlePoint = args[5];
                          const focalRadius = args[6];
                          const circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;
                        default:
                          throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                      }
                      for (const colorStop of colorStops) {
                        const stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.appendChild(stop);
                      }
                      this.defs.appendChild(gradient);
                      return `url(#${shadingId})`;
                    case "Mesh":
                      (0, _util2.warn)("Unimplemented pattern Mesh");
                      return null;
                    case "Dummy":
                      return "hotpink";
                    default:
                      throw new Error(`Unknown IR type: ${args[0]}`);
                  }
                }
                setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
                constructPath(ops, args) {
                  const current = this.current;
                  let x2 = current.x, y2 = current.y;
                  let d2 = [];
                  let j2 = 0;
                  for (const op of ops) {
                    switch (op | 0) {
                      case _util2.OPS.rectangle:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        const width = args[j2++];
                        const height = args[j2++];
                        const xw = x2 + width;
                        const yh = y2 + height;
                        d2.push("M", pf(x2), pf(y2), "L", pf(xw), pf(y2), "L", pf(xw), pf(yh), "L", pf(x2), pf(yh), "Z");
                        break;
                      case _util2.OPS.moveTo:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        d2.push("M", pf(x2), pf(y2));
                        break;
                      case _util2.OPS.lineTo:
                        x2 = args[j2++];
                        y2 = args[j2++];
                        d2.push("L", pf(x2), pf(y2));
                        break;
                      case _util2.OPS.curveTo:
                        x2 = args[j2 + 4];
                        y2 = args[j2 + 5];
                        d2.push("C", pf(args[j2]), pf(args[j2 + 1]), pf(args[j2 + 2]), pf(args[j2 + 3]), pf(x2), pf(y2));
                        j2 += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        d2.push("C", pf(x2), pf(y2), pf(args[j2]), pf(args[j2 + 1]), pf(args[j2 + 2]), pf(args[j2 + 3]));
                        x2 = args[j2 + 2];
                        y2 = args[j2 + 3];
                        j2 += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x2 = args[j2 + 2];
                        y2 = args[j2 + 3];
                        d2.push("C", pf(args[j2]), pf(args[j2 + 1]), pf(x2), pf(y2), pf(x2), pf(y2));
                        j2 += 4;
                        break;
                      case _util2.OPS.closePath:
                        d2.push("Z");
                        break;
                    }
                  }
                  d2 = d2.join(" ");
                  if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                    d2 = current.path.getAttributeNS(null, "d") + d2;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");
                    this._ensureTransformGroup().appendChild(current.path);
                  }
                  current.path.setAttributeNS(null, "d", d2);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x2, y2);
                }
                endPath() {
                  const current = this.current;
                  current.path = null;
                  if (!this.pendingClip) {
                    return;
                  }
                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }
                  const clipId = `clippath${clipCount++}`;
                  const clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  const clipElement = current.element.cloneNode(true);
                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }
                  this.pendingClip = null;
                  clipPath.appendChild(clipElement);
                  this.defs.appendChild(clipPath);
                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    this.extraStack.forEach(function(prev) {
                      prev.clipGroup = null;
                    });
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }
                  current.activeClipUrl = `url(#${clipId})`;
                  this.tgrp = null;
                }
                clip(type) {
                  this.pendingClip = type;
                }
                closePath() {
                  const current = this.current;
                  if (current.path) {
                    const d2 = `${current.path.getAttributeNS(null, "d")}Z`;
                    current.path.setAttributeNS(null, "d", d2);
                  }
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
                setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value);
                        break;
                      case "CA":
                        this.setStrokeAlpha(value);
                        break;
                      case "ca":
                        this.setFillAlpha(value);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                        break;
                    }
                  }
                }
                fill() {
                  const current = this.current;
                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
                stroke() {
                  const current = this.current;
                  if (current.element) {
                    this._setStrokeAttributes(current.element);
                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
                _setStrokeAttributes(element, lineWidthScale = 1) {
                  const current = this.current;
                  let dashArray = current.dashArray;
                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function(value) {
                      return lineWidthScale * value;
                    });
                  }
                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
                eoFill() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fill();
                }
                fillStroke() {
                  this.stroke();
                  this.fill();
                }
                eoFillStroke() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fillStroke();
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
                paintSolidColorImageMask() {
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);
                  this._ensureTransformGroup().appendChild(rect);
                }
                paintJpegXObject(objId, w2, h2) {
                  const imgObj = this.objs.get(objId);
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgObj.src);
                  imgEl.setAttributeNS(null, "width", pf(w2));
                  imgEl.setAttributeNS(null, "height", pf(h2));
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-h2));
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / w2)} ${pf(-1 / h2)})`);
                  this._ensureTransformGroup().appendChild(imgEl);
                }
                paintImageXObject(objId) {
                  const imgData = this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintInlineImageXObject(imgData, mask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                  if (mask) {
                    mask.appendChild(imgEl);
                  } else {
                    this._ensureTransformGroup().appendChild(imgEl);
                  }
                }
                paintImageMaskXObject(imgData) {
                  const current = this.current;
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = current.fillColor;
                  current.maskId = `mask${maskCount++}`;
                  const mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                  this.defs.appendChild(mask);
                  this._ensureTransformGroup().appendChild(rect);
                  this.paintInlineImageXObject(imgData, mask);
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                }
                _initialize(viewport) {
                  const svg = this.svgFactory.create(viewport.width, viewport.height);
                  const definitions = this.svgFactory.createElement("svg:defs");
                  svg.appendChild(definitions);
                  this.defs = definitions;
                  const rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.appendChild(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
                _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    const clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.appendChild(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }
                  return this.current.clipGroup;
                }
                _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().appendChild(this.tgrp);
                    } else {
                      this.svg.appendChild(this.tgrp);
                    }
                  }
                  return this.tgrp;
                }
              };
            }
          },
          /* 19 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNodeStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            const fs = require_fs();
            const http = require_http();
            const https = require_https();
            const url = require_url();
            const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              const parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse(`file:///${sourceUrl}`);
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            class PDFNodeStream {
              constructor(source) {
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(start, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                this._rangeRequestReaders.push(rangeReader);
                return rangeReader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFNodeStream = PDFNodeStream;
            class BaseFullReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                const source = stream.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._headersCapability = (0, _util2.createPromiseCapability)();
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  return this.read();
                }
                this._loaded += chunk.length;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (!this._isStreamingSupported && this._isRangeSupported) {
                  this._error(new _util2.AbortException("streaming is disabled"));
                }
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            class BaseRangeReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                const source = stream.source;
                this._isStreamingSupported = !source.disableStream;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  return this.read();
                }
                this._loaded += chunk.length;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            function createRequestOptions(url2, headers) {
              return {
                protocol: url2.protocol,
                auth: url2.auth,
                host: url2.hostname,
                port: url2.port,
                path: url2.path,
                method: "GET",
                headers
              };
            }
            class PDFNodeStreamFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._headersCapability.resolve();
                  this._setReadableStream(response);
                  const getResponseHeader = (name) => {
                    return this._readableStream.headers[name.toLowerCase()];
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                  this._headersCapability.reject(reason);
                });
                this._request.end();
              }
            }
            class PDFNodeStreamRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                this._httpHeaders = {};
                for (const property in stream.httpHeaders) {
                  const value = stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  this._httpHeaders[property] = value;
                }
                this._httpHeaders["Range"] = `bytes=${start}-${end - 1}`;
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    return;
                  }
                  this._setReadableStream(response);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                });
                this._request.end();
              }
            }
            class PDFNodeStreamFsFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                fs.lstat(path, (error, stat) => {
                  if (error) {
                    if (error.code === "ENOENT") {
                      error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                    }
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._contentLength = stat.size;
                  this._setReadableStream(fs.createReadStream(path));
                  this._headersCapability.resolve();
                });
              }
            }
            class PDFNodeStreamFsRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                this._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
              }
            }
          },
          /* 20 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.createResponseStatusError = createResponseStatusError;
            exports2.extractFilenameFromHeader = extractFilenameFromHeader;
            exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports2.validateResponseStatus = validateResponseStatus;
            var _util2 = __w_pdfjs_require__2(1);
            var _content_disposition = __w_pdfjs_require__2(21);
            function validateRangeRequestCapabilities({
              getResponseHeader,
              isHttp,
              rangeChunkSize,
              disableRange
            }) {
              (0, _util2.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
              const returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              const length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            function extractFilenameFromHeader(getResponseHeader) {
              const contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (filename.includes("%")) {
                  try {
                    filename = decodeURIComponent(filename);
                  } catch (ex) {
                  }
                }
                if (/\.pdf$/i.test(filename)) {
                  return filename;
                }
              }
              return null;
            }
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && url.startsWith("file:")) {
                return new _util2.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util2.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
            }
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
          },
          /* 21 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              let needsEncodingFixup = true;
              let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                const filename = rfc2047decode(tmp);
                return fixupEncoding(filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    const decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    const bytes = Array.from(value, function(ch) {
                      return ch.charCodeAt(0) & 255;
                    });
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                  } catch (e2) {
                    if (/^utf-?8$/i.test(encoding)) {
                      try {
                        value = decodeURIComponent(escape(value));
                        needsEncodingFixup = false;
                      } catch (err) {
                      }
                    }
                  }
                }
                return value;
              }
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              function rfc2231getparam(contentDisposition2) {
                const matches = [];
                let match;
                const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDisposition2)) !== null) {
                  let [, n2, quot, part] = match;
                  n2 = parseInt(n2, 10);
                  if (n2 in matches) {
                    if (n2 === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n2] = [quot, part];
                }
                const parts = [];
                for (let n2 = 0; n2 < matches.length; ++n2) {
                  if (!(n2 in matches)) {
                    break;
                  }
                  let [quot, part] = matches[n2];
                  part = rfc2616unquote(part);
                  if (quot) {
                    part = unescape(part);
                    if (n2 === 0) {
                      part = rfc5987decode(part);
                    }
                  }
                  parts.push(part);
                }
                return parts.join("");
              }
              function rfc2616unquote(value) {
                if (value.startsWith('"')) {
                  const parts = value.slice(1).split('\\"');
                  for (let i2 = 0; i2 < parts.length; ++i2) {
                    const quotindex = parts[i2].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i2] = parts[i2].slice(0, quotindex);
                      parts.length = i2 + 1;
                    }
                    parts[i2] = parts[i2].replace(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              function rfc5987decode(extvalue) {
                const encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                const encoding = extvalue.slice(0, encodingend);
                const langvalue = extvalue.slice(encodingend + 1);
                const value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              function rfc2047decode(value) {
                if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(_2, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replace(/_/g, " ");
                    text = text.replace(/=([0-9a-fA-F]{2})/g, function(_3, hex) {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch (e2) {
                  }
                  return textdecode(charset, text);
                });
              }
              return "";
            }
          },
          /* 22 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNetworkStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            ;
            const OK_RESPONSE = 200;
            const PARTIAL_CONTENT_RESPONSE = 206;
            function getArrayBuffer(xhr) {
              const data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              const array = (0, _util2.stringToBytes)(data);
              return array.buffer;
            }
            class NetworkManager {
              constructor(url, args) {
                this.url = url;
                args = args || {};
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = this.isHttp && args.httpHeaders || {};
                this.withCredentials = args.withCredentials || false;
                this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                  return new XMLHttpRequest();
                };
                this.currXhrId = 0;
                this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              requestRange(begin, end, listeners) {
                const args = {
                  begin,
                  end
                };
                for (const prop in listeners) {
                  args[prop] = listeners[prop];
                }
                return this.request(args);
              }
              requestFull(listeners) {
                return this.request(listeners);
              }
              request(args) {
                const xhr = this.getXhr();
                const xhrId = this.currXhrId++;
                const pendingRequest = this.pendingRequests[xhrId] = {
                  xhr
                };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;
                for (const property in this.httpHeaders) {
                  const value = this.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  xhr.setRequestHeader(property, value);
                }
                if (this.isHttp && "begin" in args && "end" in args) {
                  xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                  pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                } else {
                  pendingRequest.expectedStatus = OK_RESPONSE;
                }
                xhr.responseType = "arraybuffer";
                if (args.onError) {
                  xhr.onerror = function(evt) {
                    args.onError(xhr.status);
                  };
                }
                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              }
              onProgress(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                if (pendingRequest.onProgress) {
                  pendingRequest.onProgress(evt);
                }
              }
              onStateChange(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                const xhr = pendingRequest.xhr;
                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }
                if (xhr.readyState !== 4) {
                  return;
                }
                if (!(xhrId in this.pendingRequests)) {
                  return;
                }
                delete this.pendingRequests[xhrId];
                if (xhr.status === 0 && this.isHttp) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const xhrStatus = xhr.status || OK_RESPONSE;
                const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const chunk = getArrayBuffer(xhr);
                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  const rangeHeader = xhr.getResponseHeader("Content-Range");
                  const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  pendingRequest.onDone({
                    begin: parseInt(matches[1], 10),
                    chunk
                  });
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk
                  });
                } else if (pendingRequest.onError) {
                  pendingRequest.onError(xhr.status);
                }
              }
              hasPendingRequests() {
                for (const xhrId in this.pendingRequests) {
                  return true;
                }
                return false;
              }
              getRequestXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              }
              isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              }
              abortAllRequests() {
                for (const xhrId in this.pendingRequests) {
                  this.abortRequest(xhrId | 0);
                }
              }
              abortRequest(xhrId) {
                const xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            }
            class PDFNetworkStream {
              constructor(source) {
                this._source = source;
                this._manager = new NetworkManager(source.url, {
                  httpHeaders: source.httpHeaders,
                  withCredentials: source.withCredentials
                });
                this._rangeChunkSize = source.rangeChunkSize;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _onRangeRequestReaderClosed(reader) {
                const i2 = this._rangeRequestReaders.indexOf(reader);
                if (i2 >= 0) {
                  this._rangeRequestReaders.splice(i2, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFNetworkStream = PDFNetworkStream;
            class PDFNetworkStreamFullRequestReader {
              constructor(manager, source) {
                this._manager = manager;
                const args = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = source.url;
                this._fullRequestId = manager.requestFull(args);
                this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._contentLength = source.length;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = false;
                this._isRangeSupported = false;
                this._cachedChunks = [];
                this._requests = [];
                this._done = false;
                this._storedError = void 0;
                this._filename = null;
                this.onProgress = null;
              }
              _onHeadersReceived() {
                const fullRequestXhrId = this._fullRequestId;
                const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                const getResponseHeader = (name) => {
                  return fullRequestXhr.getResponseHeader(name);
                };
                const {
                  allowRangeRequests,
                  suggestedLength
                } = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }
                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                if (this._isRangeSupported) {
                  this._manager.abortRequest(fullRequestXhrId);
                }
                this._headersReceivedCapability.resolve();
              }
              _onDone(args) {
                if (args) {
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: args.chunk,
                      done: false
                    });
                  } else {
                    this._cachedChunks.push(args.chunk);
                  }
                }
                this._done = true;
                if (this._cachedChunks.length > 0) {
                  return;
                }
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              _onError(status) {
                const url = this._url;
                const exception = (0, _network_utils.createResponseStatusError)(status, url);
                this._storedError = exception;
                this._headersReceivedCapability.reject(exception);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.reject(exception);
                });
                this._requests = [];
                this._cachedChunks = [];
              }
              _onProgress(data) {
                if (this.onProgress) {
                  this.onProgress({
                    loaded: data.loaded,
                    total: data.lengthComputable ? data.total : this._contentLength
                  });
                }
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get contentLength() {
                return this._contentLength;
              }
              get headersReady() {
                return this._headersReceivedCapability.promise;
              }
              async read() {
                if (this._storedError) {
                  throw this._storedError;
                }
                if (this._cachedChunks.length > 0) {
                  const chunk = this._cachedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._headersReceivedCapability.reject(reason);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }
                this._fullRequestReader = null;
              }
            }
            class PDFNetworkStreamRangeRequestReader {
              constructor(manager, begin, end) {
                this._manager = manager;
                const args = {
                  onDone: this._onDone.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._requestId = manager.requestRange(begin, end, args);
                this._requests = [];
                this._queuedChunk = null;
                this._done = false;
                this.onProgress = null;
                this.onClosed = null;
              }
              _close() {
                if (this.onClosed) {
                  this.onClosed(this);
                }
              }
              _onDone(data) {
                const chunk = data.chunk;
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._close();
              }
              _onProgress(evt) {
                if (!this.isStreamingSupported && this.onProgress) {
                  this.onProgress({
                    loaded: evt.loaded
                  });
                }
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._queuedChunk !== null) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }
                this._close();
              }
            }
          },
          /* 23 */
          /***/
          function(module2, exports2, __w_pdfjs_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFetchStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController && abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            function createHeaders(httpHeaders) {
              const headers = new Headers();
              for (const property in httpHeaders) {
                const value = httpHeaders[property];
                if (typeof value === "undefined") {
                  continue;
                }
                headers.append(property, value);
              }
              return headers;
            }
            class PDFFetchStream {
              constructor(source) {
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFFetchStreamReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFFetchStreamRangeReader(this, begin, end);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFFetchStream = PDFFetchStream;
            class PDFFetchStreamReader {
              constructor(stream) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._contentLength = source.length;
                this._headersCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = createHeaders(this._stream.httpHeaders);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._reader = response.body.getReader();
                  this._headersCapability.resolve();
                  const getResponseHeader = (name) => {
                    return response.headers.get(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this.cancel(new _util2.AbortException("Streaming is disabled."));
                  }
                }).catch(this._headersCapability.reject);
                this.onProgress = null;
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._headersCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }
                const buffer = new Uint8Array(value).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
            class PDFFetchStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._isStreamingSupported = !source.disableStream;
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._headers = createHeaders(this._stream.httpHeaders);
                this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._readCapability.resolve();
                  this._reader = response.body.getReader();
                });
                this.onProgress = null;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }
                const buffer = new Uint8Array(value).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
    }
    module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime8() {
      "use strict";
      module2.exports = _regeneratorRuntime8 = function _regeneratorRuntime9() {
        return exports3;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var exports3 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports3.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              for (; ++i2 < iterable.length; )
                if (hasOwn.call(iterable, i2))
                  return next2.value = iterable[i2], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports3.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports3.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports3.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports3.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports3;
    }
    module2.exports = _regeneratorRuntime8, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    var runtime = require_regeneratorRuntime()();
    module2.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/make-event-props/dist/esm/index.js
function makeEventProps(props, getArgs) {
  var eventProps2 = {};
  allEvents.forEach(function(eventName) {
    var eventHandler = props[eventName];
    if (!eventHandler) {
      return;
    }
    if (!getArgs) {
      eventProps2[eventName] = eventHandler;
      return;
    }
    eventProps2[eventName] = function(event) {
      return eventHandler(event, getArgs(eventName));
    };
  });
  return eventProps2;
}
var __spreadArray, clipboardEvents, compositionEvents, keyboardEvents, focusEvents, formEvents, genericEvents, mouseEvents, pointerEvents, selectionEvents, touchEvents, uiEvents, wheelEvents, mediaEvents, imageEvents, animationEvents, transitionEvents, otherEvents, allEvents;
var init_esm = __esm({
  "node_modules/make-event-props/dist/esm/index.js"() {
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    clipboardEvents = ["onCopy", "onCut", "onPaste"];
    compositionEvents = [
      "onCompositionEnd",
      "onCompositionStart",
      "onCompositionUpdate"
    ];
    keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"];
    focusEvents = ["onFocus", "onBlur"];
    formEvents = ["onChange", "onInput", "onInvalid", "onReset", "onSubmit"];
    genericEvents = ["onError", "onLoad"];
    mouseEvents = [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp"
    ];
    pointerEvents = [
      "onPointerDown",
      "onPointerMove",
      "onPointerUp",
      "onPointerCancel",
      "onGotPointerCapture",
      "onLostPointerCapture",
      "onPointerEnter",
      "onPointerLeave",
      "onPointerOver",
      "onPointerOut"
    ];
    selectionEvents = ["onSelect"];
    touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"];
    uiEvents = ["onScroll"];
    wheelEvents = ["onWheel"];
    mediaEvents = [
      "onAbort",
      "onCanPlay",
      "onCanPlayThrough",
      "onDurationChange",
      "onEmptied",
      "onEncrypted",
      "onEnded",
      "onError",
      "onLoadedData",
      "onLoadedMetadata",
      "onLoadStart",
      "onPause",
      "onPlay",
      "onPlaying",
      "onProgress",
      "onRateChange",
      "onSeeked",
      "onSeeking",
      "onStalled",
      "onSuspend",
      "onTimeUpdate",
      "onVolumeChange",
      "onWaiting"
    ];
    imageEvents = ["onLoad", "onError"];
    animationEvents = [
      "onAnimationStart",
      "onAnimationEnd",
      "onAnimationIteration"
    ];
    transitionEvents = ["onTransitionEnd"];
    otherEvents = ["onToggle"];
    allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, true), compositionEvents, true), keyboardEvents, true), focusEvents, true), formEvents, true), genericEvents, true), mouseEvents, true), pointerEvents, true), selectionEvents, true), touchEvents, true), uiEvents, true), wheelEvents, true), mediaEvents, true), imageEvents, true), animationEvents, true), transitionEvents, true), otherEvents, true);
  }
});

// node_modules/make-cancellable-promise/dist/esm/index.js
function makeCancellablePromise(promise) {
  var isCancelled = false;
  var wrappedPromise = new Promise(function(resolve, reject) {
    promise.then(function(value) {
      return !isCancelled && resolve(value);
    }).catch(function(error) {
      return !isCancelled && reject(error);
    });
  });
  return {
    promise: wrappedPromise,
    cancel: function() {
      isCancelled = true;
    }
  };
}
var init_esm2 = __esm({
  "node_modules/make-cancellable-promise/dist/esm/index.js"() {
  }
});

// node_modules/merge-class-names/dist/esm/index.js
function mergeClassNames() {
  return Array.prototype.slice.call(arguments).reduce(function(classList, arg) {
    return classList.concat(arg);
  }, []).filter(function(arg) {
    return typeof arg === "string";
  }).join(" ");
}
var init_esm3 = __esm({
  "node_modules/merge-class-names/dist/esm/index.js"() {
  }
});

// node_modules/react-pdf/dist/esm/DocumentContext.js
var import_react2, DocumentContext_default;
var init_DocumentContext = __esm({
  "node_modules/react-pdf/dist/esm/DocumentContext.js"() {
    import_react2 = __toESM(require_react());
    DocumentContext_default = (0, import_react2.createContext)(null);
  }
});

// node_modules/react-pdf/dist/esm/Message.js
function Message(_ref) {
  var children = _ref.children, type = _ref.type;
  return import_react3.default.createElement("div", {
    className: "react-pdf__message react-pdf__message--".concat(type)
  }, children);
}
var import_react3, import_prop_types;
var init_Message = __esm({
  "node_modules/react-pdf/dist/esm/Message.js"() {
    import_react3 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    Message.propTypes = {
      children: import_prop_types.default.node,
      type: import_prop_types.default.oneOf(["error", "loading", "no-data"]).isRequired
    };
  }
});

// node_modules/pdfjs-dist/lib/web/ui_utils.js
var require_ui_utils = __commonJS({
  "node_modules/pdfjs-dist/lib/web/ui_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isValidRotation = isValidRotation;
    exports2.isValidScrollMode = isValidScrollMode;
    exports2.isValidSpreadMode = isValidSpreadMode;
    exports2.isPortraitOrientation = isPortraitOrientation;
    exports2.getGlobalEventBus = getGlobalEventBus;
    exports2.clamp = clamp;
    exports2.getPDFFileNameFromURL = getPDFFileNameFromURL;
    exports2.noContextMenuHandler = noContextMenuHandler;
    exports2.parseQueryString = parseQueryString;
    exports2.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
    exports2.getVisibleElements = getVisibleElements;
    exports2.roundToDivide = roundToDivide;
    exports2.getPageSizeInches = getPageSizeInches;
    exports2.approximateFraction = approximateFraction;
    exports2.getOutputScale = getOutputScale;
    exports2.scrollIntoView = scrollIntoView;
    exports2.watchScroll = watchScroll;
    exports2.binarySearchFirstItem = binarySearchFirstItem;
    exports2.normalizeWheelEventDelta = normalizeWheelEventDelta;
    exports2.waitOnEventOrTimeout = waitOnEventOrTimeout;
    exports2.moveToEndOfArray = moveToEndOfArray;
    exports2.WaitOnType = exports2.animationStarted = exports2.ProgressBar = exports2.EventBus = exports2.NullL10n = exports2.SpreadMode = exports2.ScrollMode = exports2.TextLayerMode = exports2.RendererType = exports2.PresentationModeState = exports2.VERTICAL_PADDING = exports2.SCROLLBAR_PADDING = exports2.MAX_AUTO_SCALE = exports2.UNKNOWN_SCALE = exports2.MAX_SCALE = exports2.MIN_SCALE = exports2.DEFAULT_SCALE = exports2.DEFAULT_SCALE_VALUE = exports2.CSS_UNITS = exports2.AutoPrintRegExp = void 0;
    var CSS_UNITS = 96 / 72;
    exports2.CSS_UNITS = CSS_UNITS;
    var DEFAULT_SCALE_VALUE = "auto";
    exports2.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
    var DEFAULT_SCALE = 1;
    exports2.DEFAULT_SCALE = DEFAULT_SCALE;
    var MIN_SCALE = 0.1;
    exports2.MIN_SCALE = MIN_SCALE;
    var MAX_SCALE = 10;
    exports2.MAX_SCALE = MAX_SCALE;
    var UNKNOWN_SCALE = 0;
    exports2.UNKNOWN_SCALE = UNKNOWN_SCALE;
    var MAX_AUTO_SCALE = 1.25;
    exports2.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
    var SCROLLBAR_PADDING = 40;
    exports2.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
    var VERTICAL_PADDING = 5;
    exports2.VERTICAL_PADDING = VERTICAL_PADDING;
    var PresentationModeState = {
      UNKNOWN: 0,
      NORMAL: 1,
      CHANGING: 2,
      FULLSCREEN: 3
    };
    exports2.PresentationModeState = PresentationModeState;
    var RendererType = {
      CANVAS: "canvas",
      SVG: "svg"
    };
    exports2.RendererType = RendererType;
    var TextLayerMode = {
      DISABLE: 0,
      ENABLE: 1,
      ENABLE_ENHANCE: 2
    };
    exports2.TextLayerMode = TextLayerMode;
    var ScrollMode = {
      UNKNOWN: -1,
      VERTICAL: 0,
      HORIZONTAL: 1,
      WRAPPED: 2
    };
    exports2.ScrollMode = ScrollMode;
    var SpreadMode = {
      UNKNOWN: -1,
      NONE: 0,
      ODD: 1,
      EVEN: 2
    };
    exports2.SpreadMode = SpreadMode;
    var AutoPrintRegExp = /\bprint\s*\(/;
    exports2.AutoPrintRegExp = AutoPrintRegExp;
    function formatL10nValue(text, args) {
      if (!args) {
        return text;
      }
      return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
        return name in args ? args[name] : "{{" + name + "}}";
      });
    }
    var NullL10n = {
      async getLanguage() {
        return "en-us";
      },
      async getDirection() {
        return "ltr";
      },
      async get(property, args, fallback) {
        return formatL10nValue(fallback, args);
      },
      async translate(element) {
      }
    };
    exports2.NullL10n = NullL10n;
    function getOutputScale(ctx) {
      const devicePixelRatio = window.devicePixelRatio || 1;
      const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
      const pixelRatio = devicePixelRatio / backingStoreRatio;
      return {
        sx: pixelRatio,
        sy: pixelRatio,
        scaled: pixelRatio !== 1
      };
    }
    function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {
      let parent = element.offsetParent;
      if (!parent) {
        console.error("offsetParent is not set -- cannot scroll");
        return;
      }
      let offsetY = element.offsetTop + element.clientTop;
      let offsetX = element.offsetLeft + element.clientLeft;
      while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") {
        if (parent.dataset._scaleY) {
          offsetY /= parent.dataset._scaleY;
          offsetX /= parent.dataset._scaleX;
        }
        offsetY += parent.offsetTop;
        offsetX += parent.offsetLeft;
        parent = parent.offsetParent;
        if (!parent) {
          return;
        }
      }
      if (spot) {
        if (spot.top !== void 0) {
          offsetY += spot.top;
        }
        if (spot.left !== void 0) {
          offsetX += spot.left;
          parent.scrollLeft = offsetX;
        }
      }
      parent.scrollTop = offsetY;
    }
    function watchScroll(viewAreaElement, callback) {
      const debounceScroll = function(evt) {
        if (rAF) {
          return;
        }
        rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
          rAF = null;
          const currentX = viewAreaElement.scrollLeft;
          const lastX = state.lastX;
          if (currentX !== lastX) {
            state.right = currentX > lastX;
          }
          state.lastX = currentX;
          const currentY = viewAreaElement.scrollTop;
          const lastY = state.lastY;
          if (currentY !== lastY) {
            state.down = currentY > lastY;
          }
          state.lastY = currentY;
          callback(state);
        });
      };
      const state = {
        right: true,
        down: true,
        lastX: viewAreaElement.scrollLeft,
        lastY: viewAreaElement.scrollTop,
        _eventHandler: debounceScroll
      };
      let rAF = null;
      viewAreaElement.addEventListener("scroll", debounceScroll, true);
      return state;
    }
    function parseQueryString(query) {
      const parts = query.split("&");
      const params = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0, ii = parts.length; i2 < ii; ++i2) {
        const param = parts[i2].split("=");
        const key = param[0].toLowerCase();
        const value = param.length > 1 ? param[1] : null;
        params[decodeURIComponent(key)] = decodeURIComponent(value);
      }
      return params;
    }
    function binarySearchFirstItem(items, condition) {
      let minIndex = 0;
      let maxIndex = items.length - 1;
      if (items.length === 0 || !condition(items[maxIndex])) {
        return items.length;
      }
      if (condition(items[minIndex])) {
        return minIndex;
      }
      while (minIndex < maxIndex) {
        const currentIndex = minIndex + maxIndex >> 1;
        const currentItem = items[currentIndex];
        if (condition(currentItem)) {
          maxIndex = currentIndex;
        } else {
          minIndex = currentIndex + 1;
        }
      }
      return minIndex;
    }
    function approximateFraction(x2) {
      if (Math.floor(x2) === x2) {
        return [x2, 1];
      }
      const xinv = 1 / x2;
      const limit = 8;
      if (xinv > limit) {
        return [1, limit];
      } else if (Math.floor(xinv) === xinv) {
        return [1, xinv];
      }
      const x_ = x2 > 1 ? xinv : x2;
      let a2 = 0, b2 = 1, c2 = 1, d2 = 1;
      while (true) {
        const p = a2 + c2, q2 = b2 + d2;
        if (q2 > limit) {
          break;
        }
        if (x_ <= p / q2) {
          c2 = p;
          d2 = q2;
        } else {
          a2 = p;
          b2 = q2;
        }
      }
      let result;
      if (x_ - a2 / b2 < c2 / d2 - x_) {
        result = x_ === x2 ? [a2, b2] : [b2, a2];
      } else {
        result = x_ === x2 ? [c2, d2] : [d2, c2];
      }
      return result;
    }
    function roundToDivide(x2, div) {
      const r2 = x2 % div;
      return r2 === 0 ? x2 : Math.round(x2 - r2 + div);
    }
    function getPageSizeInches({
      view,
      userUnit,
      rotate
    }) {
      const [x1, y1, x2, y2] = view;
      const changeOrientation = rotate % 180 !== 0;
      const width = (x2 - x1) / 72 * userUnit;
      const height = (y2 - y1) / 72 * userUnit;
      return {
        width: changeOrientation ? height : width,
        height: changeOrientation ? width : height
      };
    }
    function backtrackBeforeAllVisibleElements(index, views, top) {
      if (index < 2) {
        return index;
      }
      let elt = views[index].div;
      let pageTop = elt.offsetTop + elt.clientTop;
      if (pageTop >= top) {
        elt = views[index - 1].div;
        pageTop = elt.offsetTop + elt.clientTop;
      }
      for (let i2 = index - 2; i2 >= 0; --i2) {
        elt = views[i2].div;
        if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
          break;
        }
        index = i2;
      }
      return index;
    }
    function getVisibleElements(scrollEl, views, sortByVisibility = false, horizontal = false) {
      const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
      const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
      function isElementBottomAfterViewTop(view) {
        const element = view.div;
        const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
        return elementBottom > top;
      }
      function isElementRightAfterViewLeft(view) {
        const element = view.div;
        const elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
        return elementRight > left;
      }
      const visible = [], numViews = views.length;
      let firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);
      if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
        firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
      }
      let lastEdge = horizontal ? right : -1;
      for (let i2 = firstVisibleElementInd; i2 < numViews; i2++) {
        const view = views[i2], element = view.div;
        const currentWidth = element.offsetLeft + element.clientLeft;
        const currentHeight = element.offsetTop + element.clientTop;
        const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
        const viewRight = currentWidth + viewWidth;
        const viewBottom = currentHeight + viewHeight;
        if (lastEdge === -1) {
          if (viewBottom >= bottom) {
            lastEdge = viewBottom;
          }
        } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
          break;
        }
        if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
          continue;
        }
        const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
        const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
        const percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
        visible.push({
          id: view.id,
          x: currentWidth,
          y: currentHeight,
          view,
          percent
        });
      }
      const first = visible[0], last = visible[visible.length - 1];
      if (sortByVisibility) {
        visible.sort(function(a2, b2) {
          const pc = a2.percent - b2.percent;
          if (Math.abs(pc) > 1e-3) {
            return -pc;
          }
          return a2.id - b2.id;
        });
      }
      return {
        first,
        last,
        views: visible
      };
    }
    function noContextMenuHandler(evt) {
      evt.preventDefault();
    }
    function isDataSchema(url) {
      let i2 = 0;
      const ii = url.length;
      while (i2 < ii && url[i2].trim() === "") {
        i2++;
      }
      return url.substring(i2, i2 + 5).toLowerCase() === "data:";
    }
    function getPDFFileNameFromURL(url, defaultFilename = "document.pdf") {
      if (typeof url !== "string") {
        return defaultFilename;
      }
      if (isDataSchema(url)) {
        console.warn('getPDFFileNameFromURL: ignoring "data:" URL for performance reasons.');
        return defaultFilename;
      }
      const reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
      const reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
      const splitURI = reURI.exec(url);
      let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
      if (suggestedFilename) {
        suggestedFilename = suggestedFilename[0];
        if (suggestedFilename.includes("%")) {
          try {
            suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
          } catch (ex) {
          }
        }
      }
      return suggestedFilename || defaultFilename;
    }
    function normalizeWheelEventDelta(evt) {
      let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
      const angle = Math.atan2(evt.deltaY, evt.deltaX);
      if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
        delta = -delta;
      }
      const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
      const MOUSE_DOM_DELTA_LINE_MODE = 1;
      const MOUSE_PIXELS_PER_LINE = 30;
      const MOUSE_LINES_PER_PAGE = 30;
      if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
        delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
      } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
        delta /= MOUSE_LINES_PER_PAGE;
      }
      return delta;
    }
    function isValidRotation(angle) {
      return Number.isInteger(angle) && angle % 90 === 0;
    }
    function isValidScrollMode(mode) {
      return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
    }
    function isValidSpreadMode(mode) {
      return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
    }
    function isPortraitOrientation(size) {
      return size.width <= size.height;
    }
    var WaitOnType = {
      EVENT: "event",
      TIMEOUT: "timeout"
    };
    exports2.WaitOnType = WaitOnType;
    function waitOnEventOrTimeout({
      target,
      name,
      delay = 0
    }) {
      return new Promise(function(resolve, reject) {
        if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
          throw new Error("waitOnEventOrTimeout - invalid parameters.");
        }
        function handler(type) {
          if (target instanceof EventBus2) {
            target._off(name, eventHandler);
          } else {
            target.removeEventListener(name, eventHandler);
          }
          if (timeout) {
            clearTimeout(timeout);
          }
          resolve(type);
        }
        const eventHandler = handler.bind(null, WaitOnType.EVENT);
        if (target instanceof EventBus2) {
          target._on(name, eventHandler);
        } else {
          target.addEventListener(name, eventHandler);
        }
        const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
        const timeout = setTimeout(timeoutHandler, delay);
      });
    }
    var animationStarted = new Promise(function(resolve) {
      window.requestAnimationFrame(resolve);
    });
    exports2.animationStarted = animationStarted;
    function dispatchDOMEvent(eventName, args = null) {
      const details = /* @__PURE__ */ Object.create(null);
      if (args && args.length > 0) {
        const obj = args[0];
        for (const key in obj) {
          const value = obj[key];
          if (key === "source") {
            if (value === window || value === document) {
              return;
            }
            continue;
          }
          details[key] = value;
        }
      }
      const event = document.createEvent("CustomEvent");
      event.initCustomEvent(eventName, true, true, details);
      document.dispatchEvent(event);
    }
    var EventBus2 = class {
      constructor({
        dispatchToDOM = false
      } = {}) {
        this._listeners = /* @__PURE__ */ Object.create(null);
        this._dispatchToDOM = dispatchToDOM === true;
        if (dispatchToDOM) {
          console.error("The `eventBusDispatchToDOM` option/preference is deprecated, add event listeners to the EventBus instance rather than the DOM.");
        }
      }
      on(eventName, listener) {
        this._on(eventName, listener, {
          external: true
        });
      }
      off(eventName, listener) {
        this._off(eventName, listener, {
          external: true
        });
      }
      dispatch(eventName) {
        const eventListeners = this._listeners[eventName];
        if (!eventListeners || eventListeners.length === 0) {
          if (this._dispatchToDOM) {
            const args2 = Array.prototype.slice.call(arguments, 1);
            dispatchDOMEvent(eventName, args2);
          }
          return;
        }
        const args = Array.prototype.slice.call(arguments, 1);
        let externalListeners;
        eventListeners.slice(0).forEach(function({
          listener,
          external
        }) {
          if (external) {
            if (!externalListeners) {
              externalListeners = [];
            }
            externalListeners.push(listener);
            return;
          }
          listener.apply(null, args);
        });
        if (externalListeners) {
          externalListeners.forEach(function(listener) {
            listener.apply(null, args);
          });
          externalListeners = null;
        }
        if (this._dispatchToDOM) {
          dispatchDOMEvent(eventName, args);
        }
      }
      _on(eventName, listener, options = null) {
        let eventListeners = this._listeners[eventName];
        if (!eventListeners) {
          this._listeners[eventName] = eventListeners = [];
        }
        eventListeners.push({
          listener,
          external: (options && options.external) === true
        });
      }
      _off(eventName, listener, options = null) {
        const eventListeners = this._listeners[eventName];
        if (!eventListeners) {
          return;
        }
        for (let i2 = 0, ii = eventListeners.length; i2 < ii; i2++) {
          if (eventListeners[i2].listener === listener) {
            eventListeners.splice(i2, 1);
            return;
          }
        }
      }
    };
    exports2.EventBus = EventBus2;
    var globalEventBus = null;
    function getGlobalEventBus(dispatchToDOM = false) {
      console.error("getGlobalEventBus is deprecated, use a manually created EventBus instance instead.");
      if (!globalEventBus) {
        globalEventBus = new EventBus2({
          dispatchToDOM
        });
      }
      return globalEventBus;
    }
    function clamp(v2, min, max) {
      return Math.min(Math.max(v2, min), max);
    }
    var ProgressBar = class {
      constructor(id, {
        height,
        width,
        units
      } = {}) {
        this.visible = true;
        this.div = document.querySelector(id + " .progress");
        this.bar = this.div.parentNode;
        this.height = height || 100;
        this.width = width || 100;
        this.units = units || "%";
        this.div.style.height = this.height + this.units;
        this.percent = 0;
      }
      _updateBar() {
        if (this._indeterminate) {
          this.div.classList.add("indeterminate");
          this.div.style.width = this.width + this.units;
          return;
        }
        this.div.classList.remove("indeterminate");
        const progressSize = this.width * this._percent / 100;
        this.div.style.width = progressSize + this.units;
      }
      get percent() {
        return this._percent;
      }
      set percent(val) {
        this._indeterminate = isNaN(val);
        this._percent = clamp(val, 0, 100);
        this._updateBar();
      }
      setWidth(viewer) {
        if (!viewer) {
          return;
        }
        const container = viewer.parentNode;
        const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
        if (scrollbarWidth > 0) {
          this.bar.style.width = `calc(100% - ${scrollbarWidth}px)`;
        }
      }
      hide() {
        if (!this.visible) {
          return;
        }
        this.visible = false;
        this.bar.classList.add("hidden");
        document.body.classList.remove("loadingInProgress");
      }
      show() {
        if (this.visible) {
          return;
        }
        this.visible = true;
        document.body.classList.add("loadingInProgress");
        this.bar.classList.remove("hidden");
      }
    };
    exports2.ProgressBar = ProgressBar;
    function moveToEndOfArray(arr, condition) {
      const moved = [], len = arr.length;
      let write = 0;
      for (let read = 0; read < len; ++read) {
        if (condition(arr[read])) {
          moved.push(arr[read]);
        } else {
          arr[write] = arr[read];
          ++write;
        }
      }
      for (let read = 0; write < len; ++read, ++write) {
        arr[write] = moved[read];
      }
    }
  }
});

// node_modules/pdfjs-dist/lib/web/pdf_link_service.js
var require_pdf_link_service = __commonJS({
  "node_modules/pdfjs-dist/lib/web/pdf_link_service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SimpleLinkService = exports2.PDFLinkService = void 0;
    var _ui_utils = require_ui_utils();
    var PDFLinkService2 = class {
      constructor({
        eventBus,
        externalLinkTarget = null,
        externalLinkRel = null,
        externalLinkEnabled = true,
        ignoreDestinationZoom = false
      } = {}) {
        this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
        this.externalLinkTarget = externalLinkTarget;
        this.externalLinkRel = externalLinkRel;
        this.externalLinkEnabled = externalLinkEnabled;
        this._ignoreDestinationZoom = ignoreDestinationZoom;
        this.baseUrl = null;
        this.pdfDocument = null;
        this.pdfViewer = null;
        this.pdfHistory = null;
        this._pagesRefCache = null;
      }
      setDocument(pdfDocument, baseUrl = null) {
        this.baseUrl = baseUrl;
        this.pdfDocument = pdfDocument;
        this._pagesRefCache = /* @__PURE__ */ Object.create(null);
      }
      setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
      }
      setHistory(pdfHistory) {
        this.pdfHistory = pdfHistory;
      }
      get pagesCount() {
        return this.pdfDocument ? this.pdfDocument.numPages : 0;
      }
      get page() {
        return this.pdfViewer.currentPageNumber;
      }
      set page(value) {
        this.pdfViewer.currentPageNumber = value;
      }
      get rotation() {
        return this.pdfViewer.pagesRotation;
      }
      set rotation(value) {
        this.pdfViewer.pagesRotation = value;
      }
      navigateTo(dest) {
        const goToDestination = ({
          namedDest,
          explicitDest
        }) => {
          const destRef = explicitDest[0];
          let pageNumber;
          if (destRef instanceof Object) {
            pageNumber = this._cachedPageNumber(destRef);
            if (pageNumber === null) {
              this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
                this.cachePageRef(pageIndex + 1, destRef);
                goToDestination({
                  namedDest,
                  explicitDest
                });
              }).catch(() => {
                console.error(`PDFLinkService.navigateTo: "${destRef}" is not a valid page reference, for dest="${dest}".`);
              });
              return;
            }
          } else if (Number.isInteger(destRef)) {
            pageNumber = destRef + 1;
          } else {
            console.error(`PDFLinkService.navigateTo: "${destRef}" is not a valid destination reference, for dest="${dest}".`);
            return;
          }
          if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
            console.error(`PDFLinkService.navigateTo: "${pageNumber}" is not a valid page number, for dest="${dest}".`);
            return;
          }
          if (this.pdfHistory) {
            this.pdfHistory.pushCurrentPosition();
            this.pdfHistory.push({
              namedDest,
              explicitDest,
              pageNumber
            });
          }
          this.pdfViewer.scrollPageIntoView({
            pageNumber,
            destArray: explicitDest,
            ignoreDestinationZoom: this._ignoreDestinationZoom
          });
        };
        new Promise((resolve, reject) => {
          if (typeof dest === "string") {
            this.pdfDocument.getDestination(dest).then((destArray) => {
              resolve({
                namedDest: dest,
                explicitDest: destArray
              });
            });
            return;
          }
          resolve({
            namedDest: "",
            explicitDest: dest
          });
        }).then((data) => {
          if (!Array.isArray(data.explicitDest)) {
            console.error(`PDFLinkService.navigateTo: "${data.explicitDest}" is not a valid destination array, for dest="${dest}".`);
            return;
          }
          goToDestination(data);
        });
      }
      getDestinationHash(dest) {
        if (typeof dest === "string") {
          return this.getAnchorUrl("#" + escape(dest));
        }
        if (Array.isArray(dest)) {
          const str = JSON.stringify(dest);
          return this.getAnchorUrl("#" + escape(str));
        }
        return this.getAnchorUrl("");
      }
      getAnchorUrl(anchor) {
        return (this.baseUrl || "") + anchor;
      }
      setHash(hash) {
        let pageNumber, dest;
        if (hash.includes("=")) {
          const params = (0, _ui_utils.parseQueryString)(hash);
          if ("search" in params) {
            this.eventBus.dispatch("findfromurlhash", {
              source: this,
              query: params["search"].replace(/"/g, ""),
              phraseSearch: params["phrase"] === "true"
            });
          }
          if ("nameddest" in params) {
            this.navigateTo(params.nameddest);
            return;
          }
          if ("page" in params) {
            pageNumber = params.page | 0 || 1;
          }
          if ("zoom" in params) {
            const zoomArgs = params.zoom.split(",");
            const zoomArg = zoomArgs[0];
            const zoomArgNumber = parseFloat(zoomArg);
            if (!zoomArg.includes("Fit")) {
              dest = [null, {
                name: "XYZ"
              }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
            } else {
              if (zoomArg === "Fit" || zoomArg === "FitB") {
                dest = [null, {
                  name: zoomArg
                }];
              } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                dest = [null, {
                  name: zoomArg
                }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
              } else if (zoomArg === "FitR") {
                if (zoomArgs.length !== 5) {
                  console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                } else {
                  dest = [null, {
                    name: zoomArg
                  }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                }
              } else {
                console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
              }
            }
          }
          if (dest) {
            this.pdfViewer.scrollPageIntoView({
              pageNumber: pageNumber || this.page,
              destArray: dest,
              allowNegativeOffset: true
            });
          } else if (pageNumber) {
            this.page = pageNumber;
          }
          if ("pagemode" in params) {
            this.eventBus.dispatch("pagemode", {
              source: this,
              mode: params.pagemode
            });
          }
        } else {
          dest = unescape(hash);
          try {
            dest = JSON.parse(dest);
            if (!Array.isArray(dest)) {
              dest = dest.toString();
            }
          } catch (ex) {
          }
          if (typeof dest === "string" || isValidExplicitDestination(dest)) {
            this.navigateTo(dest);
            return;
          }
          console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
        }
      }
      executeNamedAction(action) {
        switch (action) {
          case "GoBack":
            if (this.pdfHistory) {
              this.pdfHistory.back();
            }
            break;
          case "GoForward":
            if (this.pdfHistory) {
              this.pdfHistory.forward();
            }
            break;
          case "NextPage":
            if (this.page < this.pagesCount) {
              this.page++;
            }
            break;
          case "PrevPage":
            if (this.page > 1) {
              this.page--;
            }
            break;
          case "LastPage":
            this.page = this.pagesCount;
            break;
          case "FirstPage":
            this.page = 1;
            break;
          default:
            break;
        }
        this.eventBus.dispatch("namedaction", {
          source: this,
          action
        });
      }
      cachePageRef(pageNum, pageRef) {
        if (!pageRef) {
          return;
        }
        const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
        this._pagesRefCache[refStr] = pageNum;
      }
      _cachedPageNumber(pageRef) {
        const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
        return this._pagesRefCache && this._pagesRefCache[refStr] || null;
      }
      isPageVisible(pageNumber) {
        return this.pdfViewer.isPageVisible(pageNumber);
      }
    };
    exports2.PDFLinkService = PDFLinkService2;
    function isValidExplicitDestination(dest) {
      if (!Array.isArray(dest)) {
        return false;
      }
      const destLength = dest.length;
      if (destLength < 2) {
        return false;
      }
      const page = dest[0];
      if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
        return false;
      }
      const zoom = dest[1];
      if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
        return false;
      }
      let allowNull = true;
      switch (zoom.name) {
        case "XYZ":
          if (destLength !== 5) {
            return false;
          }
          break;
        case "Fit":
        case "FitB":
          return destLength === 2;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
          if (destLength !== 3) {
            return false;
          }
          break;
        case "FitR":
          if (destLength !== 6) {
            return false;
          }
          allowNull = false;
          break;
        default:
          return false;
      }
      for (let i2 = 2; i2 < destLength; i2++) {
        const param = dest[i2];
        if (!(typeof param === "number" || allowNull && param === null)) {
          return false;
        }
      }
      return true;
    }
    var SimpleLinkService = class {
      constructor() {
        this.externalLinkTarget = null;
        this.externalLinkRel = null;
        this.externalLinkEnabled = true;
        this._ignoreDestinationZoom = false;
      }
      get pagesCount() {
        return 0;
      }
      get page() {
        return 0;
      }
      set page(value) {
      }
      get rotation() {
        return 0;
      }
      set rotation(value) {
      }
      navigateTo(dest) {
      }
      getDestinationHash(dest) {
        return "#";
      }
      getAnchorUrl(hash) {
        return "#";
      }
      setHash(hash) {
      }
      executeNamedAction(action) {
      }
      cachePageRef(pageNum, pageRef) {
      }
      isPageVisible(pageNumber) {
        return true;
      }
    };
    exports2.SimpleLinkService = SimpleLinkService;
  }
});

// node_modules/react-pdf/dist/esm/LinkService.js
var import_pdf_link_service, LinkService_default;
var init_LinkService = __esm({
  "node_modules/react-pdf/dist/esm/LinkService.js"() {
    import_pdf_link_service = __toESM(require_pdf_link_service());
    LinkService_default = import_pdf_link_service.PDFLinkService;
  }
});

// node_modules/react-pdf/dist/esm/PasswordResponses.js
var PasswordResponses, PasswordResponses_default;
var init_PasswordResponses = __esm({
  "node_modules/react-pdf/dist/esm/PasswordResponses.js"() {
    PasswordResponses = {
      NEED_PASSWORD: 1,
      INCORRECT_PASSWORD: 2
    };
    PasswordResponses_default = PasswordResponses;
  }
});

// node_modules/react-pdf/dist/esm/eventBus.js
var import_ui_utils, eventBus_default;
var init_eventBus = __esm({
  "node_modules/react-pdf/dist/esm/eventBus.js"() {
    import_ui_utils = __toESM(require_ui_utils());
    eventBus_default = new import_ui_utils.EventBus();
  }
});

// node_modules/react-pdf/dist/esm/shared/utils.js
var isBrowser, isLocalFileSystem, isProduction, isDefined, isProvided, isString, isArrayBuffer, isBlob, isFile, isDataURI, dataURItoUint8Array, getPixelRatio, consoleOnDev, warnOnDev, errorOnDev, displayCORSWarning, cancelRunningTask, makePageCallback, isCancelException, loadFromFile;
var init_utils = __esm({
  "node_modules/react-pdf/dist/esm/shared/utils.js"() {
    isBrowser = typeof window !== "undefined";
    isLocalFileSystem = isBrowser && window.location.protocol === "file:";
    isProduction = false;
    isDefined = function isDefined2(variable) {
      return typeof variable !== "undefined";
    };
    isProvided = function isProvided2(variable) {
      return isDefined(variable) && variable !== null;
    };
    isString = function isString2(variable) {
      return typeof variable === "string";
    };
    isArrayBuffer = function isArrayBuffer2(variable) {
      return variable instanceof ArrayBuffer;
    };
    isBlob = function isBlob2(variable) {
      if (!isBrowser) {
        throw new Error("Attempted to check if a variable is a Blob on a non-browser environment.");
      }
      return variable instanceof Blob;
    };
    isFile = function isFile2(variable) {
      if (!isBrowser) {
        throw new Error("Attempted to check if a variable is a File on a non-browser environment.");
      }
      return variable instanceof File;
    };
    isDataURI = function isDataURI2(str) {
      return isString(str) && /^data:/.test(str);
    };
    dataURItoUint8Array = function dataURItoUint8Array2(dataURI) {
      if (!isDataURI(dataURI)) {
        throw new Error("dataURItoUint8Array was provided with an argument which is not a valid data URI.");
      }
      var byteString;
      if (dataURI.split(",")[0].indexOf("base64") >= 0) {
        byteString = atob(dataURI.split(",")[1]);
      } else {
        byteString = unescape(dataURI.split(",")[1]);
      }
      var ia = new Uint8Array(byteString.length);
      for (var i2 = 0; i2 < byteString.length; i2 += 1) {
        ia[i2] = byteString.charCodeAt(i2);
      }
      return ia;
    };
    getPixelRatio = function getPixelRatio2() {
      return isBrowser && window.devicePixelRatio || 1;
    };
    consoleOnDev = function consoleOnDev2(method) {
      if (!isProduction) {
        var _console;
        for (var _len = arguments.length, message = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }
        (_console = console)[method].apply(_console, message);
      }
    };
    warnOnDev = function warnOnDev2() {
      for (var _len2 = arguments.length, message = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        message[_key2] = arguments[_key2];
      }
      return consoleOnDev.apply(void 0, ["warn"].concat(message));
    };
    errorOnDev = function errorOnDev2() {
      for (var _len3 = arguments.length, message = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        message[_key3] = arguments[_key3];
      }
      return consoleOnDev.apply(void 0, ["error"].concat(message));
    };
    displayCORSWarning = function displayCORSWarning2() {
      if (isLocalFileSystem) {
        warnOnDev("Loading PDF as base64 strings/URLs might not work on protocols other than HTTP/HTTPS. On Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.");
      }
    };
    cancelRunningTask = function cancelRunningTask2(runningTask) {
      if (runningTask && runningTask.cancel)
        runningTask.cancel();
    };
    makePageCallback = function makePageCallback2(page, scale) {
      Object.defineProperty(page, "width", {
        get: function get() {
          return this.view[2] * scale;
        },
        configurable: true
      });
      Object.defineProperty(page, "height", {
        get: function get() {
          return this.view[3] * scale;
        },
        configurable: true
      });
      Object.defineProperty(page, "originalWidth", {
        get: function get() {
          return this.view[2];
        },
        configurable: true
      });
      Object.defineProperty(page, "originalHeight", {
        get: function get() {
          return this.view[3];
        },
        configurable: true
      });
      return page;
    };
    isCancelException = function isCancelException2(error) {
      return error.name === "RenderingCancelledException";
    };
    loadFromFile = function loadFromFile2(file) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function() {
          return resolve(new Uint8Array(reader.result));
        };
        reader.onerror = function(event) {
          switch (event.target.error.code) {
            case event.target.error.NOT_FOUND_ERR:
              return reject(new Error("Error while reading a file: File not found."));
            case event.target.error.NOT_READABLE_ERR:
              return reject(new Error("Error while reading a file: File not readable."));
            case event.target.error.SECURITY_ERR:
              return reject(new Error("Error while reading a file: Security error."));
            case event.target.error.ABORT_ERR:
              return reject(new Error("Error while reading a file: Aborted."));
            default:
              return reject(new Error("Error while reading a file."));
          }
        };
        reader.readAsArrayBuffer(file);
        return null;
      });
    };
  }
});

// node_modules/react-pdf/dist/esm/shared/propTypes.js
var import_prop_types2, eventProps, fileTypes, isClassName, isFile3, isLinkService, isLinkTarget, isPage, isPageIndex, isPageNumber, isPdf, isRenderMode, isRotate;
var init_propTypes = __esm({
  "node_modules/react-pdf/dist/esm/shared/propTypes.js"() {
    init_typeof();
    init_toConsumableArray();
    import_prop_types2 = __toESM(require_prop_types());
    init_esm();
    init_utils();
    init_LinkService();
    eventProps = function() {
      var result = {};
      [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function(eventName) {
        result[eventName] = import_prop_types2.default.func;
      });
      return result;
    }();
    fileTypes = [import_prop_types2.default.string, import_prop_types2.default.instanceOf(ArrayBuffer), import_prop_types2.default.shape({
      data: import_prop_types2.default.object,
      httpHeaders: import_prop_types2.default.object,
      range: import_prop_types2.default.object,
      url: import_prop_types2.default.string,
      withCredentials: import_prop_types2.default.bool
    })];
    if (typeof File !== "undefined") {
      fileTypes.push(import_prop_types2.default.instanceOf(File));
    }
    if (typeof Blob !== "undefined") {
      fileTypes.push(import_prop_types2.default.instanceOf(Blob));
    }
    isClassName = import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]);
    isFile3 = import_prop_types2.default.oneOfType(fileTypes);
    isLinkService = import_prop_types2.default.instanceOf(LinkService_default);
    isLinkTarget = import_prop_types2.default.oneOf(["_self", "_blank", "_parent", "_top"]);
    isPage = import_prop_types2.default.shape({
      _transport: import_prop_types2.default.shape({
        fontLoader: import_prop_types2.default.object.isRequired
      }).isRequired,
      commonObjs: import_prop_types2.default.shape({
        _objs: import_prop_types2.default.object.isRequired
      }).isRequired,
      getAnnotations: import_prop_types2.default.func.isRequired,
      getTextContent: import_prop_types2.default.func.isRequired,
      getViewport: import_prop_types2.default.func.isRequired,
      render: import_prop_types2.default.func.isRequired
    });
    isPageIndex = function isPageIndex2(props, propName, componentName) {
      var pageIndex = props[propName], pageNumber = props.pageNumber, pdf = props.pdf;
      if (!isDefined(pdf)) {
        return null;
      }
      if (isDefined(pageIndex)) {
        if (typeof pageIndex !== "number") {
          return new Error("`".concat(propName, "` of type `").concat(_typeof(pageIndex), "` supplied to `").concat(componentName, "`, expected `number`."));
        }
        if (pageIndex < 0) {
          return new Error("Expected `".concat(propName, "` to be greater or equal to 0."));
        }
        var numPages = pdf.numPages;
        if (pageIndex + 1 > numPages) {
          return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages - 1, "."));
        }
      } else if (!isDefined(pageNumber)) {
        return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
      }
      return null;
    };
    isPageNumber = function isPageNumber2(props, propName, componentName) {
      var pageNumber = props[propName], pageIndex = props.pageIndex, pdf = props.pdf;
      if (!isDefined(pdf)) {
        return null;
      }
      if (isDefined(pageNumber)) {
        if (typeof pageNumber !== "number") {
          return new Error("`".concat(propName, "` of type `").concat(_typeof(pageNumber), "` supplied to `").concat(componentName, "`, expected `number`."));
        }
        if (pageNumber < 1) {
          return new Error("Expected `".concat(propName, "` to be greater or equal to 1."));
        }
        var numPages = pdf.numPages;
        if (pageNumber > numPages) {
          return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages, "."));
        }
      } else if (!isDefined(pageIndex)) {
        return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
      }
      return null;
    };
    isPdf = import_prop_types2.default.oneOfType([import_prop_types2.default.shape({
      getDestination: import_prop_types2.default.func.isRequired,
      getOutline: import_prop_types2.default.func.isRequired,
      getPage: import_prop_types2.default.func.isRequired,
      numPages: import_prop_types2.default.number.isRequired
    }), import_prop_types2.default.bool]);
    isRenderMode = import_prop_types2.default.oneOf(["canvas", "none", "svg"]);
    isRotate = import_prop_types2.default.oneOf([0, 90, 180, 270]);
  }
});

// node_modules/react-pdf/dist/esm/Document.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_regenerator, import_react4, import_prop_types3, import_pdf, PDFDataRangeTransport2, Document, isFunctionOrNode;
var init_Document = __esm({
  "node_modules/react-pdf/dist/esm/Document.js"() {
    init_extends();
    init_objectWithoutProperties();
    init_typeof();
    import_regenerator = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react4 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_esm();
    init_esm2();
    init_esm3();
    import_pdf = __toESM(require_pdf());
    init_DocumentContext();
    init_Message();
    init_LinkService();
    init_PasswordResponses();
    init_eventBus();
    init_utils();
    init_propTypes();
    PDFDataRangeTransport2 = import_pdf.default.PDFDataRangeTransport;
    Document = function(_PureComponent) {
      _inherits(Document2, _PureComponent);
      var _super = _createSuper(Document2);
      function Document2() {
        var _this;
        _classCallCheck(this, Document2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          pdf: null
        });
        _defineProperty(_assertThisInitialized(_this), "viewer", {
          scrollPageIntoView: function scrollPageIntoView(_ref) {
            var pageNumber = _ref.pageNumber;
            var onItemClick = _this.props.onItemClick;
            if (onItemClick) {
              onItemClick({
                pageNumber
              });
              return;
            }
            var page = _this.pages[pageNumber - 1];
            if (page) {
              page.scrollIntoView();
              return;
            }
            warnOnDev("Warning: An internal link leading to page ".concat(pageNumber, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));
          }
        });
        _defineProperty(_assertThisInitialized(_this), "linkService", new LinkService_default({
          eventBus: eventBus_default
        }));
        _defineProperty(_assertThisInitialized(_this), "loadDocument", _asyncToGenerator(import_regenerator.default.mark(function _callee() {
          var source, _this$props, options, onLoadProgress, onPassword2, cancellable, pdf;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  source = null;
                  _context.prev = 1;
                  _context.next = 4;
                  return _this.findDocumentSource();
                case 4:
                  source = _context.sent;
                  _this.onSourceSuccess();
                  _context.next = 11;
                  break;
                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](1);
                  _this.onSourceError(_context.t0);
                case 11:
                  if (source) {
                    _context.next = 13;
                    break;
                  }
                  return _context.abrupt("return");
                case 13:
                  _this.setState(function(prevState) {
                    if (!prevState.pdf) {
                      return null;
                    }
                    return {
                      pdf: null
                    };
                  });
                  _this$props = _this.props, options = _this$props.options, onLoadProgress = _this$props.onLoadProgress, onPassword2 = _this$props.onPassword;
                  _context.prev = 15;
                  cancelRunningTask(_this.runningTask);
                  _this.loadingTask = import_pdf.default.getDocument(_objectSpread({}, source, {}, options));
                  _this.loadingTask.onPassword = onPassword2;
                  if (onLoadProgress) {
                    _this.loadingTask.onProgress = onLoadProgress;
                  }
                  cancellable = makeCancellablePromise(_this.loadingTask.promise);
                  _this.runningTask = cancellable;
                  _context.next = 24;
                  return cancellable.promise;
                case 24:
                  pdf = _context.sent;
                  _this.setState(function(prevState) {
                    if (prevState.pdf && prevState.pdf.fingerprint === pdf.fingerprint) {
                      return null;
                    }
                    return {
                      pdf
                    };
                  }, _this.onLoadSuccess);
                  _context.next = 31;
                  break;
                case 28:
                  _context.prev = 28;
                  _context.t1 = _context["catch"](15);
                  _this.onLoadError(_context.t1);
                case 31:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 8], [15, 28]]);
        })));
        _defineProperty(_assertThisInitialized(_this), "setupLinkService", function() {
          _this.linkService.setViewer(_this.viewer);
          var documentInstance = _assertThisInitialized(_this);
          Object.defineProperty(_this.linkService, "externalLinkTarget", {
            get: function get() {
              var externalLinkTarget = documentInstance.props.externalLinkTarget;
              switch (externalLinkTarget) {
                case "_self":
                  return 1;
                case "_blank":
                  return 2;
                case "_parent":
                  return 3;
                case "_top":
                  return 4;
                default:
                  return 0;
              }
            }
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onSourceSuccess", function() {
          var onSourceSuccess = _this.props.onSourceSuccess;
          if (onSourceSuccess)
            onSourceSuccess();
        });
        _defineProperty(_assertThisInitialized(_this), "onSourceError", function(error) {
          errorOnDev(error);
          var onSourceError = _this.props.onSourceError;
          if (onSourceError)
            onSourceError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function() {
          var onLoadSuccess = _this.props.onLoadSuccess;
          var pdf = _this.state.pdf;
          if (onLoadSuccess)
            onLoadSuccess(pdf);
          _this.pages = new Array(pdf.numPages);
          _this.linkService.setDocument(pdf);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadError", function(error) {
          _this.setState({
            pdf: false
          });
          errorOnDev(error);
          var onLoadError = _this.props.onLoadError;
          if (onLoadError)
            onLoadError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "findDocumentSource", _asyncToGenerator(import_regenerator.default.mark(function _callee2() {
          var file, fileUint8Array, url, otherParams, _fileUint8Array;
          return import_regenerator.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  file = _this.props.file;
                  if (file) {
                    _context2.next = 3;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 3:
                  if (!(typeof file === "string")) {
                    _context2.next = 9;
                    break;
                  }
                  if (!isDataURI(file)) {
                    _context2.next = 7;
                    break;
                  }
                  fileUint8Array = dataURItoUint8Array(file);
                  return _context2.abrupt("return", {
                    data: fileUint8Array
                  });
                case 7:
                  displayCORSWarning();
                  return _context2.abrupt("return", {
                    url: file
                  });
                case 9:
                  if (!(file instanceof PDFDataRangeTransport2)) {
                    _context2.next = 11;
                    break;
                  }
                  return _context2.abrupt("return", {
                    range: file
                  });
                case 11:
                  if (!isArrayBuffer(file)) {
                    _context2.next = 13;
                    break;
                  }
                  return _context2.abrupt("return", {
                    data: file
                  });
                case 13:
                  if (!isBrowser) {
                    _context2.next = 19;
                    break;
                  }
                  if (!(isBlob(file) || isFile(file))) {
                    _context2.next = 19;
                    break;
                  }
                  _context2.next = 17;
                  return loadFromFile(file);
                case 17:
                  _context2.t0 = _context2.sent;
                  return _context2.abrupt("return", {
                    data: _context2.t0
                  });
                case 19:
                  if (!(_typeof(file) !== "object")) {
                    _context2.next = 21;
                    break;
                  }
                  throw new Error("Invalid parameter in file, need either Uint8Array, string or a parameter object");
                case 21:
                  if (!(!file.url && !file.data && !file.range)) {
                    _context2.next = 23;
                    break;
                  }
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                case 23:
                  if (!(typeof file.url === "string")) {
                    _context2.next = 29;
                    break;
                  }
                  if (!isDataURI(file.url)) {
                    _context2.next = 28;
                    break;
                  }
                  url = file.url, otherParams = _objectWithoutProperties(file, ["url"]);
                  _fileUint8Array = dataURItoUint8Array(url);
                  return _context2.abrupt("return", _objectSpread({
                    data: _fileUint8Array
                  }, otherParams));
                case 28:
                  displayCORSWarning();
                case 29:
                  return _context2.abrupt("return", file);
                case 30:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        })));
        _defineProperty(_assertThisInitialized(_this), "registerPage", function(pageIndex, ref) {
          _this.pages[pageIndex] = ref;
        });
        _defineProperty(_assertThisInitialized(_this), "unregisterPage", function(pageIndex) {
          delete _this.pages[pageIndex];
        });
        return _this;
      }
      _createClass(Document2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.loadDocument();
          this.setupLinkService();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var file = this.props.file;
          if (file !== prevProps.file) {
            this.loadDocument();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this.loadingTask)
            this.loadingTask.destroy();
          cancelRunningTask(this.runningTask);
        }
      }, {
        key: "renderChildren",
        value: function renderChildren() {
          var children = this.props.children;
          return import_react4.default.createElement(DocumentContext_default.Provider, {
            value: this.childContext
          }, children);
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          var file = this.props.file;
          var pdf = this.state.pdf;
          if (!file) {
            var noData = this.props.noData;
            return import_react4.default.createElement(Message, {
              type: "no-data"
            }, typeof noData === "function" ? noData() : noData);
          }
          if (pdf === null) {
            var loading = this.props.loading;
            return import_react4.default.createElement(Message, {
              type: "loading"
            }, typeof loading === "function" ? loading() : loading);
          }
          if (pdf === false) {
            var error = this.props.error;
            return import_react4.default.createElement(Message, {
              type: "error"
            }, typeof error === "function" ? error() : error);
          }
          return this.renderChildren();
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props2 = this.props, className = _this$props2.className, inputRef = _this$props2.inputRef;
          return import_react4.default.createElement("div", _extends({
            className: mergeClassNames("react-pdf__Document", className),
            ref: inputRef
          }, this.eventProps), this.renderContent());
        }
      }, {
        key: "childContext",
        get: function get() {
          var linkService = this.linkService, registerPage = this.registerPage, unregisterPage = this.unregisterPage;
          var _this$props3 = this.props, renderMode = _this$props3.renderMode, rotate = _this$props3.rotate;
          var pdf = this.state.pdf;
          return {
            linkService,
            pdf,
            registerPage,
            renderMode,
            rotate,
            unregisterPage
          };
        }
      }, {
        key: "eventProps",
        get: function get() {
          var _this2 = this;
          return makeEventProps(this.props, function() {
            return _this2.state.pdf;
          });
        }
        /**
         * Called when a document source is resolved correctly
         */
      }]);
      return Document2;
    }(import_react4.PureComponent);
    Document.defaultProps = {
      error: "Failed to load PDF file.",
      loading: "Loading PDF…",
      noData: "No PDF file specified.",
      onPassword: function onPassword(callback, reason) {
        switch (reason) {
          case PasswordResponses_default.NEED_PASSWORD: {
            var password = prompt("Enter the password to open this PDF file.");
            callback(password);
            break;
          }
          case PasswordResponses_default.INCORRECT_PASSWORD: {
            var _password = prompt("Invalid password. Please try again.");
            callback(_password);
            break;
          }
          default:
        }
      }
    };
    isFunctionOrNode = import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.node]);
    Document.propTypes = _objectSpread({}, eventProps, {
      children: import_prop_types3.default.node,
      className: isClassName,
      error: isFunctionOrNode,
      file: isFile,
      inputRef: import_prop_types3.default.func,
      loading: isFunctionOrNode,
      noData: isFunctionOrNode,
      onItemClick: import_prop_types3.default.func,
      onLoadError: import_prop_types3.default.func,
      onLoadProgress: import_prop_types3.default.func,
      onLoadSuccess: import_prop_types3.default.func,
      onPassword: import_prop_types3.default.func,
      onSourceError: import_prop_types3.default.func,
      onSourceSuccess: import_prop_types3.default.func,
      rotate: import_prop_types3.default.number
    });
  }
});

// node_modules/react-pdf/dist/esm/OutlineContext.js
var import_react5, OutlineContext_default;
var init_OutlineContext = __esm({
  "node_modules/react-pdf/dist/esm/OutlineContext.js"() {
    import_react5 = __toESM(require_react());
    OutlineContext_default = (0, import_react5.createContext)(null);
  }
});

// node_modules/react-pdf/dist/esm/Ref.js
var Ref;
var init_Ref = __esm({
  "node_modules/react-pdf/dist/esm/Ref.js"() {
    init_classCallCheck();
    init_createClass();
    Ref = function() {
      function Ref2(_ref) {
        var num = _ref.num, gen = _ref.gen;
        _classCallCheck(this, Ref2);
        this.num = num;
        this.gen = gen;
      }
      _createClass(Ref2, [{
        key: "toString",
        value: function toString() {
          var str = "".concat(this.num, "R");
          if (this.gen !== 0) {
            str += this.gen;
          }
          return str;
        }
      }]);
      return Ref2;
    }();
  }
});

// node_modules/react-pdf/dist/esm/OutlineItem.js
function _createSuper2(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct2()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_regenerator2, import_react6, import_prop_types4, OutlineItemInternal, isDestination, OutlineItem, OutlineItem_default;
var init_OutlineItem = __esm({
  "node_modules/react-pdf/dist/esm/OutlineItem.js"() {
    init_extends();
    init_objectWithoutProperties();
    init_slicedToArray();
    import_regenerator2 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react6 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_DocumentContext();
    init_OutlineContext();
    init_Ref();
    init_utils();
    init_propTypes();
    OutlineItemInternal = function(_PureComponent) {
      _inherits(OutlineItemInternal2, _PureComponent);
      var _super = _createSuper2(OutlineItemInternal2);
      function OutlineItemInternal2() {
        var _this;
        _classCallCheck(this, OutlineItemInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "getDestination", _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
          var _this$props, item, pdf;
          return import_regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$props = _this.props, item = _this$props.item, pdf = _this$props.pdf;
                  if (isDefined(_this.destination)) {
                    _context.next = 9;
                    break;
                  }
                  if (!(typeof item.dest === "string")) {
                    _context.next = 8;
                    break;
                  }
                  _context.next = 5;
                  return pdf.getDestination(item.dest);
                case 5:
                  _this.destination = _context.sent;
                  _context.next = 9;
                  break;
                case 8:
                  _this.destination = item.dest;
                case 9:
                  return _context.abrupt("return", _this.destination);
                case 10:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })));
        _defineProperty(_assertThisInitialized(_this), "getPageIndex", _asyncToGenerator(import_regenerator2.default.mark(function _callee2() {
          var pdf, destination, _destination, ref;
          return import_regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  pdf = _this.props.pdf;
                  if (isDefined(_this.pageIndex)) {
                    _context2.next = 10;
                    break;
                  }
                  _context2.next = 4;
                  return _this.getDestination();
                case 4:
                  destination = _context2.sent;
                  if (!destination) {
                    _context2.next = 10;
                    break;
                  }
                  _destination = _slicedToArray(destination, 1), ref = _destination[0];
                  _context2.next = 9;
                  return pdf.getPageIndex(new Ref(ref));
                case 9:
                  _this.pageIndex = _context2.sent;
                case 10:
                  return _context2.abrupt("return", _this.pageIndex);
                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        })));
        _defineProperty(_assertThisInitialized(_this), "getPageNumber", _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
          return import_regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (isDefined(_this.pageNumber)) {
                    _context3.next = 5;
                    break;
                  }
                  _context3.next = 3;
                  return _this.getPageIndex();
                case 3:
                  _context3.t0 = _context3.sent;
                  _this.pageNumber = _context3.t0 + 1;
                case 5:
                  return _context3.abrupt("return", _this.pageNumber);
                case 6:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        })));
        _defineProperty(_assertThisInitialized(_this), "onClick", function() {
          var _ref4 = _asyncToGenerator(import_regenerator2.default.mark(function _callee4(event) {
            var onClick, pageIndex, pageNumber;
            return import_regenerator2.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    onClick = _this.props.onClick;
                    event.preventDefault();
                    _context4.next = 4;
                    return _this.getPageIndex();
                  case 4:
                    pageIndex = _context4.sent;
                    _context4.next = 7;
                    return _this.getPageNumber();
                  case 7:
                    pageNumber = _context4.sent;
                    if (onClick) {
                      onClick({
                        pageIndex,
                        pageNumber
                      });
                    }
                  case 9:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));
          return function(_x) {
            return _ref4.apply(this, arguments);
          };
        }());
        return _this;
      }
      _createClass(OutlineItemInternal2, [{
        key: "renderSubitems",
        value: function renderSubitems() {
          var _this$props2 = this.props, item = _this$props2.item, otherProps = _objectWithoutProperties(_this$props2, ["item"]);
          if (!item.items || !item.items.length) {
            return null;
          }
          var subitems = item.items;
          return import_react6.default.createElement("ul", null, subitems.map(function(subitem, subitemIndex) {
            return import_react6.default.createElement(OutlineItemInternal2, _extends({
              key: typeof subitem.destination === "string" ? subitem.destination : subitemIndex,
              item: subitem
            }, otherProps));
          }));
        }
      }, {
        key: "render",
        value: function render() {
          var item = this.props.item;
          return import_react6.default.createElement("li", null, import_react6.default.createElement("a", {
            href: "#",
            onClick: this.onClick
          }, item.title), this.renderSubitems());
        }
      }]);
      return OutlineItemInternal2;
    }(import_react6.PureComponent);
    isDestination = import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.arrayOf(import_prop_types4.default.any)]);
    OutlineItemInternal.propTypes = {
      item: import_prop_types4.default.shape({
        dest: isDestination,
        items: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({
          dest: isDestination,
          title: import_prop_types4.default.string
        })),
        title: import_prop_types4.default.string
      }).isRequired,
      onClick: import_prop_types4.default.func,
      pdf: isPdf.isRequired
    };
    OutlineItem = function OutlineItem2(props) {
      return import_react6.default.createElement(DocumentContext_default.Consumer, null, function(documentContext) {
        return import_react6.default.createElement(OutlineContext_default.Consumer, null, function(outlineContext) {
          return import_react6.default.createElement(OutlineItemInternal, _extends({}, documentContext, outlineContext, props));
        });
      });
    };
    OutlineItem_default = OutlineItem;
  }
});

// node_modules/react-pdf/dist/esm/Outline.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper3(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct3()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function Outline(props, ref) {
  return import_react7.default.createElement(DocumentContext_default.Consumer, null, function(context) {
    return import_react7.default.createElement(OutlineInternal, _extends({
      ref
    }, context, props));
  });
}
var import_regenerator3, import_react7, import_prop_types5, OutlineInternal, Outline_default;
var init_Outline = __esm({
  "node_modules/react-pdf/dist/esm/Outline.js"() {
    init_extends();
    import_regenerator3 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react7 = __toESM(require_react());
    import_prop_types5 = __toESM(require_prop_types());
    init_esm2();
    init_esm();
    init_esm3();
    init_DocumentContext();
    init_OutlineContext();
    init_OutlineItem();
    init_utils();
    init_propTypes();
    OutlineInternal = function(_PureComponent) {
      _inherits(OutlineInternal2, _PureComponent);
      var _super = _createSuper3(OutlineInternal2);
      function OutlineInternal2() {
        var _this;
        _classCallCheck(this, OutlineInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          outline: null
        });
        _defineProperty(_assertThisInitialized(_this), "loadOutline", _asyncToGenerator(import_regenerator3.default.mark(function _callee() {
          var pdf, cancellable, outline;
          return import_regenerator3.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  pdf = _this.props.pdf;
                  _this.setState(function(prevState) {
                    if (!prevState.outline) {
                      return null;
                    }
                    return {
                      outline: null
                    };
                  });
                  _context.prev = 2;
                  cancellable = makeCancellablePromise(pdf.getOutline());
                  _this.runningTask = cancellable;
                  _context.next = 7;
                  return cancellable.promise;
                case 7:
                  outline = _context.sent;
                  _this.setState({
                    outline
                  }, _this.onLoadSuccess);
                  _context.next = 14;
                  break;
                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](2);
                  _this.onLoadError(_context.t0);
                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 11]]);
        })));
        _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function() {
          var onLoadSuccess = _this.props.onLoadSuccess;
          var outline = _this.state.outline;
          if (onLoadSuccess)
            onLoadSuccess(outline);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadError", function(error) {
          _this.setState({
            outline: false
          });
          errorOnDev(error);
          var onLoadError = _this.props.onLoadError;
          if (onLoadError)
            onLoadError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "onItemClick", function(_ref2) {
          var pageIndex = _ref2.pageIndex, pageNumber = _ref2.pageNumber;
          var onItemClick = _this.props.onItemClick;
          if (onItemClick) {
            onItemClick({
              pageIndex,
              pageNumber
            });
          }
        });
        return _this;
      }
      _createClass(OutlineInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var pdf = this.props.pdf;
          if (!pdf) {
            throw new Error("Attempted to load an outline, but no document was specified.");
          }
          this.loadOutline();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var pdf = this.props.pdf;
          if (prevProps.pdf && pdf !== prevProps.pdf) {
            this.loadOutline();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          cancelRunningTask(this.runningTask);
        }
      }, {
        key: "renderOutline",
        value: function renderOutline() {
          var outline = this.state.outline;
          return import_react7.default.createElement("ul", null, outline.map(function(item, itemIndex) {
            return import_react7.default.createElement(OutlineItem_default, {
              key: typeof item.destination === "string" ? item.destination : itemIndex,
              item
            });
          }));
        }
      }, {
        key: "render",
        value: function render() {
          var pdf = this.props.pdf;
          var outline = this.state.outline;
          if (!pdf || !outline) {
            return null;
          }
          var _this$props = this.props, className = _this$props.className, inputRef = _this$props.inputRef;
          return import_react7.default.createElement("div", _extends({
            className: mergeClassNames("react-pdf__Outline", className),
            ref: inputRef
          }, this.eventProps), import_react7.default.createElement(OutlineContext_default.Provider, {
            value: this.childContext
          }, this.renderOutline()));
        }
      }, {
        key: "childContext",
        get: function get() {
          return {
            onClick: this.onItemClick
          };
        }
      }, {
        key: "eventProps",
        get: function get() {
          var _this2 = this;
          return makeEventProps(this.props, function() {
            return _this2.state.outline;
          });
        }
        /**
         * Called when an outline is read successfully
         */
      }]);
      return OutlineInternal2;
    }(import_react7.PureComponent);
    OutlineInternal.propTypes = _objectSpread2({
      className: isClassName,
      inputRef: import_prop_types5.default.func,
      onItemClick: import_prop_types5.default.func,
      onLoadError: import_prop_types5.default.func,
      onLoadSuccess: import_prop_types5.default.func,
      pdf: isPdf
    }, eventProps);
    Outline_default = import_react7.default.forwardRef(Outline);
  }
});

// node_modules/react-pdf/dist/esm/PageContext.js
var import_react8, PageContext_default;
var init_PageContext = __esm({
  "node_modules/react-pdf/dist/esm/PageContext.js"() {
    import_react8 = __toESM(require_react());
    PageContext_default = (0, import_react8.createContext)(null);
  }
});

// node_modules/react-pdf/dist/esm/Page/PageCanvas.js
function _createSuper4(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct4()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function PageCanvas(props) {
  return import_react9.default.createElement(PageContext_default.Consumer, null, function(context) {
    return import_react9.default.createElement(PageCanvasInternal, _extends({}, context, props));
  });
}
var import_react9, import_prop_types6, PageCanvasInternal;
var init_PageCanvas = __esm({
  "node_modules/react-pdf/dist/esm/Page/PageCanvas.js"() {
    init_extends();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react9 = __toESM(require_react());
    import_prop_types6 = __toESM(require_prop_types());
    init_PageContext();
    init_utils();
    init_propTypes();
    PageCanvasInternal = function(_PureComponent) {
      _inherits(PageCanvasInternal2, _PureComponent);
      var _super = _createSuper4(PageCanvasInternal2);
      function PageCanvasInternal2() {
        var _this;
        _classCallCheck(this, PageCanvasInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function() {
          _this.renderer = null;
          var _this$props = _this.props, onRenderSuccess = _this$props.onRenderSuccess, page = _this$props.page, scale = _this$props.scale;
          if (onRenderSuccess)
            onRenderSuccess(makePageCallback(page, scale));
        });
        _defineProperty(_assertThisInitialized(_this), "onRenderError", function(error) {
          if (isCancelException(error)) {
            return;
          }
          errorOnDev(error);
          var onRenderError = _this.props.onRenderError;
          if (onRenderError)
            onRenderError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "drawPageOnCanvas", function() {
          var _assertThisInitialize = _assertThisInitialized(_this), canvas = _assertThisInitialize.canvasLayer;
          if (!canvas) {
            return null;
          }
          var _assertThisInitialize2 = _assertThisInitialized(_this), renderViewport = _assertThisInitialize2.renderViewport, viewport = _assertThisInitialize2.viewport;
          var _this$props2 = _this.props, page = _this$props2.page, renderInteractiveForms = _this$props2.renderInteractiveForms;
          canvas.width = renderViewport.width;
          canvas.height = renderViewport.height;
          canvas.style.width = "".concat(Math.floor(viewport.width), "px");
          canvas.style.height = "".concat(Math.floor(viewport.height), "px");
          var renderContext = {
            get canvasContext() {
              return canvas.getContext("2d");
            },
            viewport: renderViewport,
            renderInteractiveForms
          };
          _this.cancelRenderingTask();
          _this.renderer = page.render(renderContext);
          return _this.renderer.promise.then(_this.onRenderSuccess)["catch"](_this.onRenderError);
        });
        return _this;
      }
      _createClass(PageCanvasInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.drawPageOnCanvas();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var _this$props3 = this.props, page = _this$props3.page, renderInteractiveForms = _this$props3.renderInteractiveForms;
          if (renderInteractiveForms !== prevProps.renderInteractiveForms) {
            page.cleanup();
            this.drawPageOnCanvas();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRenderingTask();
          if (this.canvasLayer) {
            this.canvasLayer.width = 0;
            this.canvasLayer.height = 0;
            this.canvasLayer = null;
          }
        }
      }, {
        key: "cancelRenderingTask",
        value: function cancelRenderingTask() {
          if (this.renderer && this.renderer._internalRenderTask.running) {
            this.renderer._internalRenderTask.cancel();
          }
        }
        /**
         * Called when a page is rendered successfully.
         */
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          return import_react9.default.createElement("canvas", {
            className: "react-pdf__Page__canvas",
            dir: "ltr",
            ref: function ref(_ref) {
              _this2.canvasLayer = _ref;
            },
            style: {
              display: "block",
              userSelect: "none"
            }
          });
        }
      }, {
        key: "renderViewport",
        get: function get() {
          var _this$props4 = this.props, page = _this$props4.page, rotate = _this$props4.rotate, scale = _this$props4.scale;
          var pixelRatio = getPixelRatio();
          return page.getViewport({
            scale: scale * pixelRatio,
            rotation: rotate
          });
        }
      }, {
        key: "viewport",
        get: function get() {
          var _this$props5 = this.props, page = _this$props5.page, rotate = _this$props5.rotate, scale = _this$props5.scale;
          return page.getViewport({
            scale,
            rotation: rotate
          });
        }
      }]);
      return PageCanvasInternal2;
    }(import_react9.PureComponent);
    PageCanvasInternal.propTypes = {
      onRenderError: import_prop_types6.default.func,
      onRenderSuccess: import_prop_types6.default.func,
      page: isPage.isRequired,
      renderInteractiveForms: import_prop_types6.default.bool,
      rotate: isRotate,
      scale: import_prop_types6.default.number
    };
  }
});

// node_modules/react-pdf/dist/esm/Page/PageSVG.js
function _createSuper5(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct5()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function PageSVG(props) {
  return import_react10.default.createElement(PageContext_default.Consumer, null, function(context) {
    return import_react10.default.createElement(PageSVGInternal, _extends({}, context, props));
  });
}
var import_react10, import_prop_types7, import_pdf2, PageSVGInternal;
var init_PageSVG = __esm({
  "node_modules/react-pdf/dist/esm/Page/PageSVG.js"() {
    init_extends();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react10 = __toESM(require_react());
    import_prop_types7 = __toESM(require_prop_types());
    import_pdf2 = __toESM(require_pdf());
    init_PageContext();
    init_utils();
    init_propTypes();
    PageSVGInternal = function(_PureComponent) {
      _inherits(PageSVGInternal2, _PureComponent);
      var _super = _createSuper5(PageSVGInternal2);
      function PageSVGInternal2() {
        var _this;
        _classCallCheck(this, PageSVGInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          svg: null
        });
        _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function() {
          _this.renderer = null;
          var _this$props = _this.props, onRenderSuccess = _this$props.onRenderSuccess, page = _this$props.page, scale = _this$props.scale;
          if (onRenderSuccess)
            onRenderSuccess(makePageCallback(page, scale));
        });
        _defineProperty(_assertThisInitialized(_this), "onRenderError", function(error) {
          if (isCancelException(error)) {
            return;
          }
          errorOnDev(error);
          var onRenderError = _this.props.onRenderError;
          if (onRenderError)
            onRenderError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "renderSVG", function() {
          var page = _this.props.page;
          _this.renderer = page.getOperatorList();
          return _this.renderer.then(function(operatorList) {
            var svgGfx = new import_pdf2.default.SVGGraphics(page.commonObjs, page.objs);
            _this.renderer = svgGfx.getSVG(operatorList, _this.viewport).then(function(svg) {
              _this.setState({
                svg
              }, _this.onRenderSuccess);
            })["catch"](_this.onRenderError);
          })["catch"](_this.onRenderError);
        });
        _defineProperty(_assertThisInitialized(_this), "drawPageOnContainer", function(element) {
          var svg = _this.state.svg;
          if (!element || !svg) {
            return;
          }
          if (!element.firstElementChild) {
            element.appendChild(svg);
          }
          var _this$viewport = _this.viewport, width = _this$viewport.width, height = _this$viewport.height;
          svg.setAttribute("width", width);
          svg.setAttribute("height", height);
        });
        return _this;
      }
      _createClass(PageSVGInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.renderSVG();
        }
        /**
         * Called when a page is rendered successfully.
         */
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          var _this$viewport2 = this.viewport, width = _this$viewport2.width, height = _this$viewport2.height;
          return import_react10.default.createElement("div", {
            className: "react-pdf__Page__svg",
            ref: function ref(_ref) {
              return _this2.drawPageOnContainer(_ref);
            },
            style: {
              display: "block",
              backgroundColor: "white",
              overflow: "hidden",
              width,
              height,
              userSelect: "none"
            }
          });
        }
      }, {
        key: "viewport",
        get: function get() {
          var _this$props2 = this.props, page = _this$props2.page, rotate = _this$props2.rotate, scale = _this$props2.scale;
          return page.getViewport({
            scale,
            rotation: rotate
          });
        }
      }]);
      return PageSVGInternal2;
    }(import_react10.PureComponent);
    PageSVGInternal.propTypes = {
      onRenderError: import_prop_types7.default.func,
      onRenderSuccess: import_prop_types7.default.func,
      page: isPage.isRequired,
      rotate: isRotate,
      scale: import_prop_types7.default.number
    };
  }
});

// node_modules/react-pdf/dist/esm/Page/TextLayerItem.js
function _createSuper6(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct6()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function TextLayerItem(props) {
  return import_react11.default.createElement(PageContext_default.Consumer, null, function(context) {
    return import_react11.default.createElement(TextLayerItemInternal, _extends({}, context, props));
  });
}
var import_regenerator4, import_react11, import_prop_types8, TextLayerItemInternal;
var init_TextLayerItem = __esm({
  "node_modules/react-pdf/dist/esm/Page/TextLayerItem.js"() {
    init_extends();
    init_slicedToArray();
    import_regenerator4 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react11 = __toESM(require_react());
    import_prop_types8 = __toESM(require_prop_types());
    init_PageContext();
    init_propTypes();
    TextLayerItemInternal = function(_PureComponent) {
      _inherits(TextLayerItemInternal2, _PureComponent);
      var _super = _createSuper6(TextLayerItemInternal2);
      function TextLayerItemInternal2() {
        var _this;
        _classCallCheck(this, TextLayerItemInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "getElementWidth", function(element) {
          var _assertThisInitialize = _assertThisInitialized(_this), sideways = _assertThisInitialize.sideways;
          return element.getBoundingClientRect()[sideways ? "height" : "width"];
        });
        return _this;
      }
      _createClass(TextLayerItemInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.alignTextItem();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.alignTextItem();
        }
      }, {
        key: "getFontData",
        value: function() {
          var _getFontData = _asyncToGenerator(import_regenerator4.default.mark(function _callee(fontName) {
            var page, font;
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    page = this.props.page;
                    _context.next = 3;
                    return new Promise(function(resolve) {
                      page.commonObjs.get(fontName, resolve);
                    });
                  case 3:
                    font = _context.sent;
                    return _context.abrupt("return", font);
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getFontData(_x) {
            return _getFontData.apply(this, arguments);
          }
          return getFontData;
        }()
      }, {
        key: "alignTextItem",
        value: function() {
          var _alignTextItem = _asyncToGenerator(import_regenerator4.default.mark(function _callee2() {
            var element, _this$props, fontName, scale, width, fontData, fallbackFontName, targetWidth, actualWidth, transform, ascent;
            return import_regenerator4.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    element = this.item;
                    if (element) {
                      _context2.next = 3;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 3:
                    element.style.transform = "";
                    _this$props = this.props, fontName = _this$props.fontName, scale = _this$props.scale, width = _this$props.width;
                    element.style.fontFamily = "".concat(fontName, ", sans-serif");
                    _context2.next = 8;
                    return this.getFontData(fontName);
                  case 8:
                    fontData = _context2.sent;
                    fallbackFontName = fontData ? fontData.fallbackName : "sans-serif";
                    element.style.fontFamily = "".concat(fontName, ", ").concat(fallbackFontName);
                    targetWidth = width * scale;
                    actualWidth = this.getElementWidth(element);
                    transform = "scaleX(".concat(targetWidth / actualWidth, ")");
                    ascent = fontData ? fontData.ascent : 0;
                    if (ascent) {
                      transform += " translateY(".concat((1 - ascent) * 100, "%)");
                    }
                    element.style.transform = transform;
                    element.style.WebkitTransform = transform;
                  case 18:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function alignTextItem() {
            return _alignTextItem.apply(this, arguments);
          }
          return alignTextItem;
        }()
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          var fontSize = this.fontSize, top = this.top, left = this.left;
          var _this$props2 = this.props, customTextRenderer = _this$props2.customTextRenderer, scale = _this$props2.scale, text = _this$props2.str;
          return import_react11.default.createElement("span", {
            ref: function ref(_ref) {
              _this2.item = _ref;
            },
            style: {
              height: "1em",
              fontFamily: "sans-serif",
              fontSize: "".concat(fontSize * scale, "px"),
              position: "absolute",
              top: "".concat(top * scale, "px"),
              left: "".concat(left * scale, "px"),
              transformOrigin: "left bottom",
              whiteSpace: "pre",
              pointerEvents: "all"
            }
          }, customTextRenderer ? customTextRenderer(this.props) : text);
        }
      }, {
        key: "unrotatedViewport",
        get: function get() {
          var _this$props3 = this.props, page = _this$props3.page, scale = _this$props3.scale;
          return page.getViewport({
            scale
          });
        }
        /**
         * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
         * text content.
         */
      }, {
        key: "rotate",
        get: function get() {
          var _this$props4 = this.props, page = _this$props4.page, rotate = _this$props4.rotate;
          return rotate - page.rotate;
        }
      }, {
        key: "sideways",
        get: function get() {
          var rotate = this.rotate;
          return rotate % 180 !== 0;
        }
      }, {
        key: "defaultSideways",
        get: function get() {
          var rotation = this.unrotatedViewport.rotation;
          return rotation % 180 !== 0;
        }
      }, {
        key: "fontSize",
        get: function get() {
          var transform = this.props.transform;
          var defaultSideways = this.defaultSideways;
          var _transform = _slicedToArray(transform, 2), fontHeightPx = _transform[0], fontWidthPx = _transform[1];
          return defaultSideways ? fontWidthPx : fontHeightPx;
        }
      }, {
        key: "top",
        get: function get() {
          var transform = this.props.transform;
          var viewport = this.unrotatedViewport, defaultSideways = this.defaultSideways;
          var _transform2 = _slicedToArray(transform, 6), offsetX = _transform2[2], offsetY = _transform2[3], x2 = _transform2[4], y2 = _transform2[5];
          var _viewport$viewBox = _slicedToArray(viewport.viewBox, 4), yMin = _viewport$viewBox[1], yMax = _viewport$viewBox[3];
          return defaultSideways ? x2 + offsetX + yMin : yMax - (y2 + offsetY);
        }
      }, {
        key: "left",
        get: function get() {
          var transform = this.props.transform;
          var viewport = this.unrotatedViewport, defaultSideways = this.defaultSideways;
          var _transform3 = _slicedToArray(transform, 6), x2 = _transform3[4], y2 = _transform3[5];
          var _viewport$viewBox2 = _slicedToArray(viewport.viewBox, 1), xMin = _viewport$viewBox2[0];
          return defaultSideways ? y2 - xMin : x2 - xMin;
        }
      }]);
      return TextLayerItemInternal2;
    }(import_react11.PureComponent);
    TextLayerItemInternal.propTypes = {
      customTextRenderer: import_prop_types8.default.func,
      fontName: import_prop_types8.default.string.isRequired,
      itemIndex: import_prop_types8.default.number.isRequired,
      // eslint-disable-line react/no-unused-prop-types
      page: isPage.isRequired,
      rotate: isRotate,
      scale: import_prop_types8.default.number,
      str: import_prop_types8.default.string.isRequired,
      transform: import_prop_types8.default.arrayOf(import_prop_types8.default.number).isRequired,
      width: import_prop_types8.default.number.isRequired
    };
  }
});

// node_modules/react-pdf/dist/esm/Page/TextLayer.js
function _createSuper7(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct7()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function TextLayer(props) {
  return import_react12.default.createElement(PageContext_default.Consumer, null, function(context) {
    return import_react12.default.createElement(TextLayerInternal, _extends({}, context, props));
  });
}
var import_regenerator5, import_react12, import_prop_types9, TextLayerInternal;
var init_TextLayer = __esm({
  "node_modules/react-pdf/dist/esm/Page/TextLayer.js"() {
    init_extends();
    import_regenerator5 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react12 = __toESM(require_react());
    import_prop_types9 = __toESM(require_prop_types());
    init_esm2();
    init_PageContext();
    init_TextLayerItem();
    init_utils();
    init_propTypes();
    TextLayerInternal = function(_PureComponent) {
      _inherits(TextLayerInternal2, _PureComponent);
      var _super = _createSuper7(TextLayerInternal2);
      function TextLayerInternal2() {
        var _this;
        _classCallCheck(this, TextLayerInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          textItems: null
        });
        _defineProperty(_assertThisInitialized(_this), "loadTextItems", _asyncToGenerator(import_regenerator5.default.mark(function _callee() {
          var page, cancellable, _yield$cancellable$pr, textItems;
          return import_regenerator5.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  page = _this.props.page;
                  _context.prev = 1;
                  cancellable = makeCancellablePromise(page.getTextContent());
                  _this.runningTask = cancellable;
                  _context.next = 6;
                  return cancellable.promise;
                case 6:
                  _yield$cancellable$pr = _context.sent;
                  textItems = _yield$cancellable$pr.items;
                  _this.setState({
                    textItems
                  }, _this.onLoadSuccess);
                  _context.next = 14;
                  break;
                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](1);
                  _this.onLoadError(_context.t0);
                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 11]]);
        })));
        _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function() {
          var onGetTextSuccess = _this.props.onGetTextSuccess;
          var textItems = _this.state.textItems;
          if (onGetTextSuccess)
            onGetTextSuccess(textItems);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadError", function(error) {
          _this.setState({
            textItems: false
          });
          errorOnDev(error);
          var onGetTextError = _this.props.onGetTextError;
          if (onGetTextError)
            onGetTextError(error);
        });
        return _this;
      }
      _createClass(TextLayerInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var page = this.props.page;
          if (!page) {
            throw new Error("Attempted to load page text content, but no page was specified.");
          }
          this.loadTextItems();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var page = this.props.page;
          if (prevProps.page && page !== prevProps.page) {
            this.loadTextItems();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          cancelRunningTask(this.runningTask);
        }
      }, {
        key: "renderTextItems",
        value: function renderTextItems() {
          var textItems = this.state.textItems;
          if (!textItems) {
            return null;
          }
          return textItems.map(function(textItem, itemIndex) {
            return import_react12.default.createElement(
              TextLayerItem,
              _extends({
                key: itemIndex,
                itemIndex
              }, textItem)
            );
          });
        }
      }, {
        key: "render",
        value: function render() {
          var viewport = this.unrotatedViewport, rotate = this.rotate;
          return import_react12.default.createElement("div", {
            className: "react-pdf__Page__textContent",
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              width: "".concat(viewport.width, "px"),
              height: "".concat(viewport.height, "px"),
              color: "transparent",
              transform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),
              WebkitTransform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),
              pointerEvents: "none"
            }
          }, this.renderTextItems());
        }
      }, {
        key: "unrotatedViewport",
        get: function get() {
          var _this$props = this.props, page = _this$props.page, scale = _this$props.scale;
          return page.getViewport({
            scale
          });
        }
        /**
         * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
         * text content.
         */
      }, {
        key: "rotate",
        get: function get() {
          var _this$props2 = this.props, page = _this$props2.page, rotate = _this$props2.rotate;
          return rotate - page.rotate;
        }
      }]);
      return TextLayerInternal2;
    }(import_react12.PureComponent);
    TextLayerInternal.propTypes = {
      onGetTextError: import_prop_types9.default.func,
      onGetTextSuccess: import_prop_types9.default.func,
      page: isPage.isRequired,
      rotate: isRotate,
      scale: import_prop_types9.default.number
    };
  }
});

// node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js
function _createSuper8(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct8()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_regenerator6, import_react13, import_prop_types10, import_pdf3, AnnotationLayerInternal, AnnotationLayer, AnnotationLayer_default;
var init_AnnotationLayer = __esm({
  "node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js"() {
    init_extends();
    import_regenerator6 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react13 = __toESM(require_react());
    import_prop_types10 = __toESM(require_prop_types());
    import_pdf3 = __toESM(require_pdf());
    init_esm2();
    init_DocumentContext();
    init_PageContext();
    init_utils();
    init_propTypes();
    AnnotationLayerInternal = function(_PureComponent) {
      _inherits(AnnotationLayerInternal2, _PureComponent);
      var _super = _createSuper8(AnnotationLayerInternal2);
      function AnnotationLayerInternal2() {
        var _this;
        _classCallCheck(this, AnnotationLayerInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          annotations: null
        });
        _defineProperty(_assertThisInitialized(_this), "loadAnnotations", _asyncToGenerator(import_regenerator6.default.mark(function _callee() {
          var page, cancellable, annotations;
          return import_regenerator6.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  page = _this.props.page;
                  _context.prev = 1;
                  cancellable = makeCancellablePromise(page.getAnnotations());
                  _this.runningTask = cancellable;
                  _context.next = 6;
                  return cancellable.promise;
                case 6:
                  annotations = _context.sent;
                  _this.setState({
                    annotations
                  }, _this.onLoadSuccess);
                  _context.next = 13;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  _this.onLoadError(_context.t0);
                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 10]]);
        })));
        _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function() {
          var onGetAnnotationsSuccess = _this.props.onGetAnnotationsSuccess;
          var annotations = _this.state.annotations;
          if (onGetAnnotationsSuccess)
            onGetAnnotationsSuccess(annotations);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadError", function(error) {
          _this.setState({
            annotations: false
          });
          errorOnDev(error);
          var onGetAnnotationsError = _this.props.onGetAnnotationsError;
          if (onGetAnnotationsError)
            onGetAnnotationsError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function() {
          var onRenderAnnotationLayerSuccess = _this.props.onRenderAnnotationLayerSuccess;
          if (onRenderAnnotationLayerSuccess)
            onRenderAnnotationLayerSuccess();
        });
        _defineProperty(_assertThisInitialized(_this), "onRenderError", function(error) {
          errorOnDev(error);
          var onRenderAnnotationLayerError = _this.props.onRenderAnnotationLayerError;
          if (onRenderAnnotationLayerError)
            onRenderAnnotationLayerError(error);
        });
        return _this;
      }
      _createClass(AnnotationLayerInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var page = this.props.page;
          if (!page) {
            throw new Error("Attempted to load page annotations, but no page was specified.");
          }
          this.loadAnnotations();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var _this$props = this.props, page = _this$props.page, renderInteractiveForms = _this$props.renderInteractiveForms;
          if (prevProps.page && page !== prevProps.page || renderInteractiveForms !== prevProps.renderInteractiveForms) {
            this.loadAnnotations();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          cancelRunningTask(this.runningTask);
        }
      }, {
        key: "renderAnnotationLayer",
        value: function renderAnnotationLayer() {
          var annotations = this.state.annotations;
          if (!annotations) {
            return;
          }
          var _this$props2 = this.props, linkService = _this$props2.linkService, page = _this$props2.page, renderInteractiveForms = _this$props2.renderInteractiveForms;
          var viewport = this.viewport.clone({
            dontFlip: true
          });
          var parameters = {
            annotations,
            div: this.annotationLayer,
            linkService,
            page,
            renderInteractiveForms,
            viewport
          };
          this.annotationLayer.innerHTML = "";
          try {
            import_pdf3.default.AnnotationLayer.render(parameters);
            this.onRenderSuccess();
          } catch (error) {
            this.onRenderError(error);
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          return import_react13.default.createElement("div", {
            className: "react-pdf__Page__annotations annotationLayer",
            ref: function ref(_ref2) {
              _this2.annotationLayer = _ref2;
            }
          }, this.renderAnnotationLayer());
        }
      }, {
        key: "viewport",
        get: function get() {
          var _this$props3 = this.props, page = _this$props3.page, rotate = _this$props3.rotate, scale = _this$props3.scale;
          return page.getViewport({
            scale,
            rotation: rotate
          });
        }
      }]);
      return AnnotationLayerInternal2;
    }(import_react13.PureComponent);
    AnnotationLayerInternal.propTypes = {
      linkService: isLinkService.isRequired,
      onGetAnnotationsError: import_prop_types10.default.func,
      onGetAnnotationsSuccess: import_prop_types10.default.func,
      onRenderAnnotationLayerError: import_prop_types10.default.func,
      onRenderAnnotationLayerSuccess: import_prop_types10.default.func,
      page: isPage,
      renderInteractiveForms: import_prop_types10.default.bool,
      rotate: isRotate,
      scale: import_prop_types10.default.number
    };
    AnnotationLayer = function AnnotationLayer2(props) {
      return import_react13.default.createElement(DocumentContext_default.Consumer, null, function(documentContext) {
        return import_react13.default.createElement(PageContext_default.Consumer, null, function(pageContext) {
          return import_react13.default.createElement(AnnotationLayerInternal, _extends({}, documentContext, pageContext, props));
        });
      });
    };
    AnnotationLayer_default = AnnotationLayer;
  }
});

// node_modules/react-pdf/dist/esm/Page.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper9(Derived) {
  return function() {
    var Super = _getPrototypeOf(Derived), result;
    if (_isNativeReflectConstruct9()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function Page(props, ref) {
  return import_react14.default.createElement(DocumentContext_default.Consumer, null, function(context) {
    return import_react14.default.createElement(PageInternal, _extends({
      ref
    }, context, props));
  });
}
var import_regenerator7, import_react14, import_prop_types11, defaultScale, PageInternal, isFunctionOrNode2, Page_default;
var init_Page = __esm({
  "node_modules/react-pdf/dist/esm/Page.js"() {
    init_extends();
    import_regenerator7 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_react14 = __toESM(require_react());
    import_prop_types11 = __toESM(require_prop_types());
    init_esm2();
    init_esm();
    init_esm3();
    init_DocumentContext();
    init_PageContext();
    init_Message();
    init_PageCanvas();
    init_PageSVG();
    init_TextLayer();
    init_AnnotationLayer();
    init_utils();
    init_propTypes();
    defaultScale = 1;
    PageInternal = function(_PureComponent) {
      _inherits(PageInternal2, _PureComponent);
      var _super = _createSuper9(PageInternal2);
      function PageInternal2() {
        var _this;
        _classCallCheck(this, PageInternal2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          page: null
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function() {
          var _this$props = _this.props, onLoadSuccess = _this$props.onLoadSuccess, registerPage = _this$props.registerPage;
          var page = _this.state.page;
          if (onLoadSuccess)
            onLoadSuccess(makePageCallback(page, _this.scale));
          if (registerPage)
            registerPage(_this.pageIndex, _this.ref);
        });
        _defineProperty(_assertThisInitialized(_this), "onLoadError", function(error) {
          errorOnDev(error);
          var onLoadError = _this.props.onLoadError;
          if (onLoadError)
            onLoadError(error);
        });
        _defineProperty(_assertThisInitialized(_this), "loadPage", _asyncToGenerator(import_regenerator7.default.mark(function _callee() {
          var pdf, pageNumber, cancellable, page;
          return import_regenerator7.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  pdf = _this.props.pdf;
                  pageNumber = _this.getPageNumber();
                  if (pageNumber) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return");
                case 4:
                  _this.setState(function(prevState) {
                    if (!prevState.page) {
                      return null;
                    }
                    return {
                      page: null
                    };
                  });
                  _context.prev = 5;
                  cancellable = makeCancellablePromise(pdf.getPage(pageNumber));
                  _this.runningTask = cancellable;
                  _context.next = 10;
                  return cancellable.promise;
                case 10:
                  page = _context.sent;
                  _this.setState({
                    page
                  }, _this.onLoadSuccess);
                  _context.next = 18;
                  break;
                case 14:
                  _context.prev = 14;
                  _context.t0 = _context["catch"](5);
                  _this.setState({
                    page: false
                  });
                  _this.onLoadError(_context.t0);
                case 18:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[5, 14]]);
        })));
        return _this;
      }
      _createClass(PageInternal2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var pdf = this.props.pdf;
          if (!pdf) {
            throw new Error("Attempted to load a page, but no document was specified.");
          }
          this.loadPage();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var pdf = this.props.pdf;
          if (prevProps.pdf && pdf !== prevProps.pdf || this.getPageNumber() !== this.getPageNumber(prevProps)) {
            var unregisterPage = this.props.unregisterPage;
            if (unregisterPage)
              unregisterPage(this.getPageIndex(prevProps));
            this.loadPage();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var unregisterPage = this.props.unregisterPage;
          if (unregisterPage)
            unregisterPage(this.pageIndex);
          cancelRunningTask(this.runningTask);
        }
      }, {
        key: "getPageIndex",
        value: function getPageIndex() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          if (isProvided(props.pageNumber)) {
            return props.pageNumber - 1;
          }
          if (isProvided(props.pageIndex)) {
            return props.pageIndex;
          }
          return null;
        }
      }, {
        key: "getPageNumber",
        value: function getPageNumber() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          if (isProvided(props.pageNumber)) {
            return props.pageNumber;
          }
          if (isProvided(props.pageIndex)) {
            return props.pageIndex + 1;
          }
          return null;
        }
      }, {
        key: "renderMainLayer",
        value: function renderMainLayer() {
          var renderMode = this.props.renderMode;
          switch (renderMode) {
            case "none":
              return null;
            case "svg":
              return import_react14.default.createElement(PageSVG, {
                key: "".concat(this.pageKeyNoScale, "_svg")
              });
            case "canvas":
            default:
              return import_react14.default.createElement(PageCanvas, {
                key: "".concat(this.pageKey, "_canvas")
              });
          }
        }
      }, {
        key: "renderTextLayer",
        value: function renderTextLayer() {
          var renderTextLayer2 = this.props.renderTextLayer;
          if (!renderTextLayer2) {
            return null;
          }
          return import_react14.default.createElement(TextLayer, {
            key: "".concat(this.pageKey, "_text")
          });
        }
      }, {
        key: "renderAnnotationLayer",
        value: function renderAnnotationLayer() {
          var renderAnnotationLayer2 = this.props.renderAnnotationLayer;
          if (!renderAnnotationLayer2) {
            return null;
          }
          return import_react14.default.createElement(AnnotationLayer_default, {
            key: "".concat(this.pageKey, "_annotations")
          });
        }
      }, {
        key: "renderChildren",
        value: function renderChildren() {
          var children = this.props.children;
          return import_react14.default.createElement(PageContext_default.Provider, {
            value: this.childContext
          }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), children);
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          var pageNumber = this.pageNumber;
          var pdf = this.props.pdf;
          var page = this.state.page;
          if (!pageNumber) {
            var noData = this.props.noData;
            return import_react14.default.createElement(Message, {
              type: "no-data"
            }, typeof noData === "function" ? noData() : noData);
          }
          if (pdf === null || page === null) {
            var loading = this.props.loading;
            return import_react14.default.createElement(Message, {
              type: "loading"
            }, typeof loading === "function" ? loading() : loading);
          }
          if (pdf === false || page === false) {
            var error = this.props.error;
            return import_react14.default.createElement(Message, {
              type: "error"
            }, typeof error === "function" ? error() : error);
          }
          return this.renderChildren();
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          var pageNumber = this.pageNumber;
          var className = this.props.className;
          return import_react14.default.createElement("div", _extends({
            className: mergeClassNames("react-pdf__Page", className),
            "data-page-number": pageNumber,
            ref: function ref(_ref2) {
              var inputRef = _this2.props.inputRef;
              if (inputRef) {
                inputRef(_ref2);
              }
              _this2.ref = _ref2;
            },
            style: {
              position: "relative"
            }
          }, this.eventProps), this.renderContent());
        }
      }, {
        key: "childContext",
        get: function get() {
          var page = this.state.page;
          if (!page) {
            return {};
          }
          var _this$props2 = this.props, customTextRenderer = _this$props2.customTextRenderer, onGetAnnotationsError = _this$props2.onGetAnnotationsError, onGetAnnotationsSuccess = _this$props2.onGetAnnotationsSuccess, onGetTextError = _this$props2.onGetTextError, onGetTextSuccess = _this$props2.onGetTextSuccess, onRenderAnnotationLayerError = _this$props2.onRenderAnnotationLayerError, onRenderAnnotationLayerSuccess = _this$props2.onRenderAnnotationLayerSuccess, onRenderError = _this$props2.onRenderError, onRenderSuccess = _this$props2.onRenderSuccess, renderInteractiveForms = _this$props2.renderInteractiveForms;
          return {
            customTextRenderer,
            onGetAnnotationsError,
            onGetAnnotationsSuccess,
            onGetTextError,
            onGetTextSuccess,
            onRenderAnnotationLayerError,
            onRenderAnnotationLayerSuccess,
            onRenderError,
            onRenderSuccess,
            page,
            renderInteractiveForms,
            rotate: this.rotate,
            scale: this.scale
          };
        }
        /**
         * Called when a page is loaded successfully
         */
      }, {
        key: "pageIndex",
        get: function get() {
          return this.getPageIndex();
        }
      }, {
        key: "pageNumber",
        get: function get() {
          return this.getPageNumber();
        }
      }, {
        key: "rotate",
        get: function get() {
          var rotate = this.props.rotate;
          if (isProvided(rotate)) {
            return rotate;
          }
          var page = this.state.page;
          if (!page) {
            return null;
          }
          return page.rotate;
        }
      }, {
        key: "scale",
        get: function get() {
          var page = this.state.page;
          if (!page) {
            return null;
          }
          var _this$props3 = this.props, scale = _this$props3.scale, width = _this$props3.width, height = _this$props3.height;
          var rotate = this.rotate;
          var pageScale = 1;
          var scaleWithDefault = scale === null ? defaultScale : scale;
          if (width || height) {
            var viewport = page.getViewport({
              scale: 1,
              rotation: rotate
            });
            pageScale = width ? width / viewport.width : height / viewport.height;
          }
          return scaleWithDefault * pageScale;
        }
      }, {
        key: "eventProps",
        get: function get() {
          var _this3 = this;
          return makeEventProps(this.props, function() {
            var page = _this3.state.page;
            if (!page) {
              return page;
            }
            return makePageCallback(page, _this3.scale);
          });
        }
      }, {
        key: "pageKey",
        get: function get() {
          var page = this.state.page;
          return "".concat(page.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);
        }
      }, {
        key: "pageKeyNoScale",
        get: function get() {
          var page = this.state.page;
          return "".concat(page.pageIndex, "/").concat(this.rotate);
        }
      }]);
      return PageInternal2;
    }(import_react14.PureComponent);
    PageInternal.defaultProps = {
      error: "Failed to load the page.",
      loading: "Loading page…",
      noData: "No page specified.",
      renderAnnotationLayer: true,
      renderInteractiveForms: false,
      renderMode: "canvas",
      renderTextLayer: true,
      scale: defaultScale
    };
    isFunctionOrNode2 = import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.node]);
    PageInternal.propTypes = _objectSpread3({}, eventProps, {
      children: import_prop_types11.default.node,
      className: isClassName,
      customTextRenderer: import_prop_types11.default.func,
      error: isFunctionOrNode2,
      height: import_prop_types11.default.number,
      inputRef: import_prop_types11.default.func,
      loading: isFunctionOrNode2,
      noData: isFunctionOrNode2,
      onGetTextError: import_prop_types11.default.func,
      onGetTextSuccess: import_prop_types11.default.func,
      onLoadError: import_prop_types11.default.func,
      onLoadSuccess: import_prop_types11.default.func,
      onRenderError: import_prop_types11.default.func,
      onRenderSuccess: import_prop_types11.default.func,
      pageIndex: isPageIndex,
      pageNumber: isPageNumber,
      pdf: isPdf,
      registerPage: import_prop_types11.default.func,
      renderAnnotationLayer: import_prop_types11.default.bool,
      renderInteractiveForms: import_prop_types11.default.bool,
      renderMode: isRenderMode,
      renderTextLayer: import_prop_types11.default.bool,
      rotate: isRotate,
      scale: import_prop_types11.default.number,
      unregisterPage: import_prop_types11.default.func,
      width: import_prop_types11.default.number
    });
    Page_default = import_react14.default.forwardRef(Page);
  }
});

// node_modules/react-pdf/dist/esm/entry.js
var entry_exports = {};
__export(entry_exports, {
  Document: () => Document,
  Outline: () => Outline_default,
  Page: () => Page_default,
  pdfjs: () => import_pdf4.default
});
var import_pdf4;
var init_entry = __esm({
  "node_modules/react-pdf/dist/esm/entry.js"() {
    import_pdf4 = __toESM(require_pdf());
    init_Document();
    init_Outline();
    init_Page();
    init_utils();
    if (isLocalFileSystem) {
      warnOnDev("You are running React-PDF from your local file system. PDF.js Worker may fail to load due to browser's security policies. If you're on Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.");
    }
    import_pdf4.default.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/actions.js
var require_actions2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCurrentPage = exports2.SET_CURRENT_PAGE = exports2.setNumPages = exports2.SET_NUM_PAGES = exports2.setPDFPaginated = exports2.SET_PDF_PAGINATED = exports2.setZoomLevel = exports2.SET_ZOOM_LEVEL = void 0;
    exports2.SET_ZOOM_LEVEL = "SET_ZOOM_LEVEL";
    exports2.setZoomLevel = function(value) {
      return {
        type: exports2.SET_ZOOM_LEVEL,
        value
      };
    };
    exports2.SET_PDF_PAGINATED = "SET_PDF_PAGINATED";
    exports2.setPDFPaginated = function(value) {
      return {
        type: exports2.SET_PDF_PAGINATED,
        value
      };
    };
    exports2.SET_NUM_PAGES = "SET_NUM_PAGES";
    exports2.setNumPages = function(value) {
      return {
        type: exports2.SET_NUM_PAGES,
        value
      };
    };
    exports2.SET_CURRENT_PAGE = "SET_CURRENT_PAGE";
    exports2.setCurrentPage = function(value) {
      return {
        type: exports2.SET_CURRENT_PAGE,
        value
      };
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/reducer.js
var require_reducer2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/reducer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reducer = exports2.initialPDFState = void 0;
    var actions_1 = require_actions2();
    exports2.initialPDFState = {
      zoomLevel: 1,
      paginated: true,
      numPages: 0,
      currentPage: 1
    };
    exports2.reducer = function(state, action) {
      if (state === void 0) {
        state = exports2.initialPDFState;
      }
      switch (action.type) {
        case actions_1.SET_ZOOM_LEVEL: {
          var value = action.value;
          return __assign(__assign({}, state), { zoomLevel: value });
        }
        case actions_1.SET_PDF_PAGINATED: {
          var value = action.value;
          return __assign(__assign({}, state), { paginated: value });
        }
        case actions_1.SET_NUM_PAGES: {
          var value = action.value;
          return __assign(__assign({}, state), { numPages: value });
        }
        case actions_1.SET_CURRENT_PAGE: {
          var value = action.value;
          return __assign(__assign({}, state), { currentPage: value });
        }
        default:
          return state;
      }
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/index.js
var require_state2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PDFProvider = exports2.PDFContext = void 0;
    var react_1 = __importStar(require_react());
    var reducer_1 = require_reducer2();
    var PDFContext = react_1.createContext({ state: reducer_1.initialPDFState, dispatch: function() {
      return null;
    } });
    exports2.PDFContext = PDFContext;
    var PDFProvider = function(_a) {
      var children = _a.children, mainState = _a.mainState;
      var _b = react_1.useReducer(reducer_1.reducer, __assign(__assign({}, reducer_1.initialPDFState), { mainState })), state = _b[0], dispatch = _b[1];
      return react_1.default.createElement(PDFContext.Provider, { value: { state, dispatch } }, children);
    };
    exports2.PDFProvider = PDFProvider;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFSinglePage.js
var require_PDFSinglePage = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFSinglePage.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var react_pdf_1 = (init_entry(), __toCommonJS(entry_exports));
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state2();
    var PDFSinglePage = function(props) {
      var pageNum = props.pageNum;
      var _a = react_1.useContext(state_1.PDFContext).state, mainState = _a.mainState, paginated = _a.paginated, zoomLevel = _a.zoomLevel, numPages = _a.numPages, currentPage = _a.currentPage;
      var rendererRect = (mainState === null || mainState === void 0 ? void 0 : mainState.rendererRect) || null;
      var _pageNum = pageNum || currentPage;
      return react_1.default.createElement(
        PageWrapper,
        { id: "pdf-page-wrapper", last: _pageNum >= numPages },
        !paginated && react_1.default.createElement(
          PageTag,
          { id: "pdf-page-info" },
          "Page ",
          _pageNum,
          "/",
          numPages
        ),
        react_1.default.createElement(react_pdf_1.Page, { pageNumber: _pageNum || currentPage, scale: zoomLevel, height: ((rendererRect === null || rendererRect === void 0 ? void 0 : rendererRect.height) || 100) - 100, width: ((rendererRect === null || rendererRect === void 0 ? void 0 : rendererRect.width) || 100) - 100 })
      );
    };
    exports2.default = PDFSinglePage;
    var PageWrapper = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  margin: 20px 0;\n"], ["\n  margin: 20px 0;\n"])));
    var PageTag = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  padding: 0 0 10px 10px;\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"], ["\n  padding: 0 0 10px 10px;\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.text_tertiary;
    });
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFAllPages.js
var require_PDFAllPages = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFAllPages.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PDFAllPages = void 0;
    var react_1 = __importStar(require_react());
    var state_1 = require_state2();
    var PDFSinglePage_1 = __importDefault(require_PDFSinglePage());
    exports2.PDFAllPages = function(props) {
      var numPages = react_1.useContext(state_1.PDFContext).state.numPages;
      var PagesArray = [];
      for (var i2 = 0; i2 < numPages; i2++) {
        PagesArray.push(react_1.default.createElement(PDFSinglePage_1.default, { key: i2 + 1, pageNum: i2 + 1 }));
      }
      return react_1.default.createElement(react_1.default.Fragment, null, PagesArray);
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFPages.js
var require_PDFPages = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFPages.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var react_pdf_1 = (init_entry(), __toCommonJS(entry_exports));
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var reducer_1 = require_reducer2();
    var PDFAllPages_1 = require_PDFAllPages();
    var PDFSinglePage_1 = __importDefault(require_PDFSinglePage());
    var PDFPages = function() {
      var _a = react_1.useContext(state_1.PDFContext), _b = _a.state, mainState = _b.mainState, paginated = _b.paginated, dispatch = _a.dispatch;
      var currentDocument = (mainState === null || mainState === void 0 ? void 0 : mainState.currentDocument) || null;
      react_1.useEffect(function() {
        dispatch(actions_1.setNumPages(reducer_1.initialPDFState.numPages));
      }, [currentDocument]);
      if (!currentDocument || currentDocument.fileData === void 0)
        return null;
      return react_1.default.createElement(DocumentPDF, { file: currentDocument.fileData, onLoadSuccess: function(_a2) {
        var numPages = _a2.numPages;
        return dispatch(actions_1.setNumPages(numPages));
      }, loading: react_1.default.createElement("span", null, "Loading...") }, paginated ? react_1.default.createElement(PDFSinglePage_1.default, null) : react_1.default.createElement(PDFAllPages_1.PDFAllPages, null));
    };
    var DocumentPDF = styled_components_1.default(react_pdf_1.Document)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n"], ["\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n"])));
    exports2.default = PDFPages;
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/icons/index.js
var require_icons2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/icons/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TogglePaginationPDFIcon = exports2.ResetZoomPDFIcon = exports2.ZoomOutPDFIcon = exports2.ZoomInPDFIcon = exports2.DownloadPDFIcon = exports2.NextPDFNavIcon = exports2.PrevPDFNavIcon = void 0;
    var react_1 = __importDefault(require_react());
    exports2.PrevPDFNavIcon = function(props) {
      return react_1.default.createElement(PDFNavArrow, __assign({}, props, { reverse: true }));
    };
    exports2.NextPDFNavIcon = function(props) {
      return react_1.default.createElement(PDFNavArrow, __assign({}, props));
    };
    var PDFNavArrow = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, viewBox: "0 0 12 12", version: "1.1" },
        react_1.default.createElement(
          "g",
          { id: "Icons", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
          react_1.default.createElement(
            "g",
            { id: "Rounded", transform: "translate(-548.000000, -1000.000000)" },
            react_1.default.createElement(
              "g",
              { id: "AV", transform: "translate(100.000000, 852.000000)" },
              react_1.default.createElement(
                "g",
                { id: "-Round-/-AV-/-skip_next", transform: "translate(442.000000, 142.000000)" },
                react_1.default.createElement(
                  "g",
                  null,
                  react_1.default.createElement("rect", { id: "Rectangle-Copy-52", x: "0", y: "0", width: "24", height: "24" }),
                  react_1.default.createElement("path", { d: "M7.58,16.89 L13.35,12.82 C13.91,12.42 13.91,11.58 13.35,11.19 L7.58,7.11 C6.91,6.65 6,7.12 6,7.93 L6,16.07 C6,16.88 6.91,17.35 7.58,16.89 Z M16,7 L16,17 C16,17.55 16.45,18 17,18 C17.55,18 18,17.55 18,17 L18,7 C18,6.45 17.55,6 17,6 C16.45,6 16,6.45 16,7 Z", id: "icon_color", fill: color || "#aaa" })
                )
              )
            )
          )
        )
      );
    };
    exports2.DownloadPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, id: "Layer_1", viewBox: "0 0 24 24" },
        react_1.default.createElement("path", { d: "M20.57,9.43A8,8,0,0,0,5.26,10,5,5,0,1,0,5,20h5V18H5a3,3,0,0,1,0-6,3.1,3.1,0,0,1,.79.12l1.12.31.14-1.15a6,6,0,0,1,11.74-.82l.15.54.54.16A3.46,3.46,0,0,1,22,14.5,3.5,3.5,0,0,1,18.5,18H16v2h2.5A5.48,5.48,0,0,0,20.57,9.43Z", fill: color || "#aaa" }),
        react_1.default.createElement("polygon", { points: "12 11 12 15.59 10.71 14.29 9.29 15.71 13 19.41 16.71 15.71 15.29 14.29 14 15.59 14 11 12 11", fill: color || "#aaa" })
      );
    };
    exports2.ZoomInPDFIcon = function(props) {
      return react_1.default.createElement(ZoomPDFIcon, __assign({}, props));
    };
    exports2.ZoomOutPDFIcon = function(props) {
      return react_1.default.createElement(ZoomPDFIcon, __assign({}, props, { reverse: true }));
    };
    var ZoomPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", viewBox: "0 0 32 32", version: "1.1" },
        react_1.default.createElement(
          "g",
          { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
          react_1.default.createElement(
            "g",
            { id: "search-plus-icon", fill: color || "#aaa" },
            react_1.default.createElement("path", { id: "search-plus", d: reverse ? "M 13 13 L 16 13 L 19 13 L 19 16 L 16 16 L 13 16 L 10 16 L 10 13 Z M 19.4271 21.4271 C 18.0372 22.4175 16.3367 23 14.5 23 C 9.8056 23 6 19.1944 6 14.5 C 6 9.8056 9.8056 6 14.5 6 C 19.1944 6 23 9.8056 23 14.5 C 23 16.3367 22.4175 18.0372 21.4271 19.4271 L 27.0119 25.0119 C 27.5621 25.5621 27.5575 26.4425 27.0117 26.9883 L 26.9883 27.0117 C 26.4439 27.5561 25.5576 27.5576 25.0119 27.0119 L 19.4271 21.4271 L 19.4271 21.4271 L 19.4271 21.4271 Z M 14.5 21 C 18.0899 21 21 18.0899 21 14.5 C 21 10.9101 18.0899 8 14.5 8 C 10.9101 8 8 10.9101 8 14.5 C 8 18.0899 10.9101 21 14.5 21 L 14.5 21 Z" : "M 13 13 L 13 10 L 16 10 L 16 13 L 19 13 L 19 16 L 16 16 L 16 19 L 13 19 L 13 16 L 10 16 L 10 13 Z M 19.4271 21.4271 C 18.0372 22.4175 16.3367 23 14.5 23 C 9.8056 23 6 19.1944 6 14.5 C 6 9.8056 9.8056 6 14.5 6 C 19.1944 6 23 9.8056 23 14.5 C 23 16.3367 22.4175 18.0372 21.4271 19.4271 L 27.0119 25.0119 C 27.5621 25.5621 27.5575 26.4425 27.0117 26.9883 L 26.9883 27.0117 C 26.4439 27.5561 25.5576 27.5576 25.0119 27.0119 L 19.4271 21.4271 L 19.4271 21.4271 L 19.4271 21.4271 Z M 14.5 21 C 18.0899 21 21 18.0899 21 14.5 C 21 10.9101 18.0899 8 14.5 8 C 10.9101 8 8 10.9101 8 14.5 C 8 18.0899 10.9101 21 14.5 21 L 14.5 21 Z" })
          )
        )
      );
    };
    exports2.ResetZoomPDFIcon = function(props) {
      var color = props.color, size = props.size;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", viewBox: "0 0 24 24" },
        react_1.default.createElement("path", { fill: color || "#aaa", d: "M9.29,13.29,4,18.59V17a1,1,0,0,0-2,0v4a1,1,0,0,0,.08.38,1,1,0,0,0,.54.54A1,1,0,0,0,3,22H7a1,1,0,0,0,0-2H5.41l5.3-5.29a1,1,0,0,0-1.42-1.42ZM5.41,4H7A1,1,0,0,0,7,2H3a1,1,0,0,0-.38.08,1,1,0,0,0-.54.54A1,1,0,0,0,2,3V7A1,1,0,0,0,4,7V5.41l5.29,5.3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42ZM21,16a1,1,0,0,0-1,1v1.59l-5.29-5.3a1,1,0,0,0-1.42,1.42L18.59,20H17a1,1,0,0,0,0,2h4a1,1,0,0,0,.38-.08,1,1,0,0,0,.54-.54A1,1,0,0,0,22,21V17A1,1,0,0,0,21,16Zm.92-13.38a1,1,0,0,0-.54-.54A1,1,0,0,0,21,2H17a1,1,0,0,0,0,2h1.59l-5.3,5.29a1,1,0,0,0,0,1.42,1,1,0,0,0,1.42,0L20,5.41V7a1,1,0,0,0,2,0V3A1,1,0,0,0,21.92,2.62Z" })
      );
    };
    exports2.TogglePaginationPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(90deg)" : "" }, version: "1.1", id: "Scroll_1", viewBox: "0 0 297 297", xmlSpace: "preserve" },
        react_1.default.createElement("path", { fill: color || "#aaa", d: "M206.004,200.723h-31.231V96.277h31.231c0.005,0,0.014,0,0.019,0c5.289,0,9.575-4.287,9.575-9.574\n  c0-2.342-0.841-4.488-2.236-6.151L156.168,3.851C154.36,1.428,151.515,0,148.492,0c-3.023,0-5.868,1.428-7.675,3.851L83.302,80.98\n  c-2.166,2.902-2.507,6.779-0.883,10.017c1.624,3.236,4.936,5.28,8.559,5.28h31.231v104.445H90.978c-3.623,0-6.934,2.044-8.559,5.28\n  c-1.624,3.237-1.283,7.114,0.883,10.017l57.513,77.129c1.808,2.424,4.652,3.852,7.675,3.852c3.023,0,5.868-1.428,7.676-3.852\n  l57.514-77.129c2.164-2.902,2.507-6.779,0.883-10.017C212.938,202.767,209.627,200.723,206.004,200.723z" })
      );
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/PDFPagination.js
var require_PDFPagination = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/PDFPagination.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var common_1 = require_common();
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var icons_1 = require_icons2();
    var PDFPagination = function() {
      var _a = react_1.useContext(state_1.PDFContext), _b = _a.state, currentPage = _b.currentPage, numPages = _b.numPages, dispatch = _a.dispatch;
      return react_1.default.createElement(
        Container,
        { id: "pdf-pagination" },
        react_1.default.createElement(
          PageNavButtonLeft,
          { id: "pdf-pagination-prev", onClick: function() {
            return dispatch(actions_1.setCurrentPage(currentPage - 1));
          }, disabled: currentPage === 1 },
          react_1.default.createElement(icons_1.PrevPDFNavIcon, { color: "#000", size: "50%" })
        ),
        react_1.default.createElement(
          PageTag,
          { id: "pdf-pagination-info" },
          "Page ",
          currentPage,
          "/",
          numPages
        ),
        react_1.default.createElement(
          PageNavButtonRight,
          { id: "pdf-pagination-next", onClick: function() {
            return dispatch(actions_1.setCurrentPage(currentPage + 1));
          }, disabled: currentPage >= numPages },
          react_1.default.createElement(icons_1.NextPDFNavIcon, { color: "#000", size: "50%" })
        )
      );
    };
    exports2.default = PDFPagination;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n"], ["\n  display: flex;\n  align-items: center;\n"])));
    var PageNavButtonLeft = styled_components_1.default(common_1.Button)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var PageNavButtonRight = styled_components_1.default(PageNavButtonLeft)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  margin: 0 20px 0 5px;\n"], ["\n  margin: 0 20px 0 5px;\n"])));
    var PageTag = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"], ["\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.text_primary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/PDFControls.js
var require_PDFControls = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/PDFControls.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var common_1 = require_common();
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var reducer_1 = require_reducer2();
    var icons_1 = require_icons2();
    var PDFPagination_1 = __importDefault(require_PDFPagination());
    var PDFControls = function() {
      var _a = react_1.useContext(state_1.PDFContext), _b = _a.state, mainState = _b.mainState, paginated = _b.paginated, zoomLevel = _b.zoomLevel, numPages = _b.numPages, dispatch = _a.dispatch;
      var currentDocument = (mainState === null || mainState === void 0 ? void 0 : mainState.currentDocument) || null;
      return react_1.default.createElement(
        Container,
        { id: "pdf-controls" },
        paginated && numPages > 1 && react_1.default.createElement(PDFPagination_1.default, null),
        (currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData) && react_1.default.createElement(
          DownloadButton,
          { id: "pdf-download", href: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData, download: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri },
          react_1.default.createElement(icons_1.DownloadPDFIcon, { color: "#000", size: "75%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-out", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(zoomLevel - 0.1));
          } },
          react_1.default.createElement(icons_1.ZoomOutPDFIcon, { color: "#000", size: "80%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-in", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(zoomLevel + 0.1));
          } },
          react_1.default.createElement(icons_1.ZoomInPDFIcon, { color: "#000", size: "80%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-reset", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(reducer_1.initialPDFState.zoomLevel));
          }, disabled: zoomLevel === reducer_1.initialPDFState.zoomLevel },
          react_1.default.createElement(icons_1.ResetZoomPDFIcon, { color: "#000", size: "70%" })
        ),
        numPages > 1 && react_1.default.createElement(
          ControlButton,
          { id: "pdf-toggle-pagination", onMouseDown: function() {
            return dispatch(actions_1.setPDFPaginated(!paginated));
          } },
          react_1.default.createElement(icons_1.TogglePaginationPDFIcon, { color: "#000", size: "70%", reverse: paginated })
        )
      );
    };
    exports2.default = PDFControls;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  justify-content: flex-end;\n  padding: 8px;\n  background-color: ", ";\n  box-shadow: 0px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    padding: 6px;\n  }\n"], ["\n  display: flex;\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  justify-content: flex-end;\n  padding: 8px;\n  background-color: ", ";\n  box-shadow: 0px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    padding: 6px;\n  }\n"])), function(props) {
      return props.theme.tertiary;
    });
    var ControlButton = styled_components_1.default(common_1.Button)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var DownloadButton = styled_components_1.default(common_1.LinkButton)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/index.js
var require_pdf2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pdfjsWorker = __importStar(require_pdf_worker_entry());
    var react_1 = __importDefault(require_react());
    var react_pdf_1 = (init_entry(), __toCommonJS(entry_exports));
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var PDFPages_1 = __importDefault(require_PDFPages());
    var PDFControls_1 = __importDefault(require_PDFControls());
    var state_1 = require_state2();
    react_pdf_1.pdfjs.GlobalWorkerOptions.workerSrc = pdfjsWorker;
    var PDFRenderer = function(_a) {
      var mainState = _a.mainState;
      return react_1.default.createElement(
        state_1.PDFProvider,
        { mainState },
        react_1.default.createElement(
          Container,
          { id: "pdf-renderer", "data-testid": "pdf-renderer" },
          react_1.default.createElement(PDFControls_1.default, null),
          react_1.default.createElement(PDFPages_1.default, null)
        )
      );
    };
    exports2.default = PDFRenderer;
    PDFRenderer.fileTypes = ["pdf", "application/pdf"];
    PDFRenderer.weight = 0;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow-y: auto;\n\n  /* width */\n  &::-webkit-scrollbar {\n    ", ";\n  }\n  /* Track */\n  &::-webkit-scrollbar-track {\n    /* background: ", "; */\n  }\n  /* Handle */\n  &::-webkit-scrollbar-thumb {\n    background: ", ";\n  }\n  /* Handle on hover */\n  &::-webkit-scrollbar-thumb:hover {\n    background: ", ";\n  }\n"], [
      "\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow-y: auto;\n\n  /* width */\n  &::-webkit-scrollbar {\n    ",
      ";\n  }\n  /* Track */\n  &::-webkit-scrollbar-track {\n    /* background: ",
      "; */\n  }\n  /* Handle */\n  &::-webkit-scrollbar-thumb {\n    background: ",
      ";\n  }\n  /* Handle on hover */\n  &::-webkit-scrollbar-thumb:hover {\n    background: ",
      ";\n  }\n"
    ])), function(props) {
      return props.theme.disableThemeScrollbar ? "" : "width: 10px";
    }, function(props) {
      return props.theme.secondary;
    }, function(props) {
      return props.theme.tertiary;
    }, function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/png/index.js
var require_png = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/png/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var image_1 = __importDefault(require_image());
    var StyledImageRenderer = styled_components_1.default(image_1.default)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  background-color: white;\n  background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, #e0e0e0 75%),\n    linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);\n  background-size: 20px 20px;\n  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;\n"], ["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  background-color: white;\n  background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, #e0e0e0 75%),\n    linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);\n  background-size: 20px 20px;\n  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;\n"])));
    var PNGRenderer = function(props) {
      return react_1.default.createElement(StyledImageRenderer, __assign({}, props));
    };
    PNGRenderer.fileTypes = ["png", "image/png"];
    PNGRenderer.weight = 0;
    exports2.default = PNGRenderer;
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js
var require_tiffToCanvas = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js"(exports2) {
    "use strict";
    var _this = exports2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseTIFF = void 0;
    var tiffDataView = void 0;
    var littleEndian = void 0;
    var fileDirectories = [];
    var isLittleEndian = function() {
      var BOM = getBytes(2, 0);
      if (BOM === 18761) {
        littleEndian = true;
      } else if (BOM === 19789) {
        littleEndian = false;
      } else {
        throw TypeError("Invalid byte order value.");
      }
      return littleEndian;
    };
    var hasTowel = function() {
      if (getBytes(2, 2) !== 42) {
        throw RangeError("You forgot your towel!");
        return false;
      }
      return true;
    };
    var getFieldTagName = function(fieldTag) {
      var fieldTagNames = {
        // TIFF Baseline
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        // TIFF Extended
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        // EXIF
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        // IPTC
        33723: "IPTC",
        // ICC
        34675: "ICC Profile",
        // XMP
        700: "XMP",
        // GDAL
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        // Photoshop
        34377: "Photoshop"
      };
      var fieldTagName;
      if (fieldTag in fieldTagNames) {
        fieldTagName = fieldTagNames[fieldTag];
      } else {
        fieldTagName = "Tag" + fieldTag;
      }
      return fieldTagName;
    };
    var getFieldTypeName = function(fieldType) {
      var fieldTypeNames = {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
      };
      var fieldTypeName;
      if (fieldType in fieldTypeNames) {
        fieldTypeName = fieldTypeNames[fieldType];
      }
      return fieldTypeName;
    };
    var getFieldTypeLength = function(fieldTypeName) {
      var fieldTypeLength;
      if (["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 1;
      } else if (["SHORT", "SSHORT"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 2;
      } else if (["LONG", "SLONG", "FLOAT"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 4;
      } else if (["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 8;
      }
      return fieldTypeLength;
    };
    var getBits = function(numBits, byteOffset, bitOffset) {
      bitOffset = bitOffset || 0;
      var extraBytes = Math.floor(bitOffset / 8);
      var newByteOffset = byteOffset + extraBytes;
      var totalBits = bitOffset + numBits;
      var shiftRight = 32 - numBits;
      if (totalBits <= 0) {
        throw RangeError("No bits requested");
      } else if (totalBits <= 8) {
        var shiftLeft = 24 + bitOffset;
        var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);
      } else if (totalBits <= 16) {
        var shiftLeft = 16 + bitOffset;
        var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);
      } else if (totalBits <= 32) {
        var shiftLeft = bitOffset;
        var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);
      } else {
        throw RangeError("Too many bits requested");
      }
      var chunkInfo = {
        bits: rawBits << shiftLeft >>> shiftRight,
        byteOffset: newByteOffset + Math.floor(totalBits / 8),
        bitOffset: totalBits % 8
      };
      return chunkInfo;
    };
    var getBytes = function(numBytes, offset) {
      if (numBytes <= 0) {
        throw RangeError("No bytes requested");
      } else if (numBytes <= 1) {
        return tiffDataView.getUint8(offset, littleEndian);
      } else if (numBytes <= 2) {
        return tiffDataView.getUint16(offset, littleEndian);
      } else if (numBytes <= 3) {
        return tiffDataView.getUint32(offset, littleEndian) >>> 8;
      } else if (numBytes <= 4) {
        return tiffDataView.getUint32(offset, littleEndian);
      } else {
        throw RangeError("Too many bytes requested");
      }
    };
    var getFieldValues = function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
      var fieldValues = [];
      var fieldTypeLength = getFieldTypeLength(fieldTypeName);
      var fieldValueSize = fieldTypeLength * typeCount;
      if (fieldValueSize <= 4) {
        if (littleEndian === false) {
          var value = valueOffset >>> (4 - fieldTypeLength) * 8;
        } else {
          var value = valueOffset;
        }
        fieldValues.push(value);
      } else {
        for (var i2 = 0; i2 < typeCount; i2++) {
          var indexOffset = fieldTypeLength * i2;
          if (fieldTypeLength >= 8) {
            if (["RATIONAL", "SRATIONAL"].indexOf(fieldTypeName) !== -1) {
              fieldValues.push(getBytes(4, valueOffset + indexOffset));
              fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));
            } else {
              throw TypeError("Can't handle this field type or size");
            }
          } else {
            fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));
          }
        }
      }
      if (fieldTypeName === "ASCII") {
        fieldValues.forEach(function(e2, i3, a2) {
          a2[i3] = String.fromCharCode(e2);
        });
      }
      return fieldValues;
    };
    var clampColorSample = function(colorSample, bitsPerSample) {
      var multiplier = Math.pow(2, 8 - bitsPerSample);
      return Math.floor(colorSample * multiplier + (multiplier - 1));
    };
    var makeRGBAFillValue = function(r2, g2, b2, a2) {
      if (typeof a2 === "undefined") {
        a2 = 1;
      }
      return "rgba(" + r2 + ", " + g2 + ", " + b2 + ", " + a2 + ")";
    };
    var parseFileDirectory = function(byteOffset) {
      var numDirEntries = getBytes(2, byteOffset);
      var tiffFields = [];
      for (var i2 = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i2 += 12, entryCount++) {
        var fieldTag = getBytes(2, i2);
        var fieldType = getBytes(2, i2 + 2);
        var typeCount = getBytes(4, i2 + 4);
        var valueOffset = getBytes(4, i2 + 8);
        var fieldTagName = getFieldTagName(fieldTag);
        var fieldTypeName = getFieldTypeName(fieldType);
        var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
        tiffFields[fieldTagName] = { type: fieldTypeName, values: fieldValues };
      }
      fileDirectories.push(tiffFields);
      var nextIFDByteOffset = getBytes(4, i2);
      if (nextIFDByteOffset === 0) {
        return fileDirectories;
      } else {
        return parseFileDirectory(nextIFDByteOffset);
      }
    };
    exports2.parseTIFF = function(tiffArrayBuffer, _canvas2) {
      var canvas = _canvas2 || document.createElement("canvas");
      if (!tiffArrayBuffer)
        return;
      tiffDataView = new DataView(tiffArrayBuffer);
      littleEndian = isLittleEndian(tiffDataView);
      if (!hasTowel(tiffDataView, littleEndian))
        return;
      var firstIFDByteOffset = getBytes(4, 4);
      fileDirectories = parseFileDirectory(firstIFDByteOffset);
      var fileDirectory = fileDirectories[0];
      var imageWidth = fileDirectory.ImageWidth.values[0];
      var imageLength = fileDirectory.ImageLength.values[0];
      canvas.width = imageWidth;
      canvas.height = imageLength;
      var strips = [];
      var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
      var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
      var sampleProperties = [];
      var bitsPerPixel = 0;
      var hasBytesPerPixel = false;
      fileDirectory.BitsPerSample.values.forEach(function(bitsPerSample, i3, bitsPerSampleValues) {
        sampleProperties[i3] = {
          bitsPerSample,
          hasBytesPerSample: false,
          bytesPerSample: void 0
        };
        if (bitsPerSample % 8 === 0) {
          sampleProperties[i3].hasBytesPerSample = true;
          sampleProperties[i3].bytesPerSample = bitsPerSample / 8;
        }
        bitsPerPixel += bitsPerSample;
      }, _this);
      if (bitsPerPixel % 8 === 0) {
        hasBytesPerPixel = true;
        var bytesPerPixel = bitsPerPixel / 8;
      }
      var stripOffsetValues = fileDirectory.StripOffsets.values;
      var numStripOffsetValues = stripOffsetValues.length;
      if (fileDirectory.StripByteCounts) {
        var stripByteCountValues = fileDirectory.StripByteCounts.values;
      } else {
        if (numStripOffsetValues === 1) {
          var stripByteCountValues = [
            Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)
          ];
        } else {
          throw Error("Cannot recover from missing StripByteCounts");
        }
      }
      for (var i2 = 0; i2 < numStripOffsetValues; i2++) {
        var stripOffset = stripOffsetValues[i2];
        strips[i2] = [];
        var stripByteCount = stripByteCountValues[i2];
        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
          switch (compression) {
            case 1:
              for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
                if (sampleProperties[m].hasBytesPerSample) {
                  var sampleOffset = sampleProperties[m].bytesPerSample * m;
                  pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
                } else {
                  var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                  pixel.push(sampleInfo.bits);
                  byteOffset = sampleInfo.byteOffset - stripOffset;
                  bitOffset = sampleInfo.bitOffset;
                  throw RangeError("Cannot handle sub-byte bits per sample");
                }
              }
              strips[i2].push(pixel);
              if (hasBytesPerPixel) {
                jIncrement = bytesPerPixel;
              } else {
                jIncrement = 0;
                throw RangeError("Cannot handle sub-byte bits per pixel");
              }
              break;
            case 2:
              break;
            case 3:
              break;
            case 4:
              break;
            case 5:
              break;
            case 6:
              break;
            case 7:
              break;
            case 32773:
              if (getHeader) {
                getHeader = false;
                var blockLength = 1;
                var iterations = 1;
                var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);
                if (header >= 0 && header <= 127) {
                  blockLength = header + 1;
                } else if (header >= -127 && header <= -1) {
                  iterations = -header + 1;
                } else {
                  getHeader = true;
                }
              } else {
                var currentByte = getBytes(1, stripOffset + byteOffset);
                for (var m = 0; m < iterations; m++) {
                  if (sampleProperties[sample].hasBytesPerSample) {
                    currentSample = currentSample << 8 * numBytes | currentByte;
                    numBytes++;
                    if (numBytes === sampleProperties[sample].bytesPerSample) {
                      pixel.push(currentSample);
                      currentSample = numBytes = 0;
                      sample++;
                    }
                  } else {
                    throw RangeError("Cannot handle sub-byte bits per sample");
                  }
                  if (sample === samplesPerPixel) {
                    strips[i2].push(pixel);
                    pixel = [];
                    sample = 0;
                  }
                }
                blockLength--;
                if (blockLength === 0) {
                  getHeader = true;
                }
              }
              jIncrement = 1;
              break;
            default:
              break;
          }
        }
      }
      if (canvas.getContext) {
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);
        if (fileDirectory.RowsPerStrip) {
          var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];
        } else {
          var rowsPerStrip = imageLength;
        }
        var numStrips = strips.length;
        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
        var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
        var numRowsInStrip = rowsPerStrip;
        var numRowsInPreviousStrip = 0;
        var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
        var extraSamplesValues = [];
        var numExtraSamples = 0;
        if (fileDirectory.ExtraSamples) {
          extraSamplesValues = fileDirectory.ExtraSamples.values;
          numExtraSamples = extraSamplesValues.length;
        }
        if (fileDirectory.ColorMap) {
          var colorMapValues = fileDirectory.ColorMap.values;
          var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
        }
        for (var i2 = 0; i2 < numStrips; i2++) {
          if (i2 + 1 === numStrips) {
            numRowsInStrip = rowsInLastStrip;
          }
          var numPixels = strips[i2].length;
          var yPadding = numRowsInPreviousStrip * i2;
          for (var y2 = 0, j2 = 0; y2 < numRowsInStrip, j2 < numPixels; y2++) {
            for (var x2 = 0; x2 < imageWidth; x2++, j2++) {
              var pixelSamples = strips[i2][j2];
              var red = 0;
              var green = 0;
              var blue = 0;
              var opacity = 1;
              if (numExtraSamples > 0) {
                for (var k2 = 0; k2 < numExtraSamples; k2++) {
                  if (extraSamplesValues[k2] === 1 || extraSamplesValues[k2] === 2) {
                    opacity = pixelSamples[3 + k2] / 256;
                    break;
                  }
                }
              }
              switch (photometricInterpretation) {
                case 0:
                  if (sampleProperties[0].hasBytesPerSample) {
                    var invertValue = Math.pow(16, sampleProperties[0].bytesPerSample * 2);
                  }
                  pixelSamples.forEach(function(sample2, index, samples) {
                    samples[index] = invertValue - sample2;
                  });
                case 1:
                  red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                  break;
                case 2:
                  red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                  green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                  blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                  break;
                case 3:
                  if (colorMapValues === void 0) {
                    throw Error("Palette image missing color map");
                  }
                  var colorMapIndex = pixelSamples[0];
                  red = clampColorSample(colorMapValues[colorMapIndex], 16);
                  green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                  blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                  break;
                case 4:
                  throw RangeError("Not Yet Implemented: Transparency mask");
                  break;
                case 5:
                  throw RangeError("Not Yet Implemented: CMYK");
                  break;
                case 6:
                  throw RangeError("Not Yet Implemented: YCbCr");
                  break;
                case 8:
                  throw RangeError("Not Yet Implemented: CIELab");
                  break;
                default:
                  throw RangeError("Unknown Photometric Interpretation:", photometricInterpretation);
                  break;
              }
              ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);
              ctx.fillRect(x2, yPadding + y2, 1, 1);
            }
          }
          numRowsInPreviousStrip = numRowsInStrip;
        }
      }
      return canvas;
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/tiff/index.js
var require_tiff = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/tiff/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var image_1 = __importDefault(require_image());
    var tiffToCanvas_1 = require_tiffToCanvas();
    var TIFFRenderer = function(props) {
      var currentDocument = props.mainState.currentDocument;
      var _a = react_1.useState(false), loadedCanvas = _a[0], setLoadedCanvas = _a[1];
      var _b = react_1.useState(false), corruptedFile = _b[0], setCorruptedFile = _b[1];
      react_1.useEffect(function() {
        if (!currentDocument || loadedCanvas)
          return;
        var canvas = document.getElementById("tiff-img");
        try {
          canvas && tiffToCanvas_1.parseTIFF(currentDocument.fileData, canvas);
          setLoadedCanvas(true);
        } catch (error) {
          setCorruptedFile(true);
        }
      }, []);
      if (corruptedFile) {
        return react_1.default.createElement(
          image_1.default,
          __assign({}, props),
          react_1.default.createElement("div", null, "Your file is corrupted. Please check it on your machine.")
        );
      }
      return react_1.default.createElement(
        image_1.default,
        __assign({}, props),
        react_1.default.createElement(Canvas, { id: "tiff-img" })
      );
    };
    TIFFRenderer.fileTypes = ["tif", "tiff", "image/tif", "image/tiff"];
    TIFFRenderer.weight = 0;
    TIFFRenderer.fileLoader = fileLoaders_1.arrayBufferFileLoader;
    exports2.default = TIFFRenderer;
    var Canvas = styled_components_1.default.canvas(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  max-width: 95%;\n  max-height: 95%;\n"], ["\n  max-width: 95%;\n  max-height: 95%;\n"])));
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/txt/index.js
var require_txt = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/txt/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var TXTRenderer = function(_a) {
      var currentDocument = _a.mainState.currentDocument;
      return react_1.default.createElement(Container, { id: "txt-renderer" }, currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData);
    };
    exports2.default = TXTRenderer;
    TXTRenderer.fileTypes = ["txt", "text/plain"];
    TXTRenderer.weight = 0;
    TXTRenderer.fileLoader = fileLoaders_1.textFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 30px;\n"])));
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/theme/index.js
var require_theme = __commonJS({
  "node_modules/react-doc-viewer/build/theme/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultTheme = void 0;
    exports2.defaultTheme = {
      primary: "#fff",
      secondary: "#000",
      tertiary: "#ffffff99",
      text_primary: "#000",
      text_secondary: "#fff",
      text_tertiary: "#00000044",
      disableThemeScrollbar: false
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocViewerRenderers = void 0;
    var bmp_1 = __importDefault(require_bmp());
    var html_1 = __importDefault(require_html());
    var jpg_1 = __importDefault(require_jpg());
    var msdoc_1 = __importDefault(require_msdoc());
    var msg_1 = __importDefault(require_msg());
    var pdf_1 = __importDefault(require_pdf2());
    var png_1 = __importDefault(require_png());
    var tiff_1 = __importDefault(require_tiff());
    var txt_1 = __importDefault(require_txt());
    exports2.DocViewerRenderers = [
      bmp_1.default,
      html_1.default,
      jpg_1.default,
      msdoc_1.default,
      msg_1.default,
      pdf_1.default,
      png_1.default,
      tiff_1.default,
      txt_1.default
    ];
  }
});

// node_modules/react-doc-viewer/build/types/index.js
var require_types = __commonJS({
  "node_modules/react-doc-viewer/build/types/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/react-doc-viewer/build/index.js
var require_build = __commonJS({
  "node_modules/react-doc-viewer/build/index.js"(exports2) {
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TXTRenderer = exports2.TIFFRenderer = exports2.PNGRenderer = exports2.PDFRenderer = exports2.MSGRenderer = exports2.MSDocRenderer = exports2.JPGRenderer = exports2.ImageProxyRenderer = exports2.HTMLRenderer = exports2.BMPRenderer = void 0;
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var HeaderBar_1 = require_HeaderBar();
    var ProxyRenderer_1 = require_ProxyRenderer();
    var bmp_1 = __importDefault(require_bmp());
    exports2.BMPRenderer = bmp_1.default;
    var html_1 = __importDefault(require_html());
    exports2.HTMLRenderer = html_1.default;
    var image_1 = __importDefault(require_image());
    exports2.ImageProxyRenderer = image_1.default;
    var jpg_1 = __importDefault(require_jpg());
    exports2.JPGRenderer = jpg_1.default;
    var msdoc_1 = __importDefault(require_msdoc());
    exports2.MSDocRenderer = msdoc_1.default;
    var msg_1 = __importDefault(require_msg());
    exports2.MSGRenderer = msg_1.default;
    var pdf_1 = __importDefault(require_pdf2());
    exports2.PDFRenderer = pdf_1.default;
    var png_1 = __importDefault(require_png());
    exports2.PNGRenderer = png_1.default;
    var tiff_1 = __importDefault(require_tiff());
    exports2.TIFFRenderer = tiff_1.default;
    var txt_1 = __importDefault(require_txt());
    exports2.TXTRenderer = txt_1.default;
    var state_1 = require_state();
    var theme_1 = require_theme();
    var DocViewer = function(props) {
      var documents = props.documents, theme = props.theme;
      if (!documents || documents === void 0) {
        throw new Error("Please provide an array of documents to DocViewer.\ne.g. <DocViewer documents={[ { uri: 'https://mypdf.pdf' } ]} />");
      }
      return react_1.default.createElement(
        state_1.AppProvider,
        __assign({}, props),
        react_1.default.createElement(
          styled_components_1.ThemeProvider,
          { theme: theme ? __assign(__assign({}, theme_1.defaultTheme), theme) : theme_1.defaultTheme },
          react_1.default.createElement(
            Container,
            __assign({ id: "react-doc-viewer", "data-testid": "react-doc-viewer" }, props),
            react_1.default.createElement(HeaderBar_1.HeaderBar, null),
            react_1.default.createElement(ProxyRenderer_1.ProxyRenderer, null)
          )
        )
      );
    };
    exports2.default = DocViewer;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  background: #eee;\n"], ["\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  background: #eee;\n"])));
    var plugins_1 = require_plugins();
    Object.defineProperty(exports2, "DocViewerRenderers", { enumerable: true, get: function() {
      return plugins_1.DocViewerRenderers;
    } });
    __exportStar(require_types(), exports2);
    __exportStar(require_fileLoaders(), exports2);
    var templateObject_1;
  }
});
export default require_build();
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=react-doc-viewer.js.map
